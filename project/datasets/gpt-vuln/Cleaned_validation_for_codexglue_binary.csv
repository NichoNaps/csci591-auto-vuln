Project,Commit ID,Code Snippet,Is Vulnerable,Idx
krb5/krb5,f249555301940c6df3a2cdda13b56b5674eebc2e,"krb5_error_code
pkinit_check_kdc_pkid(krb5_context context,
                      pkinit_plg_crypto_context plg_cryptoctx,
                      pkinit_req_crypto_context req_cryptoctx,
                      pkinit_identity_crypto_context id_cryptoctx,
                      unsigned char *pdid_buf,
                      unsigned int pkid_len,
                      int *valid_kdcPkId)
{
    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;
    PKCS7_ISSUER_AND_SERIAL *is = NULL;
    const unsigned char *p = pdid_buf;
    int status = 1;
    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);

    *valid_kdcPkId = 0;
    pkiDebug('found kdcPkId in AS REQ\n');
    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);
    if (is == NULL)
        goto cleanup;

    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);
    if (!status) {
        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);
        if (!status)
            *valid_kdcPkId = 1;
    }

    retval = 0;
cleanup:
    X509_NAME_free(is->issuer);
    ASN1_INTEGER_free(is->serial);
    free(is);

    return retval;
}
",1,7686
krb5/krb5,f249555301940c6df3a2cdda13b56b5674eebc2e,"static krb5_error_code
get_key(char *filename, EVP_PKEY **retkey)
{
    EVP_PKEY *pkey = NULL;
    BIO *tmp = NULL;
    int code;
    krb5_error_code retval;

    if (filename == NULL || retkey == NULL)
        return EINVAL;

    tmp = BIO_new(BIO_s_file());
    if (tmp == NULL)
        return ENOMEM;

    code = BIO_read_filename(tmp, filename);
    if (code == 0) {
        retval = errno;
        goto cleanup;
    }
    pkey = (EVP_PKEY *) PEM_read_bio_PrivateKey(tmp, NULL, NULL, NULL);
    if (pkey == NULL) {
        retval = EIO;
        pkiDebug('failed to read private key from %s\n', filename);
        goto cleanup;
    }
    *retkey = pkey;
    retval = 0;
cleanup:
    if (tmp != NULL)
        BIO_free(tmp);
    return retval;
}
",0,7687
torvalds/linux,929473ea05db455ad88cdc081f2adc556b8dc48f,"static int host_start(struct ci13xxx *ci)
{
	struct usb_hcd *hcd;
	struct ehci_hcd *ehci;
	int ret;

	if (usb_disabled())
		return -ENODEV;

	hcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));
	if (!hcd)
		return -ENOMEM;

	dev_set_drvdata(ci->dev, ci);
	hcd->rsrc_start = ci->hw_bank.phys;
	hcd->rsrc_len = ci->hw_bank.size;
	hcd->regs = ci->hw_bank.abs;
	hcd->has_tt = 1;

	hcd->power_budget = ci->platdata->power_budget;
	hcd->phy = ci->transceiver;

	ehci = hcd_to_ehci(hcd);
	ehci->caps = ci->hw_bank.cap;
	ehci->has_hostpc = ci->hw_bank.lpm;

	ret = usb_add_hcd(hcd, 0, 0);
	if (ret)
		usb_put_hcd(hcd);
	else
		ci->hcd = hcd;

	return ret;
}
",1,7688
torvalds/linux,929473ea05db455ad88cdc081f2adc556b8dc48f,"int ci_hdrc_host_init(struct ci13xxx *ci)
{
	struct ci_role_driver *rdrv;

	if (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))
		return -ENXIO;

	rdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);
	if (!rdrv)
		return -ENOMEM;

	rdrv->start	= host_start;
	rdrv->stop	= host_stop;
	rdrv->irq	= host_irq;
	rdrv->name	= 'host';
	ci->roles[CI_ROLE_HOST] = rdrv;

	ehci_init_driver(&ci_ehci_hc_driver, NULL);

	return 0;
}
",0,7689
torvalds/linux,2811ebac2521ceac84f2bdae402455baa6a7fb47,"static inline int ip6_ufo_append_data(struct sock *sk,
			int getfrag(void *from, char *to, int offset, int len,
			int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int mtu,unsigned int flags,
			struct rt6_info *rt)

{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP large send offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);
		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb,fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

		/* initialize protocol header pointer */
		skb->transport_header = skb->network_header + fragheaderlen;

		skb->protocol = htons(ETH_P_IPV6);
		skb->ip_summed = CHECKSUM_PARTIAL;
		skb->csum = 0;
	}

	err = skb_append_datato_frags(sk,skb, getfrag, from,
				      (length - transhdrlen));
	if (!err) {
		struct frag_hdr fhdr;

		/* Specify the length of each IPv6 datagram fragment.
		 * It has to be a multiple of 8.
		 */
		skb_shinfo(skb)->gso_size = (mtu - fragheaderlen -
					     sizeof(struct frag_hdr)) & ~7;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
		ipv6_select_ident(&fhdr, rt);
		skb_shinfo(skb)->ip6_frag_id = fhdr.identification;
		__skb_queue_tail(&sk->sk_write_queue, skb);

		return 0;
	}
	/* There is not enough support do UPD LSO,
	 * so follow normal path
	 */
	kfree_skb(skb);

	return err;
}
",1,7690
torvalds/linux,2811ebac2521ceac84f2bdae402455baa6a7fb47,"int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
	int offset, int len, int odd, struct sk_buff *skb),
	void *from, int length, int transhdrlen,
	int hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,
	struct rt6_info *rt, unsigned int flags, int dontfrag)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct inet_cork *cork;
	struct sk_buff *skb, *skb_prev = NULL;
	unsigned int maxfraglen, fragheaderlen, mtu;
	int exthdrlen;
	int dst_exthdrlen;
	int hh_len;
	int copy;
	int err;
	int offset = 0;
	__u8 tx_flags = 0;

	if (flags&MSG_PROBE)
		return 0;
	cork = &inet->cork.base;
	if (skb_queue_empty(&sk->sk_write_queue)) {
		/*
		 * setup for corking
		 */
		if (opt) {
			if (WARN_ON(np->cork.opt))
				return -EINVAL;

			np->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);
			if (unlikely(np->cork.opt == NULL))
				return -ENOBUFS;

			np->cork.opt->tot_len = opt->tot_len;
			np->cork.opt->opt_flen = opt->opt_flen;
			np->cork.opt->opt_nflen = opt->opt_nflen;

			np->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,
							    sk->sk_allocation);
			if (opt->dst0opt && !np->cork.opt->dst0opt)
				return -ENOBUFS;

			np->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,
							    sk->sk_allocation);
			if (opt->dst1opt && !np->cork.opt->dst1opt)
				return -ENOBUFS;

			np->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,
							   sk->sk_allocation);
			if (opt->hopopt && !np->cork.opt->hopopt)
				return -ENOBUFS;

			np->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,
							    sk->sk_allocation);
			if (opt->srcrt && !np->cork.opt->srcrt)
				return -ENOBUFS;

			/* need source address above miyazawa*/
		}
		dst_hold(&rt->dst);
		cork->dst = &rt->dst;
		inet->cork.fl.u.ip6 = *fl6;
		np->cork.hop_limit = hlimit;
		np->cork.tclass = tclass;
		if (rt->dst.flags & DST_XFRM_TUNNEL)
			mtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?
			      rt->dst.dev->mtu : dst_mtu(&rt->dst);
		else
			mtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?
			      rt->dst.dev->mtu : dst_mtu(rt->dst.path);
		if (np->frag_size < mtu) {
			if (np->frag_size)
				mtu = np->frag_size;
		}
		cork->fragsize = mtu;
		if (dst_allfrag(rt->dst.path))
			cork->flags |= IPCORK_ALLFRAG;
		cork->length = 0;
		exthdrlen = (opt ? opt->opt_flen : 0);
		length += exthdrlen;
		transhdrlen += exthdrlen;
		dst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;
	} else {
		rt = (struct rt6_info *)cork->dst;
		fl6 = &inet->cork.fl.u.ip6;
		opt = np->cork.opt;
		transhdrlen = 0;
		exthdrlen = 0;
		dst_exthdrlen = 0;
		mtu = cork->fragsize;
	}

	hh_len = LL_RESERVED_SPACE(rt->dst.dev);

	fragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +
			(opt ? opt->opt_nflen : 0);
	maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);

	if (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {
		if (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {
			ipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);
			return -EMSGSIZE;
		}
	}

	/* For UDP, check if TX timestamp is enabled */
	if (sk->sk_type == SOCK_DGRAM)
		sock_tx_timestamp(sk, &tx_flags);

	/*
	 * Let's try using as much space as possible.
	 * Use MTU if total length of the message fits into the MTU.
	 * Otherwise, we need to reserve fragment header and
	 * fragment alignment (= 8-15 octects, in total).
	 *
	 * Note that we may need to 'move' the data from the tail of
	 * of the buffer to the new fragment when we split
	 * the message.
	 *
	 * FIXME: It may be fragmented into multiple chunks
	 *        at once if non-fragmentable extension headers
	 *        are too large.
	 * --yoshfuji
	 */

	cork->length += length;
	if (length > mtu) {
		int proto = sk->sk_protocol;
		if (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){
			ipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);
			return -EMSGSIZE;
		}

		if (proto == IPPROTO_UDP &&
		    (rt->dst.dev->features & NETIF_F_UFO)) {

			err = ip6_ufo_append_data(sk, getfrag, from, length,
						  hh_len, fragheaderlen,
						  transhdrlen, mtu, flags, rt);
			if (err)
				goto error;
			return 0;
		}
	}

	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)
		goto alloc_new_skb;

	while (length > 0) {
		/* Check if the remaining data fits into current packet. */
		copy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;
		if (copy < length)
			copy = maxfraglen - skb->len;

		if (copy <= 0) {
			char *data;
			unsigned int datalen;
			unsigned int fraglen;
			unsigned int fraggap;
			unsigned int alloclen;
alloc_new_skb:
			/* There's no room in the current skb */
			if (skb)
				fraggap = skb->len - maxfraglen;
			else
				fraggap = 0;
			/* update mtu and maxfraglen if necessary */
			if (skb == NULL || skb_prev == NULL)
				ip6_append_data_mtu(&mtu, &maxfraglen,
						    fragheaderlen, skb, rt,
						    np->pmtudisc ==
						    IPV6_PMTUDISC_PROBE);

			skb_prev = skb;

			/*
			 * If remaining data exceeds the mtu,
			 * we know we need more fragment(s).
			 */
			datalen = length + fraggap;

			if (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)
				datalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;
			if ((flags & MSG_MORE) &&
			    !(rt->dst.dev->features&NETIF_F_SG))
				alloclen = mtu;
			else
				alloclen = datalen + fragheaderlen;

			alloclen += dst_exthdrlen;

			if (datalen != length + fraggap) {
				/*
				 * this is not the last fragment, the trailer
				 * space is regarded as data space.
				 */
				datalen += rt->dst.trailer_len;
			}

			alloclen += rt->dst.trailer_len;
			fraglen = datalen + fragheaderlen;

			/*
			 * We just reserve space for fragment header.
			 * Note: this may be overallocation if the message
			 * (without MSG_MORE) fits into the MTU.
			 */
			alloclen += sizeof(struct frag_hdr);

			if (transhdrlen) {
				skb = sock_alloc_send_skb(sk,
						alloclen + hh_len,
						(flags & MSG_DONTWAIT), &err);
			} else {
				skb = NULL;
				if (atomic_read(&sk->sk_wmem_alloc) <=
				    2 * sk->sk_sndbuf)
					skb = sock_wmalloc(sk,
							   alloclen + hh_len, 1,
							   sk->sk_allocation);
				if (unlikely(skb == NULL))
					err = -ENOBUFS;
				else {
					/* Only the initial fragment
					 * is time stamped.
					 */
					tx_flags = 0;
				}
			}
			if (skb == NULL)
				goto error;
			/*
			 *	Fill in the control structures
			 */
			skb->protocol = htons(ETH_P_IPV6);
			skb->ip_summed = CHECKSUM_NONE;
			skb->csum = 0;
			/* reserve for fragmentation and ipsec header */
			skb_reserve(skb, hh_len + sizeof(struct frag_hdr) +
				    dst_exthdrlen);

			if (sk->sk_type == SOCK_DGRAM)
				skb_shinfo(skb)->tx_flags = tx_flags;

			/*
			 *	Find where to start putting bytes
			 */
			data = skb_put(skb, fraglen);
			skb_set_network_header(skb, exthdrlen);
			data += fragheaderlen;
			skb->transport_header = (skb->network_header +
						 fragheaderlen);
			if (fraggap) {
				skb->csum = skb_copy_and_csum_bits(
					skb_prev, maxfraglen,
					data + transhdrlen, fraggap, 0);
				skb_prev->csum = csum_sub(skb_prev->csum,
							  skb->csum);
				data += fraggap;
				pskb_trim_unique(skb_prev, maxfraglen);
			}
			copy = datalen - transhdrlen - fraggap;

			if (copy < 0) {
				err = -EINVAL;
				kfree_skb(skb);
				goto error;
			} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {
				err = -EFAULT;
				kfree_skb(skb);
				goto error;
			}

			offset += copy;
			length -= datalen - fraggap;
			transhdrlen = 0;
			exthdrlen = 0;
			dst_exthdrlen = 0;

			/*
			 * Put the packet on the pending queue
			 */
			__skb_queue_tail(&sk->sk_write_queue, skb);
			continue;
		}

		if (copy > length)
			copy = length;

		if (!(rt->dst.dev->features&NETIF_F_SG)) {
			unsigned int off;

			off = skb->len;
			if (getfrag(from, skb_put(skb, copy),
						offset, copy, off, skb) < 0) {
				__skb_trim(skb, off);
				err = -EFAULT;
				goto error;
			}
		} else {
			int i = skb_shinfo(skb)->nr_frags;
			struct page_frag *pfrag = sk_page_frag(sk);

			err = -ENOMEM;
			if (!sk_page_frag_refill(sk, pfrag))
				goto error;

			if (!skb_can_coalesce(skb, i, pfrag->page,
					      pfrag->offset)) {
				err = -EMSGSIZE;
				if (i == MAX_SKB_FRAGS)
					goto error;

				__skb_fill_page_desc(skb, i, pfrag->page,
						     pfrag->offset, 0);
				skb_shinfo(skb)->nr_frags = ++i;
				get_page(pfrag->page);
			}
			copy = min_t(int, copy, pfrag->size - pfrag->offset);
			if (getfrag(from,
				    page_address(pfrag->page) + pfrag->offset,
				    offset, copy, skb->len, skb) < 0)
				goto error_efault;

			pfrag->offset += copy;
			skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
			skb->len += copy;
			skb->data_len += copy;
			skb->truesize += copy;
			atomic_add(copy, &sk->sk_wmem_alloc);
		}
		offset += copy;
		length -= copy;
	}

	return 0;

error_efault:
	err = -EFAULT;
error:
	cork->length -= length;
	IP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);
	return err;
}
",1,7691
torvalds/linux,2811ebac2521ceac84f2bdae402455baa6a7fb47,"static void ip6_append_data_mtu(unsigned int *mtu,
				int *maxfraglen,
				unsigned int fragheaderlen,
				struct sk_buff *skb,
				struct rt6_info *rt,
				bool pmtuprobe)
{
	if (!(rt->dst.flags & DST_XFRM_TUNNEL)) {
		if (skb == NULL) {
			/* first fragment, reserve header_len */
			*mtu = *mtu - rt->dst.header_len;

		} else {
			/*
			 * this fragment is not first, the headers
			 * space is regarded as data space.
			 */
			*mtu = min(*mtu, pmtuprobe ?
				   rt->dst.dev->mtu :
				   dst_mtu(rt->dst.path));
		}
		*maxfraglen = ((*mtu - fragheaderlen) & ~7)
			      + fragheaderlen - sizeof(struct frag_hdr);
	}
}
",0,7692
torvalds/linux,2811ebac2521ceac84f2bdae402455baa6a7fb47,"static int ip6_finish_output(struct sk_buff *skb)
{
	if ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||
	    dst_allfrag(skb_dst(skb)))
		return ip6_fragment(skb, ip6_finish_output2);
	else
		return ip6_finish_output2(skb);
}
",0,7693
torvalds/linux,f5563318ff1bde15b10e736e97ffce13be08bc1a,"int ieee80211_radiotap_iterator_init(
	struct ieee80211_radiotap_iterator *iterator,
	struct ieee80211_radiotap_header *radiotap_header,
	int max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)
{
	/* Linux only supports version 0 radiotap format */
	if (radiotap_header->it_version)
		return -EINVAL;

	/* sanity check for allowed length and radiotap length field */
	if (max_length < get_unaligned_le16(&radiotap_header->it_len))
		return -EINVAL;

	iterator->_rtheader = radiotap_header;
	iterator->_max_length = get_unaligned_le16(&radiotap_header->it_len);
	iterator->_arg_index = 0;
	iterator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);
	iterator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);
	iterator->_reset_on_ext = 0;
	iterator->_next_bitmap = &radiotap_header->it_present;
	iterator->_next_bitmap++;
	iterator->_vns = vns;
	iterator->current_namespace = &radiotap_ns;
	iterator->is_radiotap_ns = 1;

	/* find payload start allowing for extended bitmap(s) */

	if (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {
		while (get_unaligned_le32(iterator->_arg) &
					(1 << IEEE80211_RADIOTAP_EXT)) {
			iterator->_arg += sizeof(uint32_t);

			/*
			 * check for insanity where the present bitmaps
			 * keep claiming to extend up to or even beyond the
			 * stated radiotap header length
			 */

			if ((unsigned long)iterator->_arg -
			    (unsigned long)iterator->_rtheader >
			    (unsigned long)iterator->_max_length)
				return -EINVAL;
		}

		iterator->_arg += sizeof(uint32_t);

		/*
		 * no need to check again for blowing past stated radiotap
		 * header length, because ieee80211_radiotap_iterator_next
		 * checks it before it is dereferenced
		 */
	}

	iterator->this_arg = iterator->_arg;

	/* we are all initialized happily */

	return 0;
}
",1,7694
torvalds/linux,f5563318ff1bde15b10e736e97ffce13be08bc1a,"int ieee80211_radiotap_iterator_next(
	struct ieee80211_radiotap_iterator *iterator)
{
	while (1) {
		int hit = 0;
		int pad, align, size, subns;
		uint32_t oui;

		/* if no more EXT bits, that's it */
		if ((iterator->_arg_index % 32) == IEEE80211_RADIOTAP_EXT &&
		    !(iterator->_bitmap_shifter & 1))
			return -ENOENT;

		if (!(iterator->_bitmap_shifter & 1))
			goto next_entry; /* arg not present */

		/* get alignment/size of data */
		switch (iterator->_arg_index % 32) {
		case IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE:
		case IEEE80211_RADIOTAP_EXT:
			align = 1;
			size = 0;
			break;
		case IEEE80211_RADIOTAP_VENDOR_NAMESPACE:
			align = 2;
			size = 6;
			break;
		default:
			if (!iterator->current_namespace ||
			    iterator->_arg_index >= iterator->current_namespace->n_bits) {
				if (iterator->current_namespace == &radiotap_ns)
					return -ENOENT;
				align = 0;
			} else {
				align = iterator->current_namespace->align_size[iterator->_arg_index].align;
				size = iterator->current_namespace->align_size[iterator->_arg_index].size;
			}
			if (!align) {
				/* skip all subsequent data */
				iterator->_arg = iterator->_next_ns_data;
				/* give up on this namespace */
				iterator->current_namespace = NULL;
				goto next_entry;
			}
			break;
		}

		/*
		 * arg is present, account for alignment padding
		 *
		 * Note that these alignments are relative to the start
		 * of the radiotap header.  There is no guarantee
		 * that the radiotap header itself is aligned on any
		 * kind of boundary.
		 *
		 * The above is why get_unaligned() is used to dereference
		 * multibyte elements from the radiotap area.
		 */

		pad = ((unsigned long)iterator->_arg -
		       (unsigned long)iterator->_rtheader) & (align - 1);

		if (pad)
			iterator->_arg += align - pad;

		if (iterator->_arg_index % 32 == IEEE80211_RADIOTAP_VENDOR_NAMESPACE) {
			int vnslen;

			if ((unsigned long)iterator->_arg + size -
			    (unsigned long)iterator->_rtheader >
			    (unsigned long)iterator->_max_length)
				return -EINVAL;

			oui = (*iterator->_arg << 16) |
				(*(iterator->_arg + 1) << 8) |
				*(iterator->_arg + 2);
			subns = *(iterator->_arg + 3);

			find_ns(iterator, oui, subns);

			vnslen = get_unaligned_le16(iterator->_arg + 4);
			iterator->_next_ns_data = iterator->_arg + size + vnslen;
			if (!iterator->current_namespace)
				size += vnslen;
		}

		/*
		 * this is what we will return to user, but we need to
		 * move on first so next call has something fresh to test
		 */
		iterator->this_arg_index = iterator->_arg_index;
		iterator->this_arg = iterator->_arg;
		iterator->this_arg_size = size;

		/* internally move on the size of this arg */
		iterator->_arg += size;

		/*
		 * check for insanity where we are given a bitmap that
		 * claims to have more arg content than the length of the
		 * radiotap section.  We will normally end up equalling this
		 * max_length on the last arg, never exceeding it.
		 */

		if ((unsigned long)iterator->_arg -
		    (unsigned long)iterator->_rtheader >
		    (unsigned long)iterator->_max_length)
			return -EINVAL;

		/* these special ones are valid in each bitmap word */
		switch (iterator->_arg_index % 32) {
		case IEEE80211_RADIOTAP_VENDOR_NAMESPACE:
			iterator->_reset_on_ext = 1;

			iterator->is_radiotap_ns = 0;
			/*
			 * If parser didn't register this vendor
			 * namespace with us, allow it to show it
			 * as 'raw. Do do that, set argument index
			 * to vendor namespace.
			 */
			iterator->this_arg_index =
				IEEE80211_RADIOTAP_VENDOR_NAMESPACE;
			if (!iterator->current_namespace)
				hit = 1;
			goto next_entry;
		case IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE:
			iterator->_reset_on_ext = 1;
			iterator->current_namespace = &radiotap_ns;
			iterator->is_radiotap_ns = 1;
			goto next_entry;
		case IEEE80211_RADIOTAP_EXT:
			/*
			 * bit 31 was set, there is more
			 * -- move to next u32 bitmap
			 */
			iterator->_bitmap_shifter =
				get_unaligned_le32(iterator->_next_bitmap);
			iterator->_next_bitmap++;
			if (iterator->_reset_on_ext)
				iterator->_arg_index = 0;
			else
				iterator->_arg_index++;
			iterator->_reset_on_ext = 0;
			break;
		default:
			/* we've got a hit! */
			hit = 1;
 next_entry:
			iterator->_bitmap_shifter >>= 1;
			iterator->_arg_index++;
		}

		/* if we found a valid arg earlier, return it now */
		if (hit)
			return 0;
	}
}
",0,7695
file/file,f97486ef5dc3e8735440edc4fc8808c63e1a3ef0," */

#include 'file.h'

#ifndef lint
FILE_RCSID('@(#)$File: cdf.c,v 1.58 2014/05/13 16:41:06 christos Exp $')
#endif

#include <assert.h>
",1,7696
file/file,f97486ef5dc3e8735440edc4fc8808c63e1a3ef0,"FILE_RCSID('@(#)$File: cdf.c,v 1.58 2014/05/13 16:41:06 christos Exp $')
#endif

#include <assert.h>
#ifdef CDF_DEBUG
",1,7697
file/file,f97486ef5dc3e8735440edc4fc8808c63e1a3ef0,"int
cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)
{
	const cdf_section_header_t *shp;
	cdf_section_header_t sh;
	const uint8_t *p, *q, *e;
	int16_t s16;
	int32_t s32;
	uint32_t u32;
	int64_t s64;
	uint64_t u64;
	cdf_timestamp_t tp;
	size_t i, o, o4, nelements, j;
	cdf_property_info_t *inp;

	if (offs > UINT32_MAX / 4) {
		errno = EFTYPE;
		goto out;
	}
	shp = CAST(const cdf_section_header_t *, (const void *)
	    ((const char *)sst->sst_tab + offs));
	if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)
		goto out;
	sh.sh_len = CDF_TOLE4(shp->sh_len);
#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)
	if (sh.sh_len > CDF_SHLEN_LIMIT) {
		errno = EFTYPE;
		goto out;
	}
	sh.sh_properties = CDF_TOLE4(shp->sh_properties);
#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))
	if (sh.sh_properties > CDF_PROP_LIMIT)
		goto out;
	DPRINTF(('section len: %u properties %u\n', sh.sh_len,
	    sh.sh_properties));
	if (*maxcount) {
		if (*maxcount > CDF_PROP_LIMIT)
			goto out;
		*maxcount += sh.sh_properties;
		inp = CAST(cdf_property_info_t *,
		    realloc(*info, *maxcount * sizeof(*inp)));
	} else {
		*maxcount = sh.sh_properties;
		inp = CAST(cdf_property_info_t *,
		    malloc(*maxcount * sizeof(*inp)));
	}
	if (inp == NULL)
		goto out;
	*info = inp;
	inp += *count;
	*count += sh.sh_properties;
	p = CAST(const uint8_t *, (const void *)
	    ((const char *)(const void *)sst->sst_tab +
	    offs + sizeof(sh)));
	e = CAST(const uint8_t *, (const void *)
	    (((const char *)(const void *)shp) + sh.sh_len));
	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
		goto out;
	for (i = 0; i < sh.sh_properties; i++) {
		size_t ofs = CDF_GETUINT32(p, (i << 1) + 1);
		q = (const uint8_t *)(const void *)
		    ((const char *)(const void *)p + ofs
		    - 2 * sizeof(uint32_t));
		if (q > e) {
			DPRINTF(('Ran of the end %p > %p\n', q, e));
			goto out;
		}
		inp[i].pi_id = CDF_GETUINT32(p, i << 1);
		inp[i].pi_type = CDF_GETUINT32(q, 0);
		DPRINTF(('%' SIZE_T_FORMAT 'u) id=%x type=%x offs=0x%tx,0x%x\n',
		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
		if (inp[i].pi_type & CDF_VECTOR) {
			nelements = CDF_GETUINT32(q, 1);
			o = 2;
		} else {
			nelements = 1;
			o = 1;
		}
		o4 = o * sizeof(uint32_t);
		if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))
			goto unknown;
		switch (inp[i].pi_type & CDF_TYPEMASK) {
		case CDF_NULL:
		case CDF_EMPTY:
			break;
		case CDF_SIGNED16:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s16, &q[o4], sizeof(s16));
			inp[i].pi_s16 = CDF_TOLE2(s16);
			break;
		case CDF_SIGNED32:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s32, &q[o4], sizeof(s32));
			inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);
			break;
		case CDF_BOOL:
		case CDF_UNSIGNED32:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u32, &q[o4], sizeof(u32));
			inp[i].pi_u32 = CDF_TOLE4(u32);
			break;
		case CDF_SIGNED64:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s64, &q[o4], sizeof(s64));
			inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);
			break;
		case CDF_UNSIGNED64:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u64, &q[o4], sizeof(u64));
			inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);
			break;
		case CDF_FLOAT:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u32, &q[o4], sizeof(u32));
			u32 = CDF_TOLE4(u32);
			memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));
			break;
		case CDF_DOUBLE:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u64, &q[o4], sizeof(u64));
			u64 = CDF_TOLE8((uint64_t)u64);
			memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));
			break;
		case CDF_LENGTH32_STRING:
		case CDF_LENGTH32_WSTRING:
			if (nelements > 1) {
				size_t nelem = inp - *info;
				if (*maxcount > CDF_PROP_LIMIT
				    || nelements > CDF_PROP_LIMIT)
					goto out;
				*maxcount += nelements;
				inp = CAST(cdf_property_info_t *,
				    realloc(*info, *maxcount * sizeof(*inp)));
				if (inp == NULL)
					goto out;
				*info = inp;
				inp = *info + nelem;
			}
			DPRINTF(('nelements = %' SIZE_T_FORMAT 'u\n',
			    nelements));
			for (j = 0; j < nelements; j++, i++) {
				uint32_t l = CDF_GETUINT32(q, o);
				inp[i].pi_str.s_len = l;
				inp[i].pi_str.s_buf = (const char *)
				    (const void *)(&q[o4 + sizeof(l)]);
				DPRINTF(('l = %d, r = %' SIZE_T_FORMAT
				    'u, s = %s\n', l,
				    CDF_ROUND(l, sizeof(l)),
				    inp[i].pi_str.s_buf));
				if (l & 1)
					l++;
				o += l >> 1;
				if (q + o >= e)
					goto out;
				o4 = o * sizeof(uint32_t);
			}
			i--;
			break;
		case CDF_FILETIME:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&tp, &q[o4], sizeof(tp));
			inp[i].pi_tp = CDF_TOLE8((uint64_t)tp);
			break;
		case CDF_CLIPBOARD:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			break;
		default:
		unknown:
			DPRINTF(('Don't know how to deal with %x\n',
			    inp[i].pi_type));
			break;
		}
	}
	return 0;
out:
	free(*info);
	return -1;
}
",1,7698
file/file,f97486ef5dc3e8735440edc4fc8808c63e1a3ef0,"#ifdef CDF_DEBUG
#define DPRINTF(a) printf a, fflush(stdout)
",0,7699
file/file,f97486ef5dc3e8735440edc4fc8808c63e1a3ef0,"static uint32_t
_cdf_tole4(uint32_t sv)
{
	uint32_t rv;
	uint8_t *s = (uint8_t *)(void *)&sv;
	uint8_t *d = (uint8_t *)(void *)&rv;
	d[0] = s[3];
	d[1] = s[2];
	d[2] = s[1];
	d[3] = s[0];
	return rv;
}
",0,7700
file/file,f97486ef5dc3e8735440edc4fc8808c63e1a3ef0," * 'Compound Document Format', nor the 'Channel Definition Format'.
 */

#include 'file.h'

",0,7701
file/file,447558595a3650db2886cd2f416ad0beba965801,"
#ifndef	lint
FILE_RCSID('@(#)$File: softmagic.c,v 1.170 2014/01/06 02:25:32 christos Exp $')
#endif	/* lint */

#include 'magic.h'
#ifdef HAVE_FMTCHECK
#include <stdio.h>
#define F(a, b) fmtcheck((a), (b))
",1,7702
file/file,447558595a3650db2886cd2f416ad0beba965801,"private void cvt_8(union VALUETYPE *, const struct magic *);
private void cvt_16(union VALUETYPE *, const struct magic *);
private void cvt_32(union VALUETYPE *, const struct magic *);
private void cvt_64(union VALUETYPE *, const struct magic *);

/*
 * softmagic - lookup one file in parsed, in-memory copy of database
 * Passed the name and FILE * of one file to be typed.
 */
",1,7703
file/file,447558595a3650db2886cd2f416ad0beba965801,"#include 'file.h'

#ifndef	lint
FILE_RCSID('@(#)$File: softmagic.c,v 1.170 2014/01/06 02:25:32 christos Exp $')
#endif	/* lint */
",1,7704
file/file,447558595a3650db2886cd2f416ad0beba965801,"/*
 * softmagic - lookup one file in parsed, in-memory copy of database
 * Passed the name and FILE * of one file to be typed.
",1,7705
file/file,447558595a3650db2886cd2f416ad0beba965801,"#endif
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>
",0,7706
file/file,447558595a3650db2886cd2f416ad0beba965801,"

		if (print && mprint(ms, m) == -1)
",0,7708
file/file,447558595a3650db2886cd2f416ad0beba965801,"			case 0:
				flush++;
",0,7709
krb5/krb5,e6ae703ae597d798e310368d52b8f38ee11c6a73,"static OM_uint32
kg_unseal_v1_iov(krb5_context context,
                 OM_uint32 *minor_status,
                 krb5_gss_ctx_id_rec *ctx,
                 gss_iov_buffer_desc *iov,
                 int iov_count,
                 size_t token_wrapper_len,
                 int *conf_state,
                 gss_qop_t *qop_state,
                 int toktype)
{
    OM_uint32 code;
    gss_iov_buffer_t header;
    gss_iov_buffer_t trailer;
    unsigned char *ptr;
    int sealalg;
    int signalg;
    krb5_checksum cksum;
    krb5_checksum md5cksum;
    size_t cksum_len = 0;
    size_t conflen = 0;
    int direction;
    krb5_ui_4 seqnum;
    OM_uint32 retval;
    size_t sumlen;
    krb5_keyusage sign_usage = KG_USAGE_SIGN;

    md5cksum.length = cksum.length = 0;
    md5cksum.contents = cksum.contents = NULL;

    header = kg_locate_header_iov(iov, iov_count, toktype);
    assert(header != NULL);

    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);
    if (trailer != NULL && trailer->buffer.length != 0) {
        *minor_status = (OM_uint32)KRB5_BAD_MSIZE;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    if (header->buffer.length < token_wrapper_len + 14) {
        *minor_status = 0;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    ptr = (unsigned char *)header->buffer.value + token_wrapper_len;

    signalg  = ptr[0];
    signalg |= ptr[1] << 8;

    sealalg  = ptr[2];
    sealalg |= ptr[3] << 8;

    if (ptr[4] != 0xFF || ptr[5] != 0xFF) {
        *minor_status = 0;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    if (toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF) {
        *minor_status = 0;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    if (toktype == KG_TOK_WRAP_MSG &&
        !(sealalg == 0xFFFF || sealalg == ctx->sealalg)) {
        *minor_status = 0;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||
        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||
        (ctx->sealalg == SEAL_ALG_DES3KD &&
         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||
        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&
         signalg != SGN_ALG_HMAC_MD5)) {
        *minor_status = 0;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    switch (signalg) {
    case SGN_ALG_DES_MAC_MD5:
    case SGN_ALG_MD2_5:
    case SGN_ALG_HMAC_MD5:
        cksum_len = 8;
        if (toktype != KG_TOK_WRAP_MSG)
            sign_usage = 15;
        break;
    case SGN_ALG_3:
        cksum_len = 16;
        break;
    case SGN_ALG_HMAC_SHA1_DES3_KD:
        cksum_len = 20;
        break;
    default:
        *minor_status = 0;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    /* get the token parameters */
    code = kg_get_seq_num(context, ctx->seq, ptr + 14, ptr + 6, &direction,
                          &seqnum);
    if (code != 0) {
        *minor_status = code;
        return GSS_S_BAD_SIG;
    }

    /* decode the message, if SEAL */
    if (toktype == KG_TOK_WRAP_MSG) {
        if (sealalg != 0xFFFF) {
            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {
                unsigned char bigend_seqnum[4];
                krb5_keyblock *enc_key;
                size_t i;

                store_32_be(seqnum, bigend_seqnum);

                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);
                if (code != 0) {
                    retval = GSS_S_FAILURE;
                    goto cleanup;
                }

                assert(enc_key->length == 16);

                for (i = 0; i < enc_key->length; i++)
                    ((char *)enc_key->contents)[i] ^= 0xF0;

                code = kg_arcfour_docrypt_iov(context, enc_key, 0,
                                              &bigend_seqnum[0], 4,
                                              iov, iov_count);
                krb5_free_keyblock(context, enc_key);
            } else {
                code = kg_decrypt_iov(context, 0,
                                      ((ctx->gss_flags & GSS_C_DCE_STYLE) != 0),
                                      0 /*EC*/, 0 /*RRC*/,
                                      ctx->enc, KG_USAGE_SEAL, NULL,
                                      iov, iov_count);
            }
            if (code != 0) {
                retval = GSS_S_FAILURE;
                goto cleanup;
            }
        }
        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);
    }

    if (header->buffer.length != token_wrapper_len + 14 + cksum_len + conflen) {
        retval = GSS_S_DEFECTIVE_TOKEN;
        goto cleanup;
    }

    /* compute the checksum of the message */

    /* initialize the checksum */

    switch (signalg) {
    case SGN_ALG_DES_MAC_MD5:
    case SGN_ALG_MD2_5:
    case SGN_ALG_DES_MAC:
    case SGN_ALG_3:
        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;
        break;
    case SGN_ALG_HMAC_MD5:
        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;
        break;
    case SGN_ALG_HMAC_SHA1_DES3_KD:
        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;
        break;
    default:
        abort();
    }

    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);
    if (code != 0) {
        retval = GSS_S_FAILURE;
        goto cleanup;
    }
    md5cksum.length = sumlen;

    /* compute the checksum of the message */
    code = kg_make_checksum_iov_v1(context, md5cksum.checksum_type,
                                   cksum_len, ctx->seq, ctx->enc,
                                   sign_usage, iov, iov_count, toktype,
                                   &md5cksum);
    if (code != 0) {
        retval = GSS_S_FAILURE;
        goto cleanup;
    }

    switch (signalg) {
    case SGN_ALG_DES_MAC_MD5:
    case SGN_ALG_3:
        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,
                                  (g_OID_equal(ctx->mech_used,
                                               gss_mech_krb5_old) ?
                                   ctx->seq->keyblock.contents : NULL),
                                  md5cksum.contents, 16);
        if (code != 0) {
            retval = GSS_S_FAILURE;
            goto cleanup;
        }

        cksum.length = cksum_len;
        cksum.contents = md5cksum.contents + 16 - cksum.length;

        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);
        break;
    case SGN_ALG_HMAC_SHA1_DES3_KD:
    case SGN_ALG_HMAC_MD5:
        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);
        break;
    default:
        code = 0;
        retval = GSS_S_DEFECTIVE_TOKEN;
        goto cleanup;
        break;
    }

    if (code != 0) {
        code = 0;
        retval = GSS_S_BAD_SIG;
        goto cleanup;
    }

    /*
     * For GSS_C_DCE_STYLE, the caller manages the padding, because the
     * pad length is in the RPC PDU. The value of the padding may be
     * uninitialized. For normal GSS, the last bytes of the decrypted
     * data contain the pad length. kg_fixup_padding_iov() will find
     * this and fixup the last data IOV appropriately.
     */
    if (toktype == KG_TOK_WRAP_MSG &&
        (ctx->gss_flags & GSS_C_DCE_STYLE) == 0) {
        retval = kg_fixup_padding_iov(&code, iov, iov_count);
        if (retval != GSS_S_COMPLETE)
            goto cleanup;
    }

    if (conf_state != NULL)
        *conf_state = (sealalg != 0xFFFF);

    if (qop_state != NULL)
        *qop_state = GSS_C_QOP_DEFAULT;

    if ((ctx->initiate && direction != 0xff) ||
        (!ctx->initiate && direction != 0)) {
        *minor_status = (OM_uint32)G_BAD_DIRECTION;
        retval = GSS_S_BAD_SIG;
    }

    code = 0;
    retval = g_order_check(&ctx->seqstate, (gssint_uint64)seqnum);

cleanup:
    krb5_free_checksum_contents(context, &md5cksum);

    *minor_status = code;

    return retval;
}
",1,7710
krb5/krb5,e6ae703ae597d798e310368d52b8f38ee11c6a73,"static OM_uint32
kg_unseal_iov_token(OM_uint32 *minor_status,
                    krb5_gss_ctx_id_rec *ctx,
                    int *conf_state,
                    gss_qop_t *qop_state,
                    gss_iov_buffer_desc *iov,
                    int iov_count,
                    int toktype)
{
    krb5_error_code code;
    krb5_context context = ctx->k5_context;
    unsigned char *ptr;
    gss_iov_buffer_t header;
    gss_iov_buffer_t padding;
    gss_iov_buffer_t trailer;
    size_t input_length;
    unsigned int bodysize;
    int toktype2;

    header = kg_locate_header_iov(iov, iov_count, toktype);
    if (header == NULL) {
        *minor_status = EINVAL;
        return GSS_S_FAILURE;
    }

    padding = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_PADDING);
    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);

    ptr = (unsigned char *)header->buffer.value;
    input_length = header->buffer.length;

    if ((ctx->gss_flags & GSS_C_DCE_STYLE) == 0 &&
        toktype == KG_TOK_WRAP_MSG) {
        size_t data_length, assoc_data_length;

        kg_iov_msglen(iov, iov_count, &data_length, &assoc_data_length);

        input_length += data_length - assoc_data_length;

        if (padding != NULL)
            input_length += padding->buffer.length;

        if (trailer != NULL)
            input_length += trailer->buffer.length;
    }

    code = g_verify_token_header(ctx->mech_used,
                                 &bodysize, &ptr, -1,
                                 input_length, 0);
    if (code != 0) {
        *minor_status = code;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    if (bodysize < 2) {
        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    toktype2 = load_16_be(ptr);

    ptr += 2;
    bodysize -= 2;

    switch (toktype2) {
    case KG2_TOK_MIC_MSG:
    case KG2_TOK_WRAP_MSG:
    case KG2_TOK_DEL_CTX:
        code = gss_krb5int_unseal_v3_iov(context, minor_status, ctx, iov, iov_count,
                                         conf_state, qop_state, toktype);
        break;
    case KG_TOK_MIC_MSG:
    case KG_TOK_WRAP_MSG:
    case KG_TOK_DEL_CTX:
        code = kg_unseal_v1_iov(context, minor_status, ctx, iov, iov_count,
                                (size_t)(ptr - (unsigned char *)header->buffer.value),
                                conf_state, qop_state, toktype);
        break;
    default:
        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;
        code = GSS_S_DEFECTIVE_TOKEN;
        break;
    }

    if (code != 0)
        save_error_info(*minor_status, context);

    return code;
}
",0,7711
sgminer-dev/sgminer,bac5831b355f916e0696b7bbcccfc51c057b729a,"bool initiate_stratum(struct pool *pool)
{
	bool ret = false, recvd = false, noresume = false, sockd = false;
	char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;
	json_t *val = NULL, *res_val, *err_val;
	json_error_t err;
	int n2size;

resend:
	if (!setup_stratum_socket(pool)) {
		/* FIXME: change to LOG_DEBUG when issue #88 resolved */
		applog(LOG_INFO, 'setup_stratum_socket() on %s failed', get_pool_name(pool));
		sockd = false;
		goto out;
	}

	sockd = true;

	if (recvd) {
		/* Get rid of any crap lying around if we're resending */
		clear_sock(pool);
		sprintf(s, '{\'id\': %d, \'method\': \'mining.subscribe\', \'params\': []}', swork_id++);
	} else {
		if (pool->sessionid)
			sprintf(s, '{\'id\': %d, \'method\': \'mining.subscribe\', \'params\': [\''PACKAGE'/'VERSION'\', \'%s\']}', swork_id++, pool->sessionid);
		else
			sprintf(s, '{\'id\': %d, \'method\': \'mining.subscribe\', \'params\': [\''PACKAGE'/'VERSION'\']}', swork_id++);
	}

	if (__stratum_send(pool, s, strlen(s)) != SEND_OK) {
		applog(LOG_DEBUG, 'Failed to send s in initiate_stratum');
		goto out;
	}

	if (!socket_full(pool, DEFAULT_SOCKWAIT)) {
		applog(LOG_DEBUG, 'Timed out waiting for response in initiate_stratum');
		goto out;
	}

	sret = recv_line(pool);
	if (!sret)
		goto out;

	recvd = true;

	val = JSON_LOADS(sret, &err);
	free(sret);
	if (!val) {
		applog(LOG_INFO, 'JSON decode failed(%d): %s', err.line, err.text);
		goto out;
	}

	res_val = json_object_get(val, 'result');
	err_val = json_object_get(val, 'error');

	if (!res_val || json_is_null(res_val) ||
	    (err_val && !json_is_null(err_val))) {
		char *ss;

		if (err_val)
			ss = json_dumps(err_val, JSON_INDENT(3));
		else
			ss = strdup('(unknown reason)');

		applog(LOG_INFO, 'JSON-RPC decode failed: %s', ss);

		free(ss);

		goto out;
	}

	sessionid = get_sessionid(res_val);
	if (!sessionid)
		applog(LOG_DEBUG, 'Failed to get sessionid in initiate_stratum');
	nonce1 = json_array_string(res_val, 1);
	if (!nonce1) {
		applog(LOG_INFO, 'Failed to get nonce1 in initiate_stratum');
		free(sessionid);
		goto out;
	}
	n2size = json_integer_value(json_array_get(res_val, 2));
	if (!n2size) {
		applog(LOG_INFO, 'Failed to get n2size in initiate_stratum');
		free(sessionid);
		free(nonce1);
		goto out;
	}

	cg_wlock(&pool->data_lock);
	pool->sessionid = sessionid;
	pool->nonce1 = nonce1;
	pool->n1_len = strlen(nonce1) / 2;
	free(pool->nonce1bin);
	pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);
	if (unlikely(!pool->nonce1bin))
		quithere(1, 'Failed to calloc pool->nonce1bin');
	hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
	pool->n2size = n2size;
	cg_wunlock(&pool->data_lock);

	if (sessionid)
		applog(LOG_DEBUG, '%s stratum session id: %s', get_pool_name(pool), pool->sessionid);

	ret = true;
out:
	if (ret) {
		if (!pool->stratum_url)
			pool->stratum_url = pool->sockaddr_url;
		pool->stratum_active = true;
		pool->swork.diff = 1;
		if (opt_protocol) {
			applog(LOG_DEBUG, '%s confirmed mining.subscribe with extranonce1 %s extran2size %d',
			       get_pool_name(pool), pool->nonce1, pool->n2size);
		}
	} else {
		if (recvd && !noresume) {
			/* Reset the sessionid used for stratum resuming in case the pool
			* does not support it, or does not know how to respond to the
			* presence of the sessionid parameter. */
			cg_wlock(&pool->data_lock);
			free(pool->sessionid);
			free(pool->nonce1);
			pool->sessionid = pool->nonce1 = NULL;
			cg_wunlock(&pool->data_lock);

			applog(LOG_DEBUG, 'Failed to resume stratum, trying afresh');
			noresume = true;
			json_decref(val);
			goto resend;
		}
		applog(LOG_DEBUG, 'Initiating stratum failed on %s', get_pool_name(pool));
		if (sockd) {
		  applog(LOG_DEBUG, 'Suspending stratum on %s', get_pool_name(pool));
			suspend_stratum(pool);
		}
	}

	json_decref(val);
	return ret;
}
",1,7712
sgminer-dev/sgminer,bac5831b355f916e0696b7bbcccfc51c057b729a,"char *bin2hex(const unsigned char *p, size_t len)
{
	ssize_t slen;
	char *s;

	slen = len * 2 + 1;
	if (slen % 4)
		slen += 4 - (slen % 4);
	s = (char *)calloc(slen, 1);
	if (unlikely(!s))
		quithere(1, 'Failed to calloc');

	__bin2hex(s, p, len);

	return s;
}
",0,7713
torvalds/linux,295dc39d941dc2ae53d5c170365af4c9d5c16212,"static int
mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
		goto out;
	}
	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
		return 1;
	follow_mount(path);
	error = 0;
out:
	terminate_walk(nd);
	return error;
}
",1,7714
torvalds/linux,295dc39d941dc2ae53d5c170365af4c9d5c16212,"void unlock_rename(struct dentry *p1, struct dentry *p2)
{
	mutex_unlock(&p1->d_inode->i_mutex);
	if (p1 != p2) {
		mutex_unlock(&p2->d_inode->i_mutex);
		mutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
	}
}
",0,7715
aircrack-ng/aircrack-ng,091b153f294b9b695b0b2831e65936438b550d7b,"int tcp_test(const char* ip_str, const short port)
{
    int sock, i;
    struct sockaddr_in s_in;
    int packetsize = 1024;
    unsigned char packet[packetsize];
    struct timeval tv, tv2, tv3;
    int caplen = 0;
    int times[REQUESTS];
    int min, avg, max, len;
    struct net_hdr nh;

    tv3.tv_sec=0;
    tv3.tv_usec=1;

    s_in.sin_family = PF_INET;
    s_in.sin_port = htons(port);
    if (!inet_aton(ip_str, &s_in.sin_addr))
            return -1;

    if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)
            return -1;

    /* avoid blocking on reading the socket */
    if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )
    {
        perror( 'fcntl(O_NONBLOCK) failed' );
        return( 1 );
    }

    gettimeofday( &tv, NULL );

    while (1)  //waiting for relayed packet
    {
        if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)
        {
            if(errno != EINPROGRESS && errno != EALREADY)
            {
                perror('connect');
                close(sock);

                printf('Failed to connect\n');

                return -1;
            }
        }
        else
        {
            gettimeofday( &tv2, NULL );
            break;
        }

        gettimeofday( &tv2, NULL );
        //wait 3000ms for a successful connect
        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3000*1000))
        {
            printf('Connection timed out\n');
            close(sock);
            return(-1);
        }
        usleep(10);
    }

    PCT; printf('TCP connection successful\n');

    //trying to identify airserv-ng
    memset(&nh, 0, sizeof(nh));
//     command: GET_CHAN
    nh.nh_type	= 2;
    nh.nh_len	= htonl(0);

    if (send(sock, &nh, sizeof(nh), 0) != sizeof(nh))
    {
        perror('send');
        return -1;
    }

    gettimeofday( &tv, NULL );
    i=0;

    while (1)  //waiting for GET_CHAN answer
    {
        caplen = read(sock, &nh, sizeof(nh));

        if(caplen == -1)
        {
            if( errno != EAGAIN )
            {
                perror('read');
                return -1;
            }
        }

        if( (unsigned)caplen == sizeof(nh))
        {
            len = ntohl(nh.nh_len);
            if( nh.nh_type == 1 && i==0 )
            {
                i=1;
                caplen = read(sock, packet, len);
                if(caplen == len)
                {
                    i=2;
                    break;
                }
                else
                {
                    i=0;
                }
            }
            else
            {
                caplen = read(sock, packet, len);
            }
        }

        gettimeofday( &tv2, NULL );
        //wait 1000ms for an answer
        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))
        {
            break;
        }
        if(caplen == -1)
            usleep(10);
    }

    if(i==2)
    {
        PCT; printf('airserv-ng found\n');
    }
    else
    {
        PCT; printf('airserv-ng NOT found\n');
    }

    close(sock);

    for(i=0; i<REQUESTS; i++)
    {
        if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)
                return -1;

        /* avoid blocking on reading the socket */
        if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )
        {
            perror( 'fcntl(O_NONBLOCK) failed' );
            return( 1 );
        }

        usleep(1000);

        gettimeofday( &tv, NULL );

        while (1)  //waiting for relayed packet
        {
            if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)
            {
                if(errno != EINPROGRESS && errno != EALREADY)
                {
                    perror('connect');
                    close(sock);

                    printf('Failed to connect\n');

                    return -1;
                }
            }
            else
            {
                gettimeofday( &tv2, NULL );
                break;
            }

            gettimeofday( &tv2, NULL );
            //wait 1000ms for a successful connect
            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))
            {
                break;
            }
            //simple 'high-precision' usleep
            select(1, NULL, NULL, NULL, &tv3);
        }
        times[i] = ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec));
        printf( '\r%d/%d\r', i, REQUESTS);
        fflush(stdout);
        close(sock);
    }

    min = INT_MAX;
    avg = 0;
    max = 0;

    for(i=0; i<REQUESTS; i++)
    {
        if(times[i] < min) min = times[i];
        if(times[i] > max) max = times[i];
        avg += times[i];
    }
    avg /= REQUESTS;

    PCT; printf('ping %s:%d (min/avg/max): %.3fms/%.3fms/%.3fms\n', ip_str, port, min/1000.0, avg/1000.0, max/1000.0);

    return 0;
}
",1,7716
aircrack-ng/aircrack-ng,091b153f294b9b695b0b2831e65936438b550d7b,"
#define RTC_RESOLUTION  8192

",0,7717
krb5/krb5,df17a1224a3406f57477bcd372c61e04c0e5a5bb,"bool_t xdr_nullstring(XDR *xdrs, char **objp)
{
     u_int size;

     if (xdrs->x_op == XDR_ENCODE) {
	  if (*objp == NULL)
	       size = 0;
	  else
	       size = strlen(*objp) + 1;
     }
     if (! xdr_u_int(xdrs, &size)) {
	  return FALSE;
	}
     switch (xdrs->x_op) {
     case XDR_DECODE:
	  if (size == 0) {
	       *objp = NULL;
	       return TRUE;
	  } else if (*objp == NULL) {
	       *objp = (char *) mem_alloc(size);
	       if (*objp == NULL) {
		    errno = ENOMEM;
		    return FALSE;
	       }
	  }
	  return (xdr_opaque(xdrs, *objp, size));

     case XDR_ENCODE:
	  if (size != 0)
	       return (xdr_opaque(xdrs, *objp, size));
	  return TRUE;

     case XDR_FREE:
	  if (*objp != NULL)
	       mem_free(*objp, size);
	  *objp = NULL;
	  return TRUE;
     }

     return FALSE;
}
",1,7718
krb5/krb5,df17a1224a3406f57477bcd372c61e04c0e5a5bb,"bool_t
xdr_chpass_arg(XDR *xdrs, chpass_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_krb5_principal(xdrs, &objp->princ)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->pass)) {
		return (FALSE);
	}
	return (TRUE);
}
",0,7719
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)
{
    static generic_ret          ret;
    char                        *prime_arg;
    gss_buffer_desc             client_name, service_name;
    OM_uint32                   minor_stat;
    kadm5_server_handle_t       handle;
    restriction_t               *rp;
    const char                  *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (CHANGEPW_SERVICE(rqstp)
        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,
                               arg->rec.principal, &rp)
        || kadm5int_acl_impose_restrictions(handle->context,
                                            &arg->rec, &arg->mask, rp)) {
        ret.code = KADM5_AUTH_ADD;
        log_unauth('kadm5_create_principal', prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code = kadm5_create_principal((void *)handle,
                                          &arg->rec, arg->mask,
                                          arg->passwd);

        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_create_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);

exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7720
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)
{
    static generic_ret          ret;
    char                        *prime_arg;
    gss_buffer_desc             client_name, service_name;
    OM_uint32                   minor_stat;
    kadm5_server_handle_t       handle;
    restriction_t               *rp;
    const char                  *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (CHANGEPW_SERVICE(rqstp)
        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,
                               arg->rec.principal, &rp)
        || kadm5int_acl_impose_restrictions(handle->context,
                                            &arg->rec, &arg->mask, rp)) {
        ret.code = KADM5_AUTH_ADD;
        log_unauth('kadm5_create_principal', prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code = kadm5_create_principal_3((void *)handle,
                                            &arg->rec, arg->mask,
                                            arg->n_ks_tuple,
                                            arg->ks_tuple,
                                            arg->passwd);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_create_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);

exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7721
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (CHANGEPW_SERVICE(rqstp)
        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,
                               arg->princ, NULL)) {
        ret.code = KADM5_AUTH_DELETE;
        log_unauth('kadm5_delete_principal', prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code = kadm5_delete_principal((void *)handle, arg->princ);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_delete_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);

    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);

exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7722
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    restriction_t                   *rp;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (CHANGEPW_SERVICE(rqstp)
        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,
                               arg->rec.principal, &rp)
        || kadm5int_acl_impose_restrictions(handle->context,
                                            &arg->rec, &arg->mask, rp)) {
        ret.code = KADM5_AUTH_MODIFY;
        log_unauth('kadm5_modify_principal', prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,
                                          arg->mask);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_modify_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7723
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)
{
    static generic_ret          ret;
    char                        *prime_arg1,
        *prime_arg2;
    gss_buffer_desc             client_name,
        service_name;
    OM_uint32                   minor_stat;
    kadm5_server_handle_t       handle;
    restriction_t               *rp;
    const char                  *errmsg = NULL;
    size_t                      tlen1, tlen2, clen, slen;
    char                        *tdots1, *tdots2, *cdots, *sdots;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||
        krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }
    tlen1 = strlen(prime_arg1);
    trunc_name(&tlen1, &tdots1);
    tlen2 = strlen(prime_arg2);
    trunc_name(&tlen2, &tdots2);
    clen = client_name.length;
    trunc_name(&clen, &cdots);
    slen = service_name.length;
    trunc_name(&slen, &sdots);

    ret.code = KADM5_OK;
    if (! CHANGEPW_SERVICE(rqstp)) {
        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),
                                ACL_DELETE, arg->src, NULL))
            ret.code = KADM5_AUTH_DELETE;
        /* any restrictions at all on the ADD kills the RENAME */
        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),
                                ACL_ADD, arg->dest, &rp) || rp) {
            if (ret.code == KADM5_AUTH_DELETE)
                ret.code = KADM5_AUTH_INSUFFICIENT;
            else
                ret.code = KADM5_AUTH_ADD;
        }
    } else
        ret.code = KADM5_AUTH_INSUFFICIENT;
    if (ret.code != KADM5_OK) {
        /* okay to cast lengths to int because trunc_name limits max value */
        krb5_klog_syslog(LOG_NOTICE,
                         _('Unauthorized request: kadm5_rename_principal, '
                           '%.*s%s to %.*s%s, '
                           'client=%.*s%s, service=%.*s%s, addr=%s'),
                         (int)tlen1, prime_arg1, tdots1,
                         (int)tlen2, prime_arg2, tdots2,
                         (int)clen, (char *)client_name.value, cdots,
                         (int)slen, (char *)service_name.value, sdots,
                         client_addr(rqstp->rq_xprt));
    } else {
        ret.code = kadm5_rename_principal((void *)handle, arg->src,
                                          arg->dest);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        /* okay to cast lengths to int because trunc_name limits max value */
        krb5_klog_syslog(LOG_NOTICE,
                         _('Request: kadm5_rename_principal, '
                           '%.*s%s to %.*s%s, %s, '
                           'client=%.*s%s, service=%.*s%s, addr=%s'),
                         (int)tlen1, prime_arg1, tdots1,
                         (int)tlen2, prime_arg2, tdots2,
                         errmsg ? errmsg : _('success'),
                         (int)clen, (char *)client_name.value, cdots,
                         (int)slen, (char *)service_name.value, sdots,
                         client_addr(rqstp->rq_xprt));

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);

    }
    free(prime_arg1);
    free(prime_arg2);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7724
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"gprinc_ret *
get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)
{
    static gprinc_ret               ret;
    char                            *prime_arg, *funcname;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_gprinc_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    funcname = 'kadm5_get_principal';

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&
        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                        rqst2name(rqstp),
                                                        ACL_INQUIRE,
                                                        arg->princ,
                                                        NULL))) {
        ret.code = KADM5_AUTH_GET;
        log_unauth(funcname, prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,
                                       arg->mask);

        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done(funcname, prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7725
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"gprincs_ret *
get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)
{
    static gprincs_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_gprincs_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    prime_arg = arg->exp;
    if (prime_arg == NULL)
        prime_arg = '*';

    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                       rqst2name(rqstp),
                                                       ACL_LIST,
                                                       NULL,
                                                       NULL)) {
        ret.code = KADM5_AUTH_LIST;
        log_unauth('kadm5_get_principals', prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code  = kadm5_get_principals((void *)handle,
                                         arg->exp, &ret.princs,
                                         &ret.count);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_get_principals', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);

    }
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7726
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {
        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,
                                              FALSE, 0, NULL, arg->pass);
    } else if (!(CHANGEPW_SERVICE(rqstp)) &&
               kadm5int_acl_check(handle->context, rqst2name(rqstp),
                                  ACL_CHANGEPW, arg->princ, NULL)) {
        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,
                                          arg->pass);
    } else {
        log_unauth('kadm5_chpass_principal', prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_CHANGEPW;
    }

    if (ret.code != KADM5_AUTH_CHANGEPW) {
        if (ret.code != 0)
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_chpass_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }

    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7727
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {
        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,
                                              arg->keepold,
                                              arg->n_ks_tuple,
                                              arg->ks_tuple,
                                              arg->pass);
    } else if (!(CHANGEPW_SERVICE(rqstp)) &&
               kadm5int_acl_check(handle->context, rqst2name(rqstp),
                                  ACL_CHANGEPW, arg->princ, NULL)) {
        ret.code = kadm5_chpass_principal_3((void *)handle, arg->princ,
                                            arg->keepold,
                                            arg->n_ks_tuple,
                                            arg->ks_tuple,
                                            arg->pass);
    } else {
        log_unauth('kadm5_chpass_principal', prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_CHANGEPW;
    }

    if(ret.code != KADM5_AUTH_CHANGEPW) {
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_chpass_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }

    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7728
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (!(CHANGEPW_SERVICE(rqstp)) &&
        kadm5int_acl_check(handle->context, rqst2name(rqstp),
                           ACL_SETKEY, arg->princ, NULL)) {
        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,
                                            arg->keyblock);
    } else {
        log_unauth('kadm5_setv4key_principal', prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_SETKEY;
    }

    if(ret.code != KADM5_AUTH_SETKEY) {
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_setv4key_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }

    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7729
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (!(CHANGEPW_SERVICE(rqstp)) &&
        kadm5int_acl_check(handle->context, rqst2name(rqstp),
                           ACL_SETKEY, arg->princ, NULL)) {
        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,
                                          arg->keyblocks, arg->n_keys);
    } else {
        log_unauth('kadm5_setkey_principal', prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_SETKEY;
    }

    if(ret.code != KADM5_AUTH_SETKEY) {
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_setkey_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }

    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7730
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (!(CHANGEPW_SERVICE(rqstp)) &&
        kadm5int_acl_check(handle->context, rqst2name(rqstp),
                           ACL_SETKEY, arg->princ, NULL)) {
        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,
                                            arg->keepold,
                                            arg->n_ks_tuple,
                                            arg->ks_tuple,
                                            arg->keyblocks, arg->n_keys);
    } else {
        log_unauth('kadm5_setkey_principal', prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_SETKEY;
    }

    if(ret.code != KADM5_AUTH_SETKEY) {
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_setkey_principal', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }

    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7731
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"chrand_ret *
chrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)
{
    static chrand_ret           ret;
    krb5_keyblock               *k;
    int                         nkeys;
    char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name,
        service_name;
    OM_uint32                   minor_stat;
    kadm5_server_handle_t       handle;
    const char                  *errmsg = NULL;

    xdr_free(xdr_chrand_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;


    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    funcname = 'kadm5_randkey_principal';

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {
        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,
                                               FALSE, 0, NULL, &k, &nkeys);
    } else if (!(CHANGEPW_SERVICE(rqstp)) &&
               kadm5int_acl_check(handle->context, rqst2name(rqstp),
                                  ACL_CHANGEPW, arg->princ, NULL)) {
        ret.code = kadm5_randkey_principal((void *)handle, arg->princ,
                                           &k, &nkeys);
    } else {
        log_unauth(funcname, prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_CHANGEPW;
    }

    if(ret.code == KADM5_OK) {
        ret.keys = k;
        ret.n_keys = nkeys;
    }

    if(ret.code != KADM5_AUTH_CHANGEPW) {
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done(funcname, prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7732
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"chrand_ret *
chrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)
{
    static chrand_ret           ret;
    krb5_keyblock               *k;
    int                         nkeys;
    char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name,
        service_name;
    OM_uint32                   minor_stat;
    kadm5_server_handle_t       handle;
    const char                  *errmsg = NULL;

    xdr_free(xdr_chrand_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    funcname = 'kadm5_randkey_principal';

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {
        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,
                                               arg->keepold,
                                               arg->n_ks_tuple,
                                               arg->ks_tuple,
                                               &k, &nkeys);
    } else if (!(CHANGEPW_SERVICE(rqstp)) &&
               kadm5int_acl_check(handle->context, rqst2name(rqstp),
                                  ACL_CHANGEPW, arg->princ, NULL)) {
        ret.code = kadm5_randkey_principal_3((void *)handle, arg->princ,
                                             arg->keepold,
                                             arg->n_ks_tuple,
                                             arg->ks_tuple,
                                             &k, &nkeys);
    } else {
        log_unauth(funcname, prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_CHANGEPW;
    }

    if(ret.code == KADM5_OK) {
        ret.keys = k;
        ret.n_keys = nkeys;
    }

    if(ret.code != KADM5_AUTH_CHANGEPW) {
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done(funcname, prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7733
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    prime_arg = arg->rec.policy;

    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                       rqst2name(rqstp),
                                                       ACL_ADD, NULL, NULL)) {
        ret.code = KADM5_AUTH_ADD;
        log_unauth('kadm5_create_policy', prime_arg,
                   &client_name, &service_name, rqstp);

    } else {
        ret.code = kadm5_create_policy((void *)handle, &arg->rec,
                                       arg->mask);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_create_policy',
                 ((prime_arg == NULL) ? '(null)' : prime_arg), errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7734
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    prime_arg = arg->name;

    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                       rqst2name(rqstp),
                                                       ACL_DELETE, NULL, NULL)) {
        log_unauth('kadm5_delete_policy', prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_DELETE;
    } else {
        ret.code = kadm5_delete_policy((void *)handle, arg->name);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_delete_policy',
                 ((prime_arg == NULL) ? '(null)' : prime_arg), errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7735
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    prime_arg = arg->rec.policy;

    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                       rqst2name(rqstp),
                                                       ACL_MODIFY, NULL, NULL)) {
        log_unauth('kadm5_modify_policy', prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_MODIFY;
    } else {
        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,
                                       arg->mask);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_modify_policy',
                 ((prime_arg == NULL) ? '(null)' : prime_arg), errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7736
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"gpol_ret *
get_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)
{
    static gpol_ret             ret;
    kadm5_ret_t         ret2;
    char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name,
        service_name;
    OM_uint32                   minor_stat;
    kadm5_principal_ent_rec     caller_ent;
    kadm5_server_handle_t       handle;
    const char                  *errmsg = NULL;

    xdr_free(xdr_gpol_ret,  &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    funcname = 'kadm5_get_policy';

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    prime_arg = arg->name;

    ret.code = KADM5_AUTH_GET;
    if (!CHANGEPW_SERVICE(rqstp) && kadm5int_acl_check(handle->context,
                                                       rqst2name(rqstp),
                                                       ACL_INQUIRE, NULL, NULL))
        ret.code = KADM5_OK;
    else {
        ret.code = kadm5_get_principal(handle->lhandle,
                                       handle->current_caller,
                                       &caller_ent,
                                       KADM5_PRINCIPAL_NORMAL_MASK);
        if (ret.code == KADM5_OK) {
            if (caller_ent.aux_attributes & KADM5_POLICY &&
                strcmp(caller_ent.policy, arg->name) == 0) {
                ret.code = KADM5_OK;
            } else ret.code = KADM5_AUTH_GET;
            ret2 = kadm5_free_principal_ent(handle->lhandle,
                                            &caller_ent);
            ret.code = ret.code ? ret.code : ret2;
        }
    }

    if (ret.code == KADM5_OK) {
        ret.code = kadm5_get_policy(handle, arg->name, &ret.rec);

        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done(funcname,
                 ((prime_arg == NULL) ? '(null)' : prime_arg), errmsg,
                 &client_name, &service_name, rqstp);
        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);

    } else {
        log_unauth(funcname, prime_arg,
                   &client_name, &service_name, rqstp);
    }
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;

}
",1,7737
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"gpols_ret *
get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)
{
    static gpols_ret                ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_gpols_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    prime_arg = arg->exp;
    if (prime_arg == NULL)
        prime_arg = '*';

    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                       rqst2name(rqstp),
                                                       ACL_LIST, NULL, NULL)) {
        ret.code = KADM5_AUTH_LIST;
        log_unauth('kadm5_get_policies', prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code  = kadm5_get_policies((void *)handle,
                                       arg->exp, &ret.pols,
                                       &ret.count);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_get_policies', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7738
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
{
    static getprivs_ret            ret;
    gss_buffer_desc                client_name, service_name;
    OM_uint32                      minor_stat;
    kadm5_server_handle_t          handle;
    const char                     *errmsg = NULL;

    xdr_free(xdr_getprivs_ret, &ret);

    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }

    ret.code = kadm5_get_privs((void *)handle, &ret.privs);
    if( ret.code != 0 )
        errmsg = krb5_get_error_message(handle->context, ret.code);

    log_done('kadm5_get_privs', client_name.value, errmsg,
             &client_name, &service_name, rqstp);

    if (errmsg != NULL)
        krb5_free_error_message(handle->context, errmsg);

    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7739
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)
{
    static generic_ret          ret;
    char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name, service_name;
    OM_uint32                   minor_stat;
    kadm5_server_handle_t       handle;

    const char                  *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    funcname = 'kadm5_purgekeys';

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&
        (CHANGEPW_SERVICE(rqstp)
         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,
                                arg->princ, NULL))) {
        ret.code = KADM5_AUTH_MODIFY;
        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);
    } else {
        ret.code = kadm5_purgekeys((void *)handle, arg->princ,
                                   arg->keepkvno);
        if (ret.code != 0)
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done(funcname, prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7740
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"gstrings_ret *
get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)
{
    static gstrings_ret             ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_gstrings_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&
        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                        rqst2name(rqstp),
                                                        ACL_INQUIRE,
                                                        arg->princ,
                                                        NULL))) {
        ret.code = KADM5_AUTH_GET;
        log_unauth('kadm5_get_strings', prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,
                                     &ret.count);
        if (ret.code != 0)
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_get_strings', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7741
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *
set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (CHANGEPW_SERVICE(rqstp)
        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,
                               arg->princ, NULL)) {
        ret.code = KADM5_AUTH_MODIFY;
        log_unauth('kadm5_mod_strings', prime_arg,
                   &client_name, &service_name, rqstp);
    } else {
        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,
                                    arg->value);
        if (ret.code != 0)
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done('kadm5_mod_strings', prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }
    free(prime_arg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}
",1,7742
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
{
    static generic_ret         ret;
    gss_buffer_desc            client_name,
        service_name;
    kadm5_server_handle_t      handle;
    OM_uint32                  minor_stat;
    const char                 *errmsg = NULL;
    size_t clen, slen;
    char *cdots, *sdots;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))
        goto exit_func;
    if (! (ret.code = check_handle((void *)handle))) {
        ret.api_version = handle->api_version;
    }

    free_server_handle(handle);

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }

    if (ret.code != 0)
        errmsg = krb5_get_error_message(NULL, ret.code);

    clen = client_name.length;
    trunc_name(&clen, &cdots);
    slen = service_name.length;
    trunc_name(&slen, &sdots);
    /* okay to cast lengths to int because trunc_name limits max value */
    krb5_klog_syslog(LOG_NOTICE, _('Request: kadm5_init, %.*s%s, %s, '
                                   'client=%.*s%s, service=%.*s%s, addr=%s, '
                                   'vers=%d, flavor=%d'),
                     (int)clen, (char *)client_name.value, cdots,
                     errmsg ? errmsg : _('success'),
                     (int)clen, (char *)client_name.value, cdots,
                     (int)slen, (char *)service_name.value, sdots,
                     client_addr(rqstp->rq_xprt),
                     ret.api_version & ~(KADM5_API_VERSION_MASK),
                     rqstp->rq_cred.oa_flavor);
    if (errmsg != NULL)
        krb5_free_error_message(NULL, errmsg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);

exit_func:
    return(&ret);
}
",1,7743
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static int
gss_name_to_string(gss_name_t gss_name, gss_buffer_desc *str)
{
    OM_uint32 status, minor_stat;
    gss_OID gss_type;
    const char pref[] = KRB5_WELLKNOWN_NAMESTR '/' KRB5_ANONYMOUS_PRINCSTR '@';
    const size_t preflen = sizeof(pref) - 1;

    status = gss_display_name(&minor_stat, gss_name, str, &gss_type);
    if (status != GSS_S_COMPLETE)
        return 1;
    if (gss_oid_equal(gss_type, GSS_C_NT_ANONYMOUS)) {
        /* Guard against non-krb5 mechs with different anonymous displays. */
        if (str->length < preflen || memcmp(str->value, pref, preflen) != 0)
            return 1;
    } else if (!gss_oid_equal(gss_type, GSS_KRB5_NT_PRINCIPAL_NAME)) {
        return 1;
    }
    return 0;
}
",0,7744
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static int gss_to_krb5_name(kadm5_server_handle_t handle,
                            gss_name_t gss_name, krb5_principal *princ)
{
    OM_uint32 minor_stat;
    gss_buffer_desc gss_str;
    int success;
    char *s;

    if (gss_name_to_string(gss_name, &gss_str) != 0)
        return 0;
    if (asprintf(&s, '%.*s', (int)gss_str.length, (char *)gss_str.value) < 0) {
        gss_release_buffer(&minor_stat, &gss_str);
        return 0;
    }
    success = (krb5_parse_name(handle->context, s, princ) == 0);
    free(s);
    gss_release_buffer(&minor_stat, &gss_str);
    return success;
}
",0,7745
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static kadm5_ret_t new_server_handle(krb5_ui_4 api_version,
                                     struct svc_req *rqstp,
                                     kadm5_server_handle_t
                                     *out_handle)
{
    kadm5_server_handle_t handle;

    *out_handle = NULL;

    if (! (handle = (kadm5_server_handle_t)
           malloc(sizeof(*handle))))
        return ENOMEM;

    *handle = *(kadm5_server_handle_t)global_server_handle;
    handle->api_version = api_version;

    if (! gss_to_krb5_name(handle, rqst2name(rqstp),
                           &handle->current_caller)) {
        free(handle);
        return KADM5_FAILURE;
    }

    *out_handle = handle;
    return 0;
}
",0,7746
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static void free_server_handle(kadm5_server_handle_t handle)
{
    if (!handle)
        return;
    krb5_free_principal(handle->context, handle->current_caller);
    free(handle);
}
",0,7747
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static int check_handle(void *handle)
{
    CHECK_HANDLE(handle);
    return 0;
}
",0,7749
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static int
log_done(
    char *op,
    char *target,
    const char *errmsg,
    gss_buffer_t client,
    gss_buffer_t server,
    struct svc_req *rqstp)
{
    size_t tlen, clen, slen;
    char *tdots, *cdots, *sdots;

    if (errmsg == NULL)
        errmsg = _('success');
    tlen = strlen(target);
    trunc_name(&tlen, &tdots);
    clen = client->length;
    trunc_name(&clen, &cdots);
    slen = server->length;
    trunc_name(&slen, &sdots);

    /* okay to cast lengths to int because trunc_name limits max value */
    return krb5_klog_syslog(LOG_NOTICE,
                            _('Request: %s, %.*s%s, %s, '
                              'client=%.*s%s, service=%.*s%s, addr=%s'),
                            op, (int)tlen, target, tdots, errmsg,
                            (int)clen, (char *)client->value, cdots,
                            (int)slen, (char *)server->value, sdots,
                            client_addr(rqstp->rq_xprt));
}
",0,7750
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"int setup_gss_names(struct svc_req *rqstp,
                    gss_buffer_desc *client_name,
                    gss_buffer_desc *server_name)
{
    OM_uint32 maj_stat, min_stat;
    gss_name_t server_gss_name;

    if (gss_name_to_string(rqst2name(rqstp), client_name) != 0)
        return -1;
    maj_stat = gss_inquire_context(&min_stat, rqstp->rq_svccred, NULL,
                                   &server_gss_name, NULL, NULL, NULL,
                                   NULL, NULL);
    if (maj_stat != GSS_S_COMPLETE) {
        gss_release_buffer(&min_stat, client_name);
        gss_release_name(&min_stat, &server_gss_name);
        return -1;
    }
    if (gss_name_to_string(server_gss_name, server_name) != 0) {
        gss_release_buffer(&min_stat, client_name);
        gss_release_name(&min_stat, &server_gss_name);
        return -1;
    }
    gss_release_name(&min_stat, &server_gss_name);
    return 0;
}
",0,7756
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static int cmp_gss_names_rel_1(gss_name_t n1, gss_name_t n2)
{
    OM_uint32 min_stat;
    int ret;

    ret = cmp_gss_names(n1, n2);
    if (n1) (void) gss_release_name(&min_stat, &n1);
    return ret;
}
",0,7757
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static int
log_unauth(
    char *op,
    char *target,
    gss_buffer_t client,
    gss_buffer_t server,
    struct svc_req *rqstp)
{
    size_t tlen, clen, slen;
    char *tdots, *cdots, *sdots;

    tlen = strlen(target);
    trunc_name(&tlen, &tdots);
    clen = client->length;
    trunc_name(&clen, &cdots);
    slen = server->length;
    trunc_name(&slen, &sdots);

    /* okay to cast lengths to int because trunc_name limits max value */
    return krb5_klog_syslog(LOG_NOTICE,
                            _('Unauthorized request: %s, %.*s%s, '
                              'client=%.*s%s, service=%.*s%s, addr=%s'),
                            op, (int)tlen, target, tdots,
                            (int)clen, (char *)client->value, cdots,
                            (int)slen, (char *)server->value, sdots,
                            client_addr(rqstp->rq_xprt));
}
",0,7759
krb5/krb5,83ed75feba32e46f736fcce0d96a0445f29b96c2,"static gss_name_t acceptor_name(gss_ctx_id_t context)
{
    OM_uint32 maj_stat, min_stat;
    gss_name_t name;

    maj_stat = gss_inquire_context(&min_stat, context, NULL, &name,
                                   NULL, NULL, NULL, NULL, NULL);
    if (maj_stat != GSS_S_COMPLETE)
        return NULL;
    return name;
}
",0,7763
torvalds/linux,f3951a3709ff50990bf3e188c27d346792103432,"static int
sg_common_write(Sg_fd * sfp, Sg_request * srp,
		unsigned char *cmnd, int timeout, int blocking)
{
	int k, at_head;
	Sg_device *sdp = sfp->parentdp;
	sg_io_hdr_t *hp = &srp->header;

	srp->data.cmd_opcode = cmnd[0];	/* hold opcode of command */
	hp->status = 0;
	hp->masked_status = 0;
	hp->msg_status = 0;
	hp->info = 0;
	hp->host_status = 0;
	hp->driver_status = 0;
	hp->resid = 0;
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,
			'sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n',
			(int) cmnd[0], (int) hp->cmd_len));

	k = sg_start_req(srp, cmnd);
	if (k) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,
			'sg_common_write: start_req err=%d\n', k));
		sg_finish_rem_req(srp);
		return k;	/* probably out of space --> ENOMEM */
	}
	if (atomic_read(&sdp->detaching)) {
		if (srp->bio)
			blk_end_request_all(srp->rq, -EIO);
		sg_finish_rem_req(srp);
		return -ENODEV;
	}

	hp->duration = jiffies_to_msecs(jiffies);
	if (hp->interface_id != '\0' &&	/* v3 (or later) interface */
	    (SG_FLAG_Q_AT_TAIL & hp->flags))
		at_head = 0;
	else
		at_head = 1;

	srp->rq->timeout = timeout;
	kref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */
	blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,
			      srp->rq, at_head, sg_rq_end_io);
	return 0;
}
",1,7770
torvalds/linux,f3951a3709ff50990bf3e188c27d346792103432,"static ssize_t
sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
	sg_io_hdr_t *hp;
	unsigned char cmnd[SG_MAX_CDB_SIZE];

	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
		return -ENXIO;
	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      'sg_write: count=%d\n', (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      'sg_write: queue full\n'));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		'sg_write:   scsi opcode=0x%02x, cmd_size=%d\n', (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if (hp->dxfer_direction == SG_DXFER_TO_DEV)
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   'sg_write: data in/out %d/%d bytes '
					   'for SCSI command 0x%x-- guessing '
					   'data in;\n   program %s not setting '
					   'count and/or reply_len properly\n',
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
",0,7771
npat-efault/picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"#define _GNU_SOURCE
#include <getopt.h>

#include 'term.h'
#ifdef LINENOISE
#include 'linenoise-1.0/linenoise.h'
#endif

/**********************************************************************/
",1,7772
npat-efault/picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"void
establish_child_signal_handlers (void)
{
	struct sigaction dfl_action;

	/* Set up the structure to specify the default action. */
	dfl_action.sa_handler = SIG_DFL;
	sigemptyset (&dfl_action.sa_mask);
	dfl_action.sa_flags = 0;
	
	sigaction (SIGINT, &dfl_action, NULL);
	sigaction (SIGTERM, &dfl_action, NULL);
}
",1,7773
npat-efault/picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"int
run_cmd(int fd, ...)
{
	pid_t pid;
	sigset_t sigm, sigm_old;

	/* block signals, let child establish its own handlers */
	sigemptyset(&sigm);
	sigaddset(&sigm, SIGTERM);
	sigprocmask(SIG_BLOCK, &sigm, &sigm_old);

	pid = fork();
	if ( pid < 0 ) {
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		fd_printf(STO, '*** cannot fork: %s ***\r\n', strerror(errno));
		return -1;
	} else if ( pid ) {
		/* father: picocom */
		int status, r;

		/* reset the mask */
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		/* wait for child to finish */
		do {
			r = waitpid(pid, &status, 0);
		} while ( r < 0 && errno == EINTR );
		/* reset terminal (back to raw mode) */
		term_apply(STI);
		/* check and report child return status */
		if ( WIFEXITED(status) ) { 
			fd_printf(STO, '\r\n*** exit status: %d ***\r\n', 
					  WEXITSTATUS(status));
			return WEXITSTATUS(status);
		} else if ( WIFSIGNALED(status) ) {
			fd_printf(STO, '\r\n*** killed by signal: %d ***\r\n', 
					  WTERMSIG(status));
			return -1;
		} else {
			fd_printf(STO, '\r\n*** abnormal termination: 0x%x ***\r\n', r);
			return -1;
		}
	} else {
		/* child: external program */
		long fl;
		char cmd[512];

		/* unmanage terminal, and reset it to canonical mode */
		term_remove(STI);
		/* unmanage serial port fd, without reset */
		term_erase(fd);
		/* set serial port fd to blocking mode */
		fl = fcntl(fd, F_GETFL); 
		fl &= ~O_NONBLOCK;
		fcntl(fd, F_SETFL, fl);
		/* connect stdin and stdout to serial port */
		close(STI);
		close(STO);
		dup2(fd, STI);
		dup2(fd, STO);
		{
			/* build command-line */
			char *c, *ce;
			const char *s;
			int n;
			va_list vls;
			
			strcpy(cmd, EXEC);
			c = &cmd[sizeof(EXEC)- 1];
			ce = cmd + sizeof(cmd) - 1;
			va_start(vls, fd);
			while ( (s = va_arg(vls, const char *)) ) {
				n = strlen(s);
				if ( c + n + 1 >= ce ) break;
				memcpy(c, s, n); c += n;
				*c++ = ' ';
			}
			va_end(vls);
			*c = '\0';
		}
		/* run extenral command */
		fd_printf(STDERR_FILENO, '%s\n', &cmd[sizeof(EXEC) - 1]);
		establish_child_signal_handlers();
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		execl('/bin/sh', 'sh', '-c', cmd, NULL);
		exit(42);
	}
}
",1,7774
npat-efault/picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"int
do_command (unsigned char c)
{
	static int dtr_up = 0;
	int newbaud, newflow, newparity, newbits;
	const char *xfr_cmd;
	char *fname;
	int r;

	switch (c) {
	case KEY_EXIT:
		return 1;
	case KEY_QUIT:
		term_set_hupcl(tty_fd, 0);
		term_flush(tty_fd);
		term_apply(tty_fd);
		term_erase(tty_fd);
		return 1;
	case KEY_STATUS:
		show_status(dtr_up);
		break;
	case KEY_PULSE:
		fd_printf(STO, '\r\n*** pulse DTR ***\r\n');
		if ( term_pulse_dtr(tty_fd) < 0 )
			fd_printf(STO, '*** FAILED\r\n');
		break;
	case KEY_TOGGLE:
		if ( dtr_up )
			r = term_lower_dtr(tty_fd);
		else
			r = term_raise_dtr(tty_fd);
		if ( r >= 0 ) dtr_up = ! dtr_up;
		fd_printf(STO, '\r\n*** DTR: %s ***\r\n', 
				  dtr_up ? 'up' : 'down');
		break;
	case KEY_BAUD_UP:
	case KEY_BAUD_DN:
		if (c == KEY_BAUD_UP)
			opts.baud = baud_up(opts.baud);
		else 
			opts.baud = baud_down(opts.baud);
		term_set_baudrate(tty_fd, opts.baud);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbaud = term_get_baudrate(tty_fd, NULL);
		if ( opts.baud != newbaud ) {
			fd_printf(STO, '\r\n*** baud: %d (%d) ***\r\n', 
					  opts.baud, newbaud);
		} else {
			fd_printf(STO, '\r\n*** baud: %d ***\r\n', opts.baud);
		}
		set_tty_write_sz(newbaud);
		break;
	case KEY_FLOW:
		opts.flow = flow_next(opts.flow);
		term_set_flowcntrl(tty_fd, opts.flow);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newflow = term_get_flowcntrl(tty_fd);
		if ( opts.flow != newflow ) {
			fd_printf(STO, '\r\n*** flow: %s (%s) ***\r\n', 
					  flow_str[opts.flow], flow_str[newflow]);
		} else {
			fd_printf(STO, '\r\n*** flow: %s ***\r\n', 
					  flow_str[opts.flow]);
		}
		break;
	case KEY_PARITY:
		opts.parity = parity_next(opts.parity);
		term_set_parity(tty_fd, opts.parity);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newparity = term_get_parity(tty_fd);
		if (opts.parity != newparity ) {
			fd_printf(STO, '\r\n*** parity: %s (%s) ***\r\n',
					  parity_str[opts.parity], 
					  parity_str[newparity]);
		} else {
			fd_printf(STO, '\r\n*** parity: %s ***\r\n', 
					  parity_str[opts.parity]);
		}
		break;
	case KEY_BITS:
		opts.databits = bits_next(opts.databits);
		term_set_databits(tty_fd, opts.databits);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbits = term_get_databits(tty_fd);
		if (opts.databits != newbits ) {
			fd_printf(STO, '\r\n*** databits: %d (%d) ***\r\n',
					  opts.databits, newbits);
		} else {
			fd_printf(STO, '\r\n*** databits: %d ***\r\n', 
					  opts.databits);
		}
		break;
	case KEY_LECHO:
		opts.lecho = ! opts.lecho;
		fd_printf(STO, '\r\n*** local echo: %s ***\r\n', 
				  opts.lecho ? 'yes' : 'no');
		break;
	case KEY_SEND:
	case KEY_RECEIVE:
		xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;
		if ( xfr_cmd[0] == '\0' ) {
			fd_printf(STO, '\r\n*** command disabled ***\r\n');
			break;
		}
		fname = read_filename();
		if (fname == NULL) {
			fd_printf(STO, '*** cannot read filename ***\r\n');
			break;
		}
		run_cmd(tty_fd, xfr_cmd, fname, NULL);
		free(fname);
		break;
	case KEY_BREAK:
		term_break(tty_fd);
		fd_printf(STO, '\r\n*** break sent ***\r\n');
		break;
	default:
		break;
	}

	return 0;
}
",1,7775
npat-efault/picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"int
fd_printf (int fd, const char *format, ...)
{
	char buf[256];
	va_list args;
	int len;
	
	va_start(args, format);
	len = vsnprintf(buf, sizeof(buf), format, args);
	buf[sizeof(buf) - 1] = '\0';
	va_end(args);
	
	return writen_ni(fd, buf, len);
}
",0,7776
npat-efault/picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"	[FC_RTSCTS] = 'RTS/CTS',
	[FC_XONXOFF] = 'xon/xoff',
	[FC_OTHER] = 'other',
",0,7777
npat-efault/picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"void
fatal (const char *format, ...)
{
	char *s, buf[256];
	va_list args;
	int len;

	term_reset(STO);
	term_reset(STI);
	
	va_start(args, format);
	len = vsnprintf(buf, sizeof(buf), format, args);
	buf[sizeof(buf) - 1] = '\0';
	va_end(args);
	
	s = '\r\nFATAL: ';
	writen_ni(STO, s, strlen(s));
	writen_ni(STO, buf, len);
	s = '\r\n';
	writen_ni(STO, s, strlen(s));

	/* wait a bit for output to drain */
	sleep(1);

#ifdef UUCP_LOCK_DIR
	uucp_unlock();
#endif
	
	exit(EXIT_FAILURE);
}
",0,7778
npat-efault/picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"int
flow_next (int flow)
{
	switch(flow) {
	case FC_NONE:
		flow = FC_RTSCTS;
		break;
	case FC_RTSCTS:
		flow = FC_XONXOFF;
		break;
	case FC_XONXOFF:
		flow = FC_NONE;
		break;
	default:
		flow = FC_NONE;
		break;
	}

	return flow;
}
",0,7779
ImageMagick/ImageMagick,b173a352397877775c51c9a0e9d59eb6ce24c455,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),'enter');

  /*
     Open image file.
   */
  image = AcquireImage(image_info);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=CloneImageInfo(image_info);
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),'  Endian %c%c',
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, 'IM', 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, 'MI', 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, 'MATLAB', 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,'ImproperImageHeader');

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf('pos=%X\n',TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3) ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
           ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
          Frames = ReadBlobXXXLong(image2);
         break;
      default: ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          'MATLAB_HDR.StructureClass %d',MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,'UnsupportedCellTypeInTheMatrix');

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        'MATLAB_HDR.CellType: %.20g',(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,'quantum:format','floating-point');
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,'quantum:format','floating-point');
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, 'IncompatibleSizeOfDouble');
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, 'UnsupportedCellTypeInTheMatrix');
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
      /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              '  MAT set image pixels returns unexpected NULL on a row %u.', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             '  MAT cannot read scanrow %u from a file.', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              '  MAT failed to ImportQuantumPixels for a row %u', (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            '  MAT failed to sync image pixels for a row %u', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
  }
  clone_info=DestroyImageInfo(clone_info);

  RelinquishMagickMemory(BImgBuff);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),'return');
  if(image==NULL)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  return (image);
}
",1,7780
ImageMagick/ImageMagick,b173a352397877775c51c9a0e9d59eb6ce24c455,"static void InsertComplexDoubleRow(double *p, int y, Image * image, double MinVal,
                                  double MaxVal)
{
  ExceptionInfo
    *exception;

  double f;
  int x;
  register PixelPacket *q;

  if (MinVal == 0)
    MinVal = -1;
  if (MaxVal == 0)
    MaxVal = 1;

  exception=(&image->exception);
  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
  if (q == (PixelPacket *) NULL)
    return;
  for (x = 0; x < (ssize_t) image->columns; x++)
  {
    if (*p > 0)
    {
      f = (*p / MaxVal) * (QuantumRange - GetPixelRed(q));
      if (f + GetPixelRed(q) > QuantumRange)
        SetPixelRed(q,QuantumRange);
      else
        SetPixelRed(q,GetPixelRed(q)+(int) f);
      if ((int) f / 2.0 > GetPixelGreen(q))
        {
          SetPixelGreen(q,0);
          SetPixelBlue(q,0);
        }
      else
        {
          SetPixelBlue(q,GetPixelBlue(q)-(int) (f/2.0));
          SetPixelGreen(q,GetPixelBlue(q));
        }
    }
    if (*p < 0)
    {
      f = (*p / MaxVal) * (QuantumRange - GetPixelBlue(q));
      if (f + GetPixelBlue(q) > QuantumRange)
        SetPixelBlue(q,QuantumRange);
      else
        SetPixelBlue(q,GetPixelBlue(q)+(int) f);
      if ((int) f / 2.0 > q->green)
        {
          SetPixelRed(q,0);
          SetPixelGreen(q,0);
        }
      else
        {
          SetPixelRed(q,GetPixelRed(q)-(int) (f/2.0));
          SetPixelGreen(q,GetPixelRed(q));
        }
    }
    p++;
    q++;
  }
  if (!SyncAuthenticPixels(image,exception))
    return;
  return;
}
",0,7781
torvalds/linux,48a992727d82cb7db076fa15d372178743b1f4cd,"static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,
					  u32 *mask)
{
	struct crypto_attr_type *algt;

	algt = crypto_get_attr_type(tb);
	if (IS_ERR(algt))
		return;
	if ((algt->type & CRYPTO_ALG_INTERNAL))
		*type |= CRYPTO_ALG_INTERNAL;
	if ((algt->mask & CRYPTO_ALG_INTERNAL))
		*mask |= CRYPTO_ALG_INTERNAL;
}
",1,7782
torvalds/linux,48a992727d82cb7db076fa15d372178743b1f4cd,"static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
			      struct mcryptd_queue *queue)
{
	struct hashd_instance_ctx *ctx;
	struct ahash_instance *inst;
	struct hash_alg_common *halg;
	struct crypto_alg *alg;
	u32 type = 0;
	u32 mask = 0;
	int err;

	mcryptd_check_internal(tb, &type, &mask);

	halg = ahash_attr_alg(tb[1], type, mask);
	if (IS_ERR(halg))
		return PTR_ERR(halg);

	alg = &halg->base;
	pr_debug('crypto: mcryptd hash alg: %s\n', alg->cra_name);
	inst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),
					sizeof(*ctx));
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	ctx = ahash_instance_ctx(inst);
	ctx->queue = queue;

	err = crypto_init_ahash_spawn(&ctx->spawn, halg,
				      ahash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	type = CRYPTO_ALG_ASYNC;
	if (alg->cra_flags & CRYPTO_ALG_INTERNAL)
		type |= CRYPTO_ALG_INTERNAL;
	inst->alg.halg.base.cra_flags = type;

	inst->alg.halg.digestsize = halg->digestsize;
	inst->alg.halg.statesize = halg->statesize;
	inst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);

	inst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;
	inst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;

	inst->alg.init   = mcryptd_hash_init_enqueue;
	inst->alg.update = mcryptd_hash_update_enqueue;
	inst->alg.final  = mcryptd_hash_final_enqueue;
	inst->alg.finup  = mcryptd_hash_finup_enqueue;
	inst->alg.export = mcryptd_hash_export;
	inst->alg.import = mcryptd_hash_import;
	inst->alg.setkey = mcryptd_hash_setkey;
	inst->alg.digest = mcryptd_hash_digest_enqueue;

	err = ahash_register_instance(tmpl, inst);
	if (err) {
		crypto_drop_ahash(&ctx->spawn);
out_free_inst:
		kfree(inst);
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
",1,7783
torvalds/linux,48a992727d82cb7db076fa15d372178743b1f4cd,"static int mcryptd_hash_init_enqueue(struct ahash_request *req)
{
	return mcryptd_hash_enqueue(req, mcryptd_hash_init);
}
",0,7784
torvalds/linux,48a992727d82cb7db076fa15d372178743b1f4cd,"int ahash_mcryptd_finup(struct ahash_request *desc)
{
	/* alignment is to be done by multi-buffer crypto algorithm if needed */

	return crypto_ahash_finup(desc);
}
",0,7785
torvalds/linux,06deeec77a5a689cc94b21a8a91a76e42176685d,"static int
smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)
{
	int rc;
	unsigned char key2[8];
	struct crypto_skcipher *tfm_des;
	struct scatterlist sgin, sgout;
	struct skcipher_request *req;

	str_to_key(key, key2);

	tfm_des = crypto_alloc_skcipher('ecb(des)', 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(tfm_des)) {
		rc = PTR_ERR(tfm_des);
		cifs_dbg(VFS, 'could not allocate des crypto API\n');
		goto smbhash_err;
	}

	req = skcipher_request_alloc(tfm_des, GFP_KERNEL);
	if (!req) {
		rc = -ENOMEM;
		cifs_dbg(VFS, 'could not allocate des crypto API\n');
		goto smbhash_free_skcipher;
	}

	crypto_skcipher_setkey(tfm_des, key2, 8);

	sg_init_one(&sgin, in, 8);
	sg_init_one(&sgout, out, 8);

	skcipher_request_set_callback(req, 0, NULL, NULL);
	skcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);

	rc = crypto_skcipher_encrypt(req);
	if (rc)
		cifs_dbg(VFS, 'could not encrypt crypt key rc: %d\n', rc);

	skcipher_request_free(req);

smbhash_free_skcipher:
	crypto_free_skcipher(tfm_des);
smbhash_err:
	return rc;
}
",1,7786
torvalds/linux,06deeec77a5a689cc94b21a8a91a76e42176685d,"int
E_md4hash(const unsigned char *passwd, unsigned char *p16,
	const struct nls_table *codepage)
{
	int rc;
	int len;
	__le16 wpwd[129];

	/* Password cannot be longer than 128 characters */
	if (passwd) /* Password must be converted to NT unicode */
		len = cifs_strtoUTF16(wpwd, passwd, 128, codepage);
	else {
		len = 0;
		*wpwd = 0; /* Ensure string is null terminated */
	}

	rc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));
	memzero_explicit(wpwd, sizeof(wpwd));

	return rc;
}
",0,7787
VirusTotal/yara,8e364afcf9e328c016c109ee2e417412e634f2e0,"YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yylval = yylval_param;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yara_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				yara_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		yara_yy_load_buffer_state(yyscanner );
		}

	{
#line 123 'lexer.l'


#line 1093 'lexer.c'

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 243 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 242 );
		yy_cp = yyg->yy_last_accepting_cpos;
		yy_current_state = yyg->yy_last_accepting_state;

yy_find_action:
		yy_act = yy_accept[yy_current_state];

		YY_DO_BEFORE_ACTION;

		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
			{
			yy_size_t yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					   
    do{ yylineno++;
        yycolumn=0;
    }while(0)
;
			}

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 125 'lexer.l'
{ return _DOT_DOT_;     }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 126 'lexer.l'
{ return _LT_;          }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 127 'lexer.l'
{ return _GT_;          }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 128 'lexer.l'
{ return _LE_;          }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 129 'lexer.l'
{ return _GE_;          }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 130 'lexer.l'
{ return _EQ_;          }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 131 'lexer.l'
{ return _NEQ_;         }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 132 'lexer.l'
{ return _SHIFT_LEFT_;  }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 133 'lexer.l'
{ return _SHIFT_RIGHT_; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 134 'lexer.l'
{ return _PRIVATE_;     }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 135 'lexer.l'
{ return _GLOBAL_;      }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 136 'lexer.l'
{ return _RULE_;        }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 137 'lexer.l'
{ return _META_;        }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 138 'lexer.l'
{ return _STRINGS_;     }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 139 'lexer.l'
{ return _ASCII_;       }
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 140 'lexer.l'
{ return _WIDE_;        }
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 141 'lexer.l'
{ return _FULLWORD_;    }
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 142 'lexer.l'
{ return _NOCASE_;      }
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 143 'lexer.l'
{ return _CONDITION_;   }
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 144 'lexer.l'
{ return _TRUE_;        }
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 145 'lexer.l'
{ return _FALSE_;       }
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 146 'lexer.l'
{ return _NOT_;         }
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 147 'lexer.l'
{ return _AND_;         }
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 148 'lexer.l'
{ return _OR_;          }
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 149 'lexer.l'
{ return _AT_;          }
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 150 'lexer.l'
{ return _IN_;          }
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 151 'lexer.l'
{ return _OF_;          }
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 152 'lexer.l'
{ return _THEM_;        }
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 153 'lexer.l'
{ return _FOR_;         }
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 154 'lexer.l'
{ return _ALL_;         }
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 155 'lexer.l'
{ return _ANY_;         }
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 156 'lexer.l'
{ return _ENTRYPOINT_;  }
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 157 'lexer.l'
{ return _FILESIZE_;    }
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 158 'lexer.l'
{ return _MATCHES_;     }
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 159 'lexer.l'
{ return _CONTAINS_;    }
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 160 'lexer.l'
{ return _IMPORT_;      }
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 163 'lexer.l'
{ BEGIN(comment);       }
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 164 'lexer.l'
{ BEGIN(INITIAL);       }
	YY_BREAK
case 39:
/* rule 39 can match eol */
YY_RULE_SETUP
#line 165 'lexer.l'
{ /* skip comments */   }
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 168 'lexer.l'
{ /* skip single-line comments */ }
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 171 'lexer.l'
{
                          yyextra->lex_buf_ptr = yyextra->lex_buf;
                          yyextra->lex_buf_len = 0;
                          BEGIN(include);
                        }
	YY_BREAK
case 42:
/* rule 42 can match eol */
YY_RULE_SETUP
#line 178 'lexer.l'
{ YYTEXT_TO_BUFFER; }
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 181 'lexer.l'
{

  char            buffer[1024];
  char            *current_file_name;
  char            *s = NULL;
  #ifdef _WIN32
  char            *b = NULL;
  #endif
  char            *f;
  FILE*           fh;

  if (compiler->allow_includes)
  {
    *yyextra->lex_buf_ptr = '\0'; // null-terminate included file path

    // move path of current source file into buffer
    current_file_name = yr_compiler_get_current_file_name(compiler);

    if (current_file_name != NULL)
    {
      strlcpy(buffer, current_file_name, sizeof(buffer));
    }
    else
    {
      buffer[0] = '\0';
    }

    // make included file path relative to current source file
    s = strrchr(buffer, '/');

    #ifdef _WIN32
    b = strrchr(buffer, '\\'); // in Windows both path delimiters are accepted
    #endif

    #ifdef _WIN32
    if (s != NULL || b != NULL)
    #else
    if (s != NULL)
    #endif
    {
      #ifdef _WIN32
      f = (b > s)? (b + 1): (s + 1);
      #else
      f = s + 1;
      #endif

      strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));

      f = buffer;

      // SECURITY: Potential for directory traversal here.
      fh = fopen(buffer, 'r');

      // if include file was not found relative to current source file,
      // try to open it with path as specified by user (maybe user wrote
      // a full path)

      if (fh == NULL)
      {
        f = yyextra->lex_buf;

        // SECURITY: Potential for directory traversal here.
        fh = fopen(yyextra->lex_buf, 'r');
      }
    }
    else
    {
      f = yyextra->lex_buf;

      // SECURITY: Potential for directory traversal here.
      fh = fopen(yyextra->lex_buf, 'r');
    }

    if (fh != NULL)
    {
      int error_code = _yr_compiler_push_file_name(compiler, f);

      if (error_code != ERROR_SUCCESS)
      {
        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)
        {
          yyerror(yyscanner, compiler, 'includes circular reference');
        }
        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)
        {
          yyerror(yyscanner, compiler, 'includes depth exceeded');
        }

        yyterminate();
      }

      _yr_compiler_push_file(compiler, fh);
      yara_yypush_buffer_state(yara_yy_create_buffer(fh,YY_BUF_SIZE,yyscanner),yyscanner);
    }
    else
    {
      snprintf(buffer, sizeof(buffer),
               'can't open include file: %s', yyextra->lex_buf);
      yyerror(yyscanner, compiler, buffer);
    }
  }
  else // not allowing includes
  {
    yyerror(yyscanner, compiler, 'includes are disabled');
    yyterminate();
  }

  BEGIN(INITIAL);
}
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(str):
case YY_STATE_EOF(regexp):
case YY_STATE_EOF(include):
case YY_STATE_EOF(comment):
#line 293 'lexer.l'
{

  YR_COMPILER* compiler = yara_yyget_extra(yyscanner);
  FILE* file = _yr_compiler_pop_file(compiler);

  if (file != NULL)
  {
    fclose(file);
  }

  _yr_compiler_pop_file_name(compiler);
  yara_yypop_buffer_state(yyscanner);

  if (!YY_CURRENT_BUFFER)
  {
    yyterminate();
  }
}
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 313 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  return _STRING_IDENTIFIER_WITH_WILDCARD_;
}
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 327 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  return _STRING_IDENTIFIER_;
}
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 341 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  yylval->c_string[0] = '$'; /* replace # by $*/
  return _STRING_COUNT_;
}
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 356 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  yylval->c_string[0] = '$'; /* replace @ by $*/
  return _STRING_OFFSET_;
}
	YY_BREAK
case 48:
YY_RULE_SETUP
#line 371 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  yylval->c_string[0] = '$'; /* replace ! by $*/
  return _STRING_LENGTH_;
}
	YY_BREAK
case 49:
YY_RULE_SETUP
#line 386 'lexer.l'
{

  char* text = yytext;

  if (*text == 'u')
  {
    yylval->integer = 3;
    text++;
  }
  else
  {
    yylval->integer = 0;
  }

  if (strstr(text, 'int8') == text)
  {
    yylval->integer += 0;
    text += 4;
  }
  else if (strstr(text, 'int16') == text)
  {
    yylval->integer += 1;
    text += 5;
  }
  else if (strstr(text, 'int32') == text)
  {
    yylval->integer += 2;
    text += 5;
  }

  if (strcmp(text, 'be') == 0)
  {
    yylval->integer += 6;
  }

  return _INTEGER_FUNCTION_;
}
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 425 'lexer.l'
{

  if (strlen(yytext) > 128)
  {
    yyerror(yyscanner, compiler, 'identifier too long');
  }

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  return _IDENTIFIER_;
}
	YY_BREAK
case 51:
YY_RULE_SETUP
#line 444 'lexer.l'
{

  #ifdef _MSC_VER
  yylval->integer = _atoi64(yytext);
  #else
  yylval->integer = atoll(yytext);
  #endif

  if (strstr(yytext, 'KB') != NULL)
  {
     yylval->integer *= 1024;
  }
  else if (strstr(yytext, 'MB') != NULL)
  {
     yylval->integer *= 1048576;
  }
  return _NUMBER_;
}
	YY_BREAK
case 52:
YY_RULE_SETUP
#line 463 'lexer.l'
{
  yylval->double_ = atof(yytext);
  return _DOUBLE_;
}
	YY_BREAK
case 53:
YY_RULE_SETUP
#line 468 'lexer.l'
{

  yylval->integer = xtoi(yytext + 2);
  return _NUMBER_;
}
	YY_BREAK
case 54:
YY_RULE_SETUP
#line 475 'lexer.l'
{     /* saw closing quote - all done */

  ALLOC_SIZED_STRING(s, yyextra->lex_buf_len);

  *yyextra->lex_buf_ptr = '\0';
  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);
  yylval->sized_string = s;

  BEGIN(INITIAL);

  return _TEXT_STRING_;
}
	YY_BREAK
case 55:
YY_RULE_SETUP
#line 489 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\t', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '\t';
  yyextra->lex_buf_len++;
}
	YY_BREAK
case 56:
YY_RULE_SETUP
#line 497 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\n', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '\n';
  yyextra->lex_buf_len++;
}
	YY_BREAK
case 57:
YY_RULE_SETUP
#line 505 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\'', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '\'';
  yyextra->lex_buf_len++;
}
	YY_BREAK
case 58:
YY_RULE_SETUP
#line 513 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\\', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '\\';
  yyextra->lex_buf_len++;
}
	YY_BREAK
case 59:
YY_RULE_SETUP
#line 521 'lexer.l'
{

   int result;

   sscanf( yytext + 2, '%x', &result );
   LEX_CHECK_SPACE_OK('X', yyextra->lex_buf_len, LEX_BUF_SIZE);
   *yyextra->lex_buf_ptr++ = result;
   yyextra->lex_buf_len++;
}
	YY_BREAK
case 60:
YY_RULE_SETUP
#line 532 'lexer.l'
{ YYTEXT_TO_BUFFER; }
	YY_BREAK
case 61:
/* rule 61 can match eol */
YY_RULE_SETUP
#line 535 'lexer.l'
{

  yyerror(yyscanner, compiler, 'unterminated string');
  yyterminate();
}
	YY_BREAK
case 62:
/* rule 62 can match eol */
YY_RULE_SETUP
#line 541 'lexer.l'
{

  yyerror(yyscanner, compiler, 'illegal escape sequence');
  yyterminate();
}
	YY_BREAK
case 63:
YY_RULE_SETUP
#line 548 'lexer.l'
{

  if (yyextra->lex_buf_len > 0)
  {
    ALLOC_SIZED_STRING(s, yyextra->lex_buf_len);

    if (yytext[1] == 'i')
      s->flags |= SIZED_STRING_FLAGS_NO_CASE;

    if (yytext[1] == 's' || yytext[2] == 's')
      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;

    *yyextra->lex_buf_ptr = '\0';
    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);
    yylval->sized_string = s;
  }
  else
  {
    yyerror(yyscanner, compiler, 'empty regular expression');
    yyterminate();
  }

  BEGIN(INITIAL);
  return _REGEXP_;
}
	YY_BREAK
case 64:
YY_RULE_SETUP
#line 575 'lexer.l'
{

  LEX_CHECK_SPACE_OK('/', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '/';
  yyextra->lex_buf_len++ ;
}
	YY_BREAK
case 65:
YY_RULE_SETUP
#line 583 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\\.', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = yytext[0];
  *yyextra->lex_buf_ptr++ = yytext[1];
  yyextra->lex_buf_len += 2;
}
	YY_BREAK
case 66:
YY_RULE_SETUP
#line 592 'lexer.l'
{ YYTEXT_TO_BUFFER; }
	YY_BREAK
case 67:
/* rule 67 can match eol */
YY_RULE_SETUP
#line 595 'lexer.l'
{

  yyerror(yyscanner, compiler, 'unterminated regular expression');
  yyterminate();
}
	YY_BREAK
case 68:
YY_RULE_SETUP
#line 602 'lexer.l'
{

  yyextra->lex_buf_ptr = yyextra->lex_buf;
  yyextra->lex_buf_len = 0;
  BEGIN(str);
}
	YY_BREAK
case 69:
YY_RULE_SETUP
#line 610 'lexer.l'
{

  yyextra->lex_buf_ptr = yyextra->lex_buf;
  yyextra->lex_buf_len = 0;
  BEGIN(regexp);
}
	YY_BREAK
case 70:
/* rule 70 can match eol */
YY_RULE_SETUP
#line 618 'lexer.l'
{
  // Match hex-digits with whitespace or comments. The latter are stripped
  // out by hex_lexer.l

  ALLOC_SIZED_STRING(s, strlen(yytext));

  strlcpy(s->c_string, yytext, s->length + 1);
  yylval->sized_string = s;

  return _HEX_STRING_;
}
	YY_BREAK
case 71:
/* rule 71 can match eol */
YY_RULE_SETUP
#line 631 'lexer.l'
/* skip whitespace */
	YY_BREAK
case 72:
YY_RULE_SETUP
#line 633 'lexer.l'
{

  if (yytext[0] >= 32 && yytext[0] < 127)
  {
    return yytext[0];
  }
  else
  {
    yyerror(yyscanner, compiler, 'non-ascii character');
    yyterminate();
  }
}
	YY_BREAK
case 73:
YY_RULE_SETUP
#line 646 'lexer.l'
ECHO;
	YY_BREAK
#line 1918 'lexer.c'

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yara_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p '<=' to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_last_accepting_cpos;
				yy_current_state = yyg->yy_last_accepting_state;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( yara_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			'fatal flex scanner internal error--no action found' );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yara_yylex */
",1,7788
VirusTotal/yara,8e364afcf9e328c016c109ee2e417412e634f2e0,"        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
",0,7789
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"YY_BUFFER_STATE yara_yy_scan_bytes (yyconst char *bytes,int len ,yyscan_t yyscanner );
",1,7790
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"static void yynoreturn yy_fatal_error (yyconst char* msg ,yyscan_t yyscanner );
",1,7791
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"
/* TODO: this is always defined, so inline it */
#define yyconst const
",1,7792
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"static int yy_get_next_buffer (yyscan_t yyscanner );
static void yynoreturn yy_fatal_error (yyconst char* msg ,yyscan_t yyscanner );

",1,7793
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"YY_RULE_SETUP
#line 598 'lexer.l'
{ YYTEXT_TO_BUFFER; }
",1,7794
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"			int yara_yyget_leng (yyscan_t yyscanner );
",1,7795
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yylval = yylval_param;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yara_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				yara_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		yara_yy_load_buffer_state(yyscanner );
		}

	{
#line 129 'lexer.l'


#line 1084 'lexer.c'

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 243 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 242 );
		yy_cp = yyg->yy_last_accepting_cpos;
		yy_current_state = yyg->yy_last_accepting_state;

yy_find_action:
		yy_act = yy_accept[yy_current_state];

		YY_DO_BEFORE_ACTION;

		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
			{
			yy_size_t yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					   
    do{ yylineno++;
        yycolumn=0;
    }while(0)
;
			}

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 131 'lexer.l'
{ return _DOT_DOT_;     }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 132 'lexer.l'
{ return _LT_;          }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 133 'lexer.l'
{ return _GT_;          }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 134 'lexer.l'
{ return _LE_;          }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 135 'lexer.l'
{ return _GE_;          }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 136 'lexer.l'
{ return _EQ_;          }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 137 'lexer.l'
{ return _NEQ_;         }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 138 'lexer.l'
{ return _SHIFT_LEFT_;  }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 139 'lexer.l'
{ return _SHIFT_RIGHT_; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 140 'lexer.l'
{ return _PRIVATE_;     }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 141 'lexer.l'
{ return _GLOBAL_;      }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 142 'lexer.l'
{ return _RULE_;        }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 143 'lexer.l'
{ return _META_;        }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 144 'lexer.l'
{ return _STRINGS_;     }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 145 'lexer.l'
{ return _ASCII_;       }
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 146 'lexer.l'
{ return _WIDE_;        }
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 147 'lexer.l'
{ return _FULLWORD_;    }
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 148 'lexer.l'
{ return _NOCASE_;      }
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 149 'lexer.l'
{ return _CONDITION_;   }
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 150 'lexer.l'
{ return _TRUE_;        }
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 151 'lexer.l'
{ return _FALSE_;       }
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 152 'lexer.l'
{ return _NOT_;         }
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 153 'lexer.l'
{ return _AND_;         }
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 154 'lexer.l'
{ return _OR_;          }
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 155 'lexer.l'
{ return _AT_;          }
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 156 'lexer.l'
{ return _IN_;          }
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 157 'lexer.l'
{ return _OF_;          }
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 158 'lexer.l'
{ return _THEM_;        }
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 159 'lexer.l'
{ return _FOR_;         }
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 160 'lexer.l'
{ return _ALL_;         }
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 161 'lexer.l'
{ return _ANY_;         }
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 162 'lexer.l'
{ return _ENTRYPOINT_;  }
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 163 'lexer.l'
{ return _FILESIZE_;    }
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 164 'lexer.l'
{ return _MATCHES_;     }
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 165 'lexer.l'
{ return _CONTAINS_;    }
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 166 'lexer.l'
{ return _IMPORT_;      }
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 169 'lexer.l'
{ BEGIN(comment);       }
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 170 'lexer.l'
{ BEGIN(INITIAL);       }
	YY_BREAK
case 39:
/* rule 39 can match eol */
YY_RULE_SETUP
#line 171 'lexer.l'
{ /* skip comments */   }
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 174 'lexer.l'
{ /* skip single-line comments */ }
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 177 'lexer.l'
{
                          yyextra->lex_buf_ptr = yyextra->lex_buf;
                          yyextra->lex_buf_len = 0;
                          BEGIN(include);
                        }
	YY_BREAK
case 42:
/* rule 42 can match eol */
YY_RULE_SETUP
#line 184 'lexer.l'
{ YYTEXT_TO_BUFFER; }
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 187 'lexer.l'
{

  char            buffer[1024];
  char            *current_file_name;
  char            *s = NULL;
  #ifdef _WIN32
  char            *b = NULL;
  #endif
  char            *f;
  FILE*           fh;

  if (compiler->allow_includes)
  {
    *yyextra->lex_buf_ptr = '\0'; // null-terminate included file path

    // move path of current source file into buffer
    current_file_name = yr_compiler_get_current_file_name(compiler);

    if (current_file_name != NULL)
    {
      strlcpy(buffer, current_file_name, sizeof(buffer));
    }
    else
    {
      buffer[0] = '\0';
    }

    // make included file path relative to current source file
    s = strrchr(buffer, '/');

    #ifdef _WIN32
    b = strrchr(buffer, '\\'); // in Windows both path delimiters are accepted
    #endif

    #ifdef _WIN32
    if (s != NULL || b != NULL)
    #else
    if (s != NULL)
    #endif
    {
      #ifdef _WIN32
      f = (b > s)? (b + 1): (s + 1);
      #else
      f = s + 1;
      #endif

      strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));

      f = buffer;

      // SECURITY: Potential for directory traversal here.
      fh = fopen(buffer, 'r');

      // if include file was not found relative to current source file,
      // try to open it with path as specified by user (maybe user wrote
      // a full path)

      if (fh == NULL)
      {
        f = yyextra->lex_buf;

        // SECURITY: Potential for directory traversal here.
        fh = fopen(yyextra->lex_buf, 'r');
      }
    }
    else
    {
      f = yyextra->lex_buf;

      // SECURITY: Potential for directory traversal here.
      fh = fopen(yyextra->lex_buf, 'r');
    }

    if (fh != NULL)
    {
      int error_code = _yr_compiler_push_file_name(compiler, f);

      if (error_code != ERROR_SUCCESS)
      {
        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)
        {
          yyerror(yyscanner, compiler, 'includes circular reference');
        }
        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)
        {
          yyerror(yyscanner, compiler, 'includes depth exceeded');
        }

        yyterminate();
      }

      _yr_compiler_push_file(compiler, fh);
      yara_yypush_buffer_state(yara_yy_create_buffer(fh,YY_BUF_SIZE,yyscanner),yyscanner);
    }
    else
    {
      snprintf(buffer, sizeof(buffer),
               'can't open include file: %s', yyextra->lex_buf);
      yyerror(yyscanner, compiler, buffer);
    }
  }
  else // not allowing includes
  {
    yyerror(yyscanner, compiler, 'includes are disabled');
    yyterminate();
  }

  BEGIN(INITIAL);
}
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(str):
case YY_STATE_EOF(regexp):
case YY_STATE_EOF(include):
case YY_STATE_EOF(comment):
#line 299 'lexer.l'
{

  YR_COMPILER* compiler = yara_yyget_extra(yyscanner);
  FILE* file = _yr_compiler_pop_file(compiler);

  if (file != NULL)
  {
    fclose(file);
  }

  _yr_compiler_pop_file_name(compiler);
  yara_yypop_buffer_state(yyscanner);

  if (!YY_CURRENT_BUFFER)
  {
    yyterminate();
  }
}
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 319 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  return _STRING_IDENTIFIER_WITH_WILDCARD_;
}
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 333 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  return _STRING_IDENTIFIER_;
}
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 347 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  yylval->c_string[0] = '$'; /* replace # by $*/
  return _STRING_COUNT_;
}
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 362 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  yylval->c_string[0] = '$'; /* replace @ by $*/
  return _STRING_OFFSET_;
}
	YY_BREAK
case 48:
YY_RULE_SETUP
#line 377 'lexer.l'
{

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  yylval->c_string[0] = '$'; /* replace ! by $*/
  return _STRING_LENGTH_;
}
	YY_BREAK
case 49:
YY_RULE_SETUP
#line 392 'lexer.l'
{

  char* text = yytext;

  if (*text == 'u')
  {
    yylval->integer = 3;
    text++;
  }
  else
  {
    yylval->integer = 0;
  }

  if (strstr(text, 'int8') == text)
  {
    yylval->integer += 0;
    text += 4;
  }
  else if (strstr(text, 'int16') == text)
  {
    yylval->integer += 1;
    text += 5;
  }
  else if (strstr(text, 'int32') == text)
  {
    yylval->integer += 2;
    text += 5;
  }

  if (strcmp(text, 'be') == 0)
  {
    yylval->integer += 6;
  }

  return _INTEGER_FUNCTION_;
}
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 431 'lexer.l'
{

  if (strlen(yytext) > 128)
  {
    yyerror(yyscanner, compiler, 'identifier too long');
  }

  yylval->c_string = yr_strdup(yytext);

  if (yylval->c_string == NULL)
  {
    yyerror(yyscanner, compiler, 'not enough memory');
    yyterminate();
  }

  return _IDENTIFIER_;
}
	YY_BREAK
case 51:
YY_RULE_SETUP
#line 450 'lexer.l'
{

  #ifdef _MSC_VER
  yylval->integer = _atoi64(yytext);
  #else
  yylval->integer = atoll(yytext);
  #endif

  if (strstr(yytext, 'KB') != NULL)
  {
     yylval->integer *= 1024;
  }
  else if (strstr(yytext, 'MB') != NULL)
  {
     yylval->integer *= 1048576;
  }
  return _NUMBER_;
}
	YY_BREAK
case 52:
YY_RULE_SETUP
#line 469 'lexer.l'
{
  yylval->double_ = atof(yytext);
  return _DOUBLE_;
}
	YY_BREAK
case 53:
YY_RULE_SETUP
#line 474 'lexer.l'
{

  yylval->integer = xtoi(yytext + 2);
  return _NUMBER_;
}
	YY_BREAK
case 54:
YY_RULE_SETUP
#line 481 'lexer.l'
{     /* saw closing quote - all done */

  ALLOC_SIZED_STRING(s, yyextra->lex_buf_len);

  *yyextra->lex_buf_ptr = '\0';
  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);
  yylval->sized_string = s;

  BEGIN(INITIAL);

  return _TEXT_STRING_;
}
	YY_BREAK
case 55:
YY_RULE_SETUP
#line 495 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\t', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '\t';
  yyextra->lex_buf_len++;
}
	YY_BREAK
case 56:
YY_RULE_SETUP
#line 503 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\n', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '\n';
  yyextra->lex_buf_len++;
}
	YY_BREAK
case 57:
YY_RULE_SETUP
#line 511 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\'', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '\'';
  yyextra->lex_buf_len++;
}
	YY_BREAK
case 58:
YY_RULE_SETUP
#line 519 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\\', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '\\';
  yyextra->lex_buf_len++;
}
	YY_BREAK
case 59:
YY_RULE_SETUP
#line 527 'lexer.l'
{

   int result;

   sscanf( yytext + 2, '%x', &result );
   LEX_CHECK_SPACE_OK('X', yyextra->lex_buf_len, LEX_BUF_SIZE);
   *yyextra->lex_buf_ptr++ = result;
   yyextra->lex_buf_len++;
}
	YY_BREAK
case 60:
YY_RULE_SETUP
#line 538 'lexer.l'
{ YYTEXT_TO_BUFFER; }
	YY_BREAK
case 61:
/* rule 61 can match eol */
YY_RULE_SETUP
#line 541 'lexer.l'
{

  yyerror(yyscanner, compiler, 'unterminated string');
  yyterminate();
}
	YY_BREAK
case 62:
/* rule 62 can match eol */
YY_RULE_SETUP
#line 547 'lexer.l'
{

  yyerror(yyscanner, compiler, 'illegal escape sequence');
  yyterminate();
}
	YY_BREAK
case 63:
YY_RULE_SETUP
#line 554 'lexer.l'
{

  if (yyextra->lex_buf_len > 0)
  {
    ALLOC_SIZED_STRING(s, yyextra->lex_buf_len);

    if (yytext[1] == 'i')
      s->flags |= SIZED_STRING_FLAGS_NO_CASE;

    if (yytext[1] == 's' || yytext[2] == 's')
      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;

    *yyextra->lex_buf_ptr = '\0';
    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);
    yylval->sized_string = s;
  }
  else
  {
    yyerror(yyscanner, compiler, 'empty regular expression');
    yyterminate();
  }

  BEGIN(INITIAL);
  return _REGEXP_;
}
	YY_BREAK
case 64:
YY_RULE_SETUP
#line 581 'lexer.l'
{

  LEX_CHECK_SPACE_OK('/', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = '/';
  yyextra->lex_buf_len++ ;
}
	YY_BREAK
case 65:
YY_RULE_SETUP
#line 589 'lexer.l'
{

  LEX_CHECK_SPACE_OK('\\.', yyextra->lex_buf_len, LEX_BUF_SIZE);
  *yyextra->lex_buf_ptr++ = yytext[0];
  *yyextra->lex_buf_ptr++ = yytext[1];
  yyextra->lex_buf_len += 2;
}
	YY_BREAK
case 66:
YY_RULE_SETUP
#line 598 'lexer.l'
{ YYTEXT_TO_BUFFER; }
	YY_BREAK
case 67:
/* rule 67 can match eol */
YY_RULE_SETUP
#line 601 'lexer.l'
{

  yyerror(yyscanner, compiler, 'unterminated regular expression');
  yyterminate();
}
	YY_BREAK
case 68:
YY_RULE_SETUP
#line 608 'lexer.l'
{

  yyextra->lex_buf_ptr = yyextra->lex_buf;
  yyextra->lex_buf_len = 0;
  BEGIN(str);
}
	YY_BREAK
case 69:
YY_RULE_SETUP
#line 616 'lexer.l'
{

  yyextra->lex_buf_ptr = yyextra->lex_buf;
  yyextra->lex_buf_len = 0;
  BEGIN(regexp);
}
	YY_BREAK
case 70:
/* rule 70 can match eol */
YY_RULE_SETUP
#line 624 'lexer.l'
{
  // Match hex-digits with whitespace or comments. The latter are stripped
  // out by hex_lexer.l

  ALLOC_SIZED_STRING(s, strlen(yytext));

  strlcpy(s->c_string, yytext, s->length + 1);
  yylval->sized_string = s;

  return _HEX_STRING_;
}
	YY_BREAK
case 71:
/* rule 71 can match eol */
YY_RULE_SETUP
#line 637 'lexer.l'
/* skip whitespace */
	YY_BREAK
case 72:
YY_RULE_SETUP
#line 639 'lexer.l'
{

  if (yytext[0] >= 32 && yytext[0] < 127)
  {
    return yytext[0];
  }
  else
  {
    yyerror(yyscanner, compiler, 'non-ascii character');
    yyterminate();
  }
}
	YY_BREAK
case 73:
YY_RULE_SETUP
#line 652 'lexer.l'
ECHO;
	YY_BREAK
#line 1909 'lexer.c'

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yara_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p '<=' to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_last_accepting_cpos;
				yy_current_state = yyg->yy_last_accepting_state;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( yara_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			'fatal flex scanner internal error--no action found' );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yara_yylex */
",1,7796
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		'fatal flex scanner internal error--end of buffer missed' );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yara_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				'fatal error - scanner input buffer overflow' );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yara_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yara_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( 'out of dynamic memory in yy_get_next_buffer()' );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}
",1,7797
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 243 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}
",1,7798
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 243 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 242);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}
",1,7799
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"static void yara_yyensure_buffer_stack (yyscan_t yyscanner)
{
	int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyg->yy_buffer_stack = (struct yy_buffer_state**)yara_yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( 'out of dynamic memory in yara_yyensure_buffer_stack()' );
								  
		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
				
		yyg->yy_buffer_stack_max = num_to_alloc;
		yyg->yy_buffer_stack_top = 0;
		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)yara_yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( 'out of dynamic memory in yara_yyensure_buffer_stack()' );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}
",1,7800
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"YY_BUFFER_STATE yara_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) yara_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( 'out of dynamic memory in yara_yy_scan_buffer()' );

	b->yy_buf_size = size - 2;	/* '- 2' to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yara_yy_switch_to_buffer(b ,yyscanner );

	return b;
}
",1,7801
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"YY_BUFFER_STATE yara_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{
    
	return yara_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}
",1,7802
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"YY_BUFFER_STATE yara_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) yara_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( 'out of dynamic memory in yara_yy_scan_bytes()' );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yara_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( 'bad buffer in yara_yy_scan_bytes()' );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}
",1,7803
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, '%s\n', msg );
	exit( YY_EXIT_FAILURE );
}
",1,7804
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"int yara_yyget_leng  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyleng;
}
",1,7805
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"static int yy_init_globals (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yara_yylex_destroy(), so don't allocate here.
     */

    yyg->yy_buffer_stack = NULL;
    yyg->yy_buffer_stack_top = 0;
    yyg->yy_buffer_stack_max = 0;
    yyg->yy_c_buf_p = NULL;
    yyg->yy_init = 0;
    yyg->yy_start = 0;

    yyg->yy_start_stack_ptr = 0;
    yyg->yy_start_stack_depth = 0;
    yyg->yy_start_stack =  NULL;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yara_yylex_init()
     */
    return 0;
}
",1,7806
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"void *yara_yyalloc (yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	return malloc(size);
}
",1,7807
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"void *yara_yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}
",1,7808
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(str):
case YY_STATE_EOF(regexp):
",0,7809
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"YY_BUFFER_STATE yara_yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
",0,7810
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"}
	YY_BREAK
case 44:
",0,7811
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"#line 392 'lexer.l'
{

",0,7812
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"int yara_yyget_column  (yyscan_t yyscanner );
",0,7813
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"YY_RULE_SETUP
#line 174 'lexer.l'
{ /* skip single-line comments */ }
",0,7814
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
",0,7815
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"FILE *yara_yyget_in  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyin;
}
",0,7816
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"static yy_state_type yy_get_previous_state (yyscan_t yyscanner );
",0,7817
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"
  return _STRING_IDENTIFIER_WITH_WILDCARD_;
}
",0,7818
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"    static void yara_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)

{
	int oerrno = errno;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yara_yy_flush_buffer(b ,yyscanner);

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yara_yy_init_buffer was _probably_
     * called from yara_yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = 0;
    
	errno = oerrno;
}
",0,7819
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"    *yyextra->lex_buf_ptr = '\0';
    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);
    yylval->sized_string = s;
",0,7820
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"void yara_yyset_lineno (int _line_number ,yyscan_t yyscanner );
",0,7821
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"#line 547 'lexer.l'
{

",0,7822
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"	YY_BREAK
case 15:
YY_RULE_SETUP
",0,7823
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"        0,    0,    0,    0,    0,    0,    0,    0,  211,  243,
      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
      243,  243,  244,  244,  244,  244,  244,  244,  244,  244,
",0,7825
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"FILE *yara_yyget_out (yyscan_t yyscanner );
",0,7826
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
",0,7827
VirusTotal/yara,eb491e03851a11bc811173f5e13c89cefa7257ac,"        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
",0,7828
VirusTotal/yara,cf70f93e3c4f21742509c98f0a47128b6773e084,"static void
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)
{
  YYUSE (yyvaluep);
  YYUSE (yyscanner);
  YYUSE (compiler);
  if (!yymsg)
    yymsg = 'Deleting';
  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  switch (yytype)
    {
          case 10: /* _IDENTIFIER_  */
#line 181 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).c_string)); }
#line 1339 'grammar.c' /* yacc.c:1257  */
        break;

    case 11: /* _STRING_IDENTIFIER_  */
#line 185 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).c_string)); }
#line 1345 'grammar.c' /* yacc.c:1257  */
        break;

    case 12: /* _STRING_COUNT_  */
#line 182 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).c_string)); }
#line 1351 'grammar.c' /* yacc.c:1257  */
        break;

    case 13: /* _STRING_OFFSET_  */
#line 183 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).c_string)); }
#line 1357 'grammar.c' /* yacc.c:1257  */
        break;

    case 14: /* _STRING_LENGTH_  */
#line 184 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).c_string)); }
#line 1363 'grammar.c' /* yacc.c:1257  */
        break;

    case 15: /* _STRING_IDENTIFIER_WITH_WILDCARD_  */
#line 186 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).c_string)); }
#line 1369 'grammar.c' /* yacc.c:1257  */
        break;

    case 19: /* _TEXT_STRING_  */
#line 187 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).sized_string)); }
#line 1375 'grammar.c' /* yacc.c:1257  */
        break;

    case 20: /* _HEX_STRING_  */
#line 188 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).sized_string)); }
#line 1381 'grammar.c' /* yacc.c:1257  */
        break;

    case 21: /* _REGEXP_  */
#line 189 'grammar.y' /* yacc.c:1257  */
      { yr_free(((*yyvaluep).sized_string)); }
#line 1387 'grammar.c' /* yacc.c:1257  */
        break;


      default:
        break;
    }
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}
",1,7829
VirusTotal/yara,cf70f93e3c4f21742509c98f0a47128b6773e084,"int
yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, 'Starting parse\n'));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_('memory exhausted'),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, 'Stack size increased to %lu\n',
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, 'Entering state %d\n', yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, 'Reading a token: '));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, 'Now at end of input.\n'));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ('Next token is', yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ('Shifting', yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 217 'grammar.y' /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 'grammar.c' /* yacc.c:1646  */
    break;

  case 9:
#line 229 'grammar.y' /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 'grammar.c' /* yacc.c:1646  */
    break;

  case 10:
#line 238 'grammar.y' /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 'grammar.c' /* yacc.c:1646  */
    break;

  case 11:
#line 246 'grammar.y' /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 'grammar.c' /* yacc.c:1646  */
    break;

  case 12:
#line 261 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 'grammar.c' /* yacc.c:1646  */
    break;

  case 13:
#line 265 'grammar.y' /* yacc.c:1646  */
    {
        // Each rule have a list of meta-data info, consisting in a
        // sequence of YR_META structures. The last YR_META structure does
        // not represent a real meta-data, it's just a end-of-list marker
        // identified by a specific type (META_TYPE_NULL). Here we
        // write the end-of-list marker.

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 'grammar.c' /* yacc.c:1646  */
    break;

  case 14:
#line 292 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 'grammar.c' /* yacc.c:1646  */
    break;

  case 15:
#line 296 'grammar.y' /* yacc.c:1646  */
    {
        // Each rule have a list of strings, consisting in a sequence
        // of YR_STRING structures. The last YR_STRING structure does not
        // represent a real string, it's just a end-of-list marker
        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        // write the end-of-list marker.

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 'grammar.c' /* yacc.c:1646  */
    break;

  case 17:
#line 327 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 'grammar.c' /* yacc.c:1646  */
    break;

  case 18:
#line 328 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 'grammar.c' /* yacc.c:1646  */
    break;

  case 19:
#line 333 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 'grammar.c' /* yacc.c:1646  */
    break;

  case 20:
#line 334 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 'grammar.c' /* yacc.c:1646  */
    break;

  case 21:
#line 340 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 'grammar.c' /* yacc.c:1646  */
    break;

  case 22:
#line 344 'grammar.y' /* yacc.c:1646  */
    {
        // Tags list is represented in the arena as a sequence
        // of null-terminated strings, the sequence ends with an
        // additional null character. Here we write the ending null
        //character. Example: tag1\0tag2\0tag3\0\0

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, '', NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 'grammar.c' /* yacc.c:1646  */
    break;

  case 23:
#line 362 'grammar.y' /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 'grammar.c' /* yacc.c:1646  */
    break;

  case 24:
#line 375 'grammar.y' /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 'grammar.c' /* yacc.c:1646  */
    break;

  case 25:
#line 411 'grammar.y' /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 'grammar.c' /* yacc.c:1646  */
    break;

  case 26:
#line 412 'grammar.y' /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 'grammar.c' /* yacc.c:1646  */
    break;

  case 27:
#line 418 'grammar.y' /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 'grammar.c' /* yacc.c:1646  */
    break;

  case 28:
#line 434 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 'grammar.c' /* yacc.c:1646  */
    break;

  case 29:
#line 447 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 'grammar.c' /* yacc.c:1646  */
    break;

  case 30:
#line 460 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 'grammar.c' /* yacc.c:1646  */
    break;

  case 31:
#line 473 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 'grammar.c' /* yacc.c:1646  */
    break;

  case 32:
#line 489 'grammar.y' /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 'grammar.c' /* yacc.c:1646  */
    break;

  case 33:
#line 490 'grammar.y' /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 'grammar.c' /* yacc.c:1646  */
    break;

  case 34:
#line 496 'grammar.y' /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 'grammar.c' /* yacc.c:1646  */
    break;

  case 35:
#line 500 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 'grammar.c' /* yacc.c:1646  */
    break;

  case 36:
#line 511 'grammar.y' /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 'grammar.c' /* yacc.c:1646  */
    break;

  case 37:
#line 515 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 'grammar.c' /* yacc.c:1646  */
    break;

  case 38:
#line 527 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 'grammar.c' /* yacc.c:1646  */
    break;

  case 39:
#line 540 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 'grammar.c' /* yacc.c:1646  */
    break;

  case 40:
#line 541 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 'grammar.c' /* yacc.c:1646  */
    break;

  case 41:
#line 546 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 'grammar.c' /* yacc.c:1646  */
    break;

  case 42:
#line 547 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 'grammar.c' /* yacc.c:1646  */
    break;

  case 43:
#line 548 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 'grammar.c' /* yacc.c:1646  */
    break;

  case 44:
#line 549 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 'grammar.c' /* yacc.c:1646  */
    break;

  case 45:
#line 555 'grammar.y' /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {
          // Search for identifier within the global namespace, where the
          // externals variables reside.

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            // If not found, search within the current namespace.
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  PTR_TO_INT64(id),
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  PTR_TO_INT64(rule),
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 'grammar.c' /* yacc.c:1646  */
    break;

  case 46:
#line 640 'grammar.y' /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  PTR_TO_INT64(ident),
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 'grammar.c' /* yacc.c:1646  */
    break;

  case 47:
#line 686 'grammar.y' /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, 'array indexes must be of integer type');
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, 'dictionary keys must be of string type');
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 'grammar.c' /* yacc.c:1646  */
    break;

  case 48:
#line 744 'grammar.y' /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                PTR_TO_INT64(args_fmt),
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 'grammar.c' /* yacc.c:1646  */
    break;

  case 49:
#line 788 'grammar.y' /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(''); }
#line 2334 'grammar.c' /* yacc.c:1646  */
    break;

  case 50:
#line 789 'grammar.y' /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 'grammar.c' /* yacc.c:1646  */
    break;

  case 51:
#line 794 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), 'i', MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), 'f', MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), 'b', MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), 's', MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), 'r', MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 'grammar.c' /* yacc.c:1646  */
    break;

  case 52:
#line 819 'grammar.y' /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), 'i', MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), 'f', MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), 'b', MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), 's', MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), 'r', MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 'grammar.c' /* yacc.c:1646  */
    break;

  case 53:
#line 855 'grammar.y' /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              PTR_TO_INT64(re->root_node->forward_code),
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 'grammar.c' /* yacc.c:1646  */
    break;

  case 54:
#line 901 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              'Using literal string \'%s\' in a boolean operation.',
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 'grammar.c' /* yacc.c:1646  */
    break;

  case 55:
#line 923 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 'grammar.c' /* yacc.c:1646  */
    break;

  case 56:
#line 932 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 'grammar.c' /* yacc.c:1646  */
    break;

  case 57:
#line 941 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, 'matches');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, 'matches');

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 'grammar.c' /* yacc.c:1646  */
    break;

  case 58:
#line 956 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, 'contains');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, 'contains');

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 'grammar.c' /* yacc.c:1646  */
    break;

  case 59:
#line 968 'grammar.y' /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 'grammar.c' /* yacc.c:1646  */
    break;

  case 60:
#line 982 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, 'at');

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 'grammar.c' /* yacc.c:1646  */
    break;

  case 61:
#line 995 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 'grammar.c' /* yacc.c:1646  */
    break;

  case 62:
#line 1006 'grammar.y' /* yacc.c:1646  */
    {
        int var_index;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Push end-of-list marker
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2619 'grammar.c' /* yacc.c:1646  */
    break;

  case 63:
#line 1036 'grammar.y' /* yacc.c:1646  */
    {
        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        uint8_t* addr;

        // Clear counter for number of expressions evaluating
        // to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        // Clear iterations counter
        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          // Pop the first integer
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          // Pop higher bound of set range
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          // Pop lower bound of set range
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
        compiler->loop_depth++;
      }
#line 2658 'grammar.c' /* yacc.c:1646  */
    break;

  case 64:
#line 1071 'grammar.y' /* yacc.c:1646  */
    {
        int mem_offset;

        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;

        // The value at the top of the stack is the result of
        // evaluating the boolean expression, so it could be
        // 0, 1 or UNDEFINED. Add this value to a counter
        // keeping the number of expressions evaluating to true.
        // If the value is UNDEFINED instruction OP_ADD_M
        // does nothing.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        // Increment iterations counter
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              PTR_TO_INT64(
                  compiler->loop_address[compiler->loop_depth]),
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          // Increment lower bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          // Push lower bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          // Push higher bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          // Compare higher bound with lower bound, do loop again
          // if lower bound is still lower or equal than higher bound
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              PTR_TO_INT64(
                compiler->loop_address[compiler->loop_depth]),
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at the top of the stack. Check if the quantifier
        // is undefined (meaning 'all') and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2743 'grammar.c' /* yacc.c:1646  */
    break;

  case 65:
#line 1152 'grammar.y' /* yacc.c:1646  */
    {
        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        // Pop the first string.
        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
        compiler->loop_depth++;
      }
#line 2777 'grammar.c' /* yacc.c:1646  */
    break;

  case 66:
#line 1182 'grammar.y' /* yacc.c:1646  */
    {
        int mem_offset;

        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;

        // Increment counter by the value returned by the
        // boolean expression (0 or 1). If the boolean expression
        // returned UNDEFINED the OP_ADD_M won't do anything.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        // Increment iterations counter.
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        // If next string is not undefined, go back to the
        // begining of the loop.
        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            PTR_TO_INT64(
                compiler->loop_address[compiler->loop_depth]),
            NULL,
            NULL);

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at top of the stack. Check if the quantifier is
        // undefined (meaning 'all') and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;

      }
#line 2831 'grammar.c' /* yacc.c:1646  */
    break;

  case 67:
#line 1232 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit(yyscanner, OP_OF, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2841 'grammar.c' /* yacc.c:1646  */
    break;

  case 68:
#line 1238 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit(yyscanner, OP_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2851 'grammar.c' /* yacc.c:1646  */
    break;

  case 69:
#line 1244 'grammar.y' /* yacc.c:1646  */
    {
        YR_FIXUP* fixup;
        int64_t* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // create a fixup entry for the jump and push it in the stack
        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
        fixup->next = compiler->fixup_stack_head;
        compiler->fixup_stack_head = fixup;
      }
#line 2881 'grammar.c' /* yacc.c:1646  */
    break;

  case 70:
#line 1270 'grammar.y' /* yacc.c:1646  */
    {
        YR_FIXUP* fixup;
        uint8_t* and_addr;

        // Ensure that we have at least two consecutive bytes in the arena's
        // current page, one for the AND opcode and one for opcode following the
        // AND. This is necessary because we need to compute the address for the
        // opcode following the AND, and we don't want the AND in one page and
        // the following opcode in another page.

        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Now we know the jump destination, which is the address of the
        // instruction following the AND. Let's fixup the jump address.

        fixup = compiler->fixup_stack_head;

        // We know that the AND opcode and the following one are within the same
        // page, so we can compute the address for the opcode following the AND
        // by simply adding one to its address.

        *(fixup->address) = PTR_TO_INT64(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2921 'grammar.c' /* yacc.c:1646  */
    break;

  case 71:
#line 1306 'grammar.y' /* yacc.c:1646  */
    {
        YR_FIXUP* fixup;
        int64_t* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
        fixup->next = compiler->fixup_stack_head;
        compiler->fixup_stack_head = fixup;
      }
#line 2950 'grammar.c' /* yacc.c:1646  */
    break;

  case 72:
#line 1331 'grammar.y' /* yacc.c:1646  */
    {
        YR_FIXUP* fixup;
        uint8_t* or_addr;

        // Ensure that we have at least two consecutive bytes in the arena's
        // current page, one for the OR opcode and one for opcode following the
        // OR. This is necessary because we need to compute the address for the
        // opcode following the OR, and we don't want the OR in one page and
        // the following opcode in another page.

        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Now we know the jump destination, which is the address of the
        // instruction following the OP_OR. Let's fixup the jump address.

        fixup = compiler->fixup_stack_head;

        // We know that the OR opcode and the following one are within the same
        // page, so we can compute the address for the opcode following the OR
        // by simply adding one to its address.

        *(fixup->address) = PTR_TO_INT64(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2990 'grammar.c' /* yacc.c:1646  */
    break;

  case 73:
#line 1367 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '<', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3003 'grammar.c' /* yacc.c:1646  */
    break;

  case 74:
#line 1376 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '>', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3016 'grammar.c' /* yacc.c:1646  */
    break;

  case 75:
#line 1385 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '<=', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3029 'grammar.c' /* yacc.c:1646  */
    break;

  case 76:
#line 1394 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '>=', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3042 'grammar.c' /* yacc.c:1646  */
    break;

  case 77:
#line 1403 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '==', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3055 'grammar.c' /* yacc.c:1646  */
    break;

  case 78:
#line 1412 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '!=', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3068 'grammar.c' /* yacc.c:1646  */
    break;

  case 79:
#line 1421 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.expression) = (yyvsp[0].expression);
      }
#line 3076 'grammar.c' /* yacc.c:1646  */
    break;

  case 80:
#line 1425 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.expression) = (yyvsp[-1].expression);
      }
#line 3084 'grammar.c' /* yacc.c:1646  */
    break;

  case 81:
#line 1432 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3090 'grammar.c' /* yacc.c:1646  */
    break;

  case 82:
#line 1433 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3096 'grammar.c' /* yacc.c:1646  */
    break;

  case 83:
#line 1439 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, 'wrong type for range's lower bound');
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, 'wrong type for range's upper bound');
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3118 'grammar.c' /* yacc.c:1646  */
    break;

  case 84:
#line 1461 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, 'wrong type for enumeration item');
          compiler->last_result = ERROR_WRONG_TYPE;

        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3134 'grammar.c' /* yacc.c:1646  */
    break;

  case 85:
#line 1473 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, 'wrong type for enumeration item');
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3149 'grammar.c' /* yacc.c:1646  */
    break;

  case 86:
#line 1488 'grammar.y' /* yacc.c:1646  */
    {
        // Push end-of-list marker
        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
      }
#line 3158 'grammar.c' /* yacc.c:1646  */
    break;

  case 88:
#line 1494 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        yr_parser_emit_pushes_for_strings(yyscanner, '$*');

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3169 'grammar.c' /* yacc.c:1646  */
    break;

  case 91:
#line 1511 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3180 'grammar.c' /* yacc.c:1646  */
    break;

  case 92:
#line 1518 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3191 'grammar.c' /* yacc.c:1646  */
    break;

  case 94:
#line 1530 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
      }
#line 3199 'grammar.c' /* yacc.c:1646  */
    break;

  case 95:
#line 1534 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
      }
#line 3207 'grammar.c' /* yacc.c:1646  */
    break;

  case 96:
#line 1542 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.expression) = (yyvsp[-1].expression);
      }
#line 3215 'grammar.c' /* yacc.c:1646  */
    break;

  case 97:
#line 1546 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit(
            yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3229 'grammar.c' /* yacc.c:1646  */
    break;

  case 98:
#line 1556 'grammar.y' /* yacc.c:1646  */
    {
        yywarning(yyscanner,
            'Using deprecated \'entrypoint\' keyword. Use the \'entry_point\' '
            'function from PE module instead.');

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3247 'grammar.c' /* yacc.c:1646  */
    break;

  case 99:
#line 1570 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, 'intXXXX or uintXXXX');

        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        // in the proper OP_INTXX opcode.

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3267 'grammar.c' /* yacc.c:1646  */
    break;

  case 100:
#line 1586 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = (yyvsp[0].integer);
      }
#line 3281 'grammar.c' /* yacc.c:1646  */
    break;

  case 101:
#line 1596 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg_double(
            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
      }
#line 3294 'grammar.c' /* yacc.c:1646  */
    break;

  case 102:
#line 1605 'grammar.y' /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string;

        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              PTR_TO_INT64(sized_string),
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_STRING;
        (yyval.expression).value.sized_string = sized_string;
      }
#line 3323 'grammar.c' /* yacc.c:1646  */
    break;

  case 103:
#line 1630 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3339 'grammar.c' /* yacc.c:1646  */
    break;

  case 104:
#line 1642 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3355 'grammar.c' /* yacc.c:1646  */
    break;

  case 105:
#line 1654 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3375 'grammar.c' /* yacc.c:1646  */
    break;

  case 106:
#line 1670 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3391 'grammar.c' /* yacc.c:1646  */
    break;

  case 107:
#line 1682 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3411 'grammar.c' /* yacc.c:1646  */
    break;

  case 108:
#line 1698 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  'wrong usage of identifier \'%s\'',
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3460 'grammar.c' /* yacc.c:1646  */
    break;

  case 109:
#line 1743 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, '-');

        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3483 'grammar.c' /* yacc.c:1646  */
    break;

  case 110:
#line 1762 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '+', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
      }
#line 3505 'grammar.c' /* yacc.c:1646  */
    break;

  case 111:
#line 1780 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '-', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
      }
#line 3527 'grammar.c' /* yacc.c:1646  */
    break;

  case 112:
#line 1798 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '*', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
      }
#line 3549 'grammar.c' /* yacc.c:1646  */
    break;

  case 113:
#line 1816 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '\\', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
      }
#line 3579 'grammar.c' /* yacc.c:1646  */
    break;

  case 114:
#line 1842 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '%');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '%');

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
      }
#line 3601 'grammar.c' /* yacc.c:1646  */
    break;

  case 115:
#line 1860 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '^');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '^');

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3615 'grammar.c' /* yacc.c:1646  */
    break;

  case 116:
#line 1870 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '^');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '^');

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3629 'grammar.c' /* yacc.c:1646  */
    break;

  case 117:
#line 1880 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '|');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '|');

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3643 'grammar.c' /* yacc.c:1646  */
    break;

  case 118:
#line 1890 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '~');

        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
            UNDEFINED : ~((yyvsp[0].expression).value.integer);
      }
#line 3657 'grammar.c' /* yacc.c:1646  */
    break;

  case 119:
#line 1900 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '<<');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '<<');

        yr_parser_emit(yyscanner, OP_SHL, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3671 'grammar.c' /* yacc.c:1646  */
    break;

  case 120:
#line 1910 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '>>');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '>>');

        yr_parser_emit(yyscanner, OP_SHR, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3685 'grammar.c' /* yacc.c:1646  */
    break;

  case 121:
#line 1920 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.expression) = (yyvsp[0].expression);
      }
#line 3693 'grammar.c' /* yacc.c:1646  */
    break;


#line 3697 'grammar.c' /* yacc.c:1646  */
      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ('-> $$ =', yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_('syntax error'));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_('syntax error');
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct ('Error: discarding',
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct ('Error: popping',
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ('Shifting', yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_('memory exhausted'));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ('Cleanup: discarding lookahead',
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ('Cleanup: popping',
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  return yyresult;
}
",1,7830
VirusTotal/yara,cf70f93e3c4f21742509c98f0a47128b6773e084,"static YYSIZE_T
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == ''')
    {
      YYSIZE_T yyn = 0;
      char const *yyp = yystr;

      for (;;)
        switch (*++yyp)
          {
          case '\'':
          case ',':
            goto do_not_strip_quotes;

          case '\\':
            if (*++yyp != '\\')
              goto do_not_strip_quotes;
            /* Fall through.  */
          default:
            if (yyres)
              yyres[yyn] = *yyp;
            yyn++;
            break;

          case ''':
            if (yyres)
              yyres[yyn] = '\0';
            return yyn;
          }
    do_not_strip_quotes: ;
    }

  if (! yyres)
    return yystrlen (yystr);

  return yystpcpy (yyres, yystr) - yyres;
}
",0,7831
VirusTotal/yara,cf70f93e3c4f21742509c98f0a47128b6773e084,"static int
yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
                yytype_int16 *yyssp, int yytoken)
{
  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
  YYSIZE_T yysize = yysize0;
  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
  /* Internationalized format string. */
  const char *yyformat = YY_NULLPTR;
  /* Arguments of yyformat. */
  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
  /* Number of reported tokens (one for the 'unexpected', one per
     'expected'). */
  int yycount = 0;

  /* There are many possibilities here to consider:
     - If this state is a consistent state with a default action, then
       the only way this function was invoked is if the default action
       is an error action.  In that case, don't check for expected
       tokens because there are none.
     - The only way there can be no lookahead present (in yychar) is if
       this state is a consistent state with a default action.  Thus,
       detecting the absence of a lookahead is sufficient to determine
       that there is no unexpected or expected token to report.  In that
       case, just report a simple 'syntax error'.
     - Don't assume there isn't a lookahead just because this state is a
       consistent state with a default action.  There might have been a
       previous inconsistent state, consistent state with a non-default
       action, or user semantic action that manipulated yychar.
     - Of course, the expected token list depends on states to have
       correct lookahead information, and it depends on the parser not
       to perform extra reductions after fetching a lookahead from the
       scanner and before detecting a syntax error.  Thus, state merging
       (from LALR or IELR) and default reductions corrupt the expected
       token list.  However, the list is correct for canonical LR with
       one exception: it will still contain any token that will not be
       accepted due to an error action in a later state.
  */
  if (yytoken != YYEMPTY)
    {
      int yyn = yypact[*yyssp];
      yyarg[yycount++] = yytname[yytoken];
      if (!yypact_value_is_default (yyn))
        {
          /* Start YYX at -YYN if negative to avoid negative indexes in
             YYCHECK.  In other words, skip the first -YYN actions for
             this state because they are default actions.  */
          int yyxbegin = yyn < 0 ? -yyn : 0;
          /* Stay within bounds of both yycheck and yytname.  */
          int yychecklim = YYLAST - yyn + 1;
          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
          int yyx;

          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
                && !yytable_value_is_error (yytable[yyx + yyn]))
              {
                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
                  {
                    yycount = 1;
                    yysize = yysize0;
                    break;
                  }
                yyarg[yycount++] = yytname[yyx];
                {
                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
                  if (! (yysize <= yysize1
                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
                    return 2;
                  yysize = yysize1;
                }
              }
        }
    }

  switch (yycount)
    {
# define YYCASE_(N, S)                      \
      case N:                               \
        yyformat = S;                       \
      break
      YYCASE_(0, YY_('syntax error'));
      YYCASE_(1, YY_('syntax error, unexpected %s'));
      YYCASE_(2, YY_('syntax error, unexpected %s, expecting %s'));
      YYCASE_(3, YY_('syntax error, unexpected %s, expecting %s or %s'));
      YYCASE_(4, YY_('syntax error, unexpected %s, expecting %s or %s or %s'));
      YYCASE_(5, YY_('syntax error, unexpected %s, expecting %s or %s or %s or %s'));
# undef YYCASE_
    }

  {
    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
      return 2;
    yysize = yysize1;
  }

  if (*yymsg_alloc < yysize)
    {
      *yymsg_alloc = 2 * yysize;
      if (! (yysize <= *yymsg_alloc
             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
      return 1;
    }

  /* Avoid sprintf, as that infringes on the user's name space.
     Don't have undefined behavior even if the translation
     produced a string with the wrong number of '%s's.  */
  {
    char *yyp = *yymsg;
    int yyi = 0;
    while ((*yyp = *yyformat) != '\0')
      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        {
          yyp += yytnamerr (yyp, yyarg[yyi++]);
          yyformat += 2;
        }
      else
        {
          yyp++;
          yyformat++;
        }
  }
  return 0;
}
",0,7832
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"	int *d0, *d1, *d2, *r, *g, *b;
	const int *y, *cb, *cr;
	unsigned int maxw, maxh, max;
",1,7833
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"	unsigned int i, j;

	upb = (int)img->comps[0].prec;
",1,7834
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"
	for(i=0U; i < maxh; ++i)
	{
",1,7835
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"
		for(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)
		{
",1,7836
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"	if(i < maxh)
	{
		for(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)
",1,7837
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"static void sycc422_to_rgb(opj_image_t *img)
{	
	int *d0, *d1, *d2, *r, *g, *b;
	const int *y, *cb, *cr;
	unsigned int maxw, maxh, max;
	int offset, upb;
	unsigned int i, j;

	upb = (int)img->comps[0].prec;
	offset = 1<<(upb - 1); upb = (1<<upb)-1;

	maxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;
	max = maxw * maxh;

	y = img->comps[0].data;
	cb = img->comps[1].data;
	cr = img->comps[2].data;

	d0 = r = (int*)malloc(sizeof(int) * (size_t)max);
	d1 = g = (int*)malloc(sizeof(int) * (size_t)max);
	d2 = b = (int*)malloc(sizeof(int) * (size_t)max);

	for(i=0U; i < maxh; ++i)
	{
		for(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)
		{
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
			++y; ++r; ++g; ++b;
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
			++y; ++r; ++g; ++b; ++cb; ++cr;
		}
		if (j < maxw) {
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
			++y; ++r; ++g; ++b; ++cb; ++cr;
		}
	}
	free(img->comps[0].data); img->comps[0].data = d0;
	free(img->comps[1].data); img->comps[1].data = d1;
	free(img->comps[2].data); img->comps[2].data = d2;

#if defined(USE_JPWL) || defined(USE_MJ2)
	img->comps[1].w = maxw; img->comps[1].h = maxh;
	img->comps[2].w = maxw; img->comps[2].h = maxh;
#else
	img->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;
	img->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;
#endif
	img->comps[1].dx = img->comps[0].dx;
	img->comps[2].dx = img->comps[0].dx;
	img->comps[1].dy = img->comps[0].dy;
	img->comps[2].dy = img->comps[0].dy;

}/* sycc422_to_rgb() */
",1,7838
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"static void sycc420_to_rgb(opj_image_t *img)
{
	int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;
	const int *y, *cb, *cr, *ny;
	unsigned int maxw, maxh, max;
	int offset, upb;
	unsigned int i, j;

	upb = (int)img->comps[0].prec;
	offset = 1<<(upb - 1); upb = (1<<upb)-1;

	maxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;
	max = maxw * maxh;

	y = img->comps[0].data;
	cb = img->comps[1].data;
	cr = img->comps[2].data;

	d0 = r = (int*)malloc(sizeof(int) * (size_t)max);
	d1 = g = (int*)malloc(sizeof(int) * (size_t)max);
	d2 = b = (int*)malloc(sizeof(int) * (size_t)max);

	for(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)
	{
		ny = y + maxw;
		nr = r + maxw; ng = g + maxw; nb = b + maxw;

		for(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)
		{
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
			++y; ++r; ++g; ++b;
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
			++y; ++r; ++g; ++b;

			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
			++ny; ++nr; ++ng; ++nb;
			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
			++ny; ++nr; ++ng; ++nb; ++cb; ++cr;
		}
		if(j < maxw)
		{
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
			++y; ++r; ++g; ++b;

			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
			++ny; ++nr; ++ng; ++nb; ++cb; ++cr;
		}
		y += maxw; r += maxw; g += maxw; b += maxw;
	}
	if(i < maxh)
	{
		for(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)
		{
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);

			++y; ++r; ++g; ++b;

			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);

			++y; ++r; ++g; ++b; ++cb; ++cr;
		}
		if(j < maxw)
		{
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
		}
	}

	free(img->comps[0].data); img->comps[0].data = d0;
	free(img->comps[1].data); img->comps[1].data = d1;
	free(img->comps[2].data); img->comps[2].data = d2;

#if defined(USE_JPWL) || defined(USE_MJ2)
	img->comps[1].w = maxw; img->comps[1].h = maxh;
	img->comps[2].w = maxw; img->comps[2].h = maxh;
#else
	img->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;
	img->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;
#endif
	img->comps[1].dx = img->comps[0].dx;
	img->comps[2].dx = img->comps[0].dx;
	img->comps[1].dy = img->comps[0].dy;
	img->comps[2].dy = img->comps[0].dy;

}/* sycc420_to_rgb() */
",1,7839
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"		unsigned int i, max;
		cmsHPROFILE in, out;
		cmsHTRANSFORM transform;
",0,7840
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"	image->color_space = OPJ_CLRSPC_SRGB;

}/* color_esycc_to_rgb() */
",0,7841
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"	else
   {
#ifdef DEBUG_PROFILE
",0,7842
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"		{
			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
			++y; ++r; ++g; ++b;
",0,7843
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0," * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
",0,7844
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"static void sycc_to_rgb(int offset, int upb, int y, int cb, int cr,
	int *out_r, int *out_g, int *out_b)
{
",0,7845
uclouvain/openjpeg,40e4e51233af796b346b619cffb5d20d5ee07df0,"		}
	}

",0,7846
uclouvain/openjpeg,162f6199c0cd3ec1c6c6dc65e41b2faab92b2d91,"void color_cmyk_to_rgb(opj_image_t *image)
{
	float C, M, Y, K;
	float sC, sM, sY, sK;
	unsigned int w, h, max, i;

	w = image->comps[0].w;
	h = image->comps[0].h;

	if(image->numcomps < 4) return;

	max = w * h;
	
	sC = 1.0F / (float)((1 << image->comps[0].prec) - 1);
	sM = 1.0F / (float)((1 << image->comps[1].prec) - 1);
	sY = 1.0F / (float)((1 << image->comps[2].prec) - 1);
	sK = 1.0F / (float)((1 << image->comps[3].prec) - 1);

	for(i = 0; i < max; ++i)
	{
		/* CMYK values from 0 to 1 */
		C = (float)(image->comps[0].data[i]) * sC;
		M = (float)(image->comps[1].data[i]) * sM;
		Y = (float)(image->comps[2].data[i]) * sY;
		K = (float)(image->comps[3].data[i]) * sK;
		
		/* Invert all CMYK values */
		C = 1.0F - C;
		M = 1.0F - M;
		Y = 1.0F - Y;
		K = 1.0F - K;

		/* CMYK -> RGB : RGB results from 0 to 255 */
		image->comps[0].data[i] = (int)(255.0F * C * K); /* R */
		image->comps[1].data[i] = (int)(255.0F * M * K); /* G */
		image->comps[2].data[i] = (int)(255.0F * Y * K); /* B */
	}

	free(image->comps[3].data); image->comps[3].data = NULL;
	image->comps[0].prec = 8;
	image->comps[1].prec = 8;
	image->comps[2].prec = 8;
	image->numcomps -= 1;
	image->color_space = OPJ_CLRSPC_SRGB;
	
	for (i = 3; i < image->numcomps; ++i) {
		memcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));
	}

}/* color_cmyk_to_rgb() */
",1,7847
uclouvain/openjpeg,162f6199c0cd3ec1c6c6dc65e41b2faab92b2d91,"		return;
	}
	if(out_prof == NULL)
",0,7848
dosfstools/dosfstools,e8eff147e9da1185f9afd5b25948153a3b97cf52,"static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)
{
    unsigned short sectors;

    printf('Boot sector contents:\n');
    if (!atari_format) {
	char id[9];
	strncpy(id, (const char *)b->system_id, 8);
	id[8] = 0;
	printf('System ID \'%s\'\n', id);
    } else {
	/* On Atari, a 24 bit serial number is stored at offset 8 of the boot
	 * sector */
	printf('Serial number 0x%x\n',
	       b->system_id[5] | (b->system_id[6] << 8) | (b->
							   system_id[7] << 16));
    }
    printf('Media byte 0x%02x (%s)\n', b->media, get_media_descr(b->media));
    printf('%10d bytes per logical sector\n', GET_UNALIGNED_W(b->sector_size));
    printf('%10d bytes per cluster\n', fs->cluster_size);
    printf('%10d reserved sector%s\n', le16toh(b->reserved),
	   le16toh(b->reserved) == 1 ? '' : 's');
    printf('First FAT starts at byte %llu (sector %llu)\n',
	   (unsigned long long)fs->fat_start,
	   (unsigned long long)fs->fat_start / lss);
    printf('%10d FATs, %d bit entries\n', b->fats, fs->fat_bits);
    printf('%10d bytes per FAT (= %u sectors)\n', fs->fat_size,
	   fs->fat_size / lss);
    if (!fs->root_cluster) {
	printf('Root directory starts at byte %llu (sector %llu)\n',
	       (unsigned long long)fs->root_start,
	       (unsigned long long)fs->root_start / lss);
	printf('%10d root directory entries\n', fs->root_entries);
    } else {
	printf('Root directory start at cluster %lu (arbitrary size)\n',
	       (unsigned long)fs->root_cluster);
    }
    printf('Data area starts at byte %llu (sector %llu)\n',
	   (unsigned long long)fs->data_start,
	   (unsigned long long)fs->data_start / lss);
    printf('%10lu data clusters (%llu bytes)\n',
	   (unsigned long)fs->data_clusters,
	   (unsigned long long)fs->data_clusters * fs->cluster_size);
    printf('%u sectors/track, %u heads\n', le16toh(b->secs_track),
	   le16toh(b->heads));
    printf('%10u hidden sectors\n', atari_format ?
	   /* On Atari, the hidden field is only 16 bit wide and unused */
	   (((unsigned char *)&b->hidden)[0] |
	    ((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden));
    sectors = GET_UNALIGNED_W(b->sectors);
    printf('%10u sectors total\n', sectors ? sectors : le32toh(b->total_sect));
}
",1,7849
dosfstools/dosfstools,e8eff147e9da1185f9afd5b25948153a3b97cf52,"void read_boot(DOS_FS * fs)
{
    struct boot_sector b;
    unsigned total_sectors;
    unsigned short logical_sector_size, sectors;
    unsigned fat_length;
    unsigned total_fat_entries;
    off_t data_size;

    fs_read(0, sizeof(b), &b);
    logical_sector_size = GET_UNALIGNED_W(b.sector_size);
    if (!logical_sector_size)
	die('Logical sector size is zero.');

    /* This was moved up because it's the first thing that will fail */
    /* if the platform needs special handling of unaligned multibyte accesses */
    /* but such handling isn't being provided. See GET_UNALIGNED_W() above. */
    if (logical_sector_size & (SECTOR_SIZE - 1))
	die('Logical sector size (%d bytes) is not a multiple of the physical '
	    'sector size.', logical_sector_size);

    fs->cluster_size = b.cluster_size * logical_sector_size;
    if (!fs->cluster_size)
	die('Cluster size is zero.');
    if (b.fats != 2 && b.fats != 1)
	die('Currently, only 1 or 2 FATs are supported, not %d.\n', b.fats);
    fs->nfats = b.fats;
    sectors = GET_UNALIGNED_W(b.sectors);
    total_sectors = sectors ? sectors : le32toh(b.total_sect);
    if (verbose)
	printf('Checking we can access the last sector of the filesystem\n');
    /* Can't access last odd sector anyway, so round down */
    fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,
	    logical_sector_size);
    fat_length = le16toh(b.fat_length) ?
	le16toh(b.fat_length) : le32toh(b.fat32_length);
    fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;
    fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *
	logical_sector_size;
    fs->root_entries = GET_UNALIGNED_W(b.dir_entries);
    fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<
							MSDOS_DIR_BITS,
							logical_sector_size);
    data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;
    fs->data_clusters = data_size / fs->cluster_size;
    fs->root_cluster = 0;	/* indicates standard, pre-FAT32 root dir */
    fs->fsinfo_start = 0;	/* no FSINFO structure */
    fs->free_clusters = -1;	/* unknown */
    if (!b.fat_length && b.fat32_length) {
	fs->fat_bits = 32;
	fs->root_cluster = le32toh(b.root_cluster);
	if (!fs->root_cluster && fs->root_entries)
	    /* M$ hasn't specified this, but it looks reasonable: If
	     * root_cluster is 0 but there is a separate root dir
	     * (root_entries != 0), we handle the root dir the old way. Give a
	     * warning, but convertig to a root dir in a cluster chain seems
	     * to complex for now... */
	    printf('Warning: FAT32 root dir not in cluster chain! '
		   'Compatibility mode...\n');
	else if (!fs->root_cluster && !fs->root_entries)
	    die('No root directory!');
	else if (fs->root_cluster && fs->root_entries)
	    printf('Warning: FAT32 root dir is in a cluster chain, but '
		   'a separate root dir\n'
		   '  area is defined. Cannot fix this easily.\n');
	if (fs->data_clusters < FAT16_THRESHOLD)
	    printf('Warning: Filesystem is FAT32 according to fat_length '
		   'and fat32_length fields,\n'
		   '  but has only %lu clusters, less than the required '
		   'minimum of %d.\n'
		   '  This may lead to problems on some systems.\n',
		   (unsigned long)fs->data_clusters, FAT16_THRESHOLD);

	check_fat_state_bit(fs, &b);
	fs->backupboot_start = le16toh(b.backup_boot) * logical_sector_size;
	check_backup_boot(fs, &b, logical_sector_size);

	read_fsinfo(fs, &b, logical_sector_size);
    } else if (!atari_format) {
	/* On real MS-DOS, a 16 bit FAT is used whenever there would be too
	 * much clusers otherwise. */
	fs->fat_bits = (fs->data_clusters >= FAT12_THRESHOLD) ? 16 : 12;
	if (fs->data_clusters >= FAT16_THRESHOLD)
	    die('Too many clusters (%lu) for FAT16 filesystem.', fs->data_clusters);
	check_fat_state_bit(fs, &b);
    } else {
	/* On Atari, things are more difficult: GEMDOS always uses 12bit FATs
	 * on floppies, and always 16 bit on harddisks. */
	fs->fat_bits = 16;	/* assume 16 bit FAT for now */
	/* If more clusters than fat entries in 16-bit fat, we assume
	 * it's a real MSDOS FS with 12-bit fat. */
	if (fs->data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||
	    /* if it has one of the usual floppy sizes -> 12bit FAT  */
	    (total_sectors == 720 || total_sectors == 1440 ||
	     total_sectors == 2880))
	    fs->fat_bits = 12;
    }
    /* On FAT32, the high 4 bits of a FAT entry are reserved */
    fs->eff_fat_bits = (fs->fat_bits == 32) ? 28 : fs->fat_bits;
    fs->fat_size = fat_length * logical_sector_size;

    fs->label = calloc(12, sizeof(uint8_t));
    if (fs->fat_bits == 12 || fs->fat_bits == 16) {
	struct boot_sector_16 *b16 = (struct boot_sector_16 *)&b;
	if (b16->extended_sig == 0x29)
	    memmove(fs->label, b16->label, 11);
	else
	    fs->label = NULL;
    } else if (fs->fat_bits == 32) {
	if (b.extended_sig == 0x29)
	    memmove(fs->label, &b.label, 11);
	else
	    fs->label = NULL;
    }

    total_fat_entries = (uint64_t)fs->fat_size * 8 / fs->fat_bits;
    if (fs->data_clusters > total_fat_entries - 2)
	die('Filesystem has %u clusters but only space for %u FAT entries.',
	    fs->data_clusters, total_fat_entries - 2);
    if (!fs->root_entries && !fs->root_cluster)
	die('Root directory has zero size.');
    if (fs->root_entries & (MSDOS_DPS - 1))
	die('Root directory (%d entries) doesn't span an integral number of '
	    'sectors.', fs->root_entries);
    if (logical_sector_size & (SECTOR_SIZE - 1))
	die('Logical sector size (%d bytes) is not a multiple of the physical '
	    'sector size.', logical_sector_size);
#if 0				/* linux kernel doesn't check that either */
    /* ++roman: On Atari, these two fields are often left uninitialized */
    if (!atari_format && (!b.secs_track || !b.heads))
	die('Invalid disk format in boot sector.');
#endif
    if (verbose)
	dump_boot(fs, &b, logical_sector_size);
}
",1,7850
dosfstools/dosfstools,e8eff147e9da1185f9afd5b25948153a3b97cf52,"
static struct {
    uint8_t media;
    const char *descr;
} mediabytes[] = {
    {
    0xf0, '5.25\' or 3.5\' HD floppy'}, {
    0xf8, 'hard disk'}, {
    0xf9, '3,5\' 720k floppy 2s/80tr/9sec or '
",0,7851
dosfstools/dosfstools,e8eff147e9da1185f9afd5b25948153a3b97cf52,"static const char *get_media_descr(unsigned char media)
{
    int i;

    for (i = 0; i < sizeof(mediabytes) / sizeof(*mediabytes); ++i) {
	if (mediabytes[i].media == media)
	    return (mediabytes[i].descr);
    }
    return ('undefined');
}
",0,7852
ImageMagick/ImageMagick,dd84447b63a71fa8c3f47071b09454efc667767b,"static MagickBooleanType Get8BIMProperty(const Image *image,const char *key,
  ExceptionInfo *exception)
{
  char
    *attribute,
    format[MagickPathExtent],
    name[MagickPathExtent],
    *resource;

  const StringInfo
    *profile;

  const unsigned char
    *info;

  long
    start,
    stop;

  MagickBooleanType
    status;

  register ssize_t
    i;

  size_t
    length;

  ssize_t
    count,
    id,
    sub_number;

  /*
    There are no newlines in path names, so it's safe as terminator.
  */
  profile=GetImageProfile(image,'8bim');
  if (profile == (StringInfo *) NULL)
    return(MagickFalse);
  count=(ssize_t) sscanf(key,'8BIM:%ld,%ld:%1024[^\n]\n%1024[^\n]',&start,&stop,
    name,format);
  if ((count != 2) && (count != 3) && (count != 4))
    return(MagickFalse);
  if (count < 4)
    (void) CopyMagickString(format,'SVG',MagickPathExtent);
  if (count < 3)
    *name='\0';
  sub_number=1;
  if (*name == '#')
    sub_number=(ssize_t) StringToLong(&name[1]);
  sub_number=MagickMax(sub_number,1L);
  resource=(char *) NULL;
  status=MagickFalse;
  length=GetStringInfoLength(profile);
  info=GetStringInfoDatum(profile);
  while ((length > 0) && (status == MagickFalse))
  {
    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')
      continue;
    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')
      continue;
    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')
      continue;
    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')
      continue;
    id=(ssize_t) ReadPropertyMSBShort(&info,&length);
    if (id < (ssize_t) start)
      continue;
    if (id > (ssize_t) stop)
      continue;
    if (resource != (char *) NULL)
      resource=DestroyString(resource);
    count=(ssize_t) ReadPropertyByte(&info,&length);
    if ((count != 0) && ((size_t) count <= length))
      {
        resource=(char *) NULL;
        if (~((size_t) count) >= (MagickPathExtent-1))
          resource=(char *) AcquireQuantumMemory((size_t) count+
            MagickPathExtent,sizeof(*resource));
        if (resource != (char *) NULL)
          {
            for (i=0; i < (ssize_t) count; i++)
              resource[i]=(char) ReadPropertyByte(&info,&length);
            resource[count]='\0';
          }
      }
    if ((count & 0x01) == 0)
      (void) ReadPropertyByte(&info,&length);
    count=(ssize_t) ReadPropertyMSBLong(&info,&length);
    if ((*name != '\0') && (*name != '#'))
      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))
        {
          /*
            No name match, scroll forward and try next.
          */
          info+=count;
          length-=MagickMin(count,(ssize_t) length);
          continue;
        }
    if ((*name == '#') && (sub_number != 1))
      {
        /*
          No numbered match, scroll forward and try next.
        */
        sub_number--;
        info+=count;
        length-=MagickMin(count,(ssize_t) length);
        continue;
      }
    /*
      We have the resource of interest.
    */
    attribute=(char *) NULL;
    if (~((size_t) count) >= (MagickPathExtent-1))
      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,
        sizeof(*attribute));
    if (attribute != (char *) NULL)
      {
        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);
        attribute[count]='\0';
        info+=count;
        length-=MagickMin(count,(ssize_t) length);
        if ((id <= 1999) || (id >= 2999))
          (void) SetImageProperty((Image *) image,key,(const char *)
            attribute,exception);
        else
          {
            char
              *path;

            if (LocaleCompare(format,'svg') == 0)
              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,
                image->columns,image->rows);
            else
              path=TracePSClippath((unsigned char *) attribute,(size_t) count);
            (void) SetImageProperty((Image *) image,key,(const char *) path,
              exception);
            path=DestroyString(path);
          }
        attribute=DestroyString(attribute);
        status=MagickTrue;
      }
  }
  if (resource != (char *) NULL)
    resource=DestroyString(resource);
  return(status);
}
",1,7853
ImageMagick/ImageMagick,dd84447b63a71fa8c3f47071b09454efc667767b,"MagickExport const char *GetMagickProperty(ImageInfo *image_info,
  Image *image,const char *property,ExceptionInfo *exception)
{
  char
    value[MagickPathExtent];

  const char
    *string;

  assert(property[0] != '\0');
  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );
  if (property[1] == '\0')  /* single letter property request */
    return(GetMagickPropertyLetter(image_info,image,*property,exception));
  if ((image != (Image *) NULL) && (image->debug != MagickFalse))
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',image->filename);
  else
    if ((image_info != (ImageInfo *) NULL) &&
        (image_info->debug != MagickFalse))
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s','no-images');
  *value='\0';           /* formated string */
  string=(char *) NULL;  /* constant string reference */
  switch (*property)
  {
    case 'b':
    {
      if (LocaleCompare('basename',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          GetPathComponent(image->magick_filename,BasePath,value);
          if (*value == '\0')
            string='';
          break;
        }
      if (LocaleCompare('bit-depth',property) == 0)
        {
          (void) FormatLocaleString(value,MagickPathExtent,'%.20g',(double)
            GetImageDepth(image,exception));
          break;
        }
      break;
    }
    case 'c':
    {
      if (LocaleCompare('channels',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          /* FUTURE: return actual image channels */
          (void) FormatLocaleString(value,MagickPathExtent,'%s',
            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)
            image->colorspace));
          LocaleLower(value);
          if( image->alpha_trait != UndefinedPixelTrait )
            (void) ConcatenateMagickString(value,'a',MagickPathExtent);
          break;
        }
      if (LocaleCompare('colorspace',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          /* FUTURE: return actual colorspace - no 'gray' stuff */
          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)
            image->colorspace);
          break;
        }
      if (LocaleCompare('compose',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)
            image->compose);
          break;
        }
      if (LocaleCompare('copyright',property) == 0)
        {
          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);
          break;
        }
      break;
    }
    case 'd':
    {
      if (LocaleCompare('depth',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) FormatLocaleString(value,MagickPathExtent,'%.20g',(double)
            image->depth);
          break;
        }
      if (LocaleCompare('directory',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          GetPathComponent(image->magick_filename,HeadPath,value);
          if (*value == '\0')
            string='';
          break;
        }
      break;
    }
    case 'e':
    {
      if (LocaleCompare('entropy',property) == 0)
        {
          double
            entropy;

          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) GetImageEntropy(image,&entropy,exception);
          (void) FormatLocaleString(value,MagickPathExtent,'%.*g',
            GetMagickPrecision(),entropy);
          break;
        }
      if (LocaleCompare('extension',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          GetPathComponent(image->magick_filename,ExtensionPath,value);
          if (*value == '\0')
            string='';
          break;
        }
      break;
    }
    case 'g':
    {
      if (LocaleCompare('gamma',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) FormatLocaleString(value,MagickPathExtent,'%.*g',
            GetMagickPrecision(),image->gamma);
          break;
        }
      break;
    }
    case 'h':
    {
      if (LocaleCompare('height',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) FormatLocaleString(value,MagickPathExtent,'%.20g',
            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);
          break;
        }
      break;
    }
    case 'i':
    {
      if (LocaleCompare('input',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          string=image->filename;
          break;
        }
      break;
    }
    case 'k':
    {
      if (LocaleCompare('kurtosis',property) == 0)
        {
          double
            kurtosis,
            skewness;

          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);
          (void) FormatLocaleString(value,MagickPathExtent,'%.*g',
            GetMagickPrecision(),kurtosis);
          break;
        }
      break;
    }
    case 'm':
    {
      if (LocaleCompare('magick',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          string=image->magick;
          break;
        }
      if ((LocaleCompare('maxima',property) == 0) ||
          (LocaleCompare('max',property) == 0))
        {
          double
            maximum,
            minimum;

          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) GetImageRange(image,&minimum,&maximum,exception);
          (void) FormatLocaleString(value,MagickPathExtent,'%.*g',
            GetMagickPrecision(),maximum);
          break;
        }
      if (LocaleCompare('mean',property) == 0)
        {
          double
            mean,
            standard_deviation;

          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) GetImageMean(image,&mean,&standard_deviation,exception);
          (void) FormatLocaleString(value,MagickPathExtent,'%.*g',
            GetMagickPrecision(),mean);
          break;
        }
      if ((LocaleCompare('minima',property) == 0) ||
          (LocaleCompare('min',property) == 0))
        {
          double
            maximum,
            minimum;

          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) GetImageRange(image,&minimum,&maximum,exception);
          (void) FormatLocaleString(value,MagickPathExtent,'%.*g',
            GetMagickPrecision(),minimum);
          break;
        }
      break;
    }
    case 'o':
    {
      if (LocaleCompare('opaque',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)
            IsImageOpaque(image,exception));
          break;
        }
      if (LocaleCompare('orientation',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)
            image->orientation);
          break;
        }
      if (LocaleCompare('output',property) == 0)
        {
          WarnNoImageInfoReturn('\'%%[%s]\'',property);
          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);
          break;
        }
     break;
    }
    case 'p':
    {
#if defined(MAGICKCORE_LCMS_DELEGATE)
      if (LocaleCompare('profile:icc',property) == 0 ||
          LocaleCompare('profile:icm',property) == 0)
        {
#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)
#define cmsUInt32Number  DWORD
#endif

          const StringInfo
            *profile;

          cmsHPROFILE
            icc_profile;

          profile=GetImageProfile(image,property+8);
          if (profile == (StringInfo *) NULL)
            break;
          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),
            (cmsUInt32Number) GetStringInfoLength(profile));
          if (icc_profile != (cmsHPROFILE *) NULL)
            {
#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)
              string=cmsTakeProductName(icc_profile);
#else
              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,
                'en','US',value,MagickPathExtent);
#endif
              (void) cmsCloseProfile(icc_profile);
            }
      }
#endif
      if (LocaleCompare('profiles',property) == 0)
        {
          const char
            *name;

          ResetImageProfileIterator(image);
          name=GetNextImageProfile(image);
          if (name != (char *) NULL)
            {
              (void) CopyMagickString(value,name,MagickPathExtent);
              name=GetNextImageProfile(image);
              while (name != (char *) NULL)
              {
                ConcatenateMagickString(value,',',MagickPathExtent);
                ConcatenateMagickString(value,name,MagickPathExtent);
                name=GetNextImageProfile(image);
              }
            }
          break;
        }
      break;
    }
    case 'r':
    {
      if (LocaleCompare('resolution.x',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) FormatLocaleString(value,MagickPathExtent,'%g',
            image->resolution.x);
          break;
        }
      if (LocaleCompare('resolution.y',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) FormatLocaleString(value,MagickPathExtent,'%g',
            image->resolution.y);
          break;
        }
      break;
    }
    case 's':
    {
      if (LocaleCompare('scene',property) == 0)
        {
          WarnNoImageInfoReturn('\'%%[%s]\'',property);
          if (image_info->number_scenes != 0)
            (void) FormatLocaleString(value,MagickPathExtent,'%.20g',(double)
              image_info->scene);
          else {
            WarnNoImageReturn('\'%%[%s]\'',property);
            (void) FormatLocaleString(value,MagickPathExtent,'%.20g',(double)
              image->scene);
          }
          break;
        }
      if (LocaleCompare('scenes',property) == 0)
        {
          /* FUTURE: equivelent to %n? */
          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) FormatLocaleString(value,MagickPathExtent,'%.20g',(double)
            GetImageListLength(image));
          break;
        }
      if (LocaleCompare('size',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,'B',
            MagickPathExtent,value);
          break;
        }
      if (LocaleCompare('skewness',property) == 0)
        {
          double
            kurtosis,
            skewness;

          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);
          (void) FormatLocaleString(value,MagickPathExtent,'%.*g',
            GetMagickPrecision(),skewness);
          break;
        }
      if (LocaleCompare('standard-deviation',property) == 0)
        {
          double
            mean,
            standard_deviation;

          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) GetImageMean(image,&mean,&standard_deviation,exception);
          (void) FormatLocaleString(value,MagickPathExtent,'%.*g',
            GetMagickPrecision(),standard_deviation);
          break;
        }
       break;
    }
    case 't':
    {
      if (LocaleCompare('type',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)
            IdentifyImageType(image,exception));
          break;
        }
       break;
    }
    case 'u':
    {
      if (LocaleCompare('unique',property) == 0)
        {
          WarnNoImageInfoReturn('\'%%[%s]\'',property);
          string=image_info->unique;
          break;
        }
      if (LocaleCompare('units',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)
            image->units);
          break;
        }
      if (LocaleCompare('copyright',property) == 0)
      break;
    }
    case 'v':
    {
      if (LocaleCompare('version',property) == 0)
        {
          string=GetMagickVersion((size_t *) NULL);
          break;
        }
      break;
    }
    case 'w':
    {
      if (LocaleCompare('width',property) == 0)
        {
          WarnNoImageReturn('\'%%[%s]\'',property);
          (void) FormatLocaleString(value,MagickPathExtent,'%.20g',(double)
            (image->magick_columns != 0 ? image->magick_columns : 256));
          break;
        }
      break;
    }
  }
  if (string != (char *) NULL)
    return(string);
  if (*value != '\0')
    {
      /*
        Create a cloned copy of result, that will get cleaned up, eventually.
      */
      if (image != (Image *) NULL)
        {
          (void) SetImageArtifact(image,'get-property',value);
          return(GetImageArtifact(image,'get-property'));
        }
      else
        {
          (void) SetImageOption(image_info,'get-property',value);
          return(GetImageOption(image_info,'get-property'));
        }
    }
  return((char *) NULL);
}
",0,7854
ImageMagick/ImageMagick,2ad6d33493750a28a5a655d319a8e0b16c392de1,"static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07

  char
    magick[12];

  Image
    *image;

  int
    opcode,
    operand,
    status;

  MagickStatusType
    flags;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    map_length,
    number_colormaps,
    number_planes,
    one,
    offset,
    pixel_info_length;

  ssize_t
    count,
    y;

  unsigned char
    background_color[256],
    *colormap,
    pixel,
    plane,
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Determine if this a RLE file.
  */
  count=ReadBlob(image,2,(unsigned char *) magick);
  if ((count != 2) || (memcmp(magick,'\122\314',2) != 0))
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  do
  {
    /*
      Read image header.
    */
    image->page.x=ReadBlobLSBShort(image);
    image->page.y=ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    flags=(MagickStatusType) ReadBlobByte(image);
    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;
    number_planes=(size_t) ReadBlobByte(image);
    bits_per_pixel=(size_t) ReadBlobByte(image);
    number_colormaps=(size_t) ReadBlobByte(image);
    map_length=(unsigned char) ReadBlobByte(image);
    if (map_length >= 64)
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    one=1;
    map_length=one << map_length;
    if ((number_planes == 0) || (number_planes == 2) || (bits_per_pixel != 8) ||
        (image->columns == 0))
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    if (flags & 0x02)
      {
        /*
          No background color-- initialize to black.
        */
        for (i=0; i < (ssize_t) number_planes; i++)
          background_color[i]=0;
        (void) ReadBlobByte(image);
      }
    else
      {
        /*
          Initialize background color.
        */
        p=background_color;
        for (i=0; i < (ssize_t) number_planes; i++)
          *p++=(unsigned char) ReadBlobByte(image);
      }
    if ((number_planes & 0x01) == 0)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,'UnexpectedEndOfFile',
          image->filename);
        break;
      }
    colormap=(unsigned char *) NULL;
    if (number_colormaps != 0)
      {
        /*
          Read image colormaps.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
          3*map_length*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
        p=colormap;
        for (i=0; i < (ssize_t) number_colormaps; i++)
          for (x=0; x < (ssize_t) map_length; x++)
            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
      }
    if ((flags & 0x08) != 0)
      {
        char
          *comment;

        size_t
          length;

        /*
          Read image comment.
        */
        length=ReadBlobLSBShort(image);
        if (length != 0)
          {
            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
            if (comment == (char *) NULL)
              ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
            count=ReadBlob(image,length-1,(unsigned char *) comment);
            comment[length-1]='\0';
            (void) SetImageProperty(image,'comment',comment,exception);
            comment=DestroyString(comment);
            if ((length & 0x01) == 0)
              (void) ReadBlobByte(image);
          }
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate RLE pixels.
    */
    if (image->alpha_trait != UndefinedPixelTrait)
      number_planes++;
    number_pixels=(MagickSizeType) image->columns*image->rows;
    if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
    pixel_info_length=image->columns*image->rows*MagickMax(number_planes,4);
    pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    if ((flags & 0x01) && !(flags & 0x02))
      {
        ssize_t
          j;

        /*
          Set background color.
        */
        p=pixels;
        for (i=0; i < (ssize_t) number_pixels; i++)
        {
          if (image->alpha_trait == UndefinedPixelTrait)
            for (j=0; j < (ssize_t) number_planes; j++)
              *p++=background_color[j];
          else
            {
              for (j=0; j < (ssize_t) (number_planes-1); j++)
                *p++=background_color[j];
              *p++=0;  /* initialize matte channel */
            }
        }
      }
    /*
      Read runlength-encoded image.
    */
    plane=0;
    x=0;
    y=0;
    opcode=ReadBlobByte(image);
    do
    {
      switch (opcode & 0x3f)
      {
        case SkipLinesOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=(int) ReadBlobLSBShort(image);
          x=0;
          y+=operand;
          break;
        }
        case SetColorOp:
        {
          operand=ReadBlobByte(image);
          plane=(unsigned char) operand;
          if (plane == 255)
            plane=(unsigned char) (number_planes-1);
          x=0;
          break;
        }
        case SkipPixelsOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=(int) ReadBlobLSBShort(image);
          x+=operand;
          break;
        }
        case ByteDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=(int) ReadBlobLSBShort(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if (offset+((size_t) operand*number_planes) > pixel_info_length)
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,'UnableToReadImageData');
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            pixel=(unsigned char) ReadBlobByte(image);
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          if (operand & 0x01)
            (void) ReadBlobByte(image);
          x+=operand;
          break;
        }
        case RunDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=(int) ReadBlobLSBShort(image);
          pixel=(unsigned char) ReadBlobByte(image);
          (void) ReadBlobByte(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if (offset+((size_t) operand*number_planes) > pixel_info_length)
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,'UnableToReadImageData');
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          x+=operand;
          break;
        }
        default:
          break;
      }
      opcode=ReadBlobByte(image);
    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
    if (number_colormaps != 0)
      {
        MagickStatusType
          mask;

        /*
          Apply colormap affineation to image.
        */
        mask=(MagickStatusType) (map_length-1);
        p=pixels;
        x=(ssize_t) number_planes;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) number_pixels; i++)
          {
            if (IsValidColormapIndex(image,*p & mask,&index,exception) ==
                MagickFalse)
              break;
            *p=colormap[(ssize_t) index];
            p++;
          }
        else
          if ((number_planes >= 3) && (number_colormaps >= 3))
            for (i=0; i < (ssize_t) number_pixels; i++)
              for (x=0; x < (ssize_t) number_planes; x++)
              {
                if (IsValidColormapIndex(image,(size_t) (x*map_length+
                    (*p & mask)),&index,exception) == MagickFalse)
                  break;
                *p=colormap[(ssize_t) index];
                p++;
              }
        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
          {
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,'UnableToReadImageData');
          }
      }
    /*
      Initialize image structure.
    */
    if (number_planes >= 3)
      {
        /*
          Convert raster image to DirectClass pixel packets.
        */
        p=pixels;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        /*
          Create colormap.
        */
        if (number_colormaps == 0)
          map_length=256;
        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
        p=colormap;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) image->colors; i++)
          {
            /*
              Pseudocolor.
            */
            image->colormap[i].red=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].green=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].blue=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
          }
        else
          if (number_colormaps > 1)
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=(MagickRealType)
                ScaleCharToQuantum(*p);
              image->colormap[i].green=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length));
              image->colormap[i].blue=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length*2));
              p++;
            }
        p=pixels;
        if (image->alpha_trait == UndefinedPixelTrait)
          {
            /*
              Convert raster image to PseudoClass pixel packets.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelIndex(image,*p++,q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            (void) SyncImage(image,exception);
          }
        else
          {
            /*
              Image has a matte channel-- promote to DirectClass.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
                    exception) == MagickFalse)
                  break;
                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].red),q);
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
                    exception) == MagickFalse)
                  break;
                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].green),q);
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
                    exception) == MagickFalse)
                  break;
                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].blue),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
                q+=GetPixelChannels(image);
              }
              if (x < (ssize_t) image->columns)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            image->colormap=(PixelInfo *) RelinquishMagickMemory(
              image->colormap);
            image->storage_class=DirectClass;
            image->colors=0;
          }
      }
    if (number_colormaps != 0)
      colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,'UnexpectedEndOfFile',
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    (void) ReadBlobByte(image);
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 0) && (memcmp(magick,'\122\314',2) == 0))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (memcmp(magick,'\122\314',2) == 0));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",1,7855
ImageMagick/ImageMagick,2ad6d33493750a28a5a655d319a8e0b16c392de1,"static MagickBooleanType IsRLE(const unsigned char *magick,const size_t length)
{
  if (length < 2)
    return(MagickFalse);
  if (memcmp(magick,'\122\314',2) == 0)
    return(MagickTrue);
  return(MagickFalse);
}
",0,7856
ImageMagick/ImageMagick,d9b2209a69ee90d8df81fb124eb66f593eb9f599,"static void InsertRow(unsigned char *p,ssize_t y,Image *image, int bpp)
{
  ExceptionInfo
    *exception;

  int
    bit;

  ssize_t
    x;

  register PixelPacket
    *q;

  IndexPacket
    index;

  register IndexPacket
    *indexes;

  exception=(&image->exception);
  switch (bpp)
    {
    case 1:  /* Convert bitmap scanline. */
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
              {
                index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
                SetPixelIndex(indexes+x+bit,index);
                SetPixelRGBO(q,image->colormap+(ssize_t) index);
                q++;
              }
            p++;
          }
        if ((image->columns % 8) != 0)
          {
            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
              {
                index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
                SetPixelIndex(indexes+x+bit,index);
                SetPixelRGBO(q,image->colormap+(ssize_t) index);
                q++;
              }
            p++;
          }
        if (!SyncAuthenticPixels(image,exception))
          break;
        break;
      }
    case 2:  /* Convert PseudoColor scanline. */
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < ((ssize_t) image->columns-1); x+=4)
        {
            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            q++;
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            q++;
            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            q++;
            index=ConstrainColormapIndex(image,(*p) & 0x3);
            SetPixelIndex(indexes+x+1,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
        }
       if ((image->columns % 4) != 0)
          {
            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            q++;
            if ((image->columns % 4) >= 1)

              {
                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3);
                SetPixelIndex(indexes+x,index);
                SetPixelRGBO(q,image->colormap+(ssize_t) index);
                q++;
                if ((image->columns % 4) >= 2)

                  {
                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3);
                    SetPixelIndex(indexes+x,index);
                    SetPixelRGBO(q,image->colormap+(ssize_t) index);
                    q++;
                  }
              }
            p++;
          }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        break;
      }

    case 4:  /* Convert PseudoColor scanline. */
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < ((ssize_t) image->columns-1); x+=2)
          {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            q++;
            index=ConstrainColormapIndex(image,(*p) & 0x0f);
            SetPixelIndex(indexes+x+1,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        if ((image->columns % 2) != 0)
          {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        break;
      }
    case 8: /* Convert PseudoColor scanline. */
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL) break;
        indexes=GetAuthenticIndexQueue(image);

        for (x=0; x < (ssize_t) image->columns; x++)
          {
            index=ConstrainColormapIndex(image,*p);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
      break;

    case 24:     /*  Convert DirectColor scanline.  */
      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (PixelPacket *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
        {
          SetPixelRed(q,ScaleCharToQuantum(*p++));
          SetPixelGreen(q,ScaleCharToQuantum(*p++));
          SetPixelBlue(q,ScaleCharToQuantum(*p++));
          q++;
        }
      if (!SyncAuthenticPixels(image,exception))
        break;
      break;
    }
}
",1,7857
ImageMagick/ImageMagick,d9b2209a69ee90d8df81fb124eb66f593eb9f599,"static Image *ReadWPGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  typedef struct
  {
    size_t FileId;
    MagickOffsetType DataOffset;
    unsigned int ProductType;
    unsigned int FileType;
    unsigned char MajorVersion;
    unsigned char MinorVersion;
    unsigned int EncryptKey;
    unsigned int Reserved;
  } WPGHeader;

  typedef struct
  {
    unsigned char RecType;
    size_t RecordLength;
  } WPGRecord;

  typedef struct
  {
    unsigned char Class;
    unsigned char RecType;
    size_t Extension;
    size_t RecordLength;
  } WPG2Record;

  typedef struct
  {
    unsigned  HorizontalUnits;
    unsigned  VerticalUnits;
    unsigned char PosSizePrecision;
  } WPG2Start;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType1;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned char Depth;
    unsigned char Compression;
  } WPG2BitmapType1;

  typedef struct
  {
    unsigned int RotAngle;
    unsigned int LowLeftX;
    unsigned int LowLeftY;
    unsigned int UpRightX;
    unsigned int UpRightY;
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType2;

  typedef struct
  {
    unsigned int StartIndex;
    unsigned int NumOfEntries;
  } WPGColorMapRec;

  /*
  typedef struct {
    size_t PS_unknown1;
    unsigned int PS_unknown2;
    unsigned int PS_unknown3;
  } WPGPSl1Record;
  */

  Image
    *image;

  unsigned int
    status;

  WPGHeader
    Header;

  WPGRecord
    Rec;

  WPG2Record
    Rec2;

  WPG2Start StartWPG;

  WPGBitmapType1
    BitmapHeader1;

  WPG2BitmapType1
    Bitmap2Header1;

  WPGBitmapType2
    BitmapHeader2;

  WPGColorMapRec
    WPG_Palette;

  int
    i,
    bpp,
    WPG2Flags;

  ssize_t
    ldblk;

  size_t
    one;

  unsigned char
    *BImgBuff;

  tCTM CTM;         /*current transform matrix*/

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  one=1;
  image=AcquireImage(image_info);
  image->depth=8;
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read WPG image.
  */
  Header.FileId=ReadBlobLSBLong(image);
  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);
  Header.ProductType=ReadBlobLSBShort(image);
  Header.FileType=ReadBlobLSBShort(image);
  Header.MajorVersion=ReadBlobByte(image);
  Header.MinorVersion=ReadBlobByte(image);
  Header.EncryptKey=ReadBlobLSBShort(image);
  Header.Reserved=ReadBlobLSBShort(image);

  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  if (Header.EncryptKey!=0)
    ThrowReaderException(CoderError,'EncryptedWPGImageFileNotSupported');

  image->columns = 1;
  image->rows = 1;
  image->colors = 0;
  bpp=0;
  BitmapHeader2.RotAngle=0;

  switch(Header.FileType)
    {
    case 1:     /* WPG level 1 */
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec.RecType=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rd_WP_DWORD(image,&Rec.RecordLength);
          if(EOFBlob(image))
            break;

          Header.DataOffset=TellBlob(image)+Rec.RecordLength;

          switch(Rec.RecType)
            {
            case 0x0B: /* bitmap type 1 */
              BitmapHeader1.Width=ReadBlobLSBShort(image);
              BitmapHeader1.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))
                ThrowReaderException(CorruptImageError,'ImproperImageHeader');
              BitmapHeader1.Depth=ReadBlobLSBShort(image);
              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader1.VertRes=ReadBlobLSBShort(image);

              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)
                {
                  image->units=PixelsPerCentimeterResolution;
                  image->x_resolution=BitmapHeader1.HorzRes/470.0;
                  image->y_resolution=BitmapHeader1.VertRes/470.0;
                }
              image->columns=BitmapHeader1.Width;
              image->rows=BitmapHeader1.Height;
              bpp=BitmapHeader1.Depth;

              goto UnpackRaster;

            case 0x0E:  /*Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);

              image->colors=WPG_Palette.NumOfEntries;
              if (!AcquireImageColormap(image,image->colors))
                goto NoMemory;
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                }
              break;

            case 0x11:  /* Start PS l1 */
              if(Rec.RecordLength > 8)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+8,   /* skip PS header in the wpg */
                  (ssize_t) Rec.RecordLength-8,exception);
              break;

            case 0x14:  /* bitmap type 2 */
              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);
              BitmapHeader2.Width=ReadBlobLSBShort(image);
              BitmapHeader2.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))
                ThrowReaderException(CorruptImageError,'ImproperImageHeader');
              BitmapHeader2.Depth=ReadBlobLSBShort(image);
              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader2.VertRes=ReadBlobLSBShort(image);

              image->units=PixelsPerCentimeterResolution;
              image->page.width=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);
              image->page.height=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);
              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);
              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);
              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)
                {
                  image->x_resolution=BitmapHeader2.HorzRes/470.0;
                  image->y_resolution=BitmapHeader2.VertRes/470.0;
                }
              image->columns=BitmapHeader2.Width;
              image->rows=BitmapHeader2.Height;
              bpp=BitmapHeader2.Depth;

            UnpackRaster:
              if ((image->colors == 0) && (bpp != 24))
                {
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors))
                    {
                    NoMemory:
                      ThrowReaderException(ResourceLimitError,
                        'MemoryAllocationFailed');
                    }
                  /* printf('Load default colormap \n'); */
                  for (i=0; (i < (int) image->colors) && (i < 256); i++)
                    {
                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);
                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);
                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);
                    }
                }
              else
                {
                  if (bpp < 24)
                    if ( (image->colors < (one << bpp)) && (bpp != 24) )
                      image->colormap=(PixelPacket *) ResizeQuantumMemory(
                        image->colormap,(size_t) (one << bpp),
                        sizeof(*image->colormap));
                }

              if (bpp == 1)
                {
                  if(image->colormap[0].red==0 &&
                     image->colormap[0].green==0 &&
                     image->colormap[0].blue==0 &&
                     image->colormap[1].red==0 &&
                     image->colormap[1].green==0 &&
                     image->colormap[1].blue==0)
                    {  /* fix crippled monochrome palette */
                      image->colormap[1].red =
                        image->colormap[1].green =
                        image->colormap[1].blue = QuantumRange;
                    }
                }

              if(UnpackWPGRaster(image,bpp) < 0)
                /* The raster cannot be unpacked */
                {
                DecompressionFailed:
                  ThrowReaderException(CoderError,'UnableToDecompressImage');
                    }

              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)
                {
                  /* flop command */
                  if(BitmapHeader2.RotAngle & 0x8000)
                    {
                      Image
                        *flop_image;

                      flop_image = FlopImage(image, exception);
                      if (flop_image != (Image *) NULL) {
                        DuplicateBlob(flop_image,image);
                        (void) RemoveLastImageFromList(&image);
                        AppendImageToList(&image,flop_image);
                      }
                    }
                  /* flip command */
                  if(BitmapHeader2.RotAngle & 0x2000)
                    {
                      Image
                        *flip_image;

                      flip_image = FlipImage(image, exception);
                      if (flip_image != (Image *) NULL) {
                        DuplicateBlob(flip_image,image);
                        (void) RemoveLastImageFromList(&image);
                        AppendImageToList(&image,flip_image);
                      }
                    }

      /* rotate command */
                  if(BitmapHeader2.RotAngle & 0x0FFF)
                    {
                      Image
                        *rotate_image;

                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &
                        0x0FFF), exception);
                      if (rotate_image != (Image *) NULL) {
                        DuplicateBlob(rotate_image,image);
                        (void) RemoveLastImageFromList(&image);
                        AppendImageToList(&image,rotate_image);
                      }
                    }
                }

              /* Allocate next image structure. */
              AcquireNextImage(image_info,image);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=0;
              image->colors=0;
              break;

            case 0x1B:  /* Postscript l2 */
              if(Rec.RecordLength>0x3C)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */
                  (ssize_t) Rec.RecordLength-0x3C,exception);
              break;
            }
        }
      break;

    case 2:  /* WPG level 2 */
      (void) memset(CTM,0,sizeof(CTM));
      StartWPG.PosSizePrecision = 0;
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec2.Class=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rec2.RecType=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rd_WP_DWORD(image,&Rec2.Extension);
          Rd_WP_DWORD(image,&Rec2.RecordLength);
          if(EOFBlob(image))
            break;

          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;

          switch(Rec2.RecType)
            {
      case 1:
              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);
              StartWPG.VerticalUnits=ReadBlobLSBShort(image);
              StartWPG.PosSizePrecision=ReadBlobByte(image);
              break;
            case 0x0C:    /* Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);

              image->colors=WPG_Palette.NumOfEntries;
              if (AcquireImageColormap(image,image->colors) == MagickFalse)
                ThrowReaderException(ResourceLimitError,
                  'MemoryAllocationFailed');
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  (void) ReadBlobByte(image);   /*Opacity??*/
                }
              break;
            case 0x0E:
              Bitmap2Header1.Width=ReadBlobLSBShort(image);
              Bitmap2Header1.Height=ReadBlobLSBShort(image);
              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))
                ThrowReaderException(CorruptImageError,'ImproperImageHeader');
              Bitmap2Header1.Depth=ReadBlobByte(image);
              Bitmap2Header1.Compression=ReadBlobByte(image);

              if(Bitmap2Header1.Compression > 1)
                continue; /*Unknown compression method */
              switch(Bitmap2Header1.Depth)
                {
                case 1:
                  bpp=1;
                  break;
                case 2:
                  bpp=2;
                  break;
                case 3:
                  bpp=4;
                  break;
                case 4:
                  bpp=8;
                  break;
                case 8:
                  bpp=24;
                  break;
                default:
                  continue;  /*Ignore raster with unknown depth*/
                }
              image->columns=Bitmap2Header1.Width;
              image->rows=Bitmap2Header1.Height;

              if ((image->colors == 0) && (bpp != 24))
                {
                  size_t
                    one;

                  one=1;
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors))
                    goto NoMemory;
                }
              else
                {
                  if(bpp < 24)
                    if( image->colors<(one << bpp) && bpp!=24 )
                      image->colormap=(PixelPacket *) ResizeQuantumMemory(
                       image->colormap,(size_t) (one << bpp),
                       sizeof(*image->colormap));
                }


              switch(Bitmap2Header1.Compression)
                {
                case 0:    /*Uncompressed raster*/
                  {
                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);
                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)
                      ldblk,sizeof(*BImgBuff));
                    if (BImgBuff == (unsigned char *) NULL)
                      goto NoMemory;

                    for(i=0; i< (ssize_t) image->rows; i++)
                      {
                        (void) ReadBlob(image,ldblk,BImgBuff);
                        InsertRow(BImgBuff,i,image,bpp);
                      }

                    if(BImgBuff)
                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);;
                    break;
                  }
                case 1:    /*RLE for WPG2 */
                  {
                    if( UnpackWPG2Raster(image,bpp) < 0)
                      goto DecompressionFailed;
                    break;
                  }
                }

              if(CTM[0][0]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flop_image;

                  flop_image = FlopImage(image, exception);
                  if (flop_image != (Image *) NULL) {
                    DuplicateBlob(flop_image,image);
                    (void) RemoveLastImageFromList(&image);
                    AppendImageToList(&image,flop_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;
                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;
                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);
                     Tx(1,2)=0;   Tx(2,2)=1; */
                }
              if(CTM[1][1]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flip_image;

                  flip_image = FlipImage(image, exception);
                  if (flip_image != (Image *) NULL) {
                    DuplicateBlob(flip_image,image);
                    (void) RemoveLastImageFromList(&image);
                    AppendImageToList(&image,flip_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     float_matrix Tx(3,3);
                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;
                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;
                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);
                     Tx(2,2)=1; */
                }


              /* Allocate next image structure. */
              AcquireNextImage(image_info,image);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x12:  /* Postscript WPG2*/
        i=ReadBlobLSBShort(image);
              if(Rec2.RecordLength > (unsigned int) i)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+i,    /*skip PS header in the wpg2*/
                  (ssize_t) (Rec2.RecordLength-i-2),exception);
              break;

      case 0x1B:          /*bitmap rectangle*/
              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);
              (void) WPG2Flags;
              break;
            }
        }

      break;

    default:
      {
         ThrowReaderException(CoderError,'DataEncodingSchemeIsNotSupported');
      }
   }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }

 Finish:
  (void) CloseBlob(image);

  {
    Image
      *p;

    ssize_t
      scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }
    /*
      Fix scene numbers.
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=(size_t) scene++;
  }
  if (image == (Image *) NULL)
    ThrowReaderException(CorruptImageError,
      'ImageFileDoesNotContainAnyImageData');
  return(image);
}
",1,7858
ImageMagick/ImageMagick,d9b2209a69ee90d8df81fb124eb66f593eb9f599,"static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,
  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)
{
  char
    postscript_file[MaxTextExtent];

  const MagicInfo
    *magic_info;

  FILE
    *ps_file;

  ImageInfo
    *clone_info;

  Image
    *image2;

  unsigned char
    magick[2*MaxTextExtent];


  if ((clone_info=CloneImageInfo(image_info)) == NULL)
    return(image);
  clone_info->blob=(void *) NULL;
  clone_info->length=0;

  /* Obtain temporary file */
  (void) AcquireUniqueFilename(postscript_file);
  ps_file=fopen_utf8(postscript_file,'wb');
  if (ps_file == (FILE *) NULL)
    goto FINISH;

  /* Copy postscript to temporary file */
  (void) SeekBlob(image,PS_Offset,SEEK_SET);
  (void) ReadBlob(image, 2*MaxTextExtent, magick);

  (void) SeekBlob(image,PS_Offset,SEEK_SET);
  while(PS_Size-- > 0)
    {
      (void) fputc(ReadBlobByte(image),ps_file);
    }
  (void) fclose(ps_file);

    /* Detect file format - Check magic.mgk configuration file. */
  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);
  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;
  /*     printf('Detected:%s  \n',magic_info->name); */
  if(exception->severity != UndefinedException) goto FINISH_UNL;
  if(magic_info->name == (char *) NULL) goto FINISH_UNL;

  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);

    /* Read nested image */
  /*FormatString(clone_info->filename,'%s:%s',magic_info->name,postscript_file);*/
  FormatLocaleString(clone_info->filename,MaxTextExtent,'%s',postscript_file);
  image2=ReadImage(clone_info,exception);

  if (!image2)
    goto FINISH_UNL;

  /*
    Replace current image with new image while copying base image
    attributes.
  */
  (void) CopyMagickMemory(image2->filename,image->filename,MaxTextExtent);
  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MaxTextExtent);
  (void) CopyMagickMemory(image2->magick,image->magick,MaxTextExtent);
  image2->depth=image->depth;
  DestroyBlob(image2);
  image2->blob=ReferenceBlob(image->blob);

  if ((image->rows == 0) || (image->columns == 0))
    DeleteImageFromList(&image);

  AppendImageToList(&image,image2);

 FINISH_UNL:
  (void) RelinquishUniqueFileResource(postscript_file);
 FINISH:
  DestroyImageInfo(clone_info);
  return(image);
}
",0,7859
ImageMagick/ImageMagick,d9b2209a69ee90d8df81fb124eb66f593eb9f599,"static int UnpackWPGRaster(Image *image,int bpp)
{
  int
    x,
    y,
    i;

  unsigned char
    bbuf,
    *BImgBuff,
    RunCount;

  ssize_t
    ldblk;

  x=0;
  y=0;

  ldblk=(ssize_t) ((bpp*image->columns+7)/8);
  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,
    8*sizeof(*BImgBuff));
  if(BImgBuff==NULL) return(-2);

  while(y<(ssize_t) image->rows)
  {
    int
      c;

    c=ReadBlobByte(image);
    if (c ==  EOF)
      break;
    bbuf=(unsigned char) c;
      RunCount=bbuf & 0x7F;
      if(bbuf & 0x80)
        {
          if(RunCount)  /* repeat next byte runcount * */
            {
              bbuf=ReadBlobByte(image);
              for(i=0;i<(int) RunCount;i++) InsertByte(bbuf);
            }
          else {  /* read next byte as RunCount; repeat 0xFF runcount* */
            c=ReadBlobByte(image);
            if (c < 0)
              break;
            RunCount=(unsigned char) c;
            for(i=0;i<(int) RunCount;i++) InsertByte(0xFF);
          }
        }
      else {
        if(RunCount)   /* next runcount byte are readed directly */
          {
            for(i=0;i < (int) RunCount;i++)
              {
                bbuf=ReadBlobByte(image);
                InsertByte(bbuf);
              }
          }
        else {  /* repeat previous line runcount* */
          c=ReadBlobByte(image);
          if (c < 0)
            break;
          RunCount=(unsigned char) c;
          if(x) {    /* attempt to duplicate row from x position: */
            /* I do not know what to do here */
            BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
            return(-3);
          }
          for(i=0;i < (int) RunCount;i++)
            {
              x=0;
              y++;    /* Here I need to duplicate previous row RUNCOUNT* */
              if(y<2) continue;
              if(y>(ssize_t) image->rows)
                {
                  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                  return(-4);
                }
              InsertRow(BImgBuff,y-1,image,bpp);
            }
        }
      }
    }
  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
  return(y < (ssize_t) image->rows ? -5 : 0);
}
",0,7860
ImageMagick/ImageMagick,b3dd69b23e9338806891c708a0cc8a82c0d1872a,"static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,
  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)
{
  char
    postscript_file[MagickPathExtent];

  const MagicInfo
    *magic_info;    

  FILE
    *ps_file;

  ImageInfo
    *clone_info;
    
  Image
    *image2;
    
  unsigned char
    magick[2*MagickPathExtent];    
    

  if ((clone_info=CloneImageInfo(image_info)) == NULL)
    return(image);
  clone_info->blob=(void *) NULL;
  clone_info->length=0;

  /* Obtain temporary file */
  (void) AcquireUniqueFilename(postscript_file);
  ps_file=fopen_utf8(postscript_file,'wb');
  if (ps_file == (FILE *) NULL)
    goto FINISH;

  /* Copy postscript to temporary file */
  (void) SeekBlob(image,PS_Offset,SEEK_SET);
  (void) ReadBlob(image, 2*MagickPathExtent, magick);
  
  (void) SeekBlob(image,PS_Offset,SEEK_SET);
  while(PS_Size-- > 0)
    {
      (void) fputc(ReadBlobByte(image),ps_file);
    }
  (void) fclose(ps_file);
  
    /* Detect file format - Check magic.mgk configuration file. */
  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);
  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;
  /*     printf('Detected:%s  \n',magic_info->name); */
  if(exception->severity != UndefinedException) goto FINISH_UNL;     
  if(magic_info->name == (char *) NULL) goto FINISH_UNL;
    
  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MagickPathExtent);
  
    /* Read nested image */
  /*FormatString(clone_info->filename,'%s:%s',magic_info->name,postscript_file);*/
  FormatLocaleString(clone_info->filename,MagickPathExtent,'%s',postscript_file);
  image2=ReadImage(clone_info,exception);

  if (!image2)
    goto FINISH_UNL;

  /*
    Replace current image with new image while copying base image
    attributes.
  */
  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);
  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);
  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);
  image2->depth=image->depth;
  DestroyBlob(image2);
  image2->blob=ReferenceBlob(image->blob);

  if ((image->rows == 0) || (image->columns == 0))
    DeleteImageFromList(&image);

  AppendImageToList(&image,image2);

 FINISH_UNL:    
  (void) RelinquishUniqueFileResource(postscript_file);
 FINISH:
  DestroyImageInfo(clone_info);
  return(image);
}
",1,7861
ImageMagick/ImageMagick,b3dd69b23e9338806891c708a0cc8a82c0d1872a,"static int UnpackWPGRaster(Image *image,int bpp,ExceptionInfo *exception)
{
  int
    x,
    y,
    i;

  unsigned char
    bbuf,
    *BImgBuff,
    RunCount;

  ssize_t
    ldblk;

  x=0;
  y=0;

  ldblk=(ssize_t) ((bpp*image->columns+7)/8);
  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,
    8*sizeof(*BImgBuff));
  if(BImgBuff==NULL) return(-2);

  while(y<(ssize_t) image->rows)
    {
      int
        c;

      c=ReadBlobByte(image);
      if (c == EOF)
        break;
      bbuf=(unsigned char) c;
      RunCount=bbuf & 0x7F;
      if(bbuf & 0x80)
        {
          if(RunCount)  /* repeat next byte runcount * */
            {
              bbuf=ReadBlobByte(image);
              for(i=0;i<(int) RunCount;i++) InsertByte(bbuf);
            }
          else {  /* read next byte as RunCount; repeat 0xFF runcount* */
            c=ReadBlobByte(image);
            if (c < 0)
              break;
            RunCount=(unsigned char) c;
            for(i=0;i<(int) RunCount;i++) InsertByte(0xFF);
          }
        }
      else {
        if(RunCount)   /* next runcount byte are readed directly */
          {
            for(i=0;i < (int) RunCount;i++)
              {
                bbuf=ReadBlobByte(image);
                InsertByte(bbuf);
              }
          }
        else {  /* repeat previous line runcount* */
          c=ReadBlobByte(image);
          if (c < 0)
            break;
          RunCount=(unsigned char) c;
          if(x) {    /* attempt to duplicate row from x position: */
            /* I do not know what to do here */
            BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
            return(-3);
          }
          for(i=0;i < (int) RunCount;i++)
            {
              x=0;
              y++;    /* Here I need to duplicate previous row RUNCOUNT* */
              if(y<2) continue;
              if(y>(ssize_t) image->rows)
                {
                  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                  return(-4);
                }
              InsertRow(image,BImgBuff,y-1,bpp,exception);
            }
        }
      }
    }
  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
  return(y <(ssize_t) image->rows ? -5 : 0);
}
",0,7862
ImageMagick/ImageMagick,a2e1064f288a353bc5fef7f79ccb7683759e775c,"static MagickBooleanType load_tile(Image *image,Image *tile_image,
  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,
  ExceptionInfo *exception)
{
  ssize_t
    y;

  register ssize_t
    x;

  register Quantum
    *q;

  ssize_t
    count;

  unsigned char
    *graydata;

  XCFPixelInfo
    *xcfdata,
    *xcfodata;

  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));
  if (xcfdata == (XCFPixelInfo *) NULL)
    ThrowBinaryException(ResourceLimitError,'MemoryAllocationFailed',
      image->filename);
  xcfodata=xcfdata;
  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */
  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);
  if (count != (ssize_t) data_length)
    ThrowBinaryException(CorruptImageError,'NotEnoughPixelData',
      image->filename);
  for (y=0; y < (ssize_t) tile_image->rows; y++)
  {
    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    if (inDocInfo->image_type == GIMP_GRAY)
      {
        for (x=0; x < (ssize_t) tile_image->columns; x++)
        {
          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);
          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)
            inLayerInfo->alpha),q);
          graydata++;
          q+=GetPixelChannels(tile_image);
        }
      }
    else
      if (inDocInfo->image_type == GIMP_RGB)
        {
          for (x=0; x < (ssize_t) tile_image->columns; x++)
          {
            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);
            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);
            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);
            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :
              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);
            xcfdata++;
            q+=GetPixelChannels(tile_image);
          }
        }
     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)
       break;
  }
  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);
  return MagickTrue;
}
",1,7863
ImageMagick/ImageMagick,a2e1064f288a353bc5fef7f79ccb7683759e775c,"static MagickBooleanType IsXCF(const unsigned char *magick,const size_t length)
{
  if (length < 8)
    return(MagickFalse);
  if (LocaleNCompare((char *) magick,'gimp xcf',8) == 0)
    return(MagickTrue);
  return(MagickFalse);
}
",0,7864
mdadams/jasper,4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,"void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,
  int parity)
{

	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];
	jpc_fix_t *buf = splitbuf;
	register jpc_fix_t *srcptr;
	register jpc_fix_t *dstptr;
	register int n;
	register int m;
	int hstartcol;

	/* Get a buffer. */
	if (bufsize > QMFB_SPLITBUFSIZE) {
		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide in this case. */
			abort();
		}
	}

	if (numrows >= 2) {
		hstartcol = (numrows + 1 - parity) >> 1;
		// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);
		m = numrows - hstartcol;

		/* Save the samples destined for the highpass channel. */
		n = m;
		dstptr = buf;
		srcptr = &a[(1 - parity) * stride];
		while (n-- > 0) {
			*dstptr = *srcptr;
			++dstptr;
			srcptr += stride << 1;
		}
		/* Copy the appropriate samples into the lowpass channel. */
		dstptr = &a[(1 - parity) * stride];
		srcptr = &a[(2 - parity) * stride];
		n = numrows - m - (!parity);
		while (n-- > 0) {
			*dstptr = *srcptr;
			dstptr += stride;
			srcptr += stride << 1;
		}
		/* Copy the saved samples into the highpass channel. */
		dstptr = &a[hstartcol * stride];
		srcptr = buf;
		n = m;
		while (n-- > 0) {
			*dstptr = *srcptr;
			dstptr += stride;
			++srcptr;
		}
	}

	/* If the split buffer was allocated on the heap, free this memory. */
	if (buf != splitbuf) {
		jas_free(buf);
	}

}
",1,7865
mdadams/jasper,4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,"void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,
  int parity)
{

	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];
	jpc_fix_t *buf = splitbuf;
	jpc_fix_t *srcptr;
	jpc_fix_t *dstptr;
	register jpc_fix_t *srcptr2;
	register jpc_fix_t *dstptr2;
	register int n;
	register int i;
	int m;
	int hstartcol;

	/* Get a buffer. */
	if (bufsize > QMFB_SPLITBUFSIZE) {
		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide in this case. */
			abort();
		}
	}

	if (numrows >= 2) {
		hstartcol = (numrows + 1 - parity) >> 1;
		// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);
		m = numrows - hstartcol;

		/* Save the samples destined for the highpass channel. */
		n = m;
		dstptr = buf;
		srcptr = &a[(1 - parity) * stride];
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += JPC_QMFB_COLGRPSIZE;
			srcptr += stride << 1;
		}
		/* Copy the appropriate samples into the lowpass channel. */
		dstptr = &a[(1 - parity) * stride];
		srcptr = &a[(2 - parity) * stride];
		n = numrows - m - (!parity);
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += stride;
			srcptr += stride << 1;
		}
		/* Copy the saved samples into the highpass channel. */
		dstptr = &a[hstartcol * stride];
		srcptr = buf;
		n = m;
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += stride;
			srcptr += JPC_QMFB_COLGRPSIZE;
		}
	}

	/* If the split buffer was allocated on the heap, free this memory. */
	if (buf != splitbuf) {
		jas_free(buf);
	}

}
",1,7866
mdadams/jasper,4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,"void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,
  int parity)
{

	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
	jpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];
	jpc_fix_t *buf = joinbuf;
	jpc_fix_t *srcptr;
	jpc_fix_t *dstptr;
	register jpc_fix_t *srcptr2;
	register jpc_fix_t *dstptr2;
	register int n;
	register int i;
	int hstartcol;

	/* Allocate memory for the join buffer from the heap. */
	if (bufsize > QMFB_JOINBUFSIZE) {
		if (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide. */
			abort();
		}
	}

	hstartcol = (numrows + 1 - parity) >> 1;

	/* Save the samples from the lowpass channel. */
	n = hstartcol;
	srcptr = &a[0];
	dstptr = buf;
	while (n-- > 0) {
		dstptr2 = dstptr;
		srcptr2 = srcptr;
		for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
			*dstptr2 = *srcptr2;
			++dstptr2;
			++srcptr2;
		}
		srcptr += stride;
		dstptr += JPC_QMFB_COLGRPSIZE;
	}
	/* Copy the samples from the highpass channel into place. */
	srcptr = &a[hstartcol * stride];
	dstptr = &a[(1 - parity) * stride];
	n = numrows - hstartcol;
	while (n-- > 0) {
		dstptr2 = dstptr;
		srcptr2 = srcptr;
		for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
			*dstptr2 = *srcptr2;
			++dstptr2;
			++srcptr2;
		}
		dstptr += 2 * stride;
		srcptr += stride;
	}
	/* Copy the samples from the lowpass channel into place. */
	srcptr = buf;
	dstptr = &a[parity * stride];
	n = hstartcol;
	while (n-- > 0) {
		dstptr2 = dstptr;
		srcptr2 = srcptr;
		for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
			*dstptr2 = *srcptr2;
			++dstptr2;
			++srcptr2;
		}
		dstptr += 2 * stride;
		srcptr += JPC_QMFB_COLGRPSIZE;
	}

	/* If the join buffer was allocated on the heap, free this memory. */
	if (buf != joinbuf) {
		jas_free(buf);
	}

}
",1,7867
mdadams/jasper,4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,"void jpc_ft_fwdlift_colgrp(jpc_fix_t *a, int numrows, int stride, int parity)
{

	jpc_fix_t *lptr;
	jpc_fix_t *hptr;
	register jpc_fix_t *lptr2;
	register jpc_fix_t *hptr2;
	register int n;
	register int i;
	int llen;

	llen = (numrows + 1 - parity) >> 1;

	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				hptr2[0] -= lptr2[0];
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//hptr2[0] -= (lptr2[0] + lptr2[stride]) >> 1;
				hptr2[0] -= jpc_fix_asr(lptr2[0] + lptr2[stride], 1);
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				hptr2[0] -= lptr2[0];
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] += (hptr2[0] + 1) >> 1;
				lptr2[0] += jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] += (hptr2[0] + hptr2[stride] + 2) >> 2;
				lptr2[0] += jpc_fix_asr(hptr2[0] + hptr2[stride] + 2, 2);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] += (hptr2[0] + 1) >> 1;
				lptr2[0] += jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
		}

	} else {

		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] <<= 1;
				lptr2[0] = jpc_fix_asl(lptr2[0], 1);
				++lptr2;
			}
		}

	}

}
",0,7868
mdadams/jasper,4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,"void jpc_ft_invlift_row(jpc_fix_t *a, int numcols, int parity)
{

	register jpc_fix_t *lptr;
	register jpc_fix_t *hptr;
	register int n;
	int llen;

	llen = (numcols + 1 - parity) >> 1;

	if (numcols > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (!parity) {
			//lptr[0] -= (hptr[0] + 1) >> 1;
			lptr[0] -= jpc_fix_asr(hptr[0] + 1, 1);
			++lptr;
		}
		n = llen - (!parity) - (parity != (numcols & 1));
		while (n-- > 0) {
			//lptr[0] -= (hptr[0] + hptr[1] + 2) >> 2;
			lptr[0] -= jpc_fix_asr(hptr[0] + hptr[1] + 2, 2);
			++lptr;
			++hptr;
		}
		if (parity != (numcols & 1)) {
			//lptr[0] -= (hptr[0] + 1) >> 1;
			lptr[0] -= jpc_fix_asr(hptr[0] + 1, 1);
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (parity) {
			hptr[0] += lptr[0];
			++hptr;
		}
		n = numcols - llen - parity - (parity == (numcols & 1));
		while (n-- > 0) {
			//hptr[0] += (lptr[0] + lptr[1]) >> 1;
			hptr[0] += jpc_fix_asr(lptr[0] + lptr[1], 1);
			++hptr;
			++lptr;
		}
		if (parity == (numcols & 1)) {
			hptr[0] += lptr[0];
		}

	} else {

		if (parity) {
			lptr = &a[0];
			//lptr[0] >>= 1;
			lptr[0] = jpc_fix_asr(lptr[0], 1);
		}

	}

}
",0,7869
mdadams/jasper,4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,"int jpc_ns_synthesize(jpc_fix_t *a, int xstart, int ystart, int width,
  int height, int stride)
{

	int numrows = height;
	int numcols = width;
	int rowparity = ystart & 1;
	int colparity = xstart & 1;
	int maxcols;
	jpc_fix_t *startptr;
	int i;

	startptr = &a[0];
	for (i = 0; i < numrows; ++i) {
		jpc_ns_invlift_row(startptr, numcols, colparity);
		jpc_qmfb_join_row(startptr, numcols, colparity);
		startptr += stride;
	}

	maxcols = (numcols / JPC_QMFB_COLGRPSIZE) * JPC_QMFB_COLGRPSIZE;
	startptr = &a[0];
	for (i = 0; i < maxcols; i += JPC_QMFB_COLGRPSIZE) {
		jpc_ns_invlift_colgrp(startptr, numrows, stride, rowparity);
		jpc_qmfb_join_colgrp(startptr, numrows, stride, rowparity);
		startptr += JPC_QMFB_COLGRPSIZE;
	}
	if (maxcols < numcols) {
		jpc_ns_invlift_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
		jpc_qmfb_join_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
	}

	return 0;

}
",0,7870
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
{
	jas_image_t *image;
	bmp_hdr_t hdr;
	bmp_info_t *info;
	uint_fast16_t cmptno;
	jas_image_cmptparm_t cmptparms[3];
	jas_image_cmptparm_t *cmptparm;
	uint_fast16_t numcmpts;
	long n;

	if (optstr) {
		jas_eprintf('warning: ignoring BMP decoder options\n');
	}

	jas_eprintf(
	  'THE BMP FORMAT IS NOT FULLY SUPPORTED!\n'
	  'THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n'
	  'IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n'
	  'TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n'
	  );

	/* Read the bitmap header. */
	if (bmp_gethdr(in, &hdr)) {
		jas_eprintf('cannot get header\n');
		return 0;
	}

	/* Read the bitmap information. */
	if (!(info = bmp_getinfo(in))) {
		jas_eprintf('cannot get info\n');
		return 0;
	}

	/* Ensure that we support this type of BMP file. */
	if (!bmp_issupported(&hdr, info)) {
		jas_eprintf('error: unsupported BMP encoding\n');
		bmp_info_destroy(info);
		return 0;
	}

	/* Skip over any useless data between the end of the palette
	  and start of the bitmap data. */
	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
		jas_eprintf('error: possibly bad bitmap offset?\n');
		return 0;
	}
	if (n > 0) {
		jas_eprintf('skipping unknown data in BMP file\n');
		if (bmp_gobble(in, n)) {
			bmp_info_destroy(info);
			return 0;
		}
	}

	/* Get the number of components. */
	numcmpts = bmp_numcmpts(info);

	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
	  ++cmptparm) {
		cmptparm->tlx = 0;
		cmptparm->tly = 0;
		cmptparm->hstep = 1;
		cmptparm->vstep = 1;
		cmptparm->width = info->width;
		cmptparm->height = info->height;
		cmptparm->prec = 8;
		cmptparm->sgnd = false;
	}

	/* Create image object. */
	if (!(image = jas_image_create(numcmpts, cmptparms,
	  JAS_CLRSPC_UNKNOWN))) {
		bmp_info_destroy(info);
		return 0;
	}

	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
		jas_image_setcmpttype(image, 1,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
		jas_image_setcmpttype(image, 2,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
	} else {
		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
	}

	/* Read the bitmap data. */
	if (bmp_getdata(in, info, image)) {
		bmp_info_destroy(info);
		jas_image_destroy(image);
		return 0;
	}

	bmp_info_destroy(info);

	return image;
}
",1,7871
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)
{
	int n;
	uint_fast32_t v;
	int c;
	for (n = 4, v = 0;;) {
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;
		}
		v |= (c << 24);
		if (--n <= 0) {
			break;
		}
		v >>= 8;
	}
	if (val) {
		*val = v;
	}
	return 0;
}
",1,7872
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"	OPT_VERSION,
	OPT_VERBOSE,
	OPT_INFILE
",1,7873
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"	{OPT_VERBOSE, 'verbose', 0},
	{OPT_INFILE, 'f', JAS_OPT_HASARG},
	{-1, 0, 0}
",1,7874
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"	char *fmtname;

	if (jas_init()) {
",1,7875
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"			exit(EXIT_SUCCESS);
			break;
		case OPT_INFILE:
",1,7876
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"int main(int argc, char **argv)
{
	int fmtid;
	int id;
	char *infile;
	jas_stream_t *instream;
	jas_image_t *image;
	int width;
	int height;
	int depth;
	int numcmpts;
	int verbose;
	char *fmtname;

	if (jas_init()) {
		abort();
	}

	cmdname = argv[0];

	infile = 0;
	verbose = 0;

	/* Parse the command line options. */
	while ((id = jas_getopt(argc, argv, opts)) >= 0) {
		switch (id) {
		case OPT_VERBOSE:
			verbose = 1;
			break;
		case OPT_VERSION:
			printf('%s\n', JAS_VERSION);
			exit(EXIT_SUCCESS);
			break;
		case OPT_INFILE:
			infile = jas_optarg;
			break;
		case OPT_HELP:
		default:
			usage();
			break;
		}
	}

	/* Open the image file. */
	if (infile) {
		/* The image is to be read from a file. */
		if (!(instream = jas_stream_fopen(infile, 'rb'))) {
			fprintf(stderr, 'cannot open input image file %s\n', infile);
			exit(EXIT_FAILURE);
		}
	} else {
		/* The image is to be read from standard input. */
		if (!(instream = jas_stream_fdopen(0, 'rb'))) {
			fprintf(stderr, 'cannot open standard input\n');
			exit(EXIT_FAILURE);
		}
	}

	if ((fmtid = jas_image_getfmt(instream)) < 0) {
		fprintf(stderr, 'unknown image format\n');
	}

	/* Decode the image. */
	if (!(image = jas_image_decode(instream, fmtid, 0))) {
		fprintf(stderr, 'cannot load image\n');
		return EXIT_FAILURE;
	}

	/* Close the image file. */
	jas_stream_close(instream);

	numcmpts = jas_image_numcmpts(image);
	width = jas_image_cmptwidth(image, 0);
	height = jas_image_cmptheight(image, 0);
	depth = jas_image_cmptprec(image, 0);
	if (!(fmtname = jas_image_fmttostr(fmtid))) {
		abort();
	}
	printf('%s %d %d %d %d %ld\n', fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));

	jas_image_destroy(image);
	jas_image_clearfmts();

	return EXIT_SUCCESS;
}
",1,7877
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"int bmp_validate(jas_stream_t *in)
{
	int n;
	int i;
	uchar buf[2];

	assert(JAS_STREAM_MAXPUTBACK >= 2);

	/* Read the first two characters that constitute the signature. */
	if ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {
		return -1;
	}
	/* Put the characters read back onto the stream. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}
	/* Did we read enough characters? */
	if (n < 2) {
		return -1;
	}
	/* Is the signature correct for the BMP format? */
	if (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {
		return 0;
	}
	return -1;
}
",0,7878
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"static int bmp_gethdr(jas_stream_t *in, bmp_hdr_t *hdr)
{
	if (bmp_getint16(in, &hdr->magic) || hdr->magic != BMP_MAGIC ||
	  bmp_getint32(in, &hdr->siz) || bmp_getint16(in, &hdr->reserved1) ||
	  bmp_getint16(in, &hdr->reserved2) || bmp_getint32(in, &hdr->off)) {
		return -1;
	}
	return 0;
}
",0,7879
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)
{
	int i;
	int j;
	int y;
	jas_matrix_t *cmpts[3];
	int numpad;
	int red;
	int grn;
	int blu;
	int ret;
	int numcmpts;
	int cmptno;
	int ind;
	bmp_palent_t *palent;
	int mxind;
	int haspal;

	assert(info->depth == 8 || info->depth == 24);
	assert(info->enctype == BMP_ENC_RGB);

	numcmpts = bmp_numcmpts(info);
	haspal = bmp_haspal(info);

	ret = 0;
	for (i = 0; i < numcmpts; ++i) {
		cmpts[i] = 0;
	}

	/* Create temporary matrices to hold component data. */
	for (i = 0; i < numcmpts; ++i) {
		if (!(cmpts[i] = jas_matrix_create(1, info->width))) {
			ret = -1;
			goto bmp_getdata_done;
		}
	}

	/* Calculate number of padding bytes per row of image data. */
	numpad = (numcmpts * info->width) % 4;
	if (numpad) {
		numpad = 4 - numpad;
	}

	mxind = (1 << info->depth) - 1;
	for (i = 0; i < info->height; ++i) {
		for (j = 0; j < info->width; ++j) {
			if (haspal) {
				if ((ind = jas_stream_getc(in)) == EOF) {
					ret = -1;
					goto bmp_getdata_done;
				}
				if (ind > mxind) {
					ret = -1;
					goto bmp_getdata_done;
				}
				if (ind < info->numcolors) {
					palent = &info->palents[ind];
					red = palent->red;
					grn = palent->grn;
					blu = palent->blu;
				} else {
					red = ind;
					grn = ind;
					blu = ind;
				}
			} else {
				if ((blu = jas_stream_getc(in)) == EOF ||
				  (grn = jas_stream_getc(in)) == EOF ||
				  (red = jas_stream_getc(in)) == EOF) {
					ret = -1;
					goto bmp_getdata_done;
				}
			}
			if (numcmpts == 3) {
				jas_matrix_setv(cmpts[0], j, red);
				jas_matrix_setv(cmpts[1], j, grn);
				jas_matrix_setv(cmpts[2], j, blu);
			} else {
				jas_matrix_setv(cmpts[0], j, red);
			}
		}
		for (j = numpad; j > 0; --j) {
				if (jas_stream_getc(in) == EOF) {
					ret = -1;
					goto bmp_getdata_done;
				}
		}
		for (cmptno = 0; cmptno < numcmpts; ++cmptno) {
			y = info->topdown ? i : (info->height - 1 - i);
			if (jas_image_writecmpt(image, cmptno, 0, y, info->width,
			  1, cmpts[cmptno])) {
				ret = -1;
				goto bmp_getdata_done;
			}
		}
	}

bmp_getdata_done:
	/* Destroy the temporary matrices. */
	for (i = 0; i < numcmpts; ++i) {
		if (cmpts[i]) {
			jas_matrix_destroy(cmpts[i]);
		}
	}

	return ret;
}
",0,7882
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"static int bmp_gobble(jas_stream_t *in, long n)
{
	while (--n >= 0) {
		if (jas_stream_getc(in) == EOF) {
			return -1;
		}
	}
	return 0;
}
",0,7883
mdadams/jasper,8f62b4761711d036fd8964df256b938c809b7fca,"static int bmp_getint16(jas_stream_t *in, int_fast16_t *val)
{
	int lo;
	int hi;
	if ((lo = jas_stream_getc(in)) == EOF || (hi = jas_stream_getc(in)) == EOF) {
		return -1;
	}
	if (val) {
		*val = (hi << 8) | lo;
	}
	return 0;
}
",0,7884
tats/w3m,4e464819dd360ffd3d58fa2a89216fe413cfcc74,"void
addMultirowsForm(Buffer *buf, AnchorList *al)
{
    int i, j, k, col, ecol, pos;
    Anchor a_form, *a;
    Line *l, *ls;

    if (al == NULL || al->nanchor == 0)
	return;
    for (i = 0; i < al->nanchor; i++) {
	a_form = al->anchors[i];
	al->anchors[i].rows = 1;
	if (a_form.hseq < 0 || a_form.rows <= 1)
	    continue;
	for (l = buf->firstLine; l != NULL; l = l->next) {
	    if (l->linenumber == a_form.y)
		break;
	}
	if (!l)
	    continue;
	if (a_form.y == a_form.start.line)
	    ls = l;
	else {
	    for (ls = l; ls != NULL;
		 ls = (a_form.y < a_form.start.line) ? ls->next : ls->prev) {
		if (ls->linenumber == a_form.start.line)
		    break;
	    }
	    if (!ls)
		continue;
	}
	col = COLPOS(ls, a_form.start.pos);
	ecol = COLPOS(ls, a_form.end.pos);
	for (j = 0; l && j < a_form.rows; l = l->next, j++) {
	    pos = columnPos(l, col);
	    if (j == 0) {
		buf->hmarklist->marks[a_form.hseq].line = l->linenumber;
		buf->hmarklist->marks[a_form.hseq].pos = pos;
	    }
	    if (a_form.start.line == l->linenumber)
		continue;
	    buf->formitem = putAnchor(buf->formitem, a_form.url,
				      a_form.target, &a, NULL, NULL, '\0',
				      l->linenumber, pos);
	    a->hseq = a_form.hseq;
	    a->y = a_form.y;
	    a->end.pos = pos + ecol - col;
	    l->lineBuf[pos - 1] = '[';
	    l->lineBuf[a->end.pos] = ']';
	    for (k = pos; k < a->end.pos; k++)
		l->propBuf[k] |= PE_FORM;
	}
    }
}
",1,7885
tats/w3m,4e464819dd360ffd3d58fa2a89216fe413cfcc74,"Anchor *
registerHref(Buffer *buf, char *url, char *target, char *referer, char *title,
	     unsigned char key, int line, int pos)
{
    Anchor *a;
    buf->href = putAnchor(buf->href, url, target, &a, referer, title, key,
			  line, pos);
    return a;
}
",0,7886
tats/w3m,7947052d2655da83175641f698bb3ae5a384b129,"void
formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
    Buffer save;
    char *p;
    int spos, epos, rows, c_rows, pos, col = 0;
    Line *l;

    copyBuffer(&save, buf);
    gotoLine(buf, a->start.line);
    switch (form->type) {
    case FORM_TEXTAREA:
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
    case FORM_SELECT:
#endif				/* MENU_SELECT */
	spos = a->start.pos;
	epos = a->end.pos;
	break;
    default:
	spos = a->start.pos + 1;
	epos = a->end.pos - 1;
    }
    switch (form->type) {
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
	if (form->checked)
	    buf->currentLine->lineBuf[spos] = '*';
	else
	    buf->currentLine->lineBuf[spos] = ' ';
	break;
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_TEXTAREA:
#ifdef MENU_SELECT
    case FORM_SELECT:
	if (form->type == FORM_SELECT) {
	    p = form->label->ptr;
	    updateSelectOption(form, form->select_option);
	}
	else
#endif				/* MENU_SELECT */
	{
	    if (!form->value)
		break;
	    p = form->value->ptr;
	}
	l = buf->currentLine;
	if (!l)
	    break;
	if (form->type == FORM_TEXTAREA) {
	    int n = a->y - buf->currentLine->linenumber;
	    if (n > 0)
		for (; l && n; l = l->prev, n--) ;
	    else if (n < 0)
		for (; l && n; l = l->prev, n++) ;
	    if (!l)
		break;
	}
	rows = form->rows ? form->rows : 1;
	col = COLPOS(l, a->start.pos);
	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
	    if (rows > 1) {
		pos = columnPos(l, col);
		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
		if (a == NULL)
		    break;
		spos = a->start.pos;
		epos = a->end.pos;
	    }
	    if (a->start.line != a->end.line || spos > epos || epos >= l->len)
		break;
	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
				   rows > 1,
				   form->type == FORM_INPUT_PASSWORD);
	    if (pos != epos) {
		shiftAnchorPosition(buf->href, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->name, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->img, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->formitem, buf->hmarklist,
				    a->start.line, spos, pos - epos);
	    }
	}
	break;
    }
    copyBuffer(buf, &save);
    arrangeLine(buf);
}
",1,7887
tats/w3m,7947052d2655da83175641f698bb3ae5a384b129,"int
formtype(char *typestr)
{
    int i;
    for (i = 0; _formtypetbl[i]; i++) {
	if (!strcasecmp(typestr, _formtypetbl[i]))
	    return i;
    }
    return FORM_INPUT_TEXT;
}
",0,7888
tats/w3m,ec99f186380d26ebf791569fdbc56dae60632365,"void
renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;

    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	/* workaround to prevent infinite recursion */
    cotable_level++;

    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;

	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}
",1,7889
tats/w3m,ec99f186380d26ebf791569fdbc56dae60632365,"    case BORDER_THICK:
    case BORDER_NOWIN:
	return RULE_WIDTH;
",0,7890
tats/w3m,a088e0263c48ba406a7ae0932a1ae64a25be7acd,"void
shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,
		    int shift)
{
    Anchor *a;
    size_t b, e, s = 0;
    int cmp;

    if (al == NULL || al->nanchor == 0)
	return;

    s = al->nanchor / 2;
    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {
	a = &al->anchors[s];
	cmp = onAnchor(a, line, pos);
	if (cmp == 0)
	    break;
	else if (cmp > 0)
	    b = s + 1;
	else if (s == 0)
	    break;
	else
	    e = s - 1;
    }
    for (; s < al->nanchor; s++) {
	a = &al->anchors[s];
	if (a->start.line > line)
	    break;
	if (a->start.pos > pos) {
	    a->start.pos += shift;
	    if (hl->marks[a->hseq].line == line)
		hl->marks[a->hseq].pos = a->start.pos;
	}
	if (a->end.pos >= pos)
	    a->end.pos += shift;
    }
}
",1,7891
tats/w3m,a088e0263c48ba406a7ae0932a1ae64a25be7acd,"Buffer *
link_list_panel(Buffer *buf)
{
    LinkList *l;
    AnchorList *al;
    Anchor *a;
    FormItemList *fi;
    int i;
    char *t, *u, *p;
    ParsedURL pu;
    /* FIXME: gettextize? */
    Str tmp = Strnew_charp('<title>Link List</title>\
<h1 align=center>Link List</h1>\n');

    if (buf->bufferprop & BP_INTERNAL ||
	(buf->linklist == NULL && buf->href == NULL && buf->img == NULL)) {
	return NULL;
    }

    if (buf->linklist) {
	Strcat_charp(tmp, '<hr><h2>Links</h2>\n<ol>\n');
	for (l = buf->linklist; l; l = l->next) {
	    if (l->url) {
		parseURL2(l->url, &pu, baseURL(buf));
		p = parsedURL2Str(&pu)->ptr;
		u = html_quote(p);
		if (DecodeURL)
		    p = html_quote(url_decode2(p, buf));
		else
		    p = u;
	    }
	    else
		u = p = '';
	    if (l->type == LINK_TYPE_REL)
		t = ' [Rel]';
	    else if (l->type == LINK_TYPE_REV)
		t = ' [Rev]';
	    else
		t = '';
	    t = Sprintf('%s%s\n', l->title ? l->title : '', t)->ptr;
	    t = html_quote(t);
	    Strcat_m_charp(tmp, '<li><a href=\'', u, '\'>', t, '</a><br>', p,
			   '\n', NULL);
	}
	Strcat_charp(tmp, '</ol>\n');
    }

    if (buf->href) {
	Strcat_charp(tmp, '<hr><h2>Anchors</h2>\n<ol>\n');
	al = buf->href;
	for (i = 0; i < al->nanchor; i++) {
	    a = &al->anchors[i];
	    if (a->hseq < 0 || a->slave)
		continue;
	    parseURL2(a->url, &pu, baseURL(buf));
	    p = parsedURL2Str(&pu)->ptr;
	    u = html_quote(p);
	    if (DecodeURL)
		p = html_quote(url_decode2(p, buf));
	    else
		p = u;
	    t = getAnchorText(buf, al, a);
	    t = t ? html_quote(t) : '';
	    Strcat_m_charp(tmp, '<li><a href=\'', u, '\'>', t, '</a><br>', p,
			   '\n', NULL);
	}
	Strcat_charp(tmp, '</ol>\n');
    }

    if (buf->img) {
	Strcat_charp(tmp, '<hr><h2>Images</h2>\n<ol>\n');
	al = buf->img;
	for (i = 0; i < al->nanchor; i++) {
	    a = &al->anchors[i];
	    if (a->slave)
		continue;
	    parseURL2(a->url, &pu, baseURL(buf));
	    p = parsedURL2Str(&pu)->ptr;
	    u = html_quote(p);
	    if (DecodeURL)
		p = html_quote(url_decode2(p, buf));
	    else
		p = u;
	    if (a->title && *a->title)
		t = html_quote(a->title);
	    else
		t = html_quote(url_decode2(a->url, buf));
	    Strcat_m_charp(tmp, '<li><a href=\'', u, '\'>', t, '</a><br>', p,
			   '\n', NULL);
	    a = retrieveAnchor(buf->formitem, a->start.line, a->start.pos);
	    if (!a)
		continue;
	    fi = (FormItemList *)a->url;
	    fi = fi->parent->item;
	    if (fi->parent->method == FORM_METHOD_INTERNAL &&
		!Strcmp_charp(fi->parent->action, 'map') && fi->value) {
		MapList *ml = searchMapList(buf, fi->value->ptr);
		ListItem *mi;
		MapArea *m;
		if (!ml)
		    continue;
		Strcat_charp(tmp, '<br>\n<b>Image map</b>\n<ol>\n');
		for (mi = ml->area->first; mi != NULL; mi = mi->next) {
		    m = (MapArea *) mi->ptr;
		    if (!m)
			continue;
		    parseURL2(m->url, &pu, baseURL(buf));
		    p = parsedURL2Str(&pu)->ptr;
		    u = html_quote(p);
		    if (DecodeURL)
			p = html_quote(url_decode2(p, buf));
		    else
			p = u;
		    if (m->alt && *m->alt)
			t = html_quote(m->alt);
		    else
			t = html_quote(url_decode2(m->url, buf));
		    Strcat_m_charp(tmp, '<li><a href=\'', u, '\'>', t,
				   '</a><br>', p, '\n', NULL);
		}
		Strcat_charp(tmp, '</ol>\n');
	    }
	}
	Strcat_charp(tmp, '</ol>\n');
    }

    return loadHTMLString(tmp);
}
",0,7892
torvalds/linux,81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755,"static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)
{
	ioapic->rtc_status.pending_eoi = 0;
	bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);
}
",1,7893
torvalds/linux,81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755,"int kvm_ioapic_init(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic;
	int ret;

	ioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL);
	if (!ioapic)
		return -ENOMEM;
	spin_lock_init(&ioapic->lock);
	INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
	kvm->arch.vioapic = ioapic;
	kvm_ioapic_reset(ioapic);
	kvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);
	ioapic->kvm = kvm;
	mutex_lock(&kvm->slots_lock);
	ret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,
				      IOAPIC_MEM_LENGTH, &ioapic->dev);
	mutex_unlock(&kvm->slots_lock);
	if (ret < 0) {
		kvm->arch.vioapic = NULL;
		kfree(ioapic);
		return ret;
	}

	kvm_vcpu_request_scan_ioapic(kvm);
	return ret;
}
",0,7894
GNOME/libgsf,95a8351a75758cf10b3bf6abae0b6b461f90d9e5,"static GsfInfileTar *
tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)
{
	const char *s = name;

	while (1) {
		const char *s0 = s;
		char *dirname;

		/* Find a directory component, if any.  */
		while (1) {
			if (*s == 0) {
				if (last && s != s0)
					break;
				else
					return dir;
			}
			/* This is deliberately slash-only.  */
			if (*s == '/')
				break;
			s++;
		}

		dirname = g_strndup (s0, s - s0);
		while (*s == '/')
			s++;

		if (strcmp (dirname, '.') != 0) {
			GsfInput *subdir =
				gsf_infile_child_by_name (GSF_INFILE (dir),
							  dirname);
			if (subdir) {
				/* Undo the ref. */
				g_object_unref (subdir);
				dir = GSF_INFILE_TAR (subdir);
			} else
				dir = tar_create_dir (dir, dirname);
		}

		g_free (dirname);
	}
}
",1,7895
GNOME/libgsf,95a8351a75758cf10b3bf6abae0b6b461f90d9e5,"static void
tar_init_info (GsfInfileTar *tar)
{
	TarHeader end;
	const TarHeader *header;
	gsf_off_t pos0 = gsf_input_tell (tar->source);
	char *pending_longname = NULL;

	memset (&end, 0, sizeof (end));

	while (tar->err == NULL &&
	       (header = (const TarHeader *)gsf_input_read (tar->source,
							    HEADER_SIZE,
							    NULL))) {
		char *name;
		gsf_off_t length;
		gsf_off_t offset;
		gint64 mtime;

		if (memcmp (header->filler, end.filler, sizeof (end.filler))) {
			tar->err = g_error_new (gsf_input_error_id (), 0,
						_('Invalid tar header'));
			break;
		}

		if (memcmp (header, &end, HEADER_SIZE) == 0)
			break;

		if (pending_longname) {
			name = pending_longname;
			pending_longname = NULL;
		} else
			name = g_strndup (header->name, sizeof (header->name));
		length = unpack_octal (tar, header->size, sizeof (header->size));
		offset = gsf_input_tell (tar->source);

		mtime = unpack_octal (tar, header->mtime, sizeof (header->mtime));

		switch (header->typeflag) {
		case '0': case 0: {
			/* Regular file. */
			GsfInfileTar *dir;
			const char *n = name, *s;
			TarChild c;

			/* This is deliberately slash-only.  */
			while ((s = strchr (n, '/')))
				n = s + 1;
			c.name = g_strdup (n);
			c.modtime = mtime > 0
				? g_date_time_new_from_unix_utc (mtime)
				: NULL;
			c.offset = offset;
			c.length = length;
			c.dir = NULL;
			dir = tar_directory_for_file (tar, name, FALSE);
			g_array_append_val (dir->children, c);
			break;
		}
		case '5': {
			/* Directory */
			(void)tar_directory_for_file (tar, name, TRUE);
			break;
		}
		case 'L': {
			const char *n;

			if (pending_longname ||
			    strcmp (name, MAGIC_LONGNAME) != 0) {
				tar->err = g_error_new (gsf_input_error_id (), 0,
							_('Invalid longname header'));
				break;
			}

			n = gsf_input_read (tar->source, length, NULL);
			if (!n) {
				tar->err = g_error_new (gsf_input_error_id (), 0,
							_('Failed to read longname'));
				break;
			}

			pending_longname = g_strndup (n, length);
			break;
		}
		default:
			/* Other -- ignore */
			break;
		}

		g_free (name);

		/* Round up to block size */
		length = (length + (BLOCK_SIZE - 1)) / BLOCK_SIZE * BLOCK_SIZE;

		if (!tar->err &&
		    gsf_input_seek (tar->source, offset + length, G_SEEK_SET)) {
			tar->err = g_error_new (gsf_input_error_id (), 0,
						_('Seek failed'));
			break;
		}
	}

	if (pending_longname) {
		if (!tar->err)
			tar->err = g_error_new (gsf_input_error_id (), 0,
						_('Truncated archive'));
		g_free (pending_longname);
	}

	if (tar->err)
		gsf_input_seek (tar->source, pos0, G_SEEK_SET);
}
",0,7896
torproject/tor,79b59a2dfcb68897ee89d98587d09e55f07e68d7,"int
connection_exit_begin_conn(cell_t *cell, circuit_t *circ)
{
  edge_connection_t *n_stream;
  relay_header_t rh;
  char *address = NULL;
  uint16_t port = 0;
  or_circuit_t *or_circ = NULL;
  const or_options_t *options = get_options();
  begin_cell_t bcell;
  int rv;
  uint8_t end_reason=0;

  assert_circuit_ok(circ);
  if (!CIRCUIT_IS_ORIGIN(circ))
    or_circ = TO_OR_CIRCUIT(circ);

  relay_header_unpack(&rh, cell->payload);
  if (rh.length > RELAY_PAYLOAD_SIZE)
    return -END_CIRC_REASON_TORPROTOCOL;

  /* Note: we have to use relay_send_command_from_edge here, not
   * connection_edge_end or connection_edge_send_command, since those require
   * that we have a stream connected to a circuit, and we don't connect to a
   * circuit until we have a pending/successful resolve. */

  if (!server_mode(options) &&
      circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {
    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,
           'Relay begin cell at non-server. Closing.');
    relay_send_end_cell_from_edge(rh.stream_id, circ,
                                  END_STREAM_REASON_EXITPOLICY, NULL);
    return 0;
  }

  rv = begin_cell_parse(cell, &bcell, &end_reason);
  if (rv < -1) {
    return -END_CIRC_REASON_TORPROTOCOL;
  } else if (rv == -1) {
    tor_free(bcell.address);
    relay_send_end_cell_from_edge(rh.stream_id, circ, end_reason, NULL);
    return 0;
  }

  if (! bcell.is_begindir) {
    /* Steal reference */
    address = bcell.address;
    port = bcell.port;

    if (or_circ && or_circ->p_chan) {
      if (!options->AllowSingleHopExits &&
           (or_circ->is_first_hop ||
            (!connection_or_digest_is_known_relay(
                or_circ->p_chan->identity_digest) &&
          should_refuse_unknown_exits(options)))) {
        /* Don't let clients use us as a single-hop proxy, unless the user
         * has explicitly allowed that in the config. It attracts attackers
         * and users who'd be better off with, well, single-hop proxies.
         */
        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,
               'Attempt by %s to open a stream %s. Closing.',
               safe_str(channel_get_canonical_remote_descr(or_circ->p_chan)),
               or_circ->is_first_hop ? 'on first hop of circuit' :
                                       'from unknown relay');
        relay_send_end_cell_from_edge(rh.stream_id, circ,
                                      or_circ->is_first_hop ?
                                        END_STREAM_REASON_TORPROTOCOL :
                                        END_STREAM_REASON_MISC,
                                      NULL);
        tor_free(address);
        return 0;
      }
    }
  } else if (rh.command == RELAY_COMMAND_BEGIN_DIR) {
    if (!directory_permits_begindir_requests(options) ||
        circ->purpose != CIRCUIT_PURPOSE_OR) {
      relay_send_end_cell_from_edge(rh.stream_id, circ,
                                    END_STREAM_REASON_NOTDIRECTORY, NULL);
      return 0;
    }
    /* Make sure to get the 'real' address of the previous hop: the
     * caller might want to know whether the remote IP address has changed,
     * and we might already have corrected base_.addr[ess] for the relay's
     * canonical IP address. */
    if (or_circ && or_circ->p_chan)
      address = tor_strdup(channel_get_actual_remote_address(or_circ->p_chan));
    else
      address = tor_strdup('127.0.0.1');
    port = 1; /* XXXX This value is never actually used anywhere, and there
               * isn't 'really' a connection here.  But we
               * need to set it to something nonzero. */
  } else {
    log_warn(LD_BUG, 'Got an unexpected command %d', (int)rh.command);
    relay_send_end_cell_from_edge(rh.stream_id, circ,
                                  END_STREAM_REASON_INTERNAL, NULL);
    return 0;
  }

  if (! options->IPv6Exit) {
    /* I don't care if you prefer IPv6; I can't give you any. */
    bcell.flags &= ~BEGIN_FLAG_IPV6_PREFERRED;
    /* If you don't want IPv4, I can't help. */
    if (bcell.flags & BEGIN_FLAG_IPV4_NOT_OK) {
      tor_free(address);
      relay_send_end_cell_from_edge(rh.stream_id, circ,
                                    END_STREAM_REASON_EXITPOLICY, NULL);
      return 0;
    }
  }

  log_debug(LD_EXIT,'Creating new exit connection.');
  /* The 'AF_INET' here is temporary; we might need to change it later in
   * connection_exit_connect(). */
  n_stream = edge_connection_new(CONN_TYPE_EXIT, AF_INET);

  /* Remember the tunneled request ID in the new edge connection, so that
   * we can measure download times. */
  n_stream->dirreq_id = circ->dirreq_id;

  n_stream->base_.purpose = EXIT_PURPOSE_CONNECT;
  n_stream->begincell_flags = bcell.flags;
  n_stream->stream_id = rh.stream_id;
  n_stream->base_.port = port;
  /* leave n_stream->s at -1, because it's not yet valid */
  n_stream->package_window = STREAMWINDOW_START;
  n_stream->deliver_window = STREAMWINDOW_START;

  if (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED) {
    origin_circuit_t *origin_circ = TO_ORIGIN_CIRCUIT(circ);
    log_info(LD_REND,'begin is for rendezvous. configuring stream.');
    n_stream->base_.address = tor_strdup('(rendezvous)');
    n_stream->base_.state = EXIT_CONN_STATE_CONNECTING;
    n_stream->rend_data = rend_data_dup(origin_circ->rend_data);
    tor_assert(connection_edge_is_rendezvous_stream(n_stream));
    assert_circuit_ok(circ);

    const int r = rend_service_set_connection_addr_port(n_stream, origin_circ);
    if (r < 0) {
      log_info(LD_REND,'Didn't find rendezvous service (port %d)',
               n_stream->base_.port);
      /* Send back reason DONE because we want to make hidden service port
       * scanning harder thus instead of returning that the exit policy
       * didn't match, which makes it obvious that the port is closed,
       * return DONE and kill the circuit. That way, a user (malicious or
       * not) needs one circuit per bad port unless it matches the policy of
       * the hidden service. */
      relay_send_end_cell_from_edge(rh.stream_id, circ,
                                    END_STREAM_REASON_DONE,
                                    origin_circ->cpath->prev);
      connection_free(TO_CONN(n_stream));
      tor_free(address);

      /* Drop the circuit here since it might be someone deliberately
       * scanning the hidden service ports. Note that this mitigates port
       * scanning by adding more work on the attacker side to successfully
       * scan but does not fully solve it. */
      if (r < -1)
        return END_CIRC_AT_ORIGIN;
      else
        return 0;
    }
    assert_circuit_ok(circ);
    log_debug(LD_REND,'Finished assigning addr/port');
    n_stream->cpath_layer = origin_circ->cpath->prev; /* link it */

    /* add it into the linked list of p_streams on this circuit */
    n_stream->next_stream = origin_circ->p_streams;
    n_stream->on_circuit = circ;
    origin_circ->p_streams = n_stream;
    assert_circuit_ok(circ);

    origin_circ->rend_data->nr_streams++;

    connection_exit_connect(n_stream);

    /* For path bias: This circuit was used successfully */
    pathbias_mark_use_success(origin_circ);

    tor_free(address);
    return 0;
  }
  tor_strlower(address);
  n_stream->base_.address = address;
  n_stream->base_.state = EXIT_CONN_STATE_RESOLVEFAILED;
  /* default to failed, change in dns_resolve if it turns out not to fail */

  if (we_are_hibernating()) {
    relay_send_end_cell_from_edge(rh.stream_id, circ,
                                  END_STREAM_REASON_HIBERNATING, NULL);
    connection_free(TO_CONN(n_stream));
    return 0;
  }

  n_stream->on_circuit = circ;

  if (rh.command == RELAY_COMMAND_BEGIN_DIR) {
    tor_addr_t tmp_addr;
    tor_assert(or_circ);
    if (or_circ->p_chan &&
        channel_get_addr_if_possible(or_circ->p_chan, &tmp_addr)) {
      tor_addr_copy(&n_stream->base_.addr, &tmp_addr);
    }
    return connection_exit_connect_dir(n_stream);
  }

  log_debug(LD_EXIT,'about to start the dns_resolve().');

  /* send it off to the gethostbyname farm */
  switch (dns_resolve(n_stream)) {
    case 1: /* resolve worked; now n_stream is attached to circ. */
      assert_circuit_ok(circ);
      log_debug(LD_EXIT,'about to call connection_exit_connect().');
      connection_exit_connect(n_stream);
      return 0;
    case -1: /* resolve failed */
      relay_send_end_cell_from_edge(rh.stream_id, circ,
                                    END_STREAM_REASON_RESOLVEFAILED, NULL);
      /* n_stream got freed. don't touch it. */
      break;
    case 0: /* resolve added to pending list */
      assert_circuit_ok(circ);
      break;
  }
  return 0;
}
",1,7897
torproject/tor,79b59a2dfcb68897ee89d98587d09e55f07e68d7,"void
connection_ap_handshake_socks_reply(entry_connection_t *conn, char *reply,
                                    size_t replylen, int endreason)
{
  char buf[256];
  socks5_reply_status_t status =
    stream_end_reason_to_socks5_response(endreason);

  tor_assert(conn->socks_request); /* make sure it's an AP stream */

  if (!SOCKS_COMMAND_IS_RESOLVE(conn->socks_request->command)) {
    control_event_stream_status(conn, status==SOCKS5_SUCCEEDED ?
                                STREAM_EVENT_SUCCEEDED : STREAM_EVENT_FAILED,
                                endreason);
  }

  /* Flag this stream's circuit as having completed a stream successfully
   * (for path bias) */
  if (status == SOCKS5_SUCCEEDED ||
      endreason == END_STREAM_REASON_RESOLVEFAILED ||
      endreason == END_STREAM_REASON_CONNECTREFUSED ||
      endreason == END_STREAM_REASON_CONNRESET ||
      endreason == END_STREAM_REASON_NOROUTE ||
      endreason == END_STREAM_REASON_RESOURCELIMIT) {
    if (!conn->edge_.on_circuit ||
       !CIRCUIT_IS_ORIGIN(conn->edge_.on_circuit)) {
      if (endreason != END_STREAM_REASON_RESOLVEFAILED) {
        log_info(LD_BUG,
                 'No origin circuit for successful SOCKS stream 'U64_FORMAT
                 '. Reason: %d',
                 U64_PRINTF_ARG(ENTRY_TO_CONN(conn)->global_identifier),
                 endreason);
      }
      /*
       * Else DNS remaps and failed hidden service lookups can send us
       * here with END_STREAM_REASON_RESOLVEFAILED; ignore it
       *
       * Perhaps we could make the test more precise; we can tell hidden
       * services by conn->edge_.renddata != NULL; anything analogous for
       * the DNS remap case?
       */
    } else {
      // XXX: Hrmm. It looks like optimistic data can't go through this
      // codepath, but someone should probably test it and make sure.
      // We don't want to mark optimistically opened streams as successful.
      pathbias_mark_use_success(TO_ORIGIN_CIRCUIT(conn->edge_.on_circuit));
    }
  }

  if (conn->socks_request->has_finished) {
    log_warn(LD_BUG, '(Harmless.) duplicate calls to '
             'connection_ap_handshake_socks_reply.');
    return;
  }
  if (replylen) { /* we already have a reply in mind */
    connection_write_to_buf(reply, replylen, ENTRY_TO_CONN(conn));
    conn->socks_request->has_finished = 1;
    return;
  }
  if (conn->socks_request->socks_version == 4) {
    memset(buf,0,SOCKS4_NETWORK_LEN);
    buf[1] = (status==SOCKS5_SUCCEEDED ? SOCKS4_GRANTED : SOCKS4_REJECT);
    /* leave version, destport, destip zero */
    connection_write_to_buf(buf, SOCKS4_NETWORK_LEN, ENTRY_TO_CONN(conn));
  } else if (conn->socks_request->socks_version == 5) {
    size_t buf_len;
    memset(buf,0,sizeof(buf));
    if (tor_addr_family(&conn->edge_.base_.addr) == AF_INET) {
      buf[0] = 5; /* version 5 */
      buf[1] = (char)status;
      buf[2] = 0;
      buf[3] = 1; /* ipv4 addr */
      /* 4 bytes for the header, 2 bytes for the port, 4 for the address. */
      buf_len = 10;
    } else { /* AF_INET6. */
      buf[0] = 5; /* version 5 */
      buf[1] = (char)status;
      buf[2] = 0;
      buf[3] = 4; /* ipv6 addr */
      /* 4 bytes for the header, 2 bytes for the port, 16 for the address. */
      buf_len = 22;
    }
    connection_write_to_buf(buf,buf_len,ENTRY_TO_CONN(conn));
  }
  /* If socks_version isn't 4 or 5, don't send anything.
   * This can happen in the case of AP bridges. */
  conn->socks_request->has_finished = 1;
  return;
}
",0,7898
blueness/sthttpd,c0dc63a49d8605649f1d8e4a96c9b468b0bff660,"static void
de_dotdot( char* file )
    {
    char* cp;
    char* cp2;
    int l;

    /* Collapse any multiple / sequences. */
    while ( ( cp = strstr( file, '//') ) != (char*) 0 )
	{
	for ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )
	    continue;
	(void) strcpy( cp + 1, cp2 );
	}

    /* Remove leading ./ and any /./ sequences. */
    while ( strncmp( file, './', 2 ) == 0 )
	(void) memmove( file, file + 2, strlen( file ) - 1 );
    while ( ( cp = strstr( file, '/./') ) != (char*) 0 )
	(void) memmove( cp, cp + 2, strlen( file ) - 1 );

    /* Alternate between removing leading ../ and removing xxx/../ */
    for (;;)
	{
	while ( strncmp( file, '../', 3 ) == 0 )
	    (void) memmove( file, file + 3, strlen( file ) - 2 );
	cp = strstr( file, '/../' );
	if ( cp == (char*) 0 )
	    break;
	for ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )
	    continue;
	(void) strcpy( cp2 + 1, cp + 4 );
	}

    /* Also elide any xxx/.. at the end. */
    while ( ( l = strlen( file ) ) > 3 &&
	    strcmp( ( cp = file + l - 3 ), '/..' ) == 0 )
	{
	for ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )
	    continue;
	if ( cp2 < file )
	    break;
	*cp2 = '\0';
	}
    }
",1,7899
blueness/sthttpd,c0dc63a49d8605649f1d8e4a96c9b468b0bff660,"int
httpd_start_request( httpd_conn* hc, struct timeval* nowP )
    {
    int r;

    /* Really start the request. */
    r = really_start_request( hc, nowP );

    /* And return the status. */
    return r;
    }
",0,7900
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void _SCCenterAccent(SplineChar *sc,SplineChar *basersc, SplineFont *sf,
	int layer, int ch, BDFFont *bdf, int disp_only,
	SplineChar *rsc, real ia, int basech,
	int invert,	/* invert accent, false==0, true!=0 */
	uint32 pos	/* unicode char position info, see #define for utype2[] in utype.h */ ) {
    real transform[6];
    DBounds bb, rbb, bbb;
    real xoff, yoff;
    real spacing = (sf->ascent+sf->descent)*accent_offset/100;
    real ybase, italicoff;
    const unichar_t *temp;
    int baserch = basech;
    int eta;
    AnchorPoint *ap1, *ap2;

    if ( rsc==NULL || sc==NULL )
return;

    /* When we center an accent on Uhorn, we don't really want it centered */
    /*  on the combination, we want it centered on 'U'. So if basech is itself*/
    /*  a combo, find what it is based on */
    if ( (temp = SFGetAlternate(sf,basech,NULL,false))!=NULL && haschar(sf,*temp,NULL))
	baserch = *temp;
    /* Similarly in  or , we really want to base the accents on O or o */
    if ( baserch==0xf8 ) baserch = 'o';
    else if ( baserch==0xd8 ) baserch = 'O';

    SplineCharFindSlantedBounds(rsc,layer,&rbb,ia);
    if ( ch==0x328 || ch==0x327 ) {	/* cedilla and ogonek */
	SCFindTopBounds(rsc,layer,&rbb,ia);
	/* should do more than touch, should overlap a tiny bit... */
	rbb.maxy -= (rbb.maxy-rbb.miny)/30;
    } else if ( ch==0x345 ) {	/* ypogegrammeni */
	SCFindTopBounds(rsc,layer,&rbb,ia);
    } else if ( (GraveAcuteCenterBottom && (ch==0x300 || ch==0x301 || ch==0x30b || ch==0x30f)) || ch==0x309 )	/* grave, acute, hungarian, Floating hook */
	SCFindBottomBounds(rsc,layer,&rbb,ia);
    else if ( basech=='A' && ch==0x30a )
	/* Again, a tiny bit of overlap is usual for Aring */
	rbb.miny += (rbb.maxy-rbb.miny)/30;
    ybase = SplineCharFindSlantedBounds(sc,layer,&bb,ia);
    if ( basersc==NULL ) {
	if ( baserch!=basech && ( basersc = SFGetChar(sf,baserch,NULL))!=NULL )
	    /* Do Nothing */;
	else if ( basersc == NULL || (basech!=-1 && (basech==sc->unicodeenc || ( basersc = SFGetChar(sf,basech,NULL))==NULL )))
	    basersc = sc;
    }
    if ( ia==0 && baserch!=basech && basersc!=NULL ) {
	ybase = SplineCharFindSlantedBounds(basersc,layer,&bbb,ia);
	if ( ff_unicode_utype2[1+ch] & (FF_UNICODE_ABOVE|FF_UNICODE_BELOW) ) {
	    /* if unicode.org character definition matches ABOVE or BELOW, then... */
	    bbb.maxy = bb.maxy;
	    bbb.miny = bb.miny;
	}
	if ( ff_unicode_utype2[1+ch] & (FF_UNICODE_RIGHT|FF_UNICODE_LEFT) ) {
	    /* if unicode.org character definition matches RIGHT or LEFT, then... */
	    bbb.maxx = bb.maxx;
	    bbb.minx = bb.minx;
	}
	bb = bbb;
    }

    transform[0] = transform[3] = 1;
    transform[1] = transform[2] = transform[4] = transform[5] = 0;

    italicoff = 0;
    if ( sc->layers[layer].refs!=NULL && sc->layers[layer].refs->next!=NULL &&
	    (AnchorClassMkMkMatch(sc->layers[layer].refs->sc,rsc,&ap1,&ap2)!=NULL ||
	     AnchorClassCursMatch(sc->layers[layer].refs->sc,rsc,&ap1,&ap2)!=NULL) ) {
	/* Do we have a mark to mark attachment to the last anchor we added? */
	/*  (or a cursive exit to entry match?) */
	/*  If so then figure offsets relative to it. */
	xoff = ap1->me.x-ap2->me.x + sc->layers[layer].refs->transform[4];
	yoff = ap1->me.y-ap2->me.y + sc->layers[layer].refs->transform[5];
	pos = ff_unicode_utype2[1+ch];	/* init with unicode.org position information */
    } else if ( AnchorClassMatch(basersc,rsc,(AnchorClass *) -1,&ap1,&ap2)!=NULL && ap2->type==at_mark ) {
	xoff = ap1->me.x-ap2->me.x;
	yoff = ap1->me.y-ap2->me.y;
	pos = ff_unicode_utype2[1+ch];	/* init with unicode.org position information */
    } else {
 /* try to establish a common line on which all accents lie. The problem being*/
 /*  that an accent above a,e,o will usually be slightly higher than an accent */
 /*  above i or u, similarly for upper case. Letters with ascenders shouldn't */
 /*  have much of a problem because ascenders are (usually) all the same shape*/
 /* Obviously this test is only meaningful for latin,greek,cyrillic alphas */
 /*  hence test for isupper,islower. And I'm assuming greek,cyrillic will */
 /*  be consistant with latin */
	if ( islower(basech) || isupper(basech)) {
	    SplineChar *common = SFGetChar(sf,islower(basech)?'o':'O',NULL);
	    if ( common!=NULL ) {
		real top = SplineCharQuickTop(common,layer);
		if ( bb.maxy<top ) {
		    bb.maxx += tan(ia)*(top-bb.maxy);
		    bb.maxy = top;
		}
	    }
	}
	eta = false;
	if ( ((basech>=0x1f20 && basech<=0x1f27) || basech==0x1f74 || basech==0x1f75 || basech==0x1fc6 || basech==0x3b7 || basech==0x3ae) &&
		ch==0x345 ) {
	    bb.miny = 0;		/* ypogegrammeni rides below baseline, not below bottom stem */
	    eta = true;
	    if ( basersc!=NULL && basersc->vstem!=NULL ) {
		bb.minx = basersc->vstem->start;
		bb.maxx = bb.minx + basersc->vstem->width;
	    } else
		bb.maxx -= (bb.maxx-bb.minx)/3;	/* Should also be centered on left stem of eta, but I don't know how to do that..., hence this hack */
	}

	if ( invert ) {
	    /* yes, this transform does a vertical flip from the vertical midpoint of the breve */
	    transform[3] = -1;
	    transform[5] = rbb.maxy+rbb.miny;
	}
	if ( pos==FF_UNICODE_NOPOSDATAGIVEN ) {
	    /* if here, then we need to initialize some type of position info for the accent */
	    if ( ch<0 || ch>=0x10000 )	/* makeutype.c only built data in utype.c for {0...MAXC} */
		pos = FF_UNICODE_ABOVE;
	    else
		pos = ff_unicode_utype2[1+ch];	/* init with unicode.org position information */
	    /* In greek, PSILI and friends are centered above lower case, and kern left*/
	    /*  for upper case */
	    if (( basech>=0x390 && basech<=0x3ff) || (basech>=0x1f00 && basech<=0x1fff)) {
		if ( ( basech==0x1fbf || basech==0x1fef || basech==0x1ffe ) &&
			(ch==0x1fbf || ch==0x1fef || ch==0x1ffe || ch==0x1fbd || ch==0x1ffd )) {
		    pos = FF_UNICODE_ABOVE|FF_UNICODE_RIGHT;
		} else if ( isupper(basech) &&
			(ch==0x313 || ch==0x314 || ch==0x301 || ch==0x300 || ch==0x30d ||
			 ch==0x1ffe || ch==0x1fbf || ch==0x1fcf || ch==0x1fdf ||
			 ch==0x1fbd || ch==0x1fef || ch==0x1ffd ||
			 ch==0x1fcd || ch==0x1fdd || ch==0x1fce || ch==0x1fde ) )
		    pos = FF_UNICODE_ABOVE|FF_UNICODE_LEFT;
		else if ( isupper(basech) && ch==0x1fbe )
		    pos = FF_UNICODE_RIGHT;
		else if ( ch==0x1fcd || ch==0x1fdd || ch==0x1fce || ch==0x1fde ||
			 ch==0x1ffe || ch==0x1fbf || ch==0x1fcf || ch==0x1fdf ||
			 ch==0x384 )
		    pos = FF_UNICODE_ABOVE;
	    } else if ( (basech==0x1ffe || basech==0x1fbf) && (ch==0x301 || ch==0x300))
		pos = FF_UNICODE_RIGHT;
	    else if ( sc->unicodeenc==0x1fbe && ch==0x345 )
		pos = FF_UNICODE_RIGHT;
	    else if ( basech=='l' && ch==0xb7 )
		pos = FF_UNICODE_RIGHT|FF_UNICODE_OVERSTRIKE;
	    else if ( basech=='L' && ch==0xb7 )
		pos = FF_UNICODE_OVERSTRIKE;
	    else if ( ch==0xb7 )
		pos = FF_UNICODE_RIGHT;
	    else if ( basech=='A' && ch==0x30a )	/* Aring usually touches */
		pos = FF_UNICODE_ABOVE|FF_UNICODE_TOUCHING;
	    else if (( basech=='A' || basech=='a' || basech=='E' || basech=='u' ) &&
		    ch == 0x328 )
		pos = FF_UNICODE_BELOW|FF_UNICODE_CENTERRIGHT|FF_UNICODE_TOUCHING;	/* ogonek off to the right for these in polish (but not lc e) */
	    else if (( basech=='N' || basech=='n' || basech=='K' || basech=='k' || basech=='R' || basech=='r' || basech=='H' || basech=='h' ) &&
		    ch == 0x327 )
		pos = FF_UNICODE_BELOW|FF_UNICODE_CENTERLEFT|FF_UNICODE_TOUCHING;	/* cedilla off under left stem for these guys */
	    if ( basech==0x391 && pos==(FF_UNICODE_ABOVE|FF_UNICODE_LEFT) ) {
		bb.minx += (bb.maxx-bb.minx)/4;
	    }
	}
	if ( sc->unicodeenc==0x0149 )
	    pos = FF_UNICODE_ABOVE|FF_UNICODE_LEFT;
	else if ( sc->unicodeenc==0x013d || sc->unicodeenc==0x013e )
	    pos = FF_UNICODE_ABOVE|FF_UNICODE_RIGHT;
	else if ( sc->unicodeenc==0x010f || sc->unicodeenc==0x013d ||
		  sc->unicodeenc==0x013e || sc->unicodeenc==0x0165 )
	    pos = FF_UNICODE_ABOVE|FF_UNICODE_RIGHT;
	else if ( (sc->unicodeenc==0x1fbd || sc->unicodeenc==0x1fbf ||
		sc->unicodeenc==0x1ffe || sc->unicodeenc==0x1fc0 ) &&
		bb.maxy==0 && bb.miny==0 ) {
	    /* Building accents on top of space */
	    bb.maxy = 7*sf->ascent/10;
	}

	if ( (pos & FF_UNICODE_ABOVE) && (pos & (FF_UNICODE_LEFT|FF_UNICODE_RIGHT)) )
	    yoff = bb.maxy - rbb.maxy;
	else if ( pos & FF_UNICODE_ABOVE ) {
	    yoff = bb.maxy - rbb.miny;
	    if ( !( pos & FF_UNICODE_TOUCHING) )
		yoff += spacing;
	} else if ( pos & FF_UNICODE_BELOW ) {
	    yoff = bb.miny - rbb.maxy;
	    if ( !( pos & FF_UNICODE_TOUCHING) )
		yoff -= spacing;
	} else if ( pos & FF_UNICODE_OVERSTRIKE )
	    yoff = bb.miny - rbb.miny + ((bb.maxy-bb.miny)-(rbb.maxy-rbb.miny))/2;
	else /* If neither Above, Below, nor overstrike then should use the same baseline */
	    yoff = bb.miny - rbb.miny;

	if ( pos & (FF_UNICODE_ABOVE|FF_UNICODE_BELOW) ) {
	    /* When we center an accent above an asymetric character like 'C' we */
	    /*  should not pick the mid point of the char. Rather we should pick */
	    /*  the highest point (mostly anyway, there are exceptions) */
	    if ( pos & FF_UNICODE_ABOVE ) {
		static DBounds pointless;
		if ( CharCenterHighest ) {
		    if ( basech!='b' && basech!='d' && basech!='h' && basech!='n' && basech!='r' && basech!=0xf8 &&
			    basech!='B' && basech!='D' && basech!='L' && basech!=0xd8 )
			ybase = SCFindTopXRange(sc,layer,&bb);
		    if ( ((basech=='h' && ch==0x307) ||	/* dot over the stem in hdot */
			    basech=='i' || basech=='j' || basech==0x131 || basech==0xf6be || basech==0x237 ||
			    (basech=='k' && ch==0x301) ||
			    (baserch=='L' && (ch==0x301 || ch==0x304)) ||
			    basech=='l' || basech=='t' ) &&
			    (xoff=SCStemCheck(sf,layer,basech,&bb,&pointless,pos))!=0x70000000 )
			bb.minx = bb.maxx = xoff;		/* While on 't' we should center over the stem */
		}
	    } else if ( ( pos & FF_UNICODE_BELOW ) && !eta )
		if ( CharCenterHighest )
		    ybase = SCFindBottomXRange(sc,layer,&bb,ia);
	}

	if ( isupper(basech) && ch==0x342)	/* While this guy rides above PSILI on left */
	    xoff = bb.minx - rbb.minx;
	else if ( pos & FF_UNICODE_LEFT )
	    xoff = bb.minx - spacing - rbb.maxx;
	else if ( pos & FF_UNICODE_RIGHT ) {
	    xoff = bb.maxx - rbb.minx+spacing/2;
	    if ( !( pos & FF_UNICODE_TOUCHING) )
		xoff += spacing;
	} else {
	    if ( (pos & (FF_UNICODE_CENTERLEFT|FF_UNICODE_CENTERRIGHT)) &&
		    (xoff=SCStemCheck(sf,layer,basech,&bb,&rbb,pos))!=0x70000000 )
		/* Done */;
	    else if ( pos & FF_UNICODE_CENTERLEFT )
		xoff = bb.minx + (bb.maxx-bb.minx)/2 - rbb.maxx;
	    else if ( pos & FF_UNICODE_LEFTEDGE )
		xoff = bb.minx - rbb.minx;
	    else if ( pos & FF_UNICODE_CENTERRIGHT )
		xoff = bb.minx + (bb.maxx-bb.minx)/2 - rbb.minx;
	    else if ( pos & FF_UNICODE_RIGHTEDGE )
		xoff = bb.maxx - rbb.maxx;
	    else
		xoff = bb.minx - rbb.minx + ((bb.maxx-bb.minx)-(rbb.maxx-rbb.minx))/2;
	}
	if ( ia!=0 )
	    xoff += (italicoff = tan(-ia)*(rbb.miny+yoff-ybase));
    }	/* Anchor points */
    transform[4] = xoff;
    /*if ( invert ) transform[5] -= yoff; else */transform[5] += yoff;

    if ( bdf == NULL || !disp_only ) {
	_SCAddRef(sc,rsc,layer,transform);
	if ( pos != FF_UNICODE_NOPOSDATAGIVEN && (pos & FF_UNICODE_RIGHT) )
	    SCSynchronizeWidth(sc,sc->width + rbb.maxx-rbb.minx+spacing,sc->width,NULL);
	if ( pos != FF_UNICODE_NOPOSDATAGIVEN && (pos & (FF_UNICODE_LEFT|FF_UNICODE_RIGHT|FF_UNICODE_CENTERLEFT|FF_UNICODE_LEFTEDGE|FF_UNICODE_CENTERRIGHT|FF_UNICODE_RIGHTEDGE)) )
	    TurnOffUseMyMetrics(sc);
    }
    if ( !disp_only ) {
	for ( bdf=sf->cidmaster?sf->cidmaster->bitmaps:sf->bitmaps; bdf!=NULL; bdf=bdf->next ) {
	    if ( bdf->glyphs[rsc->orig_pos] != NULL )
		_BCCenterAccent( bdf,sc->orig_pos,rsc->orig_pos,ch,basech,italicoff,pos,sf->ascent+sf->descent );
	}
    } else if ( bdf != NULL && bdf->glyphs[rsc->orig_pos] != NULL )
	_BCCenterAccent( bdf,sc->orig_pos,rsc->orig_pos,ch,basech,italicoff,pos,sf->ascent+sf->descent );
}
",1,7901
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void InsChrMouseDown(GWindow gw, GEvent *event) {
    int x,y;
    int ch;
    char buffer[20]; unichar_t ubuffer[20];

    x= event->u.mouse.x/inschr.spacing;
    y= (event->u.mouse.y-inschr.ybase)/inschr.spacing;
    ch = 256*inschr.page + (y*16)+x;
    /* Is it on a border line? */
    if ( y<0 || x*inschr.spacing==event->u.mouse.x ||
	    y*inschr.spacing==event->u.mouse.y-inschr.ybase )
return;
    /* Is it a valid character in the current map? */
    if ( inschr.map>em_max ) {
	if ( ch>unicode_ranges[inschr.map-em_max-1].len )
return;
    } else if ( (ch<32 && inschr.map!=em_mac) || ch==127 ||
	    (inschr.map<em_first2byte && inschr.map!=em_mac &&
		inschr.map!=em_win && inschr.map!=em_symbol &&
		inschr.map!=em_user &&
		ch>=128 && ch<160) ||
	    (inschr.map>=em_first2byte && inschr.map<=em_gb2312 &&
		((ch&0xff)<0x21 || (ch&0xff)>0x7e)) )
return;
    inschr.mouse_down = true;
    inschr.mouse_in = true;
    inschr.x = x;
    inschr.y = y;

    InsChrXorChar(inschr.icw,x,y);

    if ( inschr.dsp_mode==d_unicode || inschr.map>em_max )
	sprintf( buffer, 'U+%04lx', InsChrToUni(ch) );
    else if ( inschr.dsp_mode==d_hex )
	sprintf( buffer, inschr.map<em_first2byte?'0x%02x':'0x%04x', ch );
    else if ( inschr.dsp_mode==d_dec )
	sprintf( buffer, '%d', ch );
    else if ( inschr.map==em_unicode )
	sprintf( buffer, '%d,%d', (ch>>8), (ch&0xff) );
    else
	sprintf( buffer, '%d,%d', (ch>>8)-0x21, (ch&0xff)-0x21 );
    uc_strcpy(ubuffer,buffer);
    GGadgetSetTitle(GWidgetGetControl(inschr.icw,INSCHR_Char),ubuffer);
    InsChrFigureShow();
}
",1,7902
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void InsChrMouseMove(GWindow gw, GEvent *event) {
    int x, y;

    x= event->u.mouse.x/inschr.spacing;
    y= (event->u.mouse.y-inschr.ybase)/inschr.spacing;
    if ( !inschr.mouse_down && event->u.mouse.y>inschr.ybase ) {
	int uch = InsChrMapChar(16*y + x);
	static unichar_t space[600];
	char cspace[40];
	char *uniname;
	char *uniannot;

	if ( (uniname=unicode_name(uch))!=NULL ) {
	    uc_strncpy(space, uniname, 550);
	    sprintf( cspace, ' U+%04X', uch );
	    uc_strcpy(space+u_strlen(space),cspace);
	    free(uniname);
	} else {
	    if ( uch<160 )
		sprintf(cspace, 'Control Char U+%04X ', uch);
	    else if ( uch>=0x3400 && uch<=0x4db5 )
		sprintf(cspace, 'CJK Ideograph Extension A U+%04X ', uch);
	    else if ( uch>=0x4E00 && uch<=0x9FA5 )
		sprintf(cspace, 'CJK Ideograph U+%04X ', uch);
	    else if ( uch>=0xAC00 && uch<=0xD7A3 )
		sprintf(cspace, 'Hangul Syllable U+%04X ', uch);
	    else if ( uch>=0xD800 && uch<=0xDB7F )
 		sprintf(cspace, 'Non Private Use High Surrogate U+%04X ', uch);
	    else if ( uch>=0xDB80 && uch<=0xDBFF )
		sprintf(cspace, 'Private Use High Surrogate U+%04X ', uch);
	    else if ( uch>=0xDC00 && uch<=0xDFFF )
		sprintf(cspace, 'Low Surrogate U+%04X ', uch);
	    else if ( uch>=0xE000 && uch<=0xF8FF )
		sprintf(cspace, 'Private Use U+%04X ', uch);
	    else
		sprintf(cspace, 'Unencoded Unicode U+%04X ', uch);
	    uc_strcpy(space,cspace);
	}
	if ( (uniannot=unicode_annot(uch))!=NULL ) {
	    int left = sizeof(space)/sizeof(space[0]) - u_strlen(space)-1;
	    if ( left>4 ) {
		uc_strcat(space,'\n');
		uc_annot_strncat(space, uniannot, left-2);
	    }
	    free(uniannot);
	}
	GGadgetPreparePopup(gw,space);
    } else if ( inschr.mouse_down ) {
	int in = true;
	if ( y<0 || x*inschr.spacing==event->u.mouse.x ||
		y*inschr.spacing==event->u.mouse.y-inschr.ybase ||
		x!=inschr.x || y!=inschr.y )
	    in = false;
	if ( in!=inschr.mouse_in ) {
	    InsChrXorChar(inschr.icw,inschr.x,inschr.y);
	    inschr.mouse_in = in;
	}
    }
}
",1,7903
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"#include <utype.h>
#include 'utype.c'

#define ACUTE		0x1
#define GRAVE		0x2
",1,7904
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"void dumpinfo() {
    FILE *out;
    int i;
    struct transform *t;
    char buffer[400], buffer2[400];

    out = fopen('gdrawbuildchars.c','w');
    fprintf(out,'#include \'gdrawP.h\'\n\n' );

    for ( i=0; names[i].name!=NULL; ++i )
	fprintf( out, '#define\t%s\t0x%07x\n', names[i].name, names[i].mask );
    fprintf(out,'\n#define\tANY\t0x%07x\n\n', ANY );

    for ( i=0; i<95; ++i ) if ( info[i]!=NULL ) {
	fprintf(out, 'static struct gchr_transform trans_%s[] = {\n', charnames[i] );
	for ( t=info[i]; t!=NULL; t=t->next )
	    fprintf(out, '    { %s, %s, 0x%07x }%s\n', Mask(buffer,t->oldstate),
		    Mask(buffer2,t->newstate), t->resch, t->next==NULL?'':',' );
	fprintf(out,'};\n\n');
    }
    fprintf(out,'struct gchr_lookup _gdraw_chrlookup[95] = {\n' );
    for ( i=0; i<95; ++i ) {
	if ( info[i]==NULL )
	    fprintf(out, '    { 0 },\t\t\t/* %c */\n', i+' ' );
	else
	    fprintf(out, '    { %d, trans_%s },\t/* %c */\n', queuelen(info[i]), charnames[i], i+' ' );
    }
    fprintf(out,'};\n\n' );

    fprintf(out, 'struct gchr_accents _gdraw_accents[] = {\n' );
    fprintf(out, '    { 0x0301, 0x%07x },\n', ACUTE );
    fprintf(out, '    { 0x0300, 0x%07x },\n', GRAVE );
    fprintf(out, '    { 0x0308, 0x%07x },\n', DIAERESIS );
    fprintf(out, '    { 0x0302, 0x%07x },\n', CIRCUMFLEX );
    fprintf(out, '    { 0x0303, 0x%07x },\n', TILDE );
    fprintf(out, '    { 0x030a, 0x%07x },\n', RING );
    fprintf(out, '    { 0x0338, 0x%07x },\n', SLASH );
    fprintf(out, '    { 0x0306, 0x%07x },\n', BREVE );
    fprintf(out, '    { 0x030c, 0x%07x },\n', CARON );
    fprintf(out, '    { 0x0307, 0x%07x },\n', DOTABOVE );
    fprintf(out, '    { 0x0323, 0x%07x },\n', DOTBELOW );
    fprintf(out, '    { 0x0327, 0x%07x },\n', CEDILLA );
    fprintf(out, '    { 0x0328, 0x%07x },\n', OGONEK );
    fprintf(out, '    { 0x0304, 0x%07x },\n', MACRON );
    fprintf(out, '    { 0x030d, 0x%07x },\n', DBLGRAVE|GREEK );
    fprintf(out, '    { 0x030b, 0x%07x },\n', DBLGRAVE );
    fprintf(out, '    { 0x030b, 0x%07x },\n', DBLACUTE );
    fprintf(out, '    { 0x030b, 0x%07x },\n', INVBREVE );
    fprintf(out, '    { 0x030b, 0x%07x },\n', DIAERESISBELOW );
    fprintf(out, '    { 0x030b, 0x%07x },\n', CIRCUMFLEXBELOW );
    fprintf(out, '    { 0x030b, 0x%07x },\n', TILDEBELOW );
    fprintf(out, '    { 0x030b, 0x%07x },\n', RINGBELOW );
    fprintf(out, '    { 0x030b, 0x%07x },\n', LINEBELOW );
    fprintf(out, '    { 0x030b, 0x%07x },\n', HOOKABOVE );
    fprintf(out, '    { 0x030b, 0x%07x },\n', HORN );
    fprintf(out, '    { 0 },\n' );
    fprintf(out, '};\n\n' );
    fprintf(out, 'uint32 _gdraw_chrs_any=ANY, _gdraw_chrs_ctlmask=GREEK, _gdraw_chrs_metamask=0;\n' );
    fclose(out);
}
",1,7905
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"main() {
    FILE *in;
    int i;

    AddPredefineds();
    in = fopen('UnicodeData.txt','r');
    if ( in==NULL ) {
	fprintf(stderr,'Can't open UnicodeData.txt\n' );
	exit(1);
    }
    ParseUnicodeFile(in);
    for ( i=0; i<95; ++i )
	info[i] = RevQueue(info[i]);
    dumpinfo();
    exit(0);
}
",1,7906
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"#include <string.h>
#include <utype.h>
#define ASFIRST (-1)


struct unicoderange unicoderange[] = {
    /* { N_('Unicode'), 0, 0x10ffff, ' ' }, */
    { N_('Unicode Basic Multilingual Plane'), 0, 0xffff, ' ', false, 0, 0 },
    { N_('Basic Multilingual Plane'), 0, 0xffff, ' ', 2, 0, 0 },
",1,7907
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"    { N_('Latin-1 Supplement'), 0xa0, 0xff, 0xc0, true, 0, 0 },
    { N_('Latin Extended-A'), 0x100, 0x17f, ASFIRST, true, 0, 0 },
    { N_('Latin Extended-B'), 0x180, 0x24f, ASFIRST, true, 0, 0 },
    { N_('IPA Extensions'), 0x250, 0x2af, ASFIRST, true, 0, 0 },
    { N_('Spacing Modifier Letters'), 0x2b0, 0x2ff, ASFIRST, true, 0, 0 },
    { N_('Combining Diacritical Marks'), 0x300, 0x36f, ASFIRST, true, 0, 0 },
    { N_('Greek'), 0x370, 0x3ff, 0x391, true, 0, 0 },
    { N_('Greek and Coptic'), 0x370, 0x3ff, 0x391, true, 0, 0 },
    { N_('Cyrillic'), 0x400, 0x4ff, 0x410, true, 0, 0 },
",1,7908
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"    { N_('NUL, Default Character'), 0, 0, 0, false, 0, 0 },
    { N_('Basic Latin'), ' ', 0x7e, 'A', true, 0, 0 },
    { N_('Delete Character'), 0x7f, 0x7f, ASFIRST, true, 0, 0 },
    { N_('C1 Control Character'), 0x80, 0x9f, ASFIRST, true, 0, 0 },
    { N_('Latin-1 Supplement'), 0xa0, 0xff, 0xc0, true, 0, 0 },
",1,7909
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"    { N_('High Surrogate'), 0xd800, 0xdbff, ASFIRST, false, 0, 0 },  /* No characters defined */
    { N_('Surrogate High'), 0xd800, 0xdbff, ASFIRST, false, 0, 0 },
    { N_('Surrogate High, Non Private Use'), 0xd800, 0xdb7f, ASFIRST, false, 0, 0 },
",1,7910
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb," *
 * When done building the updated files, you can clean-up by removing
 * LineBreak.txt, NamesList.txt, PropList.txt,UnicodeData.txt, and the
 * binary executable file makeutype as they are no longer needed now.
 */
#include <fontforge-config.h>

#define UnicodeMajor	9
#define UnicodeMinor	0
",1,7911
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"#define UnicodeMajor	9
#define UnicodeMinor	0
",1,7912
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static int overrides_find_count(long uCode, int lvf) {
/* UnicodeData.txt is hard to easily extract some values therefore use this */
/* override table function for subsitution/insertion of info. This function */
/* returns table location for uCode, else it returns -1 if uCode not found. */
    int i;
    long v;
    const long *pt;

    if ( lvf==0 ) pt = lig_alt_overrides;
    else if ( lvf==1 ) pt = vul_alt_overrides;
    else if ( lvf==2 ) pt = frac_alt_overrides;

    for ( i=0,v=-1;; ) {
	if ( (v=pt[i])==uCode )
	    break;
	else if ( v>uCode || v==-1 ) {
	    i = -1;
	    break;
	} else {
	    v = pt[++i];
	    i += (++v);
	}
    }
    if ( verbLVOa || i>=0 ) fprintf( stderr, '<%d override> ', i );
    return( i );
}
",1,7913
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static int FigureAlternates_lfv(int index, char *apt, int lvf, long val) {
/* Figure-out Alternates from Unicode table for expanding {lig/vulg/other}. */
/* index=next available {altsl/altsv/altsf} array location to store values, */
/* apt=unicode.txt_line for getting {ligature/vulgar/fraction} information, */
/* lvf=work on {0=ligature,1=vulgar,2=fraction}, val=current unicode value. */
    int i=-1, po, t;
    long alt, pc;
    char c, *start, *end;

    /* begin with zero info. start points to beginning of str data to read. */
    if ( lvf==0 ) { /* ligature */
	altsl[index][0] = altsl[index][1] =altsl[index][2] = 0;
	if ( (po=overrides_find_count(val,lvf))>=0 ) {
	    t = 3;
	} else if ( (start=strstr(apt,'<compat>'))!=NULL   || \
		    (start=strstr(apt,'<isolated>'))!=NULL || \
		    (start=strstr(apt,'<initial>'))!=NULL  || \
		    (start=strstr(apt,'<medial>'))!=NULL   || \
		    (start=strstr(apt,'<final>'))!=NULL ) {
	    t = 0; /* NOTE: compression function could use info/flags above */
	} else if ( (start=strstr(apt,'CAPITAL LETTER '))!=NULL ) {
	    t = 1;
	    start += strlen('CAPITAL LETTER');
	} else if ( (start=strstr(apt,'SMALL LETTER '))!=NULL ) {
	    t = 2;
	    start += strlen('SMALL LETTER');
	}
    } else if ( lvf==1 ) { /* vulgar */
	altsv[index][0] = altsv[index][1] =altsv[index][2] = 0;
	if ( (c=overrides_find_count(val,lvf))>=0 ) {
	    t = 3;
	} else if ( (start=strstr(apt,'<fraction>'))!=NULL ) {
	    t = 0;
	}
    } else if ( lvf==2 ) {
	altsf[index][0] = altsf[index][1] =altsf[index][2] = 0;
	if ( (c=overrides_find_count(val,lvf))>=0 ) {
	    t = 3;
	} else if ( (start=strstr(apt,'<fraction>'))!=NULL ) {
	    t = 0;
	}
    }

    /* Error if no start, or cannot find trailing ' ' */
    if ( t!=3 ) {
	if ( start ) while ( *start && *start!=' ' ) ++start;
	if ( start==NULL || *start==0 ) {
	    fprintf( stderr, 'Error. unable to find alternate data for U+%08X\n', val );
	    return( -1 );
	}
    }

    if ( verbLVOa )
	fprintf( stderr,'lvf=%d index=%d t=%d val=U+%X alt{',lvf,index,t,val );
    if ( t==3 ) { /* Skip search and include table overrides */
	for ( i=0,pc=overrides_find_value((++po),lvf); pc; ++i,--pc ) {
	    alt = overrides_find_value((++po),lvf);
	    if ( i<MAXA ) {
		if ( lvf==0 ) {
		    ++altsl[index][2];
		    altsl[index][i+3] = alt;
		} else if ( lvf==1 ) {
		    ++altsv[index][2];
		    altsv[index][i+3] = alt;
		} else if ( lvf==2 ) {
		    ++altsf[index][2];
		    altsf[index][i+3] = alt;
		}
	    }
	    if ( verbLVOa ) fprintf(stderr,' T=%xh',alt);
	}
    } else if ( t ) { /* Values are single char. Stop at ';' */
	for ( i=0; ; ++i ) {
	    while ( *start && *start==' ' ) ++start;
	    if ( (c=*start)==';' )
		break;
	    if ( c==0 || *(++start)==0 )
		return( -1 );
	    alt = (long)(c&0xff);
	    if ( t==2 ) alt = alt + ('a' - 'A');
	    if ( i<MAXA ) {
		if ( lvf==0 ) {
		    ++altsl[index][2];
		    altsl[index][i+3] = alt;
		} else if ( lvf==1 ) {
		    ++altsv[index][2];
		    altsv[index][i+3] = alt;
		} else if ( lvf==2 ) {
		    ++altsf[index][2];
		    altsf[index][i+3] = alt;
		}
	    }
	    if ( verbLVOa ) fprintf(stderr,' C='%c'',alt);
	}
    } else { /* t=0. Values listed are hex digits. */
	for ( i=0; ; ++i ) {
	    alt = strtol(start,&end,16);
	    if ( end==start ) break;
	    start = end;
	    if ( i<MAXA ) {
		if ( lvf==0 ) {
		    ++altsl[index][2];
		    altsl[index][i+3] = alt;
		} else if ( lvf==1 ) {
		    ++altsv[index][2];
		    altsv[index][i+3] = alt;
		} else if ( lvf==2 ) {
		    ++altsf[index][2];
		    altsf[index][i+3] = alt;
		}
	    }
	    if ( verbLVOa ) fprintf(stderr,' %xh',alt);
	}
    }
    if ( verbLVOa ) fprintf( stderr,' }\n');

    if ( i>MAXA )
	/* need to expand MAXA for more characters or try do something else */
	fprintf( stderr, 'Error. %d is too many values for lvf=%d index=%d t=% val=%X\n', i, lvf, index, t, val );
    else if ( i>0 || (i==0 && t==3) )
	return( 0 );
    return( -1 );
}
",1,7914
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void readin(void) {
    char buffer[512+1], buf2[300+1], oldname[301], *pt, *end, *pt1;
    long index, lc, uc, tc, flg, val, indexend, wasfirst;
    int  cc;
    FILE *fp;
    long i,j;

    buffer[512]='\0'; buf2[0] = buf2[300]='\0'; oldname[0]='\0';
    if ((fp = fopen('UnicodeData.txt','r'))==NULL ) {
	fprintf( stderr, CantReadFile,'UnicodeData.txt' );
	exit(1);
    }
    while ( fgets(buffer,sizeof(buffer)-1,fp)!=NULL ) {
	if (strlen(buffer)>=299) {	/* previous version was linelength of 300 chars, jul2012 */
	    fprintf( stderr, LineLengthBg,'UnicodeData.txt',buffer );
	    fprintf( stderr, '\n%s\n',buffer );

	    fclose(fp);
	    FreeNamesMemorySpace();
	    exit(4);
	}
	if ( *buffer=='#' )
    continue;
	flg = 0;
	/* Unicode character value */
	index = strtol(buffer,&end,16);
	if ( processAssignment(index,end,&flg) ) {
	    fclose(fp);
	    FreeNamesMemorySpace();
	    exit(5);
	}
	if ( index>=MAXC )		/* For now can only deal with BMP !!!! */
    continue;
	pt = end;
	if ( *pt==';' ) {
	    ++pt;
	    /* buf2 = character name */
	    for ( pt1=pt; *pt1!=';' && *pt1!='\0'; ++pt1 );
	    strncpy(buf2,pt,pt1-pt); buf2[pt1-pt] = '\0'; pt = pt1;
	    if ( *pt==';' ) ++pt;
	    /* general category */
	    for ( pt1=pt; *pt1!=';' && *pt1!='\0'; ++pt1 );
	    if ( strncmp(pt,'Lu',pt1-pt)==0 )
		flg |= FF_UNICODE_UPPER|FF_UNICODE_ALPHABETIC;
	    else if ( strncmp(pt,'Ll',pt1-pt)==0 )
		flg |= FF_UNICODE_LOWER|FF_UNICODE_ALPHABETIC;
	    else if ( strncmp(pt,'Lt',pt1-pt)==0 )
		flg |= FF_UNICODE_TITLE|FF_UNICODE_ALPHABETIC;
	    else if ( strncmp(pt,'Lo',pt1-pt)==0 )
		flg |= FF_UNICODE_ALPHABETIC;
	    else if ( strncmp(pt,'Nd',pt1-pt)==0 )
		flg |= FF_UNICODE_DIGIT;
	    pt = pt1;
	    if ( *pt==';' ) ++pt;
	    /* Unicode combining classes, I do my own version later */
	    cc = strtol(pt,&end,16);
	    pt = end;
	    if ( *pt==';' ) ++pt;
	    /* Bidirectional Category */
	    for ( pt1=pt; *pt1!=';' && *pt1!='\0'; ++pt1 );
	    if ( strncmp(pt,'L',pt1-pt)==0 || strncmp(pt,'LRE',pt1-pt)==0 || strncmp(pt,'LRO',pt1-pt)==0 )
		flg |= FF_UNICODE_LEFT_2_RIGHT;
	    if ( strncmp(pt,'R',pt1-pt)==0 || strncmp(pt,'AL',pt1-pt)==0 || strncmp(pt,'RLE',pt1-pt)==0 || strncmp(pt,'RLO',pt1-pt)==0 )
		flg |= FF_UNICODE_RIGHT_2_LEFT;
	    else if ( strncmp(pt,'EN',pt1-pt)==0 )
		flg |= FF_UNICODE_ENUMERIC;
	    else if ( strncmp(pt,'ES',pt1-pt)==0 )
		flg |= FF_UNICODE_ENS;
	    else if ( strncmp(pt,'ET',pt1-pt)==0 )
		flg |= FF_UNICODE_ENT;
	    else if ( strncmp(pt,'AN',pt1-pt)==0 )
		flg |= FF_UNICODE_ANUMERIC;
	    else if ( strncmp(pt,'CS',pt1-pt)==0 )
		flg |= FF_UNICODE_CS;
	    pt = pt1;
	    if ( *pt==';' ) ++pt;
	    /* character decomposition */
	    if ( strncmp(pt,'<initial>',strlen('<initial>'))==0 )
		flg |= FF_UNICODE_INITIAL;
	    else if ( strncmp(pt,'<final>',strlen('<final>'))==0 )
		flg |= FF_UNICODE_FINAL;
	    else if ( strncmp(pt,'<medial>',strlen('<medial>'))==0 )
		flg |= FF_UNICODE_MEDIAL;
	    else if ( strncmp(pt,'<isolated>',strlen('<isolated>'))==0 )
		flg |= FF_UNICODE_ISOLATED;
	    FigureAlternates(index,pt, true);
	    while ( *pt!=';' && *pt!='\0' ) ++pt;
	    if ( *pt==';' ) ++pt;
	    /* Don't care about decimal digit value */
	    while ( *pt!=';' && *pt!='\0' ) ++pt;
	    if ( *pt==';' ) ++pt;
	    /* Don't care about digit value */
	    while ( *pt!=';' && *pt!='\0' ) ++pt;
	    if ( *pt==';' ) ++pt;
	    /* numeric value */
	    val = strtol(pt,&end,10);
	    if ( pt==end ) val = -1;
	    pt = end;
	    if ( *pt==';' ) ++pt;
	    /* Don't care about mirrored value */
	    while ( *pt!=';' && *pt!='\0' ) ++pt;
	    if ( *pt==';' ) ++pt;
	    /* Only care about old name (unicode 1.0) for control characters */
	    for ( pt1=pt; *pt1!=';' && *pt1!='\0'; ++pt1 );
	    strncpy(oldname,pt,pt1-pt); oldname[pt1-pt] = '\0';
	    if ( pt1-pt>100 ) oldname[100] = '\0'; pt = pt1;
	    if ( *pt==';' ) ++pt;
	    /* Don't care about 10646 comment field */
	    while ( *pt!=';' && *pt!='\0' ) ++pt;
	    if ( *pt==';' ) ++pt;
	    /* upper-case value */
	    uc = strtol(pt,&end,16);
	    if ( end==pt )
		uc = index;
	    pt = end;
	    if ( *pt==';' ) ++pt;
	    /* lower-case value */
	    lc = strtol(pt,&end,16);
	    if ( end==pt )
		lc = index;
	    pt = end;
	    if ( *pt==';' ) ++pt;
	    /* title-case value */
	    tc = strtol(pt,&end,16);
	    if ( end==pt )
		tc = index;
	    pt = end;
	    if ( *pt==';' ) ++pt;
	    if ( index>=MAXC )
    break;
	    mytolower[index]= lc;
	    mytoupper[index]= uc;
	    mytotitle[index]= tc;
	    mynumericvalue[index]= val;
	    flags[index] |= flg;
	    flags2[index] = cc&0xff;
	    if ( strstr(buf2,' First>')!=NULL )
		wasfirst = index;
	    else if ( strstr(buf2,' Last>')!=NULL ) {
		for ( ; wasfirst<index; ++wasfirst ) {
		    mytolower[wasfirst]= wasfirst;
		    mytoupper[wasfirst]= wasfirst;
		    mytotitle[wasfirst]= wasfirst;
		    mynumericvalue[wasfirst]= -1;
		    flags[wasfirst]  = flg;
		    flags2[wasfirst] = cc&0xff;
		}
	    } else {
		if ( strcmp(buf2,'<control>')==0 ) {
		    strcat(buf2, ' ');
		    strcat(buf2, oldname);
		}
		names[index]= strdup(buf2);
	    }
	}
    }
    fclose(fp);

    if ((fp = fopen('LineBreak.txt','r'))==NULL ) {
	fprintf( stderr, CantReadFile, 'LineBreak.txt' );
	FreeNamesMemorySpace();
	exit(1);
    }
    while ( fgets(buffer,sizeof(buffer)-1,fp)!=NULL ) {
	if (strlen(buffer)>=299) {	/* previous version was linelength of 300 chars, jul2012 */
	    fprintf( stderr, LineLengthBg,'LineBreak.txt',buffer );
	    fclose(fp);
	    FreeNamesMemorySpace();
	    exit(4);
	}
	if ( *buffer=='#' )
    continue;
	flg = 0;
	/* Unicode character value */
	indexend = index = strtol(buffer,&end,16);
	if ( index>0xffff )		/* Only BMP now !!!!!! */
    continue;
	pt = end;
	if ( *pt=='.' && pt[1]=='.' ) {
	    indexend = strtol(pt+2,&end,16);
	    if ( indexend>0xffff ) indexend = 0xffff;	/* Only BMP now !!!!! */
	    pt = end;
	}
	if ( *pt==';' ) {
	    ++pt;
	    for ( pt1=pt; *pt1!=';' && *pt1!=' ' && *pt1!='\0'; ++pt1 );
	    if ( strncmp(pt,'BK',pt1-pt)==0 || strncmp(pt,'CR',pt1-pt)==0 || strncmp(pt,'LF',pt1-pt)==0 )
		/*flg |= FF_UNICODE_MUSTBREAK*/;
	    else if ( strncmp(pt,'NS',pt1-pt)==0 || strncmp(pt,'CL',pt1-pt)==0 )
		flg |= FF_UNICODE_NONSTART;
	    else if ( strncmp(pt,'OP',pt1-pt)==0 || strncmp(pt,'CM',pt1-pt)==0 )
		flg |= FF_UNICODE_NONEND;
	    else if ( strncmp(pt,'GL',pt1-pt)==0 )
		flg |= FF_UNICODE_NONEND|FF_UNICODE_NONSTART;
	    else if ( strncmp(pt,'SP',pt1-pt)==0 || strncmp(pt,'HY',pt1-pt)==0 ||
		    strncmp(pt,'BA',pt1-pt)==0 ||
		    strncmp(pt,'ZW',pt1-pt)==0 )
		flg |= FF_UNICODE_BREAKAFTEROK;
	    else if ( strncmp(pt,'BB',pt1-pt)==0 )
		flg |= FF_UNICODE_BREAKBEFOREOK;
	    else if ( strncmp(pt,'B2',pt1-pt)==0 )
		flg |= FF_UNICODE_BREAKBEFOREOK|FF_UNICODE_BREAKAFTEROK;
	    else if ( strncmp(pt,'ID',pt1-pt)==0 )
		flg |= FF_UNICODE_BREAKBEFOREOK|FF_UNICODE_BREAKAFTEROK;
	    else if ( strncmp(pt,'SY',pt1-pt)==0 )
		flg |= FF_UNICODE_URLBREAKAFTER;
	    pt = pt1;
	    for ( ; index<=indexend; ++index )
		flags[index] |= flg;
	}
    }
    fclose(fp);

    if ((fp = fopen('PropList.txt','r'))==NULL ) {
	fprintf( stderr, CantReadFile, 'PropList.txt' );
	FreeNamesMemorySpace();
	exit(1);
    }
    while ( fgets(buffer,sizeof(buffer)-1,fp)!=NULL ) {
	flg = 0;
	if (strlen(buffer)>=299) {	/* previous version was linelength of 300 chars, jul2012 */
	    fprintf( stderr, LineLengthBg,'PropList.txt',buffer );
	    fclose(fp);
	    FreeNamesMemorySpace();
	    exit(4);
	}
	if ( true || strncmp(buffer,'Property dump for:', strlen('Property dump for:'))==0 ) {
	    if ( strstr(buffer, '(Zero-width)')!=NULL || strstr(buffer, 'ZERO WIDTH')!=NULL )
		flg = FF_UNICODE_ZEROWIDTH;
	    else if ( strstr(buffer, '(White space)')!=NULL || strstr(buffer, 'White_Space')!=NULL )
		flg = FF_UNICODE_SPACE;
	    else if ( strstr(buffer, '(Punctuation)')!=NULL || strstr(buffer, 'Punctuation')!=NULL )
		flg = FF_UNICODE_PUNCT;
	    else if ( strstr(buffer, '(Alphabetic)')!=NULL || strstr(buffer, 'Alphabetic')!=NULL )
		flg = FF_UNICODE_ALPHABETIC;
	    else if ( strstr(buffer, '(Ideographic)')!=NULL || strstr(buffer, 'Ideographic')!=NULL )
		flg = FF_UNICODE_IDEOGRAPHIC;
	    else if ( strstr(buffer, '(Hex Digit)')!=NULL || strstr(buffer, 'Hex_Digit')!=NULL )
		flg = FF_UNICODE_HEX;
	    else if ( strstr(buffer, '(Combining)')!=NULL || strstr(buffer, 'COMBINING')!=NULL )
		flg = FF_UNICODE_COMBINING;
	    else if ( strstr(buffer, '(Non-break)')!=NULL )
		flg = FF_UNICODE_NOBREAK;
	    if ( flg!=0 ) {
		if (( buffer[0]>='0' && buffer[0]<='9') || (buffer[0]>='A' && buffer[0]<='F')) {
		    index = wasfirst = strtol(buffer,NULL,16);
		    if ( buffer[4]=='.' && buffer[5]=='.' )
			index = strtol(buffer+6,NULL,16);
		    for ( ; wasfirst<=index && wasfirst<=0xffff; ++wasfirst )		/* BMP !!!!! */
			flags[wasfirst] |= flg;
		}
	    }
	}
    }
    fclose(fp);
    /* There used to be a zero width property, but no longer */
    flags[0x200B] |= FF_UNICODE_ZEROWIDTH;
    flags[0x200C] |= FF_UNICODE_ZEROWIDTH;
    flags[0x200D] |= FF_UNICODE_ZEROWIDTH;
    flags[0x2060] |= FF_UNICODE_ZEROWIDTH;
    flags[0xFEFF] |= FF_UNICODE_ZEROWIDTH;
    /* There used to be a No Break property, but no longer */
    flags[0x00A0] |= FF_UNICODE_NOBREAK;
    flags[0x2011] |= FF_UNICODE_NOBREAK;
    flags[0x202F] |= FF_UNICODE_NOBREAK;
    flags[0xFEFF] |= FF_UNICODE_NOBREAK;

    if ((fp = fopen('NamesList.txt','r'))==NULL ) {
	fprintf( stderr, CantReadFile, 'NamesList.txt' );
	FreeNamesMemorySpace();
	exit(1);
    }
    while ( fgets(buffer,sizeof(buffer)-1,fp)!=NULL ) {
	flg = 0;
	if (strlen(buffer)>=511) {
	    fprintf( stderr, LineLengthBg,'NamesList.txt',buffer );
	    fclose(fp);
	    FreeNamesMemorySpace();
	    exit(4);
	}
	if ( (index = strtol(buffer,NULL,16))!=0 ) {
	    if ( strstr(buffer, 'COMBINING')!=NULL )
		flg = FF_UNICODE_COMBINING;
	    else if ( strstr(buffer, 'N0-BREAK')!=NULL )
		flg = FF_UNICODE_NOBREAK;
	    else if ( strstr(buffer, 'ZERO WIDTH')!=NULL )
		flg = FF_UNICODE_ZEROWIDTH;

	    if ( index<0xffff )		/* !!!!! BMP */
		flags[wasfirst] |= flg;
	}
    }
    fclose(fp);

    /* TODO: 2016nov21 -> Get combiners directly from UnicodeData.txt */
    for ( i=0; combiners[i].low>=0; ++i ) {
	for ( j=combiners[i].low; j<=combiners[i].high; ++j )
	    flags2[j] |= combiners[i].pos[j-combiners[i].low];
    }
}
",1,7915
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void dumparabicdata(FILE *header) {
    FILE *data;
    struct arabicforms {
	unsigned short initial, medial, final, isolated;
	unsigned int isletter: 1;
	unsigned int joindual: 1;
	unsigned int required_lig_with_alef: 1;
    } forms[256];
    int i, j, index;

    memset(forms,'\0',sizeof(forms));
    for ( i=0x600; i<0x700; ++i ) {
	j = i-0x600;
	if ( names[i]==NULL )
	    /* No op (not defined) */;
	else if ( strncmp(names[i],'ARABIC LETTER ',strlen('ARABIC LETTER '))!=0 )
	    /* No op (not a letter, no fancy forms) */
	    forms[j].initial = forms[j].medial = forms[j].final = forms[j].isolated = i;
	else {
	    forms[j].isletter = 1;
	    forms[j].initial = forms[j].medial = forms[j].final = forms[j].isolated = i;
	    if ( (index = find(names[i],' ISOLATED FORM'))!= -1 )
		forms[j].isolated = index;
	    if ( (index = find(names[i],' FINAL FORM'))!= -1 )
		forms[j].final = index;
	    if ( (index = find(names[i],' INITIAL FORM'))!= -1 )
		forms[j].initial = index;
	    if ( (index = find(names[i],' MEDIAL FORM'))!= -1 )
		forms[j].medial = index;
	    if ( forms[j].initial!=i && forms[j].medial!=i )
		forms[j].joindual = 1;
	}
    }
    forms[0x44/* 0x644 == LAM */].required_lig_with_alef = 1;

    fprintf(header,'\nextern struct arabicforms {\n' );
    fprintf(header,'    unsigned short initial, medial, final, isolated;\n' );
    fprintf(header,'    unsigned int isletter: 1;\n' );
    fprintf(header,'    unsigned int joindual: 1;\n' );
    fprintf(header,'    unsigned int required_lig_with_alef: 1;\n' );
    fprintf(header,'} ArabicForms[256];\t/* for chars 0x600-0x6ff, subtract 0x600 to use array */\n' );

    data = fopen( 'ArabicForms.c','w');
    if (data==NULL) {
	fprintf( stderr, CantSaveFile, 'ArabicForms.c' );
	FreeNamesMemorySpace();
	exit(2);
    }

    fprintf( data, '/* Copyright: 2001 George Williams */\n' );
    fprintf( data, '/* License: BSD-3-clause */\n' );
    fprintf( data, '/* Contributions: Khaled Hosny, Joe Da Silva */\n' );
    fprintf( data, GeneratedFileMessage, UnicodeMajor, UnicodeMinor );

    fprintf( data, '#include <utype.h>\n\n' );

    fprintf( data, 'struct arabicforms ArabicForms[] = {\n' );
    fprintf( data, '\t/* initial, medial, final, isolated, isletter, joindual, required_lig_with_alef */\n');
    for ( i=0; i<256; ++i ) {
	fprintf( data, '\t{ 0x%04x, 0x%04x, 0x%04x, 0x%04x, %d, %d, %d }',
		forms[i].initial, forms[i].medial, forms[i].final, forms[i].isolated,
		forms[i].isletter, forms[i].joindual, forms[i].required_lig_with_alef);
	if ( i==255 )
	    fprintf( data, '\n');
	else
	    if ( (i & 31)==0 )
		fprintf( data, ',\t/* 0x%04x */\n',0x600+i);
	    else
		fprintf( data, ',\n');
    }
    fprintf( data, '};\n' );
    fclose( data );
}
",1,7916
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void dumpligaturesfractions(FILE *header) {
    FILE *data;
    int l16,v16,f16;

    fprintf( header, '\n\n/* Ligature/Vulgar_Fraction/Fraction unicode.org character lists & functions */\n\n' );

    /* Return !0 if this unicode value is a Ligature or Fraction */
    fprintf( header, 'extern int LigatureCount(void);\t\t/* Unicode table Ligature count */\n' );
    fprintf( header, 'extern int VulgarFractionCount(void);\t/* Unicode table Vulgar Fraction count */\n' );
    fprintf( header, 'extern int OtherFractionCount(void);\t/* Unicode table Other Fractions count */\n' );
    fprintf( header, 'extern int FractionCount(void);\t\t/* Unicode table Fractions found */\n\n' );
    fprintf( header, 'extern int32 Ligature_get_U(int n);\t/* Get table[N] value, error==-1 */\n' );
    fprintf( header, 'extern int32 VulgFrac_get_U(int n);\t/* Get table[N] value, error==-1 */\n' );
    fprintf( header, 'extern int32 Fraction_get_U(int n);\t/* Get table[N] value, error==-1 */\n\n' );
    fprintf( header, 'extern int Ligature_find_N(uint32 u);\t/* Find N of Ligature[N], error==-1 */\n' );
    fprintf( header, 'extern int VulgFrac_find_N(uint32 u);\t/* Find N of VulgFrac[N], error==-1 */\n' );
    fprintf( header, 'extern int Fraction_find_N(uint32 u);\t/* Find N of Fraction[N], error==-1 */\n\n' );

    fprintf( header, 'extern int Ligature_alt_getC(int n);\t/* Unicode table Ligature Alt count */\n' );
    fprintf( header, 'extern int32 Ligature_alt_getV(int n,int a); /* Unicode table Ligature Alt value */\n' );
    fprintf( header, 'extern int VulgFrac_alt_getC(int n);\t/* Unicode table Vulgar Fraction Alt count */\n' );
    fprintf( header, 'extern int32 VulgFrac_alt_getV(int n,int a); /* Unicode table Vulgar Fraction Alt value */\n' );
    fprintf( header, 'extern int Fraction_alt_getC(int n);\t/* Unicode table Other Fraction Alt count */\n' );
    fprintf( header, 'extern int32 Fraction_alt_getV(int n,int a); /* Unicode table Other Fraction Alt value */\n' );
    fprintf( header, 'extern int LigatureU_alt_getC(uint32 u);\t/* Unicode table Ligature Alt count */\n' );
    fprintf( header, 'extern int32 LigatureU_alt_getV(uint32 u,int a); /* Unicode table Ligature Alt value */\n' );
    fprintf( header, 'extern int VulgFracU_alt_getC(uint32 u);\t/* Unicode table Vulgar Fraction Alt count */\n' );
    fprintf( header, 'extern int32 VulgFracU_alt_getV(uint32 u,int a); /* Unicode table Vulgar Fraction Alt value */\n' );
    fprintf( header, 'extern int FractionU_alt_getC(uint32 u);\t/* Unicode table Other Fraction Alt count */\n' );
    fprintf( header, 'extern int32 FractionU_alt_getV(uint32 u,int a); /* Unicode table Other Fraction Alt value */\n\n' );

    fprintf( header, '/* Return !0 if codepoint is a Ligature */\n' );
    fprintf( header, 'extern int is_LIGATURE(uint32 codepoint);\n\n' );
    fprintf( header, '/* Return !0 if codepoint is a Vulgar Fraction */\n' );
    fprintf( header, 'extern int is_VULGAR_FRACTION(uint32 codepoint);\n\n' );
    fprintf( header, '/* Return !0 if codepoint is a non-vulgar Fraction */\n' );
    fprintf( header, 'extern int is_OTHER_FRACTION(uint32 codepoint);\n\n' );
    fprintf( header, '/* Return !0 if codepoint is a Fraction */\n' );
    fprintf( header, 'extern int is_FRACTION(uint32 codepoint);\n\n' );
    fprintf( header, '/* Return !0 if codepoint is a Ligature or Vulgar Fraction */\n' );
    fprintf( header, 'extern int is_LIGATURE_or_VULGAR_FRACTION(uint32 codepoint);\n\n' );
    fprintf( header, '/* Return !0 if codepoint is a Ligature or non-Vulgar Fraction */\n' );
    fprintf( header, 'extern int is_LIGATURE_or_OTHER_FRACTION(uint32 codepoint);\n\n' );
    fprintf( header, '/* Return !0 if codepoint is a Ligature or Fraction */\n' );
    fprintf( header, 'extern int is_LIGATURE_or_FRACTION(uint32 codepoint);\n\n' );

    data = fopen('is_Ligature_data.h','w');
    if (data==NULL) {
	fprintf( stderr, CantSaveFile, 'is_Ligature_data.h' );
	FreeNamesMemorySpace();
	exit(2);
    }

    fprintf( data, '/*\nCopyright: 2012 Barry Schwartz, create is_Ligature.c to test for vulgar fracs\n' );
    fprintf( data, 'Copyright: 2016 Joe Da Silva, re-write is_Ligature.c for ligs, vulg, and frac\n' );
    fprintf( data, 'Copyright: 2016 Gioele Barabucci, Simplify code and create is_Ligature_data.h\n' );
    fprintf( data, 'License: BSD-3-clause\n' );
    fprintf( data, 'Contributions:\n*/\n\n' );
    fprintf( data, GeneratedFileMessage, UnicodeMajor, UnicodeMinor );

    /* simple compression using uint16 instead of everything as uint32 */
    for ( l16=0; l16<lgm && ligature[l16]<=65535; ++l16 );
    for ( v16=0; v16<vfm && vulgfrac[v16]<=65535; ++v16 );
    for ( f16=0; f16<frm && fraction[f16]<=65535; ++f16 );

    fprintf( data, '/* unicode.org codepoints for ligatures, vulgar fractions, other fractions */\n\n' );
    buildtables(data,ligature,l16,lgm,'ligature');
    buildtables(data,vulgfrac,v16,vfm,'vulgfrac');
    buildtables(data,fraction,f16,frm,'fraction');

    build_lvf_alt_tables(data,0,ligature,altsl,l16,lgm,'ligature','Ligature');
    build_lvf_alt_tables(data,1,vulgfrac,altsv,v16,vfm,'vulgfrac','VulgFrac');
    build_lvf_alt_tables(data,2,fraction,altsf,f16,frm,'fraction','Fraction');
}
",1,7917
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void dump() {
    FILE *header, *data;
    int i,j;

    header=fopen('utype.h','w');
    data = fopen('utype.c','w');

    if ( header==NULL || data==NULL ) {
	fprintf( stderr, CantSaveFile, '(utype.[ch])' );
	if ( header ) fclose( header );
	if ( data   ) fclose( data );
	FreeNamesMemorySpace();
	exit(2);
    }

    fprintf( header, '#ifndef FONTFORGE_UNICODE_UTYPE_H\n' );
    fprintf( header, '#define FONTFORGE_UNICODE_UTYPE_H\n' );

    fprintf( header, '/* Copyright: 2001 George Williams */\n' );
    fprintf( header, '/* License: BSD-3-clause */\n' );
    fprintf( header, '/* Contributions: Joe Da Silva */\n' );
    fprintf( header, GeneratedFileMessage, UnicodeMajor, UnicodeMinor );

    fprintf( header, '#include <ctype.h>\t/* Include here so we can control it. If a system header includes it later bad things happen */\n' );
    fprintf( header, '#include <basics.h>\t/* Include here so we can use pre-defined int types to correctly size constant data arrays. */\n' );
    fprintf( header, '#ifdef tolower\n' );
    fprintf( header, '# undef tolower\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef toupper\n' );
    fprintf( header, '# undef toupper\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef islower\n' );
    fprintf( header, '# undef islower\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef isupper\n' );
    fprintf( header, '# undef isupper\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef isalpha\n' );
    fprintf( header, '# undef isalpha\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef isdigit\n' );
    fprintf( header, '# undef isdigit\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef isalnum\n' );
    fprintf( header, '# undef isalnum\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef isspace\n' );
    fprintf( header, '# undef isspace\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef ispunct\n' );
    fprintf( header, '# undef ispunct\n' );
    fprintf( header, '#endif\n' );
    fprintf( header, '#ifdef ishexdigit\n' );
    fprintf( header, '# undef ishexdigit\n' );
    fprintf( header, '#endif\n\n' );

    fprintf( header, 'extern const unsigned short ff_unicode_tolower[];\n' );
    fprintf( header, 'extern const unsigned short ff_unicode_toupper[];\n' );
    fprintf( header, 'extern const unsigned short ff_unicode_totitle[];\n' );
    fprintf( header, 'extern const unsigned short ff_unicode_tomirror[];\n' );
    fprintf( header, 'extern const unsigned char  ff_unicode_digitval[];\n' );
    fprintf( header, '\n' );

    fprintf( header, '/* utype[] MAX characters, originally 600, then increased to hold 65536 chars */\n' );
    fprintf( header, '#define FF_UTYPE_MAXC\t\t0x%0x\n\n', MAXC );

    fprintf( header, '/* utype[] holds binary flags used for features of each unicode.org character */\n' );
    fprintf( header, '#define FF_UNICODE_L\t\t0x%0x\n', FF_UNICODE_LOWER );
    fprintf( header, '#define FF_UNICODE_U\t\t0x%0x\n', FF_UNICODE_UPPER );
    fprintf( header, '#define FF_UNICODE_TITLE\t0x%0x\n', FF_UNICODE_TITLE );
    fprintf( header, '#define FF_UNICODE_D\t\t0x%0x\n', FF_UNICODE_DIGIT );
    fprintf( header, '#define FF_UNICODE_S\t\t0x%0x\n', FF_UNICODE_SPACE );
    fprintf( header, '#define FF_UNICODE_P\t\t0x%0x\n', FF_UNICODE_PUNCT );
    fprintf( header, '#define FF_UNICODE_X\t\t0x%0x\n', FF_UNICODE_HEX );
    fprintf( header, '#define FF_UNICODE_ZW\t\t0x%0x\n', FF_UNICODE_ZEROWIDTH );
    fprintf( header, '#define FF_UNICODE_L2R\t\t0x%0x\n', FF_UNICODE_LEFT_2_RIGHT );
    fprintf( header, '#define FF_UNICODE_R2L\t\t0x%0x\n', FF_UNICODE_RIGHT_2_LEFT );
    fprintf( header, '#define FF_UNICODE_ENUM\t\t0x%0x\n', FF_UNICODE_ENUMERIC );
    fprintf( header, '#define FF_UNICODE_ANUM\t\t0x%0x\n', FF_UNICODE_ANUMERIC );
    fprintf( header, '#define FF_UNICODE_ENS\t\t0x%0x\n', FF_UNICODE_ENS );
    fprintf( header, '#define FF_UNICODE_CS\t\t0x%0x\n', FF_UNICODE_CS );
    fprintf( header, '#define FF_UNICODE_ENT\t\t0x%0x\n', FF_UNICODE_ENT );
    fprintf( header, '#define FF_UNICODE_COMBINE\t0x%0x\n', FF_UNICODE_COMBINING );
    fprintf( header, '#define FF_UNICODE_BB\t\t0x%0x\n', FF_UNICODE_BREAKBEFOREOK );
    fprintf( header, '#define FF_UNICODE_BA\t\t0x%0x\n', FF_UNICODE_BREAKAFTEROK );
    fprintf( header, '#define FF_UNICODE_NS\t\t0x%0x\n', FF_UNICODE_NONSTART );
    fprintf( header, '#define FF_UNICODE_NE\t\t0x%0x\n', FF_UNICODE_NONEND );
    fprintf( header, '#define FF_UNICODE_UB\t\t0x%0x\n', FF_UNICODE_URLBREAKAFTER );
    fprintf( header, '#define FF_UNICODE_NB\t\t0x%0x\n', FF_UNICODE_NOBREAK );
    fprintf( header, '#define FF_UNICODE_AL\t\t0x%0x\n', FF_UNICODE_ALPHABETIC );
    fprintf( header, '#define FF_UNICODE_ID\t\t0x%0x\n', FF_UNICODE_IDEOGRAPHIC );
    fprintf( header, '#define FF_UNICODE_INITIAL\t0x%0x\n', FF_UNICODE_INITIAL );
    fprintf( header, '#define FF_UNICODE_MEDIAL\t0x%0x\n', FF_UNICODE_MEDIAL );
    fprintf( header, '#define FF_UNICODE_FINAL\t0x%0x\n', FF_UNICODE_FINAL );
    fprintf( header, '#define FF_UNICODE_ISOLATED\t0x%0x\n', FF_UNICODE_ISOLATED );
    fprintf( header, '#define FF_UNICODE_DECOMPNORM\t0x%0x\n', FF_UNICODE_DecompositionNormative );
    fprintf( header, '#define FF_UNICODE_LIG_OR_FRAC\t0x%0x\n', FF_UNICODE_LIG_OR_FRAC );
    fprintf( header, '\n' );

    fprintf( header, '#define islower(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_L)\n' );
    fprintf( header, '#define isupper(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_U)\n' );
    fprintf( header, '#define istitle(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_TITLE)\n' );
    fprintf( header, '#define isalpha(ch)\t\t(ff_unicode_utype[(ch)+1]&(FF_UNICODE_L|FF_UNICODE_U|FF_UNICODE_TITLE|FF_UNICODE_AL))\n' );
    fprintf( header, '#define isdigit(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_D)\n' );
    fprintf( header, '#define isalnum(ch)\t\t(ff_unicode_utype[(ch)+1]&(FF_UNICODE_L|FF_UNICODE_U|FF_UNICODE_TITLE|FF_UNICODE_AL|FF_UNICODE_D))\n' );
    fprintf( header, '#define isideographic(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_ID)\n' );
    fprintf( header, '#define isideoalpha(ch)\t\t(ff_unicode_utype[(ch)+1]&(FF_UNICODE_ID|FF_UNICODE_L|FF_UNICODE_U|FF_UNICODE_TITLE|FF_UNICODE_AL))\n' );
    fprintf( header, '#define isspace(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_S)\n' );
    fprintf( header, '#define ispunct(ch)\t\t(ff_unicode_utype[(ch)+1]&_FF_UNICODE_P)\n' );
    fprintf( header, '#define ishexdigit(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_X)\n' );
    fprintf( header, '#define iszerowidth(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_ZW)\n' );
    fprintf( header, '#define islefttoright(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_L2R)\n' );
    fprintf( header, '#define isrighttoleft(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_R2L)\n' );
    fprintf( header, '#define iseuronumeric(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_ENUM)\n' );
    fprintf( header, '#define isarabnumeric(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_ANUM)\n' );
    fprintf( header, '#define iseuronumsep(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_ENS)\n' );
    fprintf( header, '#define iscommonsep(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_CS)\n' );
    fprintf( header, '#define iseuronumterm(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_ENT)\n' );
    fprintf( header, '#define iscombining(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_COMBINE)\n' );
    fprintf( header, '#define isbreakbetweenok(ch1,ch2) (((ff_unicode_utype[(ch1)+1]&FF_UNICODE_BA) && !(ff_unicode_utype[(ch2)+1]&FF_UNICODE_NS)) || ((ff_unicode_utype[(ch2)+1]&FF_UNICODE_BB) && !(ff_unicode_utype[(ch1)+1]&FF_UNICODE_NE)) || (!(ff_unicode_utype[(ch2)+1]&FF_UNICODE_D) && ch1=='/'))\n' );
    fprintf( header, '#define isnobreak(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_NB)\n' );
    fprintf( header, '#define isarabinitial(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_INITIAL)\n' );
    fprintf( header, '#define isarabmedial(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_MEDIAL)\n' );
    fprintf( header, '#define isarabfinal(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_FINAL)\n' );
    fprintf( header, '#define isarabisolated(ch)\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_ISOLATED)\n' );
    fprintf( header, '#define isdecompositionnormative(ch) (ff_unicode_utype[(ch)+1]&FF_UNICODE_DECOMPNORM)\n' );
    fprintf( header, '#define isligorfrac(ch)\t\t(ff_unicode_utype[(ch)+1]&FF_UNICODE_LIG_OR_FRAC)\n' );
    fprintf( header, '\n' );

    fprintf( header, 'extern const uint32 ff_unicode_utype[];\t/* hold character type features for each Unicode.org defined character */\n\n' );

    fprintf( header, '/* utype2[] binary flags used for position/layout of each unicode.org character */\n' );
    fprintf( header, '#define FF_UNICODE_COMBININGCLASS\t0x%0x\n', FF_UNICODE_CombiningClass );
    fprintf( header, '#define FF_UNICODE_ABOVE\t\t0x%0x\n', FF_UNICODE_Above );
    fprintf( header, '#define FF_UNICODE_BELOW\t\t0x%0x\n', FF_UNICODE_Below );
    fprintf( header, '#define FF_UNICODE_OVERSTRIKE\t\t0x%0x\n', FF_UNICODE_Overstrike );
    fprintf( header, '#define FF_UNICODE_LEFT\t\t\t0x%0x\n', FF_UNICODE_Left );
    fprintf( header, '#define FF_UNICODE_RIGHT\t\t0x%0x\n', FF_UNICODE_Right );
    fprintf( header, '#define FF_UNICODE_JOINS2\t\t0x%0x\n', FF_UNICODE_Joins2 );
    fprintf( header, '#define FF_UNICODE_CENTERLEFT\t\t0x%0x\n', FF_UNICODE_CenterLeft );
    fprintf( header, '#define FF_UNICODE_CENTERRIGHT\t\t0x%0x\n', FF_UNICODE_CenterRight );
    fprintf( header, '#define FF_UNICODE_CENTEREDOUTSIDE\t0x%0x\n', FF_UNICODE_CenteredOutside );
    fprintf( header, '#define FF_UNICODE_OUTSIDE\t\t0x%0x\n', FF_UNICODE_Outside );
    fprintf( header, '#define FF_UNICODE_LEFTEDGE\t\t0x%0x\n', FF_UNICODE_LeftEdge );
    fprintf( header, '#define FF_UNICODE_RIGHTEDGE\t\t0x%0x\n', FF_UNICODE_RightEdge );
    fprintf( header, '#define FF_UNICODE_TOUCHING\t\t0x%0x\n', FF_UNICODE_Touching );
    fprintf( header, '#define FF_UNICODE_COMBININGPOSMASK\t0x%0x\n',
	    FF_UNICODE_Outside|FF_UNICODE_CenteredOutside|FF_UNICODE_CenterRight|FF_UNICODE_CenterLeft|FF_UNICODE_Joins2|
	    FF_UNICODE_Right|FF_UNICODE_Left|FF_UNICODE_Overstrike|FF_UNICODE_Below|FF_UNICODE_Above|FF_UNICODE_RightEdge|FF_UNICODE_LeftEdge|
	    FF_UNICODE_Touching);
    fprintf( header, '#define FF_UNICODE_NOPOSDATAGIVEN\t(uint32)(-1)\t/* -1 == no position data given */\n\n' );

    fprintf( header, '#define combiningclass(ch)\t(ff_unicode_utype2[(ch)+1]&FF_UNICODE_COMBININGCLASS)\n' );
    fprintf( header, '#define combiningposmask(ch)\t(ff_unicode_utype2[(ch)+1]&FF_UNICODE_COMBININGPOSMASK)\n\n' );

    fprintf( header, 'extern const uint32 ff_unicode_utype2[];\t/* hold position boolean flags for each Unicode.org defined character */\n\n' );

    fprintf( header, '#define isunicodepointassigned(ch) (ff_unicode_codepointassigned[(ch)/32]&(1<<((ch)%%32)))\n\n' );

    fprintf( header, 'extern const uint32 ff_unicode_codepointassigned[]; /* 1bit_boolean_flag x 32 = exists in Unicode.org character chart list. */\n\n' );

    fprintf( header, '#define tolower(ch) (ff_unicode_tolower[(ch)+1])\n' );
    fprintf( header, '#define toupper(ch) (ff_unicode_toupper[(ch)+1])\n' );
    fprintf( header, '#define totitle(ch) (ff_unicode_totitle[(ch)+1])\n' );
    fprintf( header, '#define tomirror(ch) (ff_unicode_tomirror[(ch)+1])\n' );
    fprintf( header, '#define tovalue(ch) (ff_unicode_digitval[(ch)+1])\n' );
    fprintf( header, '\n' );

    fprintf( data, '/* Copyright: 2001 George Williams */\n' );
    fprintf( data, '/* License: BSD-3-clause */\n' );
    fprintf( data, '/* Contributions: Werner Lemberg, Khaled Hosny, Joe Da Silva */\n\n' );
    fprintf( data, '#include \'utype.h\'\n' );
    fprintf( data, GeneratedFileMessage, UnicodeMajor, UnicodeMinor );
    fprintf( data, 'const unsigned short ff_unicode_tolower[]= { 0,\n' );
    for ( i=0; i<MAXC; i+=j ) {
	fprintf( data, ' ' );
	for ( j=0; j<8 && i+j<MAXC-1; ++j )
	    fprintf(data, ' 0x%04x,', mytolower[i+j]);
	if ( i+j==MAXC-1 ) {
	    fprintf(data, ' 0x%04x\n};\n\n', mytolower[i+j]);
    break;
	} else
	    if ( (i & 63)==0 )
		fprintf( data, '\t/* 0x%04x */\n',i);
	    else
		fprintf( data, '\n');
    }
    fprintf( data, 'const unsigned short ff_unicode_toupper[] = { 0,\n' );
    for ( i=0; i<MAXC; i+=j ) {
	fprintf( data, ' ' );
	for ( j=0; j<8 && i+j<MAXC-1; ++j )
	    fprintf(data, ' 0x%04x,', mytoupper[i+j]);
	if ( i+j==MAXC-1 ) {
	    fprintf(data, ' 0x%04x\n};\n\n', mytoupper[i+j]);
    break;
	} else
	    if ( (i & 63)==0 )
		fprintf( data, '\t/* 0x%04x */\n',i);
	    else
		fprintf( data, '\n');
    }
    fprintf( data, 'const unsigned short ff_unicode_totitle[] = { 0,\n' );
    for ( i=0; i<MAXC; i+=j ) {
	fprintf( data, ' ' );
	for ( j=0; j<8 && i+j<MAXC-1; ++j )
	    fprintf(data, ' 0x%04x,', mytotitle[i+j]);
	if ( i+j==MAXC-1 ) {
	    fprintf(data, ' 0x%04x\n};\n\n', mytotitle[i+j]);
    break;
	} else
	    if ( (i & 63)==0 )
		fprintf( data, '\t/* 0x%04x */\n',i);
	    else
		fprintf( data, '\n');
    }
    fprintf( data, 'const unsigned short ff_unicode_tomirror[] = { 0,\n' );
    for ( i=0; i<MAXC; i+=j ) {
	fprintf( data, ' ' );
	for ( j=0; j<8 && i+j<MAXC-1; ++j )
	    fprintf(data, ' 0x%04x,', mymirror[i+j]);
	if ( i+j==MAXC-1 ) {
	    fprintf(data, ' 0x%04x\n};\n\n', mymirror[i+j]);
    break;
	} else
	    if ( (i & 63)==0 )
		fprintf( data, '\t/* 0x%04x */\n',i);
	    else
		fprintf( data, '\n');
    }
    fprintf( data, 'const unsigned char ff_unicode_digitval[] = { 0,\n' );
    for ( i=0; i<MAXC; i+=j ) {
	fprintf( data, ' ' );
	for ( j=0; j<8 && i+j<MAXC-1; ++j )
	    fprintf(data, ' 0x%02x,', mynumericvalue[i+j]);
	if ( i+j==MAXC-1 ) {
	    fprintf(data, ' 0x%02x\n};\n\n', mynumericvalue[i+j]);
    break;
	} else
	    if ( (i & 63)==0 )
		fprintf( data, '\t/* 0x%04x */\n',i);
	    else
		fprintf( data, '\n');
    }
    fprintf( data, 'const uint32 ff_unicode_utype[] = { 0,\n' );
    for ( i=0; i<MAXC; i+=j ) {
	fprintf( data, ' ' );
	for ( j=0; j<8 && i+j<MAXC-1; ++j )
	    fprintf(data, ' 0x%08x,', flags[i+j]);
	if ( i+j==MAXC-1 ) {
	    fprintf(data, ' 0x%08x\n};\n\n', flags[i+j]);
    break;
	} else
	    if ( (i & 63)==0 )
		fprintf( data, '\t/* 0x%04x */\n',i);
	    else
		fprintf( data, '\n');
    }
    fprintf( data, 'const uint32 ff_unicode_utype2[] = { 0,\n' );
    fprintf( data, '  /* binary flags used for physical layout of each unicode.org character */\n' );
    for ( i=0; i<MAXC; i+=j ) {
	fprintf( data, ' ' );
	for ( j=0; j<8 && i+j<MAXC-1; ++j )
	    fprintf(data, ' 0x%08x,', flags2[i+j]);
	if ( i+j==MAXC-1 ) {
	    fprintf(data, ' 0x%08x\n};\n\n', flags2[i+j]);
    break;
	} else
	    if ( (i & 63)==0 )
		fprintf( data, '\t/* 0x%04x */\n',i);
	    else
		fprintf( data, '\n');
    }

    fprintf( data, 'const uint32 ff_unicode_codepointassigned[] = {\n' );
    fprintf( data, '  /* 32 unicode.org characters represented for each data value in array */\n' );
    for ( i=0; i<0x120000/32; i+=j ) {
	fprintf( data, ' ' );
	for ( j=0; j<8 && i+j<0x120000/32-1; ++j )
	    fprintf(data, ' 0x%08x,', assignedcodepoints[i+j]);
	if ( i+j==0x120000/32-1 ) {
	    fprintf(data, ' 0x%08x\n};\n\n', assignedcodepoints[i+j]);
    break;
	} else
	    if ( (i & 63)==0 )
		fprintf( data, '\t/* 0x%04x */\n',i);
	    else
		fprintf( data, '\n');
    }

    fclose( data );

    dumparabicdata(header);
    dumpligaturesfractions(header);
    fprintf( header, '\n#define FF_UNICODE_SOFT_HYPHEN\t0xad\n' );
    fprintf( header, '\n#define FF_UNICODE_DOUBLE_S\t0xdf\n' );
    fprintf( header, '\n#endif /* FONTFORGE_UNICODE_UTYPE_H */\n' );
    fclose( header );
}
",1,7918
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"	if ( alt[1]=='\0' )
	    alt = NULL;		/* Single replacements aren't ligatures */
	else if ( iscombining(alt[1]) && ( alt[2]=='\0' || iscombining(alt[2]))) {
",1,7919
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static char *LigDefaultStr(int uni, char *name, int alt_lig ) {
    const unichar_t *alt=NULL, *pt;
    char *components = NULL, *tmp;
    int len;
    unichar_t hack[30], *upt;
    char buffer[80];

    /* If it's not (bmp) unicode we have no info on it */
    /*  Unless it looks like one of adobe's special ligature names */
    if ( uni==-1 || uni>=0x10000 )
	/* Nope */;
    else if ( isdecompositionnormative(uni) &&
		unicode_alternates[uni>>8]!=NULL &&
		(alt = unicode_alternates[uni>>8][uni&0xff])!=NULL ) {
	if ( alt[1]=='\0' )
	    alt = NULL;		/* Single replacements aren't ligatures */
	else if ( iscombining(alt[1]) && ( alt[2]=='\0' || iscombining(alt[2]))) {
	    if ( alt_lig != -10 )	/* alt_lig = 10 => mac unicode decomp */
		alt = NULL;		/* Otherwise, don't treat accented letters as ligatures */
	} else if (! is_LIGATURE_or_VULGAR_FRACTION((uint32)(uni)) &&
		uni!=0x152 && uni!=0x153 &&	/* oe ligature should not be standard */
		uni!=0x132 && uni!=0x133 &&	/* nor ij */
		(uni<0xfb2a || uni>0xfb4f) &&	/* Allow hebrew precomposed chars */
		uni!=0x215f &&
		!((uni>=0x0958 && uni<=0x095f) || uni==0x929 || uni==0x931 || uni==0x934)) {
	    alt = NULL;
	} else if ( (tmp=unicode_name(65))==NULL ) { /* test for 'A' to see if library exists */
	    if ( (uni>=0xbc && uni<=0xbe ) ||		/* Latin1 fractions */
		    (uni>=0x2153 && uni<=0x215e ) ||	/* other fractions */
		    (uni>=0xfb00 && uni<=0xfb06 ) ||	/* latin ligatures */
		    (uni>=0xfb13 && uni<=0xfb17 ) ||	/* armenian ligatures */
		    uni==0xfb17 ||			/* hebrew ligature */
		    (uni>=0xfb2a && uni<=0xfb4f ) ||	/* hebrew precomposed chars */
		    (uni>=0xfbea && uni<=0xfdcf ) ||	/* arabic ligatures */
		    (uni>=0xfdf0 && uni<=0xfdfb ) ||	/* arabic ligatures */
		    (uni>=0xfef5 && uni<=0xfefc ))	/* arabic ligatures */
		;	/* These are good */
	    else
		alt = NULL;
	} else
	    free(tmp); /* found 'A' means there is a library, now cleanup */
    }
    if ( alt==NULL ) {
	if ( name==NULL || alt_lig )
return( NULL );
	else
return( AdobeLigatureFormat(name));
    }

    if ( uni==0xfb03 && alt_lig==1 )
	components = copy('ff i');
    else if ( uni==0xfb04 && alt_lig==1 )
	components = copy('ff l');
    else if ( alt!=NULL ) {
	if ( alt[1]==0x2044 && (alt[2]==0 || alt[3]==0) && alt_lig==1 ) {
	    u_strcpy(hack,alt);
	    hack[1] = '/';
	    alt = hack;
	} else if ( alt_lig>0 )
return( NULL );

	if ( isarabisolated(uni) || isarabinitial(uni) || isarabmedial(uni) || isarabfinal(uni) ) {
	    /* If it is arabic, then convert from the unformed version to the formed */
	    if ( u_strlen(alt)<sizeof(hack)/sizeof(hack[0])-1 ) {
		u_strcpy(hack,alt);
		for ( upt=hack ; *upt ; ++upt ) {
		    /* Make everything medial */
		    if ( *upt>=0x600 && *upt<=0x6ff )
			*upt = ArabicForms[*upt-0x600].medial;
		}
		if ( isarabisolated(uni) || isarabfinal(uni) ) {
		    int len = upt-hack-1;
		    if ( alt[len]>=0x600 && alt[len]<=0x6ff )
			hack[len] = ArabicForms[alt[len]-0x600].final;
		}
		if ( isarabisolated(uni) || isarabinitial(uni) ) {
		    if ( alt[0]>=0x600 && alt[0]<=0x6ff )
			hack[0] = ArabicForms[alt[0]-0x600].initial;
		}
		alt = hack;
	    }
	}

	components=NULL;
	while ( 1 ) {
	    len = 0;
	    for ( pt=alt; *pt; ++pt ) {
		if ( components==NULL ) {
		    len += strlen(StdGlyphName(buffer,*pt,ui_none,(NameList *)-1))+1;
		} else {
		    const char *temp = StdGlyphName(buffer,*pt,ui_none,(NameList *)-1);
		    strcpy(components+len,temp);
		    len += strlen( temp );
		    components[len++] = ' ';
		}
	    }
	    if ( components!=NULL )
	break;
	    components = malloc(len+1);
	}
	components[len-1] = '\0';
    }
return( components );
}
",1,7920
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"uint32 LigTagFromUnicode(int uni) {
    int tag = CHR('l','i','g','a');	/* standard */

    if (( uni>=0xbc && uni<=0xbe ) || (uni>=0x2153 && uni<=0x215f) )
	tag = CHR('f','r','a','c');	/* Fraction */
    /* hebrew precomposed characters */
    else if ( uni>=0xfb2a && uni<=0xfb4e )
	tag = CHR('c','c','m','p');
    else if ( uni==0xfb4f )
	tag = CHR('h','l','i','g');
    /* armenian */
    else if ( uni>=0xfb13 && uni<=0xfb17 )
	tag = CHR('l','i','g','a');
    /* devanagari ligatures */
    else if ( (uni>=0x0958 && uni<=0x095f) || uni==0x931 || uni==0x934 || uni==0x929 )
	tag = CHR('n','u','k','t');
    else switch ( uni ) {
      case 0xfb05:		/* long-s t */
	/* This should be 'liga' for long-s+t and 'hlig' for s+t */
	tag = CHR('l','i','g','a');
      break;
      case 0x00c6: case 0x00e6:		/* ae, AE */
      case 0x0152: case 0x0153:		/* oe, OE */
      case 0x0132: case 0x0133:		/* ij, IJ */
      case 0xfb06:			/* s t */
	tag = CHR('d','l','i','g');
      break;
      case 0xfefb: case 0xfefc:	/* Lam & Alef, required ligs */
	tag = CHR('r','l','i','g');
      break;
    }
return( tag );
}
",1,7921
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static SplineChar *GetGoodAccentGlyph(SplineFont *sf, int uni, int basech,
	int *invert,double ia, char *dot, SplineChar *destination);

",0,7922
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"		    else if ( x<bounds->minx ) bounds->minx = x;
		}
	    }
",0,7923
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"/* U+F685 */ { 0xf769, 0x0304, 0 },
/* U+F686 */ { 0xf769, 0x0328, 0 },
/* U+F687 */ { 0xf769, 0x0303, 0 },
",0,7924
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"/* U+F748 */ { 0 },
/* U+F749 */ { 0 },
/* U+F74A */ { 0 },
",0,7925
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"int queuelen(struct transform *queue) {
    int len=0;

    while ( queue!=NULL ) {
	queue = queue->next;
	++len;
    }
return( len );
}
",0,7926
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void CI_SetColorList(CharInfo *ci,Color color) {
    int i;
    uint16 junk;

    std_colors[CUSTOM_COLOR].image = NULL;
    for ( i=0; std_colors[i].image!=NULL; ++i ) {
	if ( std_colors[i].userdata == (void *) (intpt) color )
    break;
    }
    if ( std_colors[i].image==NULL ) {
	std_colors[i].image = &customcolor_image;
	customcolor_image.u.image->clut->clut[1] = color;
	std_colors[i].userdata = (void *) (intpt) color;
    }
    GGadgetSetList(GWidgetGetControl(ci->gw,CID_Color), GTextInfoArrayFromList(std_colors,&junk), false);
    GGadgetSelectOneListItem(GWidgetGetControl(ci->gw,CID_Color),i);
    if ( color!=COLOR_DEFAULT )
	ci->last = color;
    ci->real_last = color;
}
",0,7927
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"char *DevTab_Dlg(GGadget *g, int r, int c) {
    int rows, k, j, cols = GMatrixEditGetColCnt(g);
    struct matrix_data *strings = GMatrixEditGet(g, &rows);
    char *dvstr = strings[cols*r+c].u.md_str;
    struct devtab_dlg dvd;
    GRect pos;
    GWindow gw;
    GWindowAttrs wattrs;
    GGadgetCreateData gcd[4], boxes[3];
    GGadgetCreateData *varray[6], *harray3[8];
    GTextInfo label[4];
    struct matrixinit mi;

    memset(&dvd,0,sizeof(dvd));

    memset(&wattrs,0,sizeof(wattrs));
    wattrs.mask = wam_events|wam_cursor|wam_utf8_wtitle|wam_undercursor|wam_isdlg|wam_restrict;
    wattrs.event_masks = ~(1<<et_charup);
    wattrs.is_dlg = true;
    wattrs.restrict_input_to_me = 1;
    wattrs.undercursor = 1;
    wattrs.cursor = ct_pointer;
    wattrs.utf8_window_title = _('Device Table Adjustments');
    pos.x = pos.y = 0;
    pos.width =GDrawPointsToPixels(NULL,GGadgetScale(268));
    pos.height = GDrawPointsToPixels(NULL,375);
    dvd.gw = gw = GDrawCreateTopWindow(NULL,&pos,devtabdlg_e_h,&dvd,&wattrs);

    DevTabMatrixInit(&mi,dvstr);

    memset(&gcd,0,sizeof(gcd));
    memset(&boxes,0,sizeof(boxes));
    memset(&label,0,sizeof(label));
    k=j=0;
    gcd[k].gd.pos.x = 10; gcd[k].gd.pos.y = gcd[1].gd.pos.y+14;
    gcd[k].gd.flags = gg_enabled | gg_visible | gg_utf8_popup;
    gcd[k].gd.u.matrix = &mi;
    gcd[k].gd.popup_msg = (unichar_t *) _(
	'At small pixel sizes (screen font sizes)\n'
	'the rounding errors that occur may be\n'
	'extremely ugly. A device table allows\n'
	'you to specify adjustments to the rounded\n'
	'Every pixel size my have its own adjustment.');
    gcd[k].creator = GMatrixEditCreate;
    varray[j++] = &gcd[k++]; varray[j++] = NULL;

    gcd[k].gd.pos.x = 30-3; 
    gcd[k].gd.flags = gg_visible | gg_enabled | gg_but_default;
    label[k].text = (unichar_t *) _('_OK');
    label[k].text_is_1byte = true;
    label[k].text_in_resource = true;
    gcd[k].gd.label = &label[k];
    gcd[k].gd.handle_controlevent = DevTabDlg_OK;
    gcd[k++].creator = GButtonCreate;

    gcd[k].gd.pos.x = -30;
    gcd[k].gd.flags = gg_visible | gg_enabled | gg_but_cancel;
    label[k].text = (unichar_t *) _('_Cancel');
    label[k].text_is_1byte = true;
    label[k].text_in_resource = true;
    gcd[k].gd.label = &label[k];
    gcd[k].gd.handle_controlevent = DevTabDlg_Cancel;
    gcd[k].gd.cid = CID_Cancel;
    gcd[k++].creator = GButtonCreate;

    harray3[0] = harray3[2] = harray3[3] = harray3[4] = harray3[6] = GCD_Glue;
    harray3[7] = NULL;
    harray3[1] = &gcd[k-2]; harray3[5] = &gcd[k-1];

    boxes[0].gd.flags = gg_enabled|gg_visible;
    boxes[0].gd.u.boxelements = harray3;
    boxes[0].creator = GHBoxCreate;
    varray[j++] = &boxes[0]; varray[j++] = NULL; varray[j] = NULL;
    
    boxes[1].gd.pos.x = boxes[1].gd.pos.y = 2;
    boxes[1].gd.flags = gg_enabled|gg_visible;
    boxes[1].gd.u.boxelements = varray;
    boxes[1].creator = GHVGroupCreate;

    GGadgetsCreate(gw,boxes+1);

    free( mi.matrix_data );

    dvd.gme = gcd[0].ret;
    GMatrixEditSetNewText(gcd[0].ret,S_('PixelSize|New'));
    GHVBoxSetExpandableRow(boxes[1].ret,1);
    GHVBoxSetExpandableCol(boxes[0].ret,gb_expandgluesame);

    GHVBoxFitWindow(boxes[1].ret);

    GDrawSetVisible(gw,true);
    while ( !dvd.done )
	GDrawProcessOneEvent(NULL);
    GDrawDestroyWindow(gw);
    if ( dvd.done==2 ) {
	char *ret;
	DevTabToString(&ret,&dvd.devtab);
	free(dvd.devtab.corrections);
return( ret );
    } else
return( copy(dvstr));
}
",0,7928
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"    *_low = low; *_high = high;
return( true );
}
",0,7929
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"    int isisolated=0, iscircled=0;

    for ( i=0; ; ++i ) {
",0,7930
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"    for ( j=0; accents[j][0]!=0xffff; ++j ) {
	for ( k=0; k<4 && accents[j][k]!=0; ++k ) {
	    if ( uni==accents[j][k] ) {
",0,7931
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"#define CID_New		1221
#define CID_Delete	1222
#define CID_Edit	1223
",0,7932
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"GImage *SC_GetLinedImage(SplineChar *sc, int def_layer, int pos, int is_italic_cor) {
    BDFChar *me;
    double scale = kern_popup_size/(double) (sc->parent->ascent+sc->parent->descent);
    int miny, maxy, minx, maxx;
    GImage *img;
    struct _GImage *base;
    Color fg, bg;
    int l,clut_scale;
    int x,y, xoffset, yoffset;
    int pixel;

    if ( is_italic_cor )
	pos += sc->width;
    pos = rint( pos*scale );
    if ( pos<-100 || pos>100 )
return( NULL );
    me = Rasterize(sc,def_layer);
    if ( pos<me->xmin-10 || pos>me->xmax+30 ) {
	BDFCharFree(me);
return( NULL );
    }
    if ( (minx=me->xmin)>0 ) minx = 0;
    if ( (maxx=me->xmax)<me->width ) maxx = me->width;
    if ( pos<minx ) minx = pos-2;
    if ( pos>maxx ) maxx = pos+2;
    miny = me->ymin - 4;
    maxy = me->ymax + 4;

    pixel = me->depth == 8 ? 0xff : 0xf;

    img = GImageCreate(it_index,maxx-minx+2,maxy-miny+2);
    base = img->u.image;
    memset(base->data,'\0',base->bytes_per_line*base->height);

    xoffset = 1 - minx;
    yoffset = 1 + maxy;
    for ( y=me->ymin; y<=me->ymax; ++y ) {
	for ( x=me->xmin; x<=me->xmax; ++x ) {
	    base->data[(yoffset-y)*base->bytes_per_line + (x+xoffset)] =
		    me->bitmap[(me->ymax-y)*me->bytes_per_line + (x-me->xmin)];
	}
    }
    for ( y=miny; y<=maxy; ++y ) {
	base->data[(yoffset-y)*base->bytes_per_line + (pos+xoffset)] = pixel;
	if ( is_italic_cor && (y&1 ))
	    base->data[(yoffset-y)*base->bytes_per_line + (me->width+xoffset)] = pixel;
    }
    
    memset(base->clut,'\0',sizeof(*base->clut));
    bg = GDrawGetDefaultBackground(NULL);
    fg = GDrawGetDefaultForeground(NULL);
    clut_scale = me->depth == 8 ? 8 : 4;
    base->clut->clut_len = 1<<clut_scale;
    for ( l=0; l<(1<<clut_scale); ++l )
	base->clut->clut[l] =
	    COLOR_CREATE(
	     COLOR_RED(bg) + (l*(COLOR_RED(fg)-COLOR_RED(bg)))/((1<<clut_scale)-1),
	     COLOR_GREEN(bg) + (l*(COLOR_GREEN(fg)-COLOR_GREEN(bg)))/((1<<clut_scale)-1),
	     COLOR_BLUE(bg) + (l*(COLOR_BLUE(fg)-COLOR_BLUE(bg)))/((1<<clut_scale)-1) );
    BDFCharFree(me);
return( img );
}
",0,7933
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"int FVParseSelectByPST(FontView *fv,struct lookup_subtable *sub,
	int search_type) {
    int first;

    first = FVBParseSelectByPST((FontViewBase *) fv,sub,search_type);

    if ( first!=-1 )
	FVScrollToChar(fv,first);
    else if ( !no_windowing_ui )
	ff_post_notice(_('Select By ATT...'),_('No glyphs matched'));
    if (  !no_windowing_ui )
	GDrawRequestExpose(fv->v,NULL,false);
return( true );
}
",0,7934
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"/* U+F631 */ { 0 },
/* U+F632 */ { 0 },
/* U+F633 */ { 0 },
",0,7935
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"void ParseUnicodeFile(FILE *in) {
    char buffer[600];
    int ch, mask, base, lc, i;
    char *pt;

    while ( mygets(in,buffer)!=NULL ) {
	ch = strtol(buffer,NULL,16);
	if ( ch==0x1ec0 )
	    ch = 0x1ec0;
	pt = buffer+4;
	if ( strncmp(pt,';LATIN ',7)!=0 )
    continue;
	pt += 7;
	if ( strncmp(pt,'CAPITAL ',8)==0 ) {
	    lc = 0;
	    pt += 8;
	} else if ( strncmp(pt,'SMALL ',6)==0 ) {
	    lc = 1;
	    pt += 6;
	} else
    continue;
	if ( strncmp(pt,'LETTER ',7)!=0 )
    continue;
	pt += 7;
	base = *pt++;
	if ( lc ) base = tolower(base);
	if ( strncmp(pt,' WITH ',6)!=0 )
    continue;
	pt += 6;
	mask = 0;
	for (;;) {
	    for ( i=0; names2[i].name!=NULL; ++i ) {
		if ( strncmp(pt,names2[i].name,strlen(names2[i].name))==0 )
	    break;
	    }
	    if ( names2[i].name==NULL || names2[i].mask==0 )
    goto continue_2_loop;
	    mask |= names2[i].mask;
	    pt += strlen(names2[i].name);
	    while ( *pt!=';' && !(*pt==' ' && pt[1]=='A' && pt[2]=='N' && pt[3]=='D' && pt[4]==' '))
		++pt;
	    if ( *pt==';' )
	break;
	    else
		pt += 5;
	}
	AddTransform(base,mask,0,ch);
    continue_2_loop:;
    }
    fclose(in);
}
",0,7936
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"    const unichar_t *pt, *all; unichar_t ch, basech;
    SplineChar *one, *two;
    char *dot = NULL;
",0,7937
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"			possub[cols*i+PAIR_DX_ADV1].u.md_ival==0 &&
			possub[cols*i+PAIR_DY_ADV1].u.md_ival==0 &&
			possub[cols*i+PAIR_DX2].u.md_ival==0 &&
",0,7938
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"return( false );
}

",0,7939
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static int CI_Cancel(GGadget *g, GEvent *e) {
    if ( e->type==et_controlevent && e->u.control.subtype == et_buttonactivate ) {
	CharInfo *ci = GDrawGetUserData(GGadgetGetWindow(g));
	CI_DoCancel(ci);
    }
return( true );
}
",0,7940
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"/* U+F66E */ { 0xf761, 0x0304, 0 },
/* U+F66F */ { 0xf761, 0x0328, 0 },
/* U+F670 */ { 0xf7e6, 0x0301, 0 },
/* U+F671 */ { 0xf763, 0x0301, 0 },
",0,7941
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"void SCAddRef(SplineChar *sc,SplineChar *rsc,int layer, real xoff, real yoff) {
    real transform[6];
    transform[0] = transform[3] = 1;
",0,7942
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"return;
    }
    *str = pt = malloc(11*(adjust->last_pixel_size-adjust->first_pixel_size+1)+1);
",0,7943
fontforge/fontforge,ac099b39ec2b98202ca51077a612c3eecee95bdb,"static void extpart_finishedit(GGadget *g, int r, int c, int wasnew) {
    int rows;
    struct matrix_data *possub;
    CharInfo *ci;
    int is_horiz,cols;
    DBounds b;
    double full_advance;
    SplineChar *sc;

    if ( c!=0 )
return;
    if ( !wasnew )
return;
    /* If they added a new glyph to the sequence then set some defaults for it. */
    /*  only the full advance has any likelyhood of being correct */
    ci = GDrawGetUserData(GGadgetGetWindow(g));
    is_horiz = GTabSetGetSel(GWidgetGetControl(ci->gw,CID_Tabs))-ci->vert_aspect;
    possub = GMatrixEditGet(g, &rows);
    cols = GMatrixEditGetColCnt(g);
    if ( possub[r*cols+0].u.md_str==NULL )
return;
    sc = SFGetChar(ci->sc->parent,-1,possub[r*cols+0].u.md_str);
    if ( sc==NULL )
return;
    SplineCharFindBounds(sc,&b);
    if ( is_horiz )
	full_advance = b.maxx - b.minx;
    else
	full_advance = b.maxy - b.miny;
    possub[r*cols+2].u.md_ival = possub[r*cols+3].u.md_ival = rint(full_advance/3);
    possub[r*cols+4].u.md_ival = rint(full_advance);
    GGadgetRedraw(g);
}
",0,7944
fontforge/fontforge,4de0c58a01e5e30610c200e9aea98bc7db12c7ac,"static SplinePointList *SplinesFromLayers(SplineChar *sc,int *flags, int tostroke) {
    int layer;
    SplinePointList *head=NULL, *last, *new, *nlast, *temp, *each, *transed;
    StrokeInfo si;
    /*SplineSet *spl;*/
    int handle_eraser;
    real inversetrans[6], transform[6];
    int changed;

    if ( tostroke ) {
	for ( layer=ly_fore; layer<sc->layer_cnt; ++layer ) {
	    if ( sc->layers[layer].splines==NULL )
	continue;
	    else if ( head==NULL )
		head = sc->layers[layer].splines;
	    else
		last->next = sc->layers[layer].splines;
	    for ( last = sc->layers[layer].splines; last->next!=NULL; last=last->next );
	    sc->layers[layer].splines = NULL;
	}
return( head );
    }

    if ( *flags==-1 )
	*flags = PsStrokeFlagsDlg();

    if ( *flags & sf_correctdir ) {
	for ( layer=ly_fore; layer<sc->layer_cnt; ++layer ) if ( sc->layers[layer].dofill )
	    SplineSetsCorrect(sc->layers[layer].splines,&changed);
    }

    handle_eraser = *flags & sf_handle_eraser;

    for ( layer=ly_fore; layer<sc->layer_cnt; ++layer ) {
	if ( sc->layers[layer].dostroke ) {
	    memset(&si,'\0',sizeof(si));
	    si.join = sc->layers[layer].stroke_pen.linejoin;
	    si.cap = sc->layers[layer].stroke_pen.linecap;
	    si.radius = sc->layers[layer].stroke_pen.width/2.0f;
	    if ( sc->layers[layer].stroke_pen.width==WIDTH_INHERITED )
		si.radius = .5;
	    if ( si.cap == lc_inherited ) si.cap = lc_butt;
	    if ( si.join == lj_inherited ) si.join = lj_miter;
	    new = NULL;
	    memcpy(transform,sc->layers[layer].stroke_pen.trans,4*sizeof(real));
	    transform[4] = transform[5] = 0;
	    MatInverse(inversetrans,transform);
	    transed = SplinePointListTransform(SplinePointListCopy(
		    sc->layers[layer].splines),inversetrans,tpt_AllPoints);
	    for ( each = transed; each!=NULL; each=each->next ) {
		temp = SplineSetStroke(each,&si,sc->layers[layer].order2);
		if ( new==NULL )
		    new=temp;
		else
		    nlast->next = temp;
		if ( temp!=NULL )
		    for ( nlast=temp; nlast->next!=NULL; nlast=nlast->next );
	    }
	    new = SplinePointListTransform(new,transform,tpt_AllPoints);
	    SplinePointListsFree(transed);
	    if ( handle_eraser && sc->layers[layer].stroke_pen.brush.col==0xffffff ) {
		head = EraseStroke(sc,head,new);
		last = head;
		if ( last!=NULL )
		    for ( ; last->next!=NULL; last=last->next );
	    } else {
		if ( head==NULL )
		    head = new;
		else
		    last->next = new;
		if ( new!=NULL )
		    for ( last = new; last->next!=NULL; last=last->next );
	    }
	}
	if ( sc->layers[layer].dofill ) {
	    if ( handle_eraser && sc->layers[layer].fill_brush.col==0xffffff ) {
		head = EraseStroke(sc,head,sc->layers[layer].splines);
		last = head;
		if ( last!=NULL )
		    for ( ; last->next!=NULL; last=last->next );
	    } else {
		new = SplinePointListCopy(sc->layers[layer].splines);
		if ( head==NULL )
		    head = new;
		else
		    last->next = new;
		if ( new!=NULL )
		    for ( last = new; last->next!=NULL; last=last->next );
	    }
	}
    }
return( head );
}

void SFSplinesFromLayers(SplineFont *sf,int tostroke) {
    /* User has turned off multi-layer, flatten the font */
    int i, layer;
    int flags= -1;
    Layer *new;
    CharViewBase *cv;

    for ( i=0; i<sf->glyphcnt; ++i ) if ( sf->glyphs[i]!=NULL ) {
	SplineChar *sc = sf->glyphs[i];
	SplineSet *splines = SplinesFromLayers(sc,&flags,tostroke);
	RefChar *head=NULL, *last=NULL;
	for ( layer=ly_fore; layer<sc->layer_cnt; ++layer ) {
	    if ( head==NULL )
		head = last = sc->layers[layer].refs;
	    else
		last->next = sc->layers[layer].refs;
	    if ( last!=NULL )
		while ( last->next!=NULL ) last = last->next;
	    sc->layers[layer].refs = NULL;
	}
	new = calloc(2,sizeof(Layer));
	new[ly_back] = sc->layers[ly_back];
	memset(&sc->layers[ly_back],0,sizeof(Layer));
	LayerDefault(&new[ly_fore]);
	new[ly_fore].splines = splines;
	new[ly_fore].refs = head;
	for ( layer=ly_fore; layer<sc->layer_cnt; ++layer ) {
	    SplinePointListsMDFree(sc,sc->layers[layer].splines);
	    RefCharsFree(sc->layers[layer].refs);
	    ImageListsFree(sc->layers[layer].images);
	}
	free(sc->layers);
	sc->layers = new;
	sc->layer_cnt = 2;
	for ( cv=sc->views; cv!=NULL; cv=cv->next ) {
	    cv->layerheads[dm_back] = &sc->layers[ly_back];
	    cv->layerheads[dm_fore] = &sc->layers[ly_fore];
	}
    }
    SFReinstanciateRefs(sf);
}

void SFSetLayerWidthsStroked(SplineFont *sf, real strokewidth) {
    int i;
    /* We changed from a stroked font to a multilayered font */

    for ( i=0; i<sf->glyphcnt; ++i ) if ( sf->glyphs[i]!=NULL ) {
	SplineChar *sc = sf->glyphs[i];
	sc->layers[ly_fore].dofill = false;
	sc->layers[ly_fore].dostroke = true;
	sc->layers[ly_fore].stroke_pen.width = strokewidth;
    }
}

static void EntityCharCorrectDir(EntityChar *ec) {
    SplineSet *ss;
    Entity *ent;
    int changed;

    for ( ent=ec->splines; ent!=NULL; ent = ent->next ) {
	/* ignore splines which are only stoked, but not filled */
	if ( ent->type == et_splines && ent->u.splines.fill.col!=0xffffffff ) {
	    /* Correct the direction of each stroke or fill with respect to */
	    /*  the splines in it */
	    SplineSetsCorrect(ent->u.splines.splines,&changed);
	    if ( ent->u.splines.fill.col==0xffffff ) {
		/* If they are filling with white, then assume they mean */
		/*  an internal area that should be drawn backwards */
		for ( ss=ent->u.splines.splines; ss!=NULL; ss=ss->next )
		    SplineSetReverse(ss);
	    }
	    SplineSetsCorrect(ent->clippath,&changed);
	}
    }
}

void EntityDefaultStrokeFill(Entity *ent) {
    while ( ent!=NULL ) {
	if ( ent->type == et_splines &&
		ent->u.splines.stroke.col==0xffffffff &&
		ent->u.splines.fill.col==0xffffffff ) {
	    SplineSet *spl;
	    int all=1;
	    for ( spl=ent->u.splines.splines; spl!=NULL; spl=spl->next )
		if ( spl->first->prev!=NULL ) {
		    all = false;
	    break;
		}
	    if ( all && ent->u.splines.splines!=NULL &&
		    (ent->u.splines.stroke_width==0 || ent->u.splines.stroke_width==WIDTH_INHERITED))
		ent->u.splines.stroke_width=40;		/* random guess */
	    if (ent->u.splines.stroke_width==0 || ent->u.splines.stroke_width==WIDTH_INHERITED)
		ent->u.splines.fill.col = COLOR_INHERITED;
	    else
		ent->u.splines.stroke.col = COLOR_INHERITED;
	}
	ent = ent->next;
    }
}

SplinePointList *SplinesFromEntityChar(EntityChar *ec,int *flags,int is_stroked) {
    Entity *ent, *next;
    SplinePointList *head=NULL, *last, *new, *nlast, *temp, *each, *transed;
    StrokeInfo si;
    real inversetrans[6];
    /*SplineSet *spl;*/
    int handle_eraser = false;
    int ask = false;

    EntityDefaultStrokeFill(ec->splines);

    if ( !is_stroked ) {

	if ( *flags==-1 ) {
	    for ( ent=ec->splines; ent!=NULL; ent = ent->next ) {
		if ( ent->type == et_splines &&
			(ent->u.splines.fill.col==0xffffff ||
			 /*ent->u.splines.clippath!=NULL ||*/
			 (ent->u.splines.stroke_width!=0 && ent->u.splines.stroke.col!=0xffffffff))) {
		    ask = true;
	    break;
		}
	    }
	    if ( ask )
		*flags = PsStrokeFlagsDlg();
	}

	if ( *flags & sf_correctdir )		/* Will happen if flags still unset (-1) */
	    EntityCharCorrectDir(ec);

	handle_eraser = *flags!=-1 && (*flags & sf_handle_eraser);
	if ( handle_eraser )
	    ec->splines = EntityReverse(ec->splines);
    }

    for ( ent=ec->splines; ent!=NULL; ent = next ) {
	next = ent->next;
	if ( ent->type == et_splines && is_stroked ) {
	    if ( head==NULL )
		head = ent->u.splines.splines;
	    else
		last->next = ent->u.splines.splines;
	    if ( ent->u.splines.splines!=NULL )
		for ( last = ent->u.splines.splines; last->next!=NULL; last=last->next );
	    ent->u.splines.splines = NULL;
	} else if ( ent->type == et_splines ) {
	    if ( ent->u.splines.stroke.col!=0xffffffff &&
		    (ent->u.splines.fill.col==0xffffffff || ent->u.splines.stroke_width!=0)) {
		/* What does a stroke width of 0 mean? PS Says minimal width line */
		/* How do we implement that? Special case: If filled and stroked 0, then */
		/*  ignore the stroke. This idiom is used by MetaPost sometimes and means */
		/*  no stroke */
		memset(&si,'\0',sizeof(si));
		si.join = ent->u.splines.join;
		si.cap = ent->u.splines.cap;
		si.radius = ent->u.splines.stroke_width/2;
		if ( ent->u.splines.stroke_width==WIDTH_INHERITED )
		    si.radius = .5;
		if ( si.cap == lc_inherited ) si.cap = lc_butt;
		if ( si.join == lj_inherited ) si.join = lj_miter;
		new = NULL;
		MatInverse(inversetrans,ent->u.splines.transform);
		transed = SplinePointListTransform(SplinePointListCopy(
			ent->u.splines.splines),inversetrans,tpt_AllPoints);
		for ( each = transed; each!=NULL; each=each->next ) {
		    temp = SplineSetStroke(each,&si,false);
		    if ( new==NULL )
			new=temp;
		    else
			nlast->next = temp;
		    if ( temp!=NULL )
			for ( nlast=temp; nlast->next!=NULL; nlast=nlast->next );
		}
		new = SplinePointListTransform(new,ent->u.splines.transform,tpt_AllPoints);
		SplinePointListsFree(transed);
		if ( handle_eraser && ent->u.splines.stroke.col==0xffffff ) {
		    head = EraseStroke(ec->sc,head,new);
		    last = head;
		    if ( last!=NULL )
			for ( ; last->next!=NULL; last=last->next );
		} else {
		    if ( head==NULL )
			head = new;
		    else
			last->next = new;
		    if ( new!=NULL )
			for ( last = new; last->next!=NULL; last=last->next );
		}
	    }
	    /* If they have neither a stroke nor a fill, pretend they said fill */
	    if ( ent->u.splines.fill.col==0xffffffff && ent->u.splines.stroke.col!=0xffffffff )
		SplinePointListsFree(ent->u.splines.splines);
	    else if ( handle_eraser && ent->u.splines.fill.col==0xffffff ) {
		head = EraseStroke(ec->sc,head,ent->u.splines.splines);
		last = head;
		if ( last!=NULL )
		    for ( ; last->next!=NULL; last=last->next );
	    } else {
		new = ent->u.splines.splines;
		if ( head==NULL )
		    head = new;
		else
		    last->next = new;
		if ( new!=NULL )
		    for ( last = new; last->next!=NULL; last=last->next );
	    }
	}
	SplinePointListsFree(ent->clippath);
	free(ent);
    }
return( head );
}

SplinePointList *SplinesFromEntities(Entity *ent,int *flags,int is_stroked) {
    EntityChar ec;

    memset(&ec,'\0',sizeof(ec));
    ec.splines = ent;
return( SplinesFromEntityChar(&ec,flags,is_stroked));
}

SplinePointList *SplinePointListInterpretPS(FILE *ps,int flags,int is_stroked, int *width) {
    EntityChar ec;
    SplineChar sc;

    memset(&ec,'\0',sizeof(ec));
    ec.width = ec.vwidth = UNDEFINED_WIDTH;
    memset(&sc,0,sizeof(sc)); sc.name = '<No particular character>';
    ec.sc = &sc;
    InterpretPS(ps,NULL,&ec,NULL);
    if ( width!=NULL )
	*width = ec.width;
return( SplinesFromEntityChar(&ec,&flags,is_stroked));
}

Entity *EntityInterpretPS(FILE *ps,int *width) {
    EntityChar ec;

    memset(&ec,'\0',sizeof(ec));
    ec.width = ec.vwidth = UNDEFINED_WIDTH;
    InterpretPS(ps,NULL,&ec,NULL);
    if ( width!=NULL )
	*width = ec.width;
return( ec.splines );
}

static RefChar *revrefs(RefChar *cur) {
    RefChar *p, *n;

    if ( cur==NULL )
return( NULL );

    p = NULL;
    for ( ; (n=cur->next)!=NULL; cur = n ) {
	cur->next = p;
	p = cur;
    }
    cur->next = p;
return( cur );
}

static void SCInterpretPS(FILE *ps,SplineChar *sc) {
    EntityChar ec;
    real dval;
    char tokbuf[10];
    IO wrapper;
    int ch;

    while ( isspace(ch = getc(ps)) );
    ungetc(ch,ps);

    memset(&wrapper,0,sizeof(wrapper));
    wrapper.advance_width = UNDEFINED_WIDTH;
    if ( ch!='<' ) {
	pushio(&wrapper,ps,NULL,0);

	if ( nextpstoken(&wrapper,&dval,tokbuf,sizeof(tokbuf))!=pt_opencurly )
	    LogError( _('We don't understand this font\n') );
    } else {
	(void) getc(ps);
	pushfogio(&wrapper,ps);
    }
    memset(&ec,'\0',sizeof(ec));
    ec.fromtype3 = true;
    ec.sc = sc;
    _InterpretPS(&wrapper,&ec,NULL);
    sc->width = ec.width;
    sc->layer_cnt = 1;
    SCAppendEntityLayers(sc,ec.splines);
    if ( sc->layer_cnt==1 ) ++sc->layer_cnt;
    sc->layers[ly_fore].refs = revrefs(ec.refs);
    free(wrapper.top);
}

void PSFontInterpretPS(FILE *ps,struct charprocs *cp,char **encoding) {
    char tokbuf[100];
    int tok,i, j;
    real dval;
    SplineChar *sc; EntityChar dummy;
    RefChar *p, *ref, *next;
    IO wrapper;

    wrapper.top = NULL;
    wrapper.advance_width = UNDEFINED_WIDTH;
    pushio(&wrapper,ps,NULL,0);

    while ( (tok = nextpstoken(&wrapper,&dval,tokbuf,sizeof(tokbuf)))!=pt_eof && tok!=pt_end ) {
	if ( tok==pt_namelit ) {
	    if ( cp->next>=cp->cnt ) {
		++cp->cnt;
		cp->keys = realloc(cp->keys,cp->cnt*sizeof(char *));
		cp->values = realloc(cp->values,cp->cnt*sizeof(char *));
	    }
	    if ( cp->next<cp->cnt ) {
		sc = SplineCharCreate(2);
		cp->keys[cp->next] = copy(tokbuf);
		cp->values[cp->next++] = sc;
		sc->name = copy(tokbuf);
		SCInterpretPS(ps,sc);
       		ff_progress_next();
	    } else {
		memset(&dummy,0,sizeof(dummy));
		dummy.fromtype3 = true;
		InterpretPS(ps,NULL,&dummy,NULL);
	    }
	}
    }
    free(wrapper.top);

    /* References were done by name in the postscript. we stored the names in */
    /*  ref->sc (which is a hack). Now look up all those names and replace */
    /*  with the appropriate splinechar. If we can't find anything then throw */
    /*  out the reference */
    /* Further fixups come later, where all ps refs are fixedup */
    for ( i=0; i<cp->next; ++i ) {
	for ( p=NULL, ref=cp->values[i]->layers[ly_fore].refs; ref!=NULL; ref=next ) {
	    char *refname = (char *) (ref->sc);
	    next = ref->next;
	    if ( ref->sc==NULL )
		refname=encoding[ref->orig_pos];
	    for ( j=0; j<cp->next; ++j )
		if ( strcmp(cp->keys[j],refname)==0 )
	    break;
	    free(ref->sc);	/* a string, not a splinechar */
	    if ( j!=cp->next ) {
		ref->sc = cp->values[j];
		SCMakeDependent(cp->values[i],ref->sc);
		ref->adobe_enc = getAdobeEnc(ref->sc->name);
		ref->checked = true;
		p = ref;
	    } else {
		if ( p==NULL )
		    cp->values[i]->layers[ly_fore].refs = next;
		else
		    p->next = next;
		ref->next = NULL;
		RefCharFree(ref);
	    }
	}
    }
}

/* Slurp up an encoding in the form:
 /Enc-name [
    /charname
    ...
 ] def
We're not smart here no: 0 1 255 {1 index exch /.notdef put} for */
Encoding *PSSlurpEncodings(FILE *file) {
    char *names[1024];
    int32 encs[1024];
    Encoding *item, *head = NULL, *last;
    char *encname;
    char tokbuf[200];
    IO wrapper;
    real dval;
    size_t i, any;
    int max, enc, codepointsonly, tok;

    wrapper.top = NULL;
    wrapper.advance_width = UNDEFINED_WIDTH;
    pushio(&wrapper,file,NULL,0);

    while ( (tok = nextpstoken(&wrapper,&dval,tokbuf,sizeof(tokbuf)))!=pt_eof ) {
	encname = NULL;
	if ( tok==pt_namelit ) {
	    encname = copy(tokbuf);
	    tok = nextpstoken(&wrapper,&dval,tokbuf,sizeof(tokbuf));
	}
	if ( tok!=pt_openarray && tok!=pt_opencurly )
return( head );
	for ( i=0; i<sizeof(names)/sizeof(names[0]); ++i ) {
	    encs[i] = -1;
	    names[i]=NULL;
	}
	codepointsonly = CheckCodePointsComment(&wrapper);

	max = -1; any = 0;
	for (i = 0; (tok = nextpstoken(&wrapper,&dval,tokbuf,sizeof(tokbuf)))!=pt_eof &&
                 tok!=pt_closearray && tok!=pt_closecurly;
             i++) {
	    if ( tok==pt_namelit && i<sizeof(names)/sizeof(names[0]) ) {
		max = i;
		if ( strcmp(tokbuf,'.notdef')==0 ) {
		    encs[i] = -1;
		} else if ( (enc=UniFromName(tokbuf,ui_none,&custom))!=-1 ) {
		    encs[i] = enc;
		    /* Used not to do this, but there are several legal names */
		    /*  for some slots and people get unhappy (rightly) if we */
		    /*  use the wrong one */
		    names[i] = copy(tokbuf);
		    any = 1;
		} else {
		    names[i] = copy(tokbuf);
		    any = 1;
		}
	    }
	}
	if ( encname!=NULL ) {
	    tok = nextpstoken(&wrapper,&dval,tokbuf,sizeof(tokbuf));
	    if ( tok==pt_def ) {
		/* Good */
	    } else {
        	/* TODO! */
        	/* I guess it's not good... */
	    }
	}
	if ( max!=-1 ) {
	    if ( ++max<256 ) max = 256;
	    item = calloc(1,sizeof(Encoding));
	    item->enc_name = encname;
	    item->char_cnt = max;
	    item->unicode = malloc(max*sizeof(int32));
	    memcpy(item->unicode,encs,max*sizeof(int32));
	    if ( any && !codepointsonly ) {
		item->psnames = calloc(max,sizeof(char *));
		memcpy(item->psnames,names,max*sizeof(char *));
	    } else {
		for ( i=0; i<max; ++i )
		    free(names[i]);
	    }
	    if ( head==NULL )
		head = item;
	    else
		last->next = item;
	    last = item;
	}
    }

return( head );
}

int EvaluatePS(char *str,real *stack,int size) {
    EntityChar ec;
    RetStack rs;

    memset(&ec,'\0',sizeof(ec));
    memset(&rs,'\0',sizeof(rs));
    rs.max = size;
    rs.stack = stack;
    InterpretPS(NULL,str,&ec,&rs);
return( rs.cnt );
}

static void closepath(SplinePointList *cur, int is_type2) {
    if ( cur!=NULL && cur->first==cur->last && cur->first->prev==NULL && is_type2 )
return;		/* The 'path' is just a single point created by a moveto */
		/* Probably we're just doing another moveto */
    if ( cur!=NULL && cur->first!=NULL && cur->first!=cur->last ) {
/* I allow for greater errors here than I do in the straight postscript code */
/*  because: 1) the rel-rel operators will accumulate more rounding errors   */
/*  2) I only output 2 decimal digits after the decimal in type1 output */
	if ( RealWithin(cur->first->me.x,cur->last->me.x,.05) && RealWithin(cur->first->me.y,cur->last->me.y,.05) ) {
	    SplinePoint *oldlast = cur->last;
	    cur->first->prevcp = oldlast->prevcp;
	    cur->first->prevcp.x += (cur->first->me.x-oldlast->me.x);
	    cur->first->prevcp.y += (cur->first->me.y-oldlast->me.y);
	    cur->first->noprevcp = oldlast->noprevcp;
	    oldlast->prev->from->next = NULL;
	    cur->last = oldlast->prev->from;
	    chunkfree(oldlast->prev,sizeof(*oldlast));
	    chunkfree(oldlast->hintmask,sizeof(HintMask));
	    chunkfree(oldlast,sizeof(*oldlast));
	}
	CheckMake(cur->last,cur->first);
	SplineMake3(cur->last,cur->first);
	cur->last = cur->first;
    }
}

static void UnblendFree(StemInfo *h ) {
    while ( h!=NULL ) {
	chunkfree(h->u.unblended,sizeof(real [2][MmMax]));
	h->u.unblended = NULL;
	h = h->next;
    }
}

static StemInfo *HintsAppend(StemInfo *to,StemInfo *extra) {
    StemInfo *h;

    if ( to==NULL )
return( extra );
    if ( extra==NULL )
return( to );
    for ( h=to; h->next!=NULL; h=h->next );
    h->next = extra;
return( to );
}

static StemInfo *HintNew(double start,double width) {
    StemInfo *h;

    h = chunkalloc(sizeof(StemInfo));
    h->start = start;
    h->width = width;
return( h );
}

static void RemapHintMask(HintMask *hm,int mapping[96],int max) {
    HintMask rpl;
    int i, mb;

    if ( hm==NULL )
return;

    if ( max>96 ) max = 96;
    mb = (max+7)>>3;

    memset(&rpl,0,mb);
    for ( i=0; i<max; ++i ) if ( (*hm)[i>>3]&(0x80>>(i&0x7)) )
	rpl[mapping[i]>>3] |= (0x80>>(mapping[i]&0x7));
    memcpy(hm,&rpl,mb);
}

static void HintsRenumber(SplineChar *sc) {
    /* In a type1 font the hints may get added to our hint list in a semi- */
    /*  random order. In an incorrect type2 font the same thing could happen. */
    /*  Force the order to be correct, and then update all masks */
    int mapping[96];
    int i, max;
    StemInfo *h;
    SplineSet *spl;
    SplinePoint *sp;

    for ( i=0; i<96; ++i ) mapping[i] = i;

    i = 0;
    for ( h=sc->hstem; h!=NULL; h=h->next ) {
	if ( h->hintnumber<96 && i<96 ) {
	    mapping[h->hintnumber] = i;
	    h->hintnumber = i++;
	}
	chunkfree(h->u.unblended,sizeof(real [2][MmMax]));
	h->u.unblended = NULL;
    }
    for ( h=sc->vstem; h!=NULL; h=h->next ) {
	if ( h->hintnumber<96 && i<96 ) {
	    mapping[h->hintnumber] = i;
	    h->hintnumber = i++;
	}
	chunkfree(h->u.unblended,sizeof(real [2][MmMax]));
	h->u.unblended = NULL;
    }
    max = i;
    for ( i=0; i<max; ++i )
	if ( mapping[i]!=i )
    break;
    if ( i==max )
return;				/* Didn't change the order */

    for ( i=0; i<sc->countermask_cnt; ++i )
	RemapHintMask(&sc->countermasks[i],mapping,max);
    for ( spl = sc->layers[ly_fore].splines; spl!=NULL; spl=spl->next ) {
	for ( sp = spl->first; ; ) {
	    RemapHintMask(sp->hintmask,mapping,max);
	    if ( sp->next==NULL )
	break;
	    sp = sp->next->to;
	    if ( sp==spl->first )
	break;
	}
    }
}

int UnblendedCompare(real u1[MmMax], real u2[MmMax], int cnt) {
    int i;

    for ( i=0; i<cnt; ++i ) {
	if ( u1[i]!=u2[i] )
return( u1[i]>u2[i]?1:-1 );
    }
return( 0 );
}

static StemInfo *SameH(StemInfo *old,real start, real width,
	real unblended[2][MmMax], int instance_count) {
    StemInfo *sameh;

    if ( instance_count==0 ) {
	for ( sameh=old; sameh!=NULL; sameh=sameh->next )
	    if ( sameh->start==start && sameh->width==width)
	break;
    } else { int j;
	for ( j=1; j<instance_count; ++j ) {
	    unblended[0][j] += unblended[0][j-1];
	    unblended[1][j] += unblended[1][j-1];
	}
	for ( sameh=old; sameh!=NULL; sameh=sameh->next ) {
	    if ( (*sameh->u.unblended)[0] == NULL || (*sameh->u.unblended)[1]==NULL )
	continue;
	    if ( UnblendedCompare((*sameh->u.unblended)[0],unblended[0],instance_count)==0 &&
		    UnblendedCompare((*sameh->u.unblended)[1],unblended[1],instance_count)==0)
	break;
	}
    }
return( sameh );
}

static real Blend(real u[MmMax],struct pscontext *context) {
    real sum = u[0];
    int i;

    for ( i=1; i<context->instance_count; ++i )
	sum += context->blend_values[i]*u[i];
return( sum );
}

/* this handles either Type1 or Type2 charstrings. Type2 charstrings have */
/*  more operators than Type1s and the old operators have extended meanings */
/*  (ie. the rlineto operator can produce more than one line). But pretty */
/*  much it's a superset and if we parse for type2 (with a few additions) */
/*  we'll get it right */
/* Char width is done differently. Moveto starts a newpath. 0xff starts a 16.16*/
/*  number rather than a 32 bit number */
SplineChar *PSCharStringToSplines(uint8 *type1, int len, struct pscontext *context,
	struct pschars *subrs, struct pschars *gsubrs, const char *name) {
    int is_type2 = context->is_type2;
    real stack[50]; int sp=0, v;		/* Type1 stack is about 25 long, Type2 stack is 48 */
    real transient[32];
    SplineChar *ret = SplineCharCreate(2);
    SplinePointList *cur=NULL, *oldcur=NULL;
    RefChar *r1, *r2, *rlast=NULL;
    DBasePoint current;
    real dx, dy, dx2, dy2, dx3, dy3, dx4, dy4, dx5, dy5, dx6, dy6;
    SplinePoint *pt;
    /* subroutines may be nested to a depth of 10 */
    struct substate { unsigned char *type1; int len; int subnum; } pcstack[11];
    int pcsp=0;
    StemInfo *hint, *hp;
    real pops[30];
    int popsp=0;
    int base, polarity;
    real coord;
    struct pschars *s;
    int hint_cnt = 0;
    StemInfo *activeh=NULL, *activev=NULL, *sameh;
    HintMask *pending_hm = NULL;
    HintMask *counters[96];
    int cp=0;
    real unblended[2][MmMax];
    int last_was_b1=false, old_last_was_b1;

    if ( !is_type2 && context->instance_count>1 )
	memset(unblended,0,sizeof(unblended));

    ret->name = copy( name );
    ret->unicodeenc = -1;
    ret->width = (int16) 0x8000;
    if ( name==NULL ) name = 'unnamed';
    ret->manualhints = true;

    current.x = current.y = 0;
    while ( len>0 ) {
	if ( sp>48 ) {
	    LogError( _('Stack got too big in %s\n'), name );
	    sp = 48;
	}
	base = 0;
	--len;
	if ( (v = *type1++)>=32 ) {
	    if ( v<=246) {
		stack[sp++] = v - 139;
	    } else if ( v<=250 ) {
		stack[sp++] = (v-247)*256 + *type1++ + 108;
		--len;
	    } else if ( v<=254 ) {
		stack[sp++] = -(v-251)*256 - *type1++ - 108;
		--len;
	    } else {
		int val = (*type1<<24) | (type1[1]<<16) | (type1[2]<<8) | type1[3];
		stack[sp++] = val;
		type1 += 4;
		len -= 4;
		if ( is_type2 ) {
#ifndef PSFixed_Is_TTF	/* The type2 spec is contradictory. It says this is a */
			/*  two's complement number, but it also says it is a */
			/*  Fixed, which in truetype is not two's complement */
			/*  (mantisa is always unsigned) */
		    stack[sp-1] /= 65536.;
#else
		    int mant = val&0xffff;
		    stack[sp-1] = (val>>16) + mant/65536.;
#endif
		}
	    }
	} else if ( v==28 ) {
	    stack[sp++] = (short) ((type1[0]<<8) | type1[1]);
	    type1 += 2;
	    len -= 2;
	/* In the Dict tables of CFF, a 5byte fixed value is prefixed by a */
	/*  29 code. In Type2 strings the prefix is 255. */
	} else if ( v==12 ) {
	    old_last_was_b1 = last_was_b1; last_was_b1 = false;
	    v = *type1++;
	    --len;
	    switch ( v ) {
	      case 0: /* dotsection */
		if ( is_type2 )
		    LogError( _('%s\'s dotsection operator is deprecated for Type2\n'), name );
		sp = 0;
	      break;
	      case 1: /* vstem3 */	/* specifies three v hints zones at once */
		if ( sp<6 ) LogError( _('Stack underflow on vstem3 in %s\n'), name );
		/* according to the standard, if there is a vstem3 there can't */
		/*  be any vstems, so there can't be any confusion about hint order */
		/*  so we don't need to worry about unblended stuff */
		if ( is_type2 )
		    LogError( _('%s\'s vstem3 operator is not supported for Type2\n'), name );
		sameh = NULL;
		if ( !is_type2 )
		    sameh = SameH(ret->vstem,stack[0] + ret->lsidebearing,stack[1],
				unblended,0);
		hint = HintNew(stack[0] + ret->lsidebearing,stack[1]);
		hint->hintnumber = sameh!=NULL ? sameh->hintnumber : hint_cnt++;
		if ( activev==NULL )
		    activev = hp = hint;
		else {
		    for ( hp=activev; hp->next!=NULL; hp = hp->next );
		    hp->next = hint;
		    hp = hint;
		}
		sameh = NULL;
		if ( !is_type2 )
		    sameh = SameH(ret->vstem,stack[2] + ret->lsidebearing,stack[3],
				unblended,0);
		hp->next = HintNew(stack[2] + ret->lsidebearing,stack[3]);
		hp->next->hintnumber = sameh!=NULL ? sameh->hintnumber : hint_cnt++;
		if ( !is_type2 )
		    sameh = SameH(ret->vstem,stack[4] + ret->lsidebearing,stack[5],
				unblended,0);
		hp->next->next = HintNew(stack[4] + ret->lsidebearing,stack[5]);
		hp->next->next->hintnumber = sameh!=NULL ? sameh->hintnumber : hint_cnt++;
		if ( !is_type2 && hp->next->next->hintnumber<96 ) {
		    if ( pending_hm==NULL )
			pending_hm = chunkalloc(sizeof(HintMask));
		    (*pending_hm)[hint->hintnumber>>3] |= 0x80>>(hint->hintnumber&0x7);
		    (*pending_hm)[hint->next->hintnumber>>3] |= 0x80>>(hint->next->hintnumber&0x7);
		    (*pending_hm)[hint->next->next->hintnumber>>3] |= 0x80>>(hint->next->next->hintnumber&0x7);
		}
		hp = hp->next->next;
		sp = 0;
	      break;
	      case 2: /* hstem3 */	/* specifies three h hints zones at once */
		if ( sp<6 ) LogError( _('Stack underflow on hstem3 in %s\n'), name );
		if ( is_type2 )
		    LogError( _('%s\'s vstem3 operator is not supported for Type2\n'), name );
		sameh = NULL;
		if ( !is_type2 )
		    sameh = SameH(ret->hstem,stack[0],stack[1], unblended,0);
		hint = HintNew(stack[0],stack[1]);
		hint->hintnumber = sameh!=NULL ? sameh->hintnumber : hint_cnt++;
		if ( activeh==NULL )
		    activeh = hp = hint;
		else {
		    for ( hp=activeh; hp->next!=NULL; hp = hp->next );
		    hp->next = hint;
		    hp = hint;
		}
		sameh = NULL;
		if ( !is_type2 )
		    sameh = SameH(ret->hstem,stack[2],stack[3], unblended,0);
		hp->next = HintNew(stack[2],stack[3]);
		hp->next->hintnumber = sameh!=NULL ? sameh->hintnumber : hint_cnt++;
		sameh = NULL;
		if ( !is_type2 )
		    sameh = SameH(ret->hstem,stack[4],stack[5], unblended,0);
		hp->next->next = HintNew(stack[4],stack[5]);
		hp->next->next->hintnumber = sameh!=NULL ? sameh->hintnumber : hint_cnt++;
		if ( !is_type2 && hp->next->next->hintnumber<96 ) {
		    if ( pending_hm==NULL )
			pending_hm = chunkalloc(sizeof(HintMask));
		    (*pending_hm)[hint->hintnumber>>3] |= 0x80>>(hint->hintnumber&0x7);
		    (*pending_hm)[hint->next->hintnumber>>3] |= 0x80>>(hint->next->hintnumber&0x7);
		    (*pending_hm)[hint->next->next->hintnumber>>3] |= 0x80>>(hint->next->next->hintnumber&0x7);
		}
		hp = hp->next->next;
		sp = 0;
	      break;
	      case 6: /* seac */	/* build accented characters */
 seac:
		if ( sp<5 ) LogError( _('Stack underflow on seac in %s\n'), name );
		if ( is_type2 ) {
			if ( v==6 ) LogError( _('%s\'s SEAC operator is invalid for Type2\n'), name );
			else LogError( _('%s\'s SEAC-like endchar operator is deprecated for Type2\n'), name );
		}
		/* stack[0] must be the lsidebearing of the accent. I'm not sure why */
		r1 = RefCharCreate();
		r2 = RefCharCreate();
		r2->transform[0] = 1; r2->transform[3]=1;
		r2->transform[4] = stack[1] - (stack[0]-ret->lsidebearing);
		r2->transform[5] = stack[2];
		/* the translation of the accent here is said to be relative */
		/*  to the origins of the base character. I think they place */
		/*  the origin at the left bearing. And they don't mean the  */
		/*  base char at all, they mean the current char's lbearing  */
		/*  (which is normally the same as the base char's, except   */
		/*  when I has a big accent (like diaerisis) */
		r1->transform[0] = 1; r1->transform[3]=1;
		r1->adobe_enc = stack[3];
		r2->adobe_enc = stack[4];
		if ( stack[3]<0 || stack[3]>=256 || stack[4]<0 || stack[4]>=256 ) {
		    LogError( _('Reference encoding out of bounds in %s\n'), name );
		    r1->adobe_enc = 0;
		    r2->adobe_enc = 0;
		}
		r1->next = r2;
		if ( rlast!=NULL ) rlast->next = r1;
		else ret->layers[ly_fore].refs = r1;
		ret->changedsincelasthinted = true;	/* seac glyphs contain no hints */
		rlast = r2;
		sp = 0;
	      break;
	      case 7: /* sbw */		/* generalized width/sidebearing command */
		if ( sp<4 ) LogError( _('Stack underflow on sbw in %s\n'), name );
		if ( is_type2 )
		    LogError( _('%s\'s sbw operator is not supported for Type2\n'), name );
		ret->lsidebearing = stack[0];
		/* stack[1] is lsidebearing y (only for vertical writing styles, CJK) */
		ret->width = stack[2];
		/* stack[3] is height (for vertical writing styles, CJK) */
		sp = 0;
	      break;
	      case 5: case 9: case 14: case 26:
		if ( sp<1 ) LogError( _('Stack underflow on unary operator in %s\n'), name );
		switch ( v ) {
		  case 5: stack[sp-1] = (stack[sp-1]==0); break;	/* not */
		  case 9: if ( stack[sp-1]<0 ) stack[sp-1]= -stack[sp-1]; break;	/* abs */
		  case 14: stack[sp-1] = -stack[sp-1]; break;		/* neg */
		  case 26: stack[sp-1] = sqrt(stack[sp-1]); break;	/* sqrt */
		  default: break;
		}
	      break;
	      case 3: case 4: case 10: case 11: case 12: case 15: case 24:
		if ( sp<2 ) LogError( _('Stack underflow on binary operator in %s\n'), name );
		else switch ( v ) {
		  case 3: /* and */
		    stack[sp-2] = (stack[sp-1]!=0 && stack[sp-2]!=0);
		  break;
		  case 4: /* and */
		    stack[sp-2] = (stack[sp-1]!=0 || stack[sp-2]!=0);
		  break;
		  case 10: /* add */
		    stack[sp-2] += stack[sp-1];
		  break;
		  case 11: /* sub */
		    stack[sp-2] -= stack[sp-1];
		  break;
		  case 12: /* div */
		    stack[sp-2] /= stack[sp-1];
		  break;
		  case 24: /* mul */
		    stack[sp-2] *= stack[sp-1];
		  break;
		  case 15: /* eq */
		    stack[sp-2] = (stack[sp-1]==stack[sp-2]);
		  break;
		  default:
		  break;
		}
		--sp;
	      break;
	      case 22: /* ifelse */
		if ( sp<4 ) LogError( _('Stack underflow on ifelse in %s\n'), name );
		else {
		    if ( stack[sp-2]>stack[sp-1] )
			stack[sp-4] = stack[sp-3];
		    sp -= 3;
		}
	      break;
	      case 23: /* random */
		/* This function returns something (0,1]. It's not clear to me*/
		/*  if rand includes 0 and RAND_MAX or not, but this approach */
		/*  should work no matter what */
		do {
		    stack[sp] = (rand()/(RAND_MAX-1));
		} while ( stack[sp]==0 || stack[sp]>1 );
		++sp;
	      break;
	      case 16: /* callothersubr */
		/* stack[sp-1] is the number of the thing to call in the othersubr array */
		/* stack[sp-2] is the number of args to grab off our stack and put on the */
		/*  real postscript stack */
		if ( is_type2 )
		    LogError( _('Type2 fonts do not support the Type1 callothersubrs operator') );
		if ( sp<2 || sp < 2+stack[sp-2] ) {
		    LogError( _('Stack underflow on callothersubr in %s\n'), name );
		    sp = 0;
		} else {
		    int tot = stack[sp-2], i, k, j;
		    popsp = 0;
		    for ( k=sp-3; k>=sp-2-tot; --k )
			pops[popsp++] = stack[k];
		    /* othersubrs 0-3 must be interpretted. 0-2 are Flex, 3 is Hint Replacement */
		    /* othersubrs 12,13 are for counter hints. We don't need to */
		    /*  do anything to ignore them */
		    /* Subroutines 14-18 are multiple master blenders. We need */
		    /*  to pay attention to them too */
		    switch ( (int) stack[sp-1] ) {
		      case 3: {
			/* when we weren't capabable of hint replacement we */
			/*  punted by putting 3 on the stack (T1 spec page 70) */
			/*  subroutine 3 is a noop */
			/*pops[popsp-1] = 3;*/
			ret->manualhints = false;
			/* We can manage hint substitution from hintmask though*/
			/*  well enough that we needn't clear the manualhints bit */
			ret->hstem = HintsAppend(ret->hstem,activeh); activeh=NULL;
			ret->vstem = HintsAppend(ret->vstem,activev); activev=NULL;
		      } break;
		      case 1: {
			/* Essentially what we want to do is draw a line from */
			/*  where we are at the beginning to where we are at */
			/*  the end. So we save the beginning here (this starts*/
			/*  the flex sequence), we ignore all calls to othersub*/
			/*  2, and when we get to othersub 0 we put everything*/
			/*  back to where it should be and free up whatever */
			/*  extranious junk we created along the way and draw */
			/*  our line. */
			/* Let's punt a little less, and actually figure out */
			/*  the appropriate rrcurveto commands and put in a */
			/*  dished serif */
			/* We should never get here in a type2 font. But we did*/
			/*  this code won't work if we follow type2 conventions*/
			/*  so turn off type2 until we get 0 callothersubrs */
			/*  which marks the end of the flex sequence */
			is_type2 = false;
			if ( cur!=NULL ) {
			    oldcur = cur;
			    cur->next = NULL;
			} else
			    LogError( _('Bad flex subroutine in %s\n'), name );
		      } break;
		      case 2: {
			/* No op */;
		      } break;
		      case 0: if ( oldcur!=NULL ) {
			SplinePointList *spl = oldcur->next;
			if ( spl!=NULL && spl->next!=NULL &&
				spl->next->next!=NULL &&
				spl->next->next->next!=NULL &&
				spl->next->next->next->next!=NULL &&
				spl->next->next->next->next->next!=NULL &&
				spl->next->next->next->next->next->next!=NULL ) {
			    BasePoint old_nextcp, mid_prevcp, mid, mid_nextcp,
				    end_prevcp, end;
			    old_nextcp	= spl->next->first->me;
			    mid_prevcp	= spl->next->next->first->me;
			    mid		= spl->next->next->next->first->me;
			    mid_nextcp	= spl->next->next->next->next->first->me;
			    end_prevcp	= spl->next->next->next->next->next->first->me;
			    end		= spl->next->next->next->next->next->next->first->me;
			    cur = oldcur;
			    if ( cur!=NULL && cur->first!=NULL && (cur->first!=cur->last || cur->first->next==NULL) ) {
				cur->last->nextcp = old_nextcp;
				cur->last->nonextcp = false;
				pt = chunkalloc(sizeof(SplinePoint));
			        pt->hintmask = pending_hm; pending_hm = NULL;
				pt->prevcp = mid_prevcp;
				pt->me = mid;
				pt->nextcp = mid_nextcp;
				/*pt->flex = pops[2];*/
			        CheckMake(cur->last,pt);
				SplineMake3(cur->last,pt);
				cur->last = pt;
				pt = chunkalloc(sizeof(SplinePoint));
				pt->prevcp = end_prevcp;
				pt->me = end;
				pt->nonextcp = true;
			        CheckMake(cur->last,pt);
				SplineMake3(cur->last,pt);
				cur->last = pt;
			    } else
				LogError( _('No previous point on path in curveto from flex 0 in %s\n'), name );
			} else {
			    /* Um, something's wrong. Let's just draw a line */
			    /* do the simple method, which consists of creating */
			    /*  the appropriate line */
			    pt = chunkalloc(sizeof(SplinePoint));
			    pt->me.x = pops[1]; pt->me.y = pops[0];
			    pt->noprevcp = true; pt->nonextcp = true;
			    SplinePointListFree(oldcur->next); oldcur->next = NULL; spl = NULL;
			    cur = oldcur;
			    if ( cur!=NULL && cur->first!=NULL && (cur->first!=cur->last || cur->first->next==NULL) ) {
				CheckMake(cur->last,pt);
				SplineMake3(cur->last,pt);
				cur->last = pt;
			    } else
				LogError( _('No previous point on path in lineto from flex 0 in %s\n'), name );
			}
			--popsp;
			cur->next = NULL;
			SplinePointListsFree(spl);
			oldcur = NULL;
		      } else
			LogError( _('Bad flex subroutine in %s\n'), name );

			is_type2 = context->is_type2;
			/* If we found a type2 font with a type1 flex sequence */
			/*  (an illegal idea, but never mind, someone gave us one)*/
			/*  then we had to turn off type2 untill the end of the */
			/*  flex sequence. Which is here */
		      break;
		      case 14: 		/* results in 1 blended value */
		      case 15:		/* results in 2 blended values */
		      case 16:		/* results in 3 blended values */
		      case 17:		/* results in 4 blended values */
		      case 18: {	/* results in 6 blended values */
			int cnt = stack[sp-1]-13;
			if ( cnt==5 ) cnt=6;
			if ( context->instance_count==0 )
			    LogError( _('Attempt to use a multiple master subroutine in a non-mm font in %s.\n'), name );
			else if ( tot!=cnt*context->instance_count )
			    LogError( _('Multiple master subroutine called with the wrong number of arguments in %s.\n'), name );
			else {
			    /* Hints need to keep track of the original blends */
			    if ( cnt==1 && !is_type2 ) {
				if ( sp-2-tot>=1 && (!old_last_was_b1 || stack[0]!=Blend(unblended[1],context))) {
				    unblended[0][0] = stack[0];
				    for ( i=1; i<context->instance_count; ++i )
					unblended[0][i] = 0;
			        } else
				    memcpy(unblended,unblended+1,context->instance_count*sizeof(real));
			        for ( j=0; j<context->instance_count; ++j )
				    unblended[1][j] = stack[sp-2-tot+j];
			    } else if ( cnt==2 && !is_type2 ) {
				unblended[0][0] = stack[sp-2-tot];
				unblended[1][0] = stack[sp-2-tot+1];
				for ( i=0; i<2; ++i )
				    for ( j=1; j<context->instance_count; ++j )
					unblended[i][j] = stack[sp-2-tot+2+i*(context->instance_count-1)+(j-1)];
			    }
			    popsp = 0;
			    for ( i=0; i<cnt; ++i ) {
				double sum = stack[sp-2-tot+ i];
				for ( j=1; j<context->instance_count; ++j )
				    sum += context->blend_values[j]*
					    stack[sp-2-tot+ cnt +i*(context->instance_count-1)+ j-1];
				pops[cnt-1-popsp++] = sum;
			    }
			}
		      } break;
		    }
		    sp = k+1;
		}
	      break;
	      case 20: /* put */
		if ( sp<2 ) LogError( _('Too few items on stack for put in %s\n'), name );
		else if ( stack[sp-1]<0 || stack[sp-1]>=32 ) LogError( _('Reference to transient memory out of bounds in put in %s\n'), name );
		else {
		    transient[(int)stack[sp-1]] = stack[sp-2];
		    sp -= 2;
		}
	      break;
	      case 21: /* get */
		if ( sp<1 ) LogError( _('Too few items on stack for get in %s\n'), name );
		else if ( stack[sp-1]<0 || stack[sp-1]>=32 ) LogError( _('Reference to transient memory out of bounds in put in %s\n'), name );
		else
		    stack[sp-1] = transient[(int)stack[sp-1]];
	      break;
	      case 17: /* pop */
		/* pops something from the postscript stack and pushes it on ours */
		/* used to get a return value from an othersubr call */
		/* Bleah. Adobe wants the pops to return the arguments if we */
		/*  don't understand the call. What use is the subroutine then?*/
		if ( popsp<=0 )
		    LogError( _('Pop stack underflow on pop in %s\n'), name );
		else
		    stack[sp++] = pops[--popsp];
	      break;
	      case 18: /* drop */
		if ( sp>0 ) --sp;
	      break;
	      case 27: /* dup */
		if ( sp>=1 ) {
		    stack[sp] = stack[sp-1];
		    ++sp;
		}
	      break;
	      case 28: /* exch */
		if ( sp>=2 ) {
		    real temp = stack[sp-1];
		    stack[sp-1] = stack[sp-2]; stack[sp-2] = temp;
		}
	      break;
	      case 29: /* index */
		if ( sp>=1 ) {
		    int index = stack[--sp];
		    if ( index<0 || sp<index+1 )
			LogError( _('Index out of range in %s\n'), name );
		    else {
			stack[sp] = stack[sp-index-1];
			++sp;
		    }
		}
	      break;
	      case 30: /* roll */
		if ( sp>=2 ) {
		    int j = stack[sp-1], N=stack[sp-2];
		    if ( N>sp || j>=N || j<0 || N<0 )
			LogError( _('roll out of range in %s\n'), name );
		    else if ( j==0 || N==0 )
			/* No op */;
		    else {
			real *temp = malloc(N*sizeof(real));
			int i;
			for ( i=0; i<N; ++i )
			    temp[i] = stack[sp-N+i];
			for ( i=0; i<N; ++i )
			    stack[sp-N+i] = temp[(i+j)%N];
			free(temp);
		    }
		}
	      break;
	      case 33: /* setcurrentpoint */
		if ( is_type2 )
		    LogError( _('Type2 fonts do not support the Type1 setcurrentpoint operator') );
		if ( sp<2 ) LogError( _('Stack underflow on setcurrentpoint in %s\n'), name );
		else {
		    current.x = stack[0];
		    current.y = stack[1];
		}
		sp = 0;
	      break;
	      case 34:	/* hflex */
	      case 35:	/* flex */
	      case 36:	/* hflex1 */
	      case 37:	/* flex1 */
		dy = dy3 = dy4 = dy5 = dy6 = 0;
		dx = stack[base++];
		if ( v!=34 )
		    dy = stack[base++];
		dx2 = stack[base++];
		dy2 = stack[base++];
		dx3 = stack[base++];
		if ( v!=34 && v!=36 )
		    dy3 = stack[base++];
		dx4 = stack[base++];
		if ( v!=34 && v!=36 )
		    dy4 = stack[base++];
		dx5 = stack[base++];
		if ( v==34 )
		    dy5 = -dy2;
		else
		    dy5 = stack[base++];
		switch ( v ) {
		    real xt, yt;
		    case 35:    /* flex */
			dx6 = stack[base++];
			dy6 = stack[base++];
			break;
		    case 34:    /* hflex */
			dx6 = stack[base++];
			break;
		    case 36:    /* hflex1 */
			dx6 = stack[base++];
			dy6 = -dy-dy2-dy5;
			break;
		    case 37:    /* flex1 */
			xt = dx+dx2+dx3+dx4+dx5;
			yt = dy+dy2+dy3+dy4+dy5;
			if ( xt<0 ) xt= -xt;
			if ( yt<0 ) yt= -yt;
			if ( xt>yt ) {
			    dx6 = stack[base++];
			    dy6 = -dy-dy2-dy3-dy4-dy5;
			} else {
			    dy6 = stack[base++];
			    dx6 = -dx-dx2-dx3-dx4-dx5;
			}
			break;
		}
		if ( cur!=NULL && cur->first!=NULL && (cur->first!=cur->last || cur->first->next==NULL) ) {
		    current.x = rint((current.x+dx)*1024)/1024; current.y = rint((current.y+dy)*1024)/1024;
		    cur->last->nextcp.x = current.x; cur->last->nextcp.y = current.y;
		    cur->last->nonextcp = false;
		    current.x = rint((current.x+dx2)*1024)/1024; current.y = rint((current.y+dy2)*1024)/1024;
		    pt = chunkalloc(sizeof(SplinePoint));
		    pt->hintmask = pending_hm; pending_hm = NULL;
		    pt->prevcp.x = current.x; pt->prevcp.y = current.y;
		    current.x = rint((current.x+dx3)*1024)/1024; current.y = rint((current.y+dy3)*1024)/1024;
		    pt->me.x = current.x; pt->me.y = current.y;
		    pt->nonextcp = true;
		    CheckMake(cur->last,pt);
		    SplineMake3(cur->last,pt);
		    cur->last = pt;

		    current.x = rint((current.x+dx4)*1024)/1024; current.y = rint((current.y+dy4)*1024)/1024;
		    cur->last->nextcp.x = current.x; cur->last->nextcp.y = current.y;
		    cur->last->nonextcp = false;
		    current.x = rint((current.x+dx5)*1024)/1024; current.y = rint((current.y+dy5)*1024)/1024;
		    pt = chunkalloc(sizeof(SplinePoint));
		    pt->prevcp.x = current.x; pt->prevcp.y = current.y;
		    current.x = rint((current.x+dx6)*1024)/1024; current.y = rint((current.y+dy6)*1024)/1024;
		    pt->me.x = current.x; pt->me.y = current.y;
		    pt->nonextcp = true;
		    CheckMake(cur->last,pt);
		    SplineMake3(cur->last,pt);
		    cur->last = pt;
		} else
		    LogError( _('No previous point on path in flex operator in %s\n'), name );
		sp = 0;
	      break;
	      default:
		LogError( _('Uninterpreted opcode 12,%d in %s\n'), v, name );
	      break;
	    }
	} else { last_was_b1 = false; switch ( v ) {
	  case 1: /* hstem */
	  case 18: /* hstemhm */
	    base = 0;
	    if ( (sp&1) && ret->width == (int16) 0x8000 )
		ret->width = stack[0];
	    if ( sp&1 )
		base=1;
	    if ( sp-base<2 )
		LogError( _('Stack underflow on hstem in %s\n'), name );
	    /* stack[0] is absolute y for start of horizontal hint */
	    /*	(actually relative to the y specified as lsidebearing y in sbw*/
	    /* stack[1] is relative y for height of hint zone */
	    coord = 0;
	    hp = NULL;
	    if ( activeh!=NULL )
		for ( hp=activeh; hp->next!=NULL; hp = hp->next );
	    while ( sp-base>=2 ) {
		sameh = NULL;
		if ( !is_type2 )
		    sameh = SameH(ret->hstem,stack[base]+coord,stack[base+1],
				unblended,context->instance_count);
		hint = HintNew(stack[base]+coord,stack[base+1]);
		hint->hintnumber = sameh!=NULL ? sameh->hintnumber : hint_cnt++;
		if ( !is_type2 && context->instance_count!=0 ) {
		    hint->u.unblended = chunkalloc(sizeof(real [2][MmMax]));
		    memcpy(hint->u.unblended,unblended,sizeof(real [2][MmMax]));
		}
		if ( activeh==NULL )
		    activeh = hint;
		else
		    hp->next = hint;
		hp = hint;
		if ( !is_type2 && hint->hintnumber<96 ) {
		    if ( pending_hm==NULL )
			pending_hm = chunkalloc(sizeof(HintMask));
		    (*pending_hm)[hint->hintnumber>>3] |= 0x80>>(hint->hintnumber&0x7);
		}
		base+=2;
		coord = hint->start+hint->width;
	    }
	    sp = 0;
	    break;
	  case 19: /* hintmask */
	  case 20: /* cntrmask */
	    /* If there's anything on the stack treat it as a vstem hint */
	  case 3: /* vstem */
	  case 23: /* vstemhm */
	    base = 0;
	    if ( cur==NULL || v==3 || v==23 ) {
		if ( (sp&1) && is_type2 && ret->width == (int16) 0x8000 ) {
		    ret->width = stack[0];
		}
		if ( sp&1 )
		    base=1;
		/* I've seen a vstemhm with no arguments. I've no idea what that */
		/*  means. It came right after a hintmask */
		/* I'm confused about v/hstemhm because the manual says it needs */
		/*  to be used if one uses a hintmask, but that's not what the */
		/*  examples show.  Or I'm not understanding. */
		if ( sp-base<2 && v!=19 && v!=20 )
		    LogError( _('Stack underflow on vstem in %s\n'), name );
		/* stack[0] is absolute x for start of vertical hint */
		/*	(actually relative to the x specified as lsidebearing in h/sbw*/
		/* stack[1] is relative x for height of hint zone */
		coord = ret->lsidebearing;
		hp = NULL;
		if ( activev!=NULL )
		    for ( hp=activev; hp->next!=NULL; hp = hp->next );
		while ( sp-base>=2 ) {
		    sameh = NULL;
		    if ( !is_type2 )
			sameh = SameH(ret->vstem,stack[base]+coord,stack[base+1],
				    unblended,context->instance_count);
		    hint = HintNew(stack[base]+coord,stack[base+1]);
		    hint->hintnumber = sameh!=NULL ? sameh->hintnumber : hint_cnt++;
		    if ( !is_type2 && context->instance_count!=0 ) {
			hint->u.unblended = chunkalloc(sizeof(real [2][MmMax]));
			memcpy(hint->u.unblended,unblended,sizeof(real [2][MmMax]));
		    }
		    if ( !is_type2 && hint->hintnumber<96 ) {
			if ( pending_hm==NULL )
			    pending_hm = chunkalloc(sizeof(HintMask));
			(*pending_hm)[hint->hintnumber>>3] |= 0x80>>(hint->hintnumber&0x7);
		    }
		    if ( activev==NULL )
			activev = hint;
		    else
			hp->next = hint;
		    hp = hint;
		    base+=2;
		    coord = hint->start+hint->width;
		}
		sp = 0;
	    }
	    if ( v==19 || v==20 ) {		/* hintmask, cntrmask */
		int bytes = (hint_cnt+7)/8;
		if ( bytes>sizeof(HintMask) ) bytes = sizeof(HintMask);
		if ( v==19 ) {
		    ret->hstem = HintsAppend(ret->hstem,activeh); activeh=NULL;
		    ret->vstem = HintsAppend(ret->vstem,activev); activev=NULL;
		    if ( pending_hm==NULL )
			pending_hm = chunkalloc(sizeof(HintMask));
		    memcpy(pending_hm,type1,bytes);
		} else if ( cp<sizeof(counters)/sizeof(counters[0]) ) {
		    counters[cp] = chunkalloc(sizeof(HintMask));
		    memcpy(counters[cp],type1,bytes);
		    ++cp;
		}
		if ( bytes!=hint_cnt/8 ) {
		    int mask = 0xff>>(hint_cnt&7);
		    if ( type1[bytes-1]&mask )
			LogError( _('Hint mask (or counter mask) with too many hints in %s\n'), name );
		}
		type1 += bytes;
		len -= bytes;
	    }
	  break;
	  case 14: /* endchar */
	    /* endchar is allowed to terminate processing even within a subroutine */
	    if ( (sp&1) && is_type2 && ret->width == (int16) 0x8000 )
		ret->width = stack[0];
	    if ( context->painttype!=2 )
		closepath(cur,is_type2);
	    pcsp = 0;
	    if ( sp==4 ) {
		/* In Type2 strings endchar has a deprecated function of doing */
		/*  a seac (which doesn't exist at all). Except enchar takes */
		/*  4 args and seac takes 5. Bleah */
		stack[4] = stack[3]; stack[3] = stack[2]; stack[2] = stack[1]; stack[1] = stack[0];
		stack[0] = 0;
		sp = 5;
  goto seac;
	    } else if ( sp==5 ) {
		/* same as above except also specified a width */
		stack[0] = 0;
  goto seac;
	    }
	    /* the docs say that endchar must be the last command in a char */
	    /*  (or the last command in a subroutine which is the last in the */
	    /*  char) So in theory if there's anything left we should complain*/
	    /*  In practice though, the EuroFont has a return statement after */
	    /*  the endchar in a subroutine. So we won't try to catch that err*/
	    /*  and just stop. */
	    /* Adobe says it's not an error, but I can't understand their */
	    /*  logic */
  goto done;
	  break;
	  case 13: /* hsbw (set left sidebearing and width) */
	    if ( sp<2 ) LogError( _('Stack underflow on hsbw in %s\n'), name );
	    ret->lsidebearing = stack[0];
	    current.x = stack[0];		/* sets the current point too */
	    ret->width = stack[1];
	    sp = 0;
	  break;
	  case 9: /* closepath */
	    sp = 0;
	    closepath(cur,is_type2);
	  break;
	  case 21: /* rmoveto */
	  case 22: /* hmoveto */
	  case 4: /* vmoveto */
	    if ( is_type2 ) {
		if (( (v==21 && sp==3) || (v!=21 && sp==2))  && ret->width == (int16) 0x8000 )
		    /* Character's width may be specified on the first moveto */
		    ret->width = stack[0];
		if ( v==21 && sp>2 ) {
		    stack[0] = stack[sp-2]; stack[1] = stack[sp-1];
		    sp = 2;
		} else if ( v!=21 && sp>1 ) {
		    stack[0] = stack[sp-1];
		    sp = 1;
		}
		if ( context->painttype!=2 )
		    closepath(cur,true);
	    }
	  case 5: /* rlineto */
	  case 6: /* hlineto */
	  case 7: /* vlineto */
	    polarity = 0;
	    base = 0;
	    while ( base<sp ) {
		dx = dy = 0;
		if ( v==5 || v==21 ) {
		    if ( sp<base+2 ) {
			LogError( _('Stack underflow on rlineto/rmoveto in %s\n'), name );
	    break;
		    }
		    dx = stack[base++];
		    dy = stack[base++];
		} else if ( (v==6 && !(polarity&1)) || (v==7 && (polarity&1)) || v==22 ) {
		    if ( sp<=base ) {
			LogError( _('Stack underflow on hlineto/hmoveto in %s\n'), name );
	    break;
		    }
		    dx = stack[base++];
		} else /*if ( (v==7 && !(parity&1)) || (v==6 && (parity&1) || v==4 )*/ {
		    if ( sp<=base ) {
			LogError( _('Stack underflow on vlineto/vmoveto in %s\n'), name );
	    break;
		    }
		    dy = stack[base++];
		}
		++polarity;
		current.x = rint((current.x+dx)*1024)/1024; current.y = rint((current.y+dy)*1024)/1024;
		pt = chunkalloc(sizeof(SplinePoint));
		pt->hintmask = pending_hm; pending_hm = NULL;
		pt->me.x = current.x; pt->me.y = current.y;
		pt->noprevcp = true; pt->nonextcp = true;
		if ( v==4 || v==21 || v==22 ) {
		    if ( cur!=NULL && cur->first==cur->last && cur->first->prev==NULL && is_type2 ) {
			/* Two adjacent movetos should not create single point paths */
			cur->first->me.x = current.x; cur->first->me.y = current.y;
			SplinePointFree(pt);
		    } else {
			SplinePointList *spl = chunkalloc(sizeof(SplinePointList));
			spl->first = spl->last = pt;
			if ( cur!=NULL )
			    cur->next = spl;
			else
			    ret->layers[ly_fore].splines = spl;
			cur = spl;
		    }
	    break;
		} else {
		    if ( cur!=NULL && cur->first!=NULL && (cur->first!=cur->last || cur->first->next==NULL) ) {
			CheckMake(cur->last,pt);
			SplineMake3(cur->last,pt);
			cur->last = pt;
		    } else
			LogError( _('No previous point on path in lineto in %s\n'), name );
		    if ( !is_type2 )
	    break;
		}
	    }
	    sp = 0;
	  break;
	  case 25: /* rlinecurve */
	    base = 0;
	    while ( sp>base+6 ) {
		current.x = rint((current.x+stack[base++])*1024)/1024; current.y = rint((current.y+stack[base++])*1024)/1024;
		if ( cur!=NULL ) {
		    pt = chunkalloc(sizeof(SplinePoint));
		    pt->hintmask = pending_hm; pending_hm = NULL;
		    pt->me.x = current.x; pt->me.y = current.y;
		    pt->noprevcp = true; pt->nonextcp = true;
		    CheckMake(cur->last,pt);
		    SplineMake3(cur->last,pt);
		    cur->last = pt;
		}
	    }
	  case 24: /* rcurveline */
	  case 8:  /* rrcurveto */
	  case 31: /* hvcurveto */
	  case 30: /* vhcurveto */
	  case 27: /* hhcurveto */
	  case 26: /* vvcurveto */
	    polarity = 0;
	    while ( sp>base+2 ) {
		dx = dy = dx2 = dy2 = dx3 = dy3 = 0;
		if ( v==8 || v==25 || v==24 ) {
		    if ( sp<6+base ) {
			LogError( _('Stack underflow on rrcurveto in %s\n'), name );
			base = sp;
		    } else {
			dx = stack[base++];
			dy = stack[base++];
			dx2 = stack[base++];
			dy2 = stack[base++];
			dx3 = stack[base++];
			dy3 = stack[base++];
		    }
		} else if ( v==27 ) {		/* hhcurveto */
		    if ( sp<4+base ) {
			LogError( _('Stack underflow on hhcurveto in %s\n'), name );
			base = sp;
		    } else {
			if ( (sp-base)&1 ) dy = stack[base++];
			dx = stack[base++];
			dx2 = stack[base++];
			dy2 = stack[base++];
			dx3 = stack[base++];
		    }
		} else if ( v==26 ) {		/* vvcurveto */
		    if ( sp<4+base ) {
			LogError( _('Stack underflow on hhcurveto in %s\n'), name );
			base = sp;
		    } else {
			if ( (sp-base)&1 ) dx = stack[base++];
			dy = stack[base++];
			dx2 = stack[base++];
			dy2 = stack[base++];
			dy3 = stack[base++];
		    }
		} else if ( (v==31 && !(polarity&1)) || (v==30 && (polarity&1)) ) {
		    if ( sp<4+base ) {
			LogError( _('Stack underflow on hvcurveto in %s\n'), name );
			base = sp;
		    } else {
			dx = stack[base++];
			dx2 = stack[base++];
			dy2 = stack[base++];
			dy3 = stack[base++];
			if ( sp==base+1 )
			    dx3 = stack[base++];
		    }
		} else /*if ( (v==30 && !(polarity&1)) || (v==31 && (polarity&1)) )*/ {
		    if ( sp<4+base ) {
			LogError( _('Stack underflow on vhcurveto in %s\n'), name );
			base = sp;
		    } else {
			dy = stack[base++];
			dx2 = stack[base++];
			dy2 = stack[base++];
			dx3 = stack[base++];
			if ( sp==base+1 )
			    dy3 = stack[base++];
		    }
		}
		++polarity;
		if ( cur!=NULL && cur->first!=NULL && (cur->first!=cur->last || cur->first->next==NULL) ) {
		    current.x = rint((current.x+dx)*1024)/1024; current.y = rint((current.y+dy)*1024)/1024;
		    cur->last->nextcp.x = current.x; cur->last->nextcp.y = current.y;
		    cur->last->nonextcp = false;
		    current.x = rint((current.x+dx2)*1024)/1024; current.y = rint((current.y+dy2)*1024)/1024;
		    pt = chunkalloc(sizeof(SplinePoint));
		    pt->hintmask = pending_hm; pending_hm = NULL;
		    pt->prevcp.x = current.x; pt->prevcp.y = current.y;
		    current.x = rint((current.x+dx3)*1024)/1024; current.y = rint((current.y+dy3)*1024)/1024;
		    pt->me.x = current.x; pt->me.y = current.y;
		    pt->nonextcp = true;
		    CheckMake(cur->last,pt);
		    SplineMake3(cur->last,pt);
		    cur->last = pt;
		} else
		    LogError( _('No previous point on path in curveto in %s\n'), name );
	    }
	    if ( v==24 ) {
		current.x = rint((current.x+stack[base++])*1024)/1024; current.y = rint((current.y+stack[base++])*1024)/1024;
		if ( cur!=NULL ) {	/* In legal code, cur can't be null here, but I got something illegal... */
		    pt = chunkalloc(sizeof(SplinePoint));
		    pt->hintmask = pending_hm; pending_hm = NULL;
		    pt->me.x = current.x; pt->me.y = current.y;
		    pt->noprevcp = true; pt->nonextcp = true;
		    CheckMake(cur->last,pt);
		    SplineMake3(cur->last,pt);
		    cur->last = pt;
		}
	    }
	    sp = 0;
	  break;
	  case 29: /* callgsubr */
	  case 10: /* callsubr */
	    /* stack[sp-1] contains the number of the subroutine to call */
	    if ( sp<1 ) {
		LogError( _('Stack underflow on callsubr in %s\n'), name );
	  break;
	    } else if ( pcsp>10 ) {
		LogError( _('Too many subroutine calls in %s\n'), name );
	  break;
	    }
	    s=subrs; if ( v==29 ) s = gsubrs;
	    if ( s!=NULL ) stack[sp-1] += s->bias;
	    /* Type2 subrs have a bias that must be added to the subr-number */
	    /* Type1 subrs do not. We set the bias on them to 0 */
	    if ( s==NULL || stack[sp-1]>=s->cnt || stack[sp-1]<0 ||
		    s->values[(int) stack[sp-1]]==NULL )
		LogError( _('Subroutine number out of bounds in %s\n'), name );
	    else {
		pcstack[pcsp].type1 = type1;
		pcstack[pcsp].len = len;
		pcstack[pcsp].subnum = stack[sp-1];
		++pcsp;
		type1 = s->values[(int) stack[sp-1]];
		len = s->lens[(int) stack[sp-1]];
	    }
	    if ( --sp<0 ) sp = 0;
	  break;
	  case 11: /* return */
	    /* return from a subr outine */
	    if ( pcsp<1 ) LogError( _('return when not in subroutine in %s\n'), name );
	    else {
		--pcsp;
		type1 = pcstack[pcsp].type1;
		len = pcstack[pcsp].len;
	    }
	  break;
	  case 16: { /* blend -- obsolete type 2 multiple master operator */
	    int cnt,i,j;
	    if ( context->instance_count==0 )
		LogError( _('Attempt to use a multiple master subroutine in a non-mm font.\n') );
	    else if ( sp<1 || sp<context->instance_count*stack[sp-1]+1 )
		LogError( _('Too few items on stack for blend in %s\n'), name );
	    else {
		if ( !context->blend_warn ) {
		    LogError( _('Use of obsolete blend operator.\n') );
		    context->blend_warn = true;
		}
		cnt = stack[sp-1];
		sp -= context->instance_count*stack[sp-1]+1;
		for ( i=0; i<cnt; ++i ) {
		    for ( j=1; j<context->instance_count; ++j )
			stack[sp+i] += context->blend_values[j]*stack[sp+
				cnt+ i*(context->instance_count-1)+ j-1];
		}
		/* there will always be fewer pushes than there were pops */
		/*  so I don't bother to check the stack */
		sp += cnt;
	    }
	  }
	  break;
	  default:
	    LogError( _('Uninterpreted opcode %d in %s\n'), v, name );
	  break;
	}}
    }
  done:
    if ( pcsp!=0 )
	LogError( _('end of subroutine reached with no return in %s\n'), name );
    SCCategorizePoints(ret);

    ret->hstem = HintsAppend(ret->hstem,activeh); activeh=NULL;
    ret->vstem = HintsAppend(ret->vstem,activev); activev=NULL;

    if ( cp!=0 ) { int i;
	ret->countermasks = malloc(cp*sizeof(HintMask));
	ret->countermask_cnt = cp;
	for ( i=0; i<cp; ++i ) {
	    memcpy(&ret->countermasks[i],counters[i],sizeof(HintMask));
	    chunkfree(counters[i],sizeof(HintMask));
	}
    }

    /* Even in type1 fonts all paths should be closed. But if we close them at*/
    /*  the obvious moveto, that breaks flex hints. So we have a hack here at */
    /*  the end which closes any open paths. */
    /* If we do have a PaintType 2 font, then presumably the difference between*/
    /*  open and closed paths matters */
    if ( !is_type2 && !context->painttype )
	for ( cur = ret->layers[ly_fore].splines; cur!=NULL; cur = cur->next ) if ( cur->first->prev==NULL ) {
	    CheckMake(cur->last,cur->first);
	    SplineMake3(cur->last,cur->first);
	    cur->last = cur->first;
	}

    /* Oh, I see. PS and TT disagree on which direction to use, so Fontographer*/
    /*  chose the TT direction and we must reverse postscript */
    for ( cur = ret->layers[ly_fore].splines; cur!=NULL; cur = cur->next )
	SplineSetReverse(cur);
    if ( ret->hstem==NULL && ret->vstem==NULL )
	ret->manualhints = false;
    if ( !is_type2 && context->instance_count!=0 ) {
	UnblendFree(ret->hstem);
	UnblendFree(ret->vstem);
    }
    ret->hstem = HintCleanup(ret->hstem,true,context->instance_count);
    ret->vstem = HintCleanup(ret->vstem,true,context->instance_count);

    SCGuessHHintInstancesList(ret,ly_fore);
    SCGuessVHintInstancesList(ret,ly_fore);

    ret->hconflicts = StemListAnyConflicts(ret->hstem);
    ret->vconflicts = StemListAnyConflicts(ret->vstem);
    if ( context->instance_count==1 && !ret->hconflicts && !ret->vconflicts )
	SCClearHintMasks(ret,ly_fore,false);
    HintsRenumber(ret);
    if ( name!=NULL && strcmp(name,'.notdef')!=0 )
	ret->widthset = true;
return( ret );
}
",1,7945
fontforge/fontforge,4de0c58a01e5e30610c200e9aea98bc7db12c7ac,"void DefaultTTFEnglishNames(struct ttflangname *dummy, SplineFont *sf) {
    time_t now;
    struct tm *tm;
    char buffer[200];

    if ( dummy->names[ttf_copyright]==NULL || *dummy->names[ttf_copyright]=='\0' )
	dummy->names[ttf_copyright] = utf8_verify_copy(sf->copyright);
    if ( dummy->names[ttf_family]==NULL || *dummy->names[ttf_family]=='\0' )
	dummy->names[ttf_family] = utf8_verify_copy(sf->familyname);
    if ( dummy->names[ttf_subfamily]==NULL || *dummy->names[ttf_subfamily]=='\0' )
	dummy->names[ttf_subfamily] = utf8_verify_copy(SFGetModifiers(sf));
    if ( dummy->names[ttf_uniqueid]==NULL || *dummy->names[ttf_uniqueid]=='\0' ) {
	time(&now);
	tm = localtime(&now);
	sprintf( buffer, '%s : %s : %d-%d-%d',
		BDFFoundry?BDFFoundry:TTFFoundry?TTFFoundry:'FontForge 2.0',
		sf->fullname!=NULL?sf->fullname:sf->fontname,
		tm->tm_mday, tm->tm_mon+1, tm->tm_year+1900 );
	dummy->names[ttf_uniqueid] = copy(buffer);
    }
    if ( dummy->names[ttf_fullname]==NULL || *dummy->names[ttf_fullname]=='\0' )
	dummy->names[ttf_fullname] = utf8_verify_copy(sf->fullname);
    if ( dummy->names[ttf_version]==NULL || *dummy->names[ttf_version]=='\0' ) {
	if ( sf->subfontcnt!=0 )
	    sprintf( buffer, 'Version %f ', (double)sf->cidversion );
	else if ( sf->version!=NULL )
	    sprintf(buffer,'Version %.20s ', sf->version);
	else
	    strcpy(buffer,'Version 1.0' );
	dummy->names[ttf_version] = copy(buffer);
    }
    if ( dummy->names[ttf_postscriptname]==NULL || *dummy->names[ttf_postscriptname]=='\0' )
	dummy->names[ttf_postscriptname] = utf8_verify_copy(sf->fontname);
}
",1,7946
fontforge/fontforge,4de0c58a01e5e30610c200e9aea98bc7db12c7ac,"static struct topdicts **readcfftopdicts(FILE *ttf, char **fontnames, int32 cff_start,
	struct ttfinfo *info, struct topdicts *parent_dict) {
    uint16 count = getushort(ttf);
    int offsize;
    uint32 *offsets;
    struct topdicts **dicts;
    int i;

    if ( count==0 )
return( NULL );
    offsets = malloc((count+1)*sizeof(uint32));
    offsize = getc(ttf);
    for ( i=0; i<=count; ++i )
	offsets[i] = getoffset(ttf,offsize);
    dicts = malloc((count+1)*sizeof(struct topdicts *));
    for ( i=0; i<count; ++i ) {
	dicts[i] = readcfftopdict(ttf,fontnames!=NULL?fontnames[i]:NULL,
		offsets[i+1]-offsets[i], info);
	if ( parent_dict!=NULL && parent_dict->fontmatrix_set ) {
	    MatMultiply(parent_dict->fontmatrix,dicts[i]->fontmatrix,dicts[i]->fontmatrix);
	}
	dicts[i]->cff_start = cff_start;
    }
    dicts[i] = NULL;
    free(offsets);
return( dicts );
}
",1,7947
fontforge/fontforge,4de0c58a01e5e30610c200e9aea98bc7db12c7ac,"#define _Y_Short	4
#define _Repeat		8
#define _X_Same		0x10
",0,7948
fontforge/fontforge,4de0c58a01e5e30610c200e9aea98bc7db12c7ac,"static void dumpdbloper(FILE *cfff,double d, int oper ) {
    dumpdbl(cfff,d);
    dumpoper(cfff,oper);
}
",0,7949
fontforge/fontforge,4de0c58a01e5e30610c200e9aea98bc7db12c7ac,"int SFFigureDefWidth(SplineFont *sf, int *_nomwid) {
    uint16 *widths; uint32 *cumwid;
    int nomwid, defwid, i, j, sameval=(int) 0x80000000, maxw=0, allsame=true;
    unsigned cnt;

    for ( i=0; i<sf->glyphcnt; ++i )
	if ( SCWorthOutputting(sf->glyphs[i]) ) {
	    if ( maxw<sf->glyphs[i]->width ) maxw = sf->glyphs[i]->width;
	    if ( sameval == 0x8000000 )
		sameval = sf->glyphs[i]->width;
	    else if ( sameval!=sf->glyphs[i]->width )
		allsame = false;
	}
    if ( allsame ) {
	nomwid = defwid = sameval;
    } else {
	++maxw;
	if ( maxw>65535 ) maxw = 3*(sf->ascent+sf->descent);
	widths = calloc(maxw,sizeof(uint16));
	cumwid = calloc(maxw,sizeof(uint32));
	defwid = 0; cnt=0;
	for ( i=0; i<sf->glyphcnt; ++i )
	    if ( SCWorthOutputting(sf->glyphs[i]) &&
		    sf->glyphs[i]->width>=0 &&
		    sf->glyphs[i]->width<maxw )
		if ( ++widths[sf->glyphs[i]->width] > cnt ) {
		    defwid = sf->glyphs[i]->width;
		    cnt = widths[defwid];
		}
	widths[defwid] = 0;
	for ( i=0; i<maxw; ++i )
		for ( j=-107; j<=107; ++j )
		    if ( i+j>=0 && i+j<maxw )
			cumwid[i] += widths[i+j];
	cnt = 0; nomwid = 0;
	for ( i=0; i<maxw; ++i )
	    if ( cnt<cumwid[i] ) {
		cnt = cumwid[i];
		nomwid = i;
	    }
	free(widths); free(cumwid);
    }
    if ( _nomwid!=NULL )
	*_nomwid = nomwid;
return( defwid );
}
",0,7950
shadow-maint/shadow,954e3d2e7113e9ac06632aee3c69b8d818cc8952,"int lrename (const char *old, const char *new)
{
	int res;
	char *r = NULL;

#if defined(S_ISLNK)
#ifndef __GLIBC__
	char resolved_path[PATH_MAX];
#endif				/* !__GLIBC__ */
	struct stat sb;
	if (lstat (new, &sb) == 0 && S_ISLNK (sb.st_mode)) {
#ifdef __GLIBC__ /* now a POSIX.1-2008 feature */
		r = realpath (new, NULL);
#else				/* !__GLIBC__ */
		r = realpath (new, resolved_path);
#endif				/* !__GLIBC__ */
		if (NULL == r) {
			perror ('realpath in lrename()');
		} else {
			new = r;
		}
	}
#endif				/* S_ISLNK */

	res = rename (old, new);

#ifdef __GLIBC__
	if (NULL != r) {
		free (r);
	}
#endif				/* __GLIBC__ */

	return res;
}

static int check_link_count (const char *file)
{
	struct stat sb;

	if (stat (file, &sb) != 0) {
		return 0;
	}

	if (sb.st_nlink != 2) {
		return 0;
	}

	return 1;
}


static int do_lock_file (const char *file, const char *lock, bool log)
{
	int fd;
	pid_t pid;
	ssize_t len;
	int retval;
	char buf[32];

	fd = open (file, O_CREAT | O_EXCL | O_WRONLY, 0600);
	if (-1 == fd) {
		if (log) {
			(void) fprintf (stderr,
			                '%s: %s: %s\n',
			                Prog, file, strerror (errno));
		}
		return 0;
	}

	pid = getpid ();
	snprintf (buf, sizeof buf, '%lu', (unsigned long) pid);
	len = (ssize_t) strlen (buf) + 1;
	if (write (fd, buf, (size_t) len) != len) {
		if (log) {
			(void) fprintf (stderr,
			                '%s: %s: %s\n',
			                Prog, file, strerror (errno));
		}
		(void) close (fd);
		unlink (file);
		return 0;
	}
	close (fd);

	if (link (file, lock) == 0) {
		retval = check_link_count (file);
		if ((0==retval) && log) {
			(void) fprintf (stderr,
			                '%s: %s: lock file already used\n',
			                Prog, file);
		}
		unlink (file);
		return retval;
	}

	fd = open (lock, O_RDWR);
	if (-1 == fd) {
		if (log) {
			(void) fprintf (stderr,
			                '%s: %s: %s\n',
			                Prog, lock, strerror (errno));
		}
		unlink (file);
		errno = EINVAL;
		return 0;
	}
	len = read (fd, buf, sizeof (buf) - 1);
	close (fd);
	if (len <= 0) {
		if (log) {
			(void) fprintf (stderr,
			                '%s: existing lock file %s without a PID\n',
			                Prog, lock);
		}
		unlink (file);
		errno = EINVAL;
		return 0;
	}
	buf[len] = '\0';
	if (get_pid (buf, &pid) == 0) {
		if (log) {
			(void) fprintf (stderr,
			                '%s: existing lock file %s with an invalid PID '%s'\n',
			                Prog, lock, buf);
		}
		unlink (file);
		errno = EINVAL;
		return 0;
	}
	if (kill (pid, 0) == 0) {
		if (log) {
			(void) fprintf (stderr,
			                '%s: lock %s already used by PID %lu\n',
			                Prog, lock, (unsigned long) pid);
		}
		unlink (file);
		errno = EEXIST;
		return 0;
	}
	if (unlink (lock) != 0) {
		if (log) {
			(void) fprintf (stderr,
			                '%s: cannot get lock %s: %s\n',
			                Prog, lock, strerror (errno));
		}
		unlink (file);
		return 0;
	}

	retval = 0;
	if (link (file, lock) == 0) {
		retval = check_link_count (file);
		if ((0==retval) && log) {
			(void) fprintf (stderr,
			                '%s: %s: lock file already used\n',
			                Prog, file);
		}
	} else {
		if (log) {
			(void) fprintf (stderr,
			                '%s: cannot get lock %s: %s\n',
			                Prog, lock, strerror (errno));
		}
	}

	unlink (file);
	return retval;
}


static /*@null@*/ /*@dependent@*/FILE *fopen_set_perms (
	const char *name,
	const char *mode,
	const struct stat *sb)
{
	FILE *fp;
	mode_t mask;

	mask = umask (0777);
	fp = fopen (name, mode);
	(void) umask (mask);
	if (NULL == fp) {
		return NULL;
	}

#ifdef HAVE_FCHOWN
	if (fchown (fileno (fp), sb->st_uid, sb->st_gid) != 0) {
		goto fail;
	}
#else				/* !HAVE_FCHOWN */
	if (chown (name, sb->st_mode) != 0) {
		goto fail;
	}
#endif				/* !HAVE_FCHOWN */

#ifdef HAVE_FCHMOD
	if (fchmod (fileno (fp), sb->st_mode & 0664) != 0) {
		goto fail;
	}
#else				/* !HAVE_FCHMOD */
	if (chmod (name, sb->st_mode & 0664) != 0) {
		goto fail;
	}
#endif				/* !HAVE_FCHMOD */
	return fp;

      fail:
	(void) fclose (fp);
	/* fopen_set_perms is used for intermediate files */
	(void) unlink (name);
	return NULL;
}


static int create_backup (const char *backup, FILE * fp)
{
	struct stat sb;
	struct utimbuf ub;
	FILE *bkfp;
	int c;

	if (fstat (fileno (fp), &sb) != 0) {
		return -1;
	}

	bkfp = fopen_set_perms (backup, 'w', &sb);
	if (NULL == bkfp) {
		return -1;
	}

	/* TODO: faster copy, not one-char-at-a-time.  --marekm */
	c = 0;
	if (fseek (fp, 0, SEEK_SET) == 0) {
		while ((c = getc (fp)) != EOF) {
			if (putc (c, bkfp) == EOF) {
				break;
			}
		}
	}
	if ((c != EOF) || (ferror (fp) != 0) || (fflush (bkfp) != 0)) {
		(void) fclose (bkfp);
		/* FIXME: unlink the backup file? */
		return -1;
	}
	if (   (fsync (fileno (bkfp)) != 0)
	    || (fclose (bkfp) != 0)) {
		/* FIXME: unlink the backup file? */
		return -1;
	}

	ub.actime = sb.st_atime;
	ub.modtime = sb.st_mtime;
	(void) utime (backup, &ub);
	return 0;
}


static void free_linked_list (struct commonio_db *db)
{
	struct commonio_entry *p;

	while (NULL != db->head) {
		p = db->head;
		db->head = p->next;

		if (NULL != p->line) {
			free (p->line);
		}

		if (NULL != p->eptr) {
			db->ops->free (p->eptr);
		}

		free (p);
	}
	db->tail = NULL;
}


int commonio_setname (struct commonio_db *db, const char *name)
{
	snprintf (db->filename, sizeof (db->filename), '%s', name);
	return 1;
}


bool commonio_present (const struct commonio_db *db)
{
	return (access (db->filename, F_OK) == 0);
}


int commonio_lock_nowait (struct commonio_db *db, bool log)
{
	char file[1024];
	char lock[1024];

	if (db->locked) {
		return 1;
	}

	snprintf (file, sizeof file, '%s.%lu',
	          db->filename, (unsigned long) getpid ());
	snprintf (lock, sizeof lock, '%s.lock', db->filename);
	if (do_lock_file (file, lock, log) != 0) {
		db->locked = true;
		lock_count++;
		return 1;
	}
	return 0;
}


int commonio_lock (struct commonio_db *db)
{
#ifdef HAVE_LCKPWDF
	/*
	 * only if the system libc has a real lckpwdf() - the one from
	 * lockpw.c calls us and would cause infinite recursion!
	 */

	/*
	 * Call lckpwdf() on the first lock.
	 * If it succeeds, call *_lock() only once
	 * (no retries, it should always succeed).
	 */
	if (0 == lock_count) {
		if (lckpwdf () == -1) {
			if (geteuid () != 0) {
				(void) fprintf (stderr,
				                '%s: Permission denied.\n',
				                Prog);
			}
			return 0;	/* failure */
		}
	}

	if (commonio_lock_nowait (db, true) != 0) {
		return 1;	/* success */
	}

	ulckpwdf ();
	return 0;		/* failure */
#else				/* !HAVE_LCKPWDF */
	int i;

	/*
	 * lckpwdf() not used - do it the old way.
	 */
#ifndef LOCK_TRIES
#define LOCK_TRIES 15
#endif

#ifndef LOCK_SLEEP
#define LOCK_SLEEP 1
#endif
	for (i = 0; i < LOCK_TRIES; i++) {
		if (i > 0) {
			sleep (LOCK_SLEEP);	/* delay between retries */
		}
		if (commonio_lock_nowait (db, i==LOCK_TRIES-1) != 0) {
			return 1;	/* success */
		}
		/* no unnecessary retries on 'permission denied' errors */
		if (geteuid () != 0) {
			(void) fprintf (stderr, '%s: Permission denied.\n',
			                Prog);
			return 0;
		}
	}
	return 0;		/* failure */
#endif				/* !HAVE_LCKPWDF */
}

static void dec_lock_count (void)
{
	if (lock_count > 0) {
		lock_count--;
		if (lock_count == 0) {
			/* Tell nscd when lock count goes to zero,
			   if any of the files were changed.  */
			if (nscd_need_reload) {
				nscd_flush_cache ('passwd');
				nscd_flush_cache ('group');
				nscd_need_reload = false;
			}
#ifdef HAVE_LCKPWDF
			ulckpwdf ();
#endif				/* HAVE_LCKPWDF */
		}
	}
}


int commonio_unlock (struct commonio_db *db)
{
	char lock[1024];

	if (db->isopen) {
		db->readonly = true;
		if (commonio_close (db) == 0) {
			if (db->locked) {
				dec_lock_count ();
			}
			return 0;
		}
	}
	if (db->locked) {
		/*
		 * Unlock in reverse order: remove the lock file,
		 * then call ulckpwdf() (if used) on last unlock.
		 */
		db->locked = false;
		snprintf (lock, sizeof lock, '%s.lock', db->filename);
		unlink (lock);
		dec_lock_count ();
		return 1;
	}
	return 0;
}


/*
 * Add an entry at the end.
 *
 * defines p->next, p->prev
 * (unfortunately, owned special are not supported)
 */
static void add_one_entry (struct commonio_db *db,
                           /*@owned@*/struct commonio_entry *p)
{
	/*@-mustfreeonly@*/
	p->next = NULL;
	p->prev = db->tail;
	/*@=mustfreeonly@*/
	if (NULL == db->head) {
		db->head = p;
	}
	if (NULL != db->tail) {
		db->tail->next = p;
	}
	db->tail = p;
}


static bool name_is_nis (const char *name)
{
	return (('+' == name[0]) || ('-' == name[0]));
}


/*
 * New entries are inserted before the first NIS entry.  Order is preserved
 * when db is written out.
 */
#ifndef KEEP_NIS_AT_END
#define KEEP_NIS_AT_END 1
#endif

#if KEEP_NIS_AT_END
static void add_one_entry_nis (struct commonio_db *db,
                               /*@owned@*/struct commonio_entry *newp);

/*
 * Insert an entry between the regular entries, and the NIS entries.
 *
 * defines newp->next, newp->prev
 * (unfortunately, owned special are not supported)
 */
static void add_one_entry_nis (struct commonio_db *db,
                               /*@owned@*/struct commonio_entry *newp)
{
	struct commonio_entry *p;

	for (p = db->head; NULL != p; p = p->next) {
		if (name_is_nis (p->eptr ? db->ops->getname (p->eptr)
		                         : p->line)) {
			/*@-mustfreeonly@*/
			newp->next = p;
			newp->prev = p->prev;
			/*@=mustfreeonly@*/
			if (NULL != p->prev) {
				p->prev->next = newp;
			} else {
				db->head = newp;
			}
			p->prev = newp;
			return;
		}
	}
	add_one_entry (db, newp);
}
#endif				/* KEEP_NIS_AT_END */

/* Initial buffer size, as well as increment if not sufficient
   (for reading very long lines in group files).  */
#define BUFLEN 4096

int commonio_open (struct commonio_db *db, int mode)
{
	char *buf;
	char *cp;
	char *line;
	struct commonio_entry *p;
	void *eptr = NULL;
	int flags = mode;
	size_t buflen;
	int fd;
	int saved_errno;

	mode &= ~O_CREAT;

	if (   db->isopen
	    || (   (O_RDONLY != mode)
	        && (O_RDWR != mode))) {
		errno = EINVAL;
		return 0;
	}
	db->readonly = (mode == O_RDONLY);
	if (!db->readonly && !db->locked) {
		errno = EACCES;
		return 0;
	}

	db->head = NULL;
	db->tail = NULL;
	db->cursor = NULL;
	db->changed = false;

	fd = open (db->filename,
	             (db->readonly ? O_RDONLY : O_RDWR)
	           | O_NOCTTY | O_NONBLOCK | O_NOFOLLOW);
	saved_errno = errno;
	db->fp = NULL;
	if (fd >= 0) {
#ifdef WITH_TCB
		if (tcb_is_suspect (fd) != 0) {
			(void) close (fd);
			errno = EINVAL;
			return 0;
		}
#endif				/* WITH_TCB */
		db->fp = fdopen (fd, db->readonly ? 'r' : 'r+');
		saved_errno = errno;
		if (NULL == db->fp) {
			(void) close (fd);
		}
	}
	errno = saved_errno;

	/*
	 * If O_CREAT was specified and the file didn't exist, it will be
	 * created by commonio_close().  We have no entries to read yet.  --marekm
	 */
	if (NULL == db->fp) {
		if (((flags & O_CREAT) != 0) && (ENOENT == errno)) {
			db->isopen = true;
			return 1;
		}
		return 0;
	}

	/* Do not inherit fd in spawned processes (e.g. nscd) */
	fcntl (fileno (db->fp), F_SETFD, FD_CLOEXEC);

	buflen = BUFLEN;
	buf = (char *) malloc (buflen);
	if (NULL == buf) {
		goto cleanup_ENOMEM;
	}

	while (db->ops->fgets (buf, (int) buflen, db->fp) == buf) {
		while (   ((cp = strrchr (buf, '\n')) == NULL)
		       && (feof (db->fp) == 0)) {
			size_t len;

			buflen += BUFLEN;
			cp = (char *) realloc (buf, buflen);
			if (NULL == cp) {
				goto cleanup_buf;
			}
			buf = cp;
			len = strlen (buf);
			if (db->ops->fgets (buf + len,
			                    (int) (buflen - len),
			                    db->fp) == NULL) {
				goto cleanup_buf;
			}
		}
		cp = strrchr (buf, '\n');
		if (NULL != cp) {
			*cp = '\0';
		}

		line = strdup (buf);
		if (NULL == line) {
			goto cleanup_buf;
		}

		if (name_is_nis (line)) {
			eptr = NULL;
		} else {
			eptr = db->ops->parse (line);
			if (NULL != eptr) {
				eptr = db->ops->dup (eptr);
				if (NULL == eptr) {
					goto cleanup_line;
				}
			}
		}

		p = (struct commonio_entry *) malloc (sizeof *p);
		if (NULL == p) {
			goto cleanup_entry;
		}

		p->eptr = eptr;
		p->line = line;
		p->changed = false;

		add_one_entry (db, p);
	}

	free (buf);

	if (ferror (db->fp) != 0) {
		goto cleanup_errno;
	}

	if ((NULL != db->ops->open_hook) && (db->ops->open_hook () == 0)) {
		goto cleanup_errno;
	}

	db->isopen = true;
	return 1;

      cleanup_entry:
	if (NULL != eptr) {
		db->ops->free (eptr);
	}
      cleanup_line:
	free (line);
      cleanup_buf:
	free (buf);
      cleanup_ENOMEM:
	errno = ENOMEM;
      cleanup_errno:
	saved_errno = errno;
	free_linked_list (db);
	fclose (db->fp);
	db->fp = NULL;
	errno = saved_errno;
	return 0;
}

/*
 * Sort given db according to cmp function (usually compares uids)
 */
int
commonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *))
{
	struct commonio_entry **entries, *ptr;
	size_t n = 0, i;
#if KEEP_NIS_AT_END
	struct commonio_entry *nis = NULL;
#endif

	for (ptr = db->head;
	        (NULL != ptr)
#if KEEP_NIS_AT_END
	     && (NULL != ptr->line)
	     && (   ('+' != ptr->line[0])
	         && ('-' != ptr->line[0]))
#endif
	     ;
	     ptr = ptr->next) {
		n++;
	}
#if KEEP_NIS_AT_END
	if ((NULL != ptr) && (NULL != ptr->line)) {
		nis = ptr;
	}
#endif

	if (n <= 1) {
		return 0;
	}

	entries = malloc (n * sizeof (struct commonio_entry *));
	if (entries == NULL) {
		return -1;
	}

	n = 0;
	for (ptr = db->head;
#if KEEP_NIS_AT_END
	     nis != ptr;
#else
	     NULL != ptr;
#endif
/*@ -nullderef @*/
	     ptr = ptr->next
/*@ +nullderef @*/
	    ) {
		entries[n] = ptr;
		n++;
	}
	qsort (entries, n, sizeof (struct commonio_entry *), cmp);

	/* Take care of the head and tail separately */
	db->head = entries[0];
	n--;
#if KEEP_NIS_AT_END
	if (NULL == nis)
#endif
	{
		db->tail = entries[n];
	}
	db->head->prev = NULL;
	db->head->next = entries[1];
	entries[n]->prev = entries[n - 1];
#if KEEP_NIS_AT_END
	entries[n]->next = nis;
#else
	entries[n]->next = NULL;
#endif

	/* Now other elements have prev and next entries */
	for (i = 1; i < n; i++) {
		entries[i]->prev = entries[i - 1];
		entries[i]->next = entries[i + 1];
	}

	free (entries);
	db->changed = true;

	return 0;
}

/*
 * Sort entries in db according to order in another.
 */
int commonio_sort_wrt (struct commonio_db *shadow,
                       const struct commonio_db *passwd)
{
	struct commonio_entry *head = NULL, *pw_ptr, *spw_ptr;
	const char *name;

	if ((NULL == shadow) || (NULL == shadow->head)) {
		return 0;
	}

	for (pw_ptr = passwd->head; NULL != pw_ptr; pw_ptr = pw_ptr->next) {
		if (NULL == pw_ptr->eptr) {
			continue;
		}
		name = passwd->ops->getname (pw_ptr->eptr);
		for (spw_ptr = shadow->head;
		     NULL != spw_ptr;
		     spw_ptr = spw_ptr->next) {
			if (NULL == spw_ptr->eptr) {
				continue;
			}
			if (strcmp (name, shadow->ops->getname (spw_ptr->eptr))
			    == 0) {
				break;
			}
		}
		if (NULL == spw_ptr) {
			continue;
		}
		commonio_del_entry (shadow, spw_ptr);
		spw_ptr->next = head;
		head = spw_ptr;
	}

	for (spw_ptr = head; NULL != spw_ptr; spw_ptr = head) {
		head = head->next;

		if (NULL != shadow->head) {
			shadow->head->prev = spw_ptr;
		}
		spw_ptr->next = shadow->head;
		shadow->head = spw_ptr;
	}

	shadow->head->prev = NULL;
	shadow->changed = true;

	return 0;
}

/*
 * write_all - Write the database to its file.
 *
 * It returns 0 if all the entries could be written correctly.
 */
static int write_all (const struct commonio_db *db)
	/*@requires notnull db->fp@*/
{
	const struct commonio_entry *p;
	void *eptr;

	for (p = db->head; NULL != p; p = p->next) {
		if (p->changed) {
			eptr = p->eptr;
			assert (NULL != eptr);
			if (db->ops->put (eptr, db->fp) != 0) {
				return -1;
			}
		} else if (NULL != p->line) {
			if (db->ops->fputs (p->line, db->fp) == EOF) {
				return -1;
			}
			if (putc ('\n', db->fp) == EOF) {
				return -1;
			}
		}
	}
	return 0;
}


int commonio_close (struct commonio_db *db)
	/*@requires notnull db->fp@*/
{
	char buf[1024];
	int errors = 0;
	struct stat sb;

	if (!db->isopen) {
		errno = EINVAL;
		return 0;
	}
	db->isopen = false;

	if (!db->changed || db->readonly) {
		(void) fclose (db->fp);
		db->fp = NULL;
		goto success;
	}

	if ((NULL != db->ops->close_hook) && (db->ops->close_hook () == 0)) {
		goto fail;
	}

	memzero (&sb, sizeof sb);
	if (NULL != db->fp) {
		if (fstat (fileno (db->fp), &sb) != 0) {
			(void) fclose (db->fp);
			db->fp = NULL;
			goto fail;
		}

		/*
		 * Create backup file.
		 */
		snprintf (buf, sizeof buf, '%s-', db->filename);

#ifdef WITH_SELINUX
		if (set_selinux_file_context (buf) != 0) {
			errors++;
		}
#endif
		if (create_backup (buf, db->fp) != 0) {
			errors++;
		}

		if (fclose (db->fp) != 0) {
			errors++;
		}

#ifdef WITH_SELINUX
		if (reset_selinux_file_context () != 0) {
			errors++;
		}
#endif
		if (errors != 0) {
			db->fp = NULL;
			goto fail;
		}
	} else {
		/*
		 * Default permissions for new [g]shadow files.
		 */
		sb.st_mode = db->st_mode;
		sb.st_uid = db->st_uid;
		sb.st_gid = db->st_gid;
	}

	snprintf (buf, sizeof buf, '%s+', db->filename);

#ifdef WITH_SELINUX
	if (set_selinux_file_context (buf) != 0) {
		errors++;
	}
#endif

	db->fp = fopen_set_perms (buf, 'w', &sb);
	if (NULL == db->fp) {
		goto fail;
	}

	if (write_all (db) != 0) {
		errors++;
	}

	if (fflush (db->fp) != 0) {
		errors++;
	}
#ifdef HAVE_FSYNC
	if (fsync (fileno (db->fp)) != 0) {
		errors++;
	}
#else				/* !HAVE_FSYNC */
	sync ();
#endif				/* !HAVE_FSYNC */
	if (fclose (db->fp) != 0) {
		errors++;
	}

	db->fp = NULL;

	if (errors != 0) {
		unlink (buf);
		goto fail;
	}

	if (lrename (buf, db->filename) != 0) {
		goto fail;
	}

#ifdef WITH_SELINUX
	if (reset_selinux_file_context () != 0) {
		goto fail;
	}
#endif

	nscd_need_reload = true;
	goto success;
      fail:
	errors++;
      success:

	free_linked_list (db);
	return errors == 0;
}

static /*@dependent@*/ /*@null@*/struct commonio_entry *next_entry_by_name (
	struct commonio_db *db,
	/*@null@*/struct commonio_entry *pos,
	const char *name)
{
	struct commonio_entry *p;
	void *ep;

	if (NULL == pos) {
		return NULL;
	}

	for (p = pos; NULL != p; p = p->next) {
		ep = p->eptr;
		if (   (NULL != ep)
		    && (strcmp (db->ops->getname (ep), name) == 0)) {
			break;
		}
	}
	return p;
}

static /*@dependent@*/ /*@null@*/struct commonio_entry *find_entry_by_name (
	struct commonio_db *db,
	const char *name)
{
	return next_entry_by_name (db, db->head, name);
}


int commonio_update (struct commonio_db *db, const void *eptr)
{
	struct commonio_entry *p;
	void *nentry;

	if (!db->isopen || db->readonly) {
		errno = EINVAL;
		return 0;
	}
	nentry = db->ops->dup (eptr);
	if (NULL == nentry) {
		errno = ENOMEM;
		return 0;
	}
	p = find_entry_by_name (db, db->ops->getname (eptr));
	if (NULL != p) {
		if (next_entry_by_name (db, p->next, db->ops->getname (eptr)) != NULL) {
			fprintf (stderr, _('Multiple entries named '%s' in %s. Please fix this with pwck or grpck.\n'), db->ops->getname (eptr), db->filename);
			db->ops->free (nentry);
			return 0;
		}
		db->ops->free (p->eptr);
		p->eptr = nentry;
		p->changed = true;
		db->cursor = p;

		db->changed = true;
		return 1;
	}
	/* not found, new entry */
	p = (struct commonio_entry *) malloc (sizeof *p);
	if (NULL == p) {
		db->ops->free (nentry);
		errno = ENOMEM;
		return 0;
	}

	p->eptr = nentry;
	p->line = NULL;
	p->changed = true;

#if KEEP_NIS_AT_END
	add_one_entry_nis (db, p);
#else				/* !KEEP_NIS_AT_END */
	add_one_entry (db, p);
#endif				/* !KEEP_NIS_AT_END */

	db->changed = true;
	return 1;
}

#ifdef ENABLE_SUBIDS
int commonio_append (struct commonio_db *db, const void *eptr)
{
	struct commonio_entry *p;
	void *nentry;

	if (!db->isopen || db->readonly) {
		errno = EINVAL;
		return 0;
	}
	nentry = db->ops->dup (eptr);
	if (NULL == nentry) {
		errno = ENOMEM;
		return 0;
	}
	/* new entry */
	p = (struct commonio_entry *) malloc (sizeof *p);
	if (NULL == p) {
		db->ops->free (nentry);
		errno = ENOMEM;
		return 0;
	}

	p->eptr = nentry;
	p->line = NULL;
	p->changed = true;
	add_one_entry (db, p);

	db->changed = true;
	return 1;
}
#endif				/* ENABLE_SUBIDS */

void commonio_del_entry (struct commonio_db *db, const struct commonio_entry *p)
{
	if (p == db->cursor) {
		db->cursor = p->next;
	}

	if (NULL != p->prev) {
		p->prev->next = p->next;
	} else {
		db->head = p->next;
	}

	if (NULL != p->next) {
		p->next->prev = p->prev;
	} else {
		db->tail = p->prev;
	}

	db->changed = true;
}

/*
 * commonio_remove - Remove the entry of the given name from the database.
 */
int commonio_remove (struct commonio_db *db, const char *name)
{
	struct commonio_entry *p;

	if (!db->isopen || db->readonly) {
		errno = EINVAL;
		return 0;
	}
	p = find_entry_by_name (db, name);
	if (NULL == p) {
		errno = ENOENT;
		return 0;
	}
	if (next_entry_by_name (db, p->next, name) != NULL) {
		fprintf (stderr, _('Multiple entries named '%s' in %s. Please fix this with pwck or grpck.\n'), name, db->filename);
		return 0;
	}

	commonio_del_entry (db, p);

	if (NULL != p->line) {
		free (p->line);
	}

	if (NULL != p->eptr) {
		db->ops->free (p->eptr);
	}

	return 1;
}

/*
 * commonio_locate - Find the first entry with the specified name in
 *                   the database.
 *
 *	If found, it returns the entry and set the cursor of the database to
 *	that entry.
 *
 *	Otherwise, it returns NULL.
 */
/*@observer@*/ /*@null@*/const void *commonio_locate (struct commonio_db *db, const char *name)
{
	struct commonio_entry *p;

	if (!db->isopen) {
		errno = EINVAL;
		return NULL;
	}
	p = find_entry_by_name (db, name);
	if (NULL == p) {
		errno = ENOENT;
		return NULL;
	}
	db->cursor = p;
	return p->eptr;
}

/*
 * commonio_rewind - Restore the database cursor to the first entry.
 *
 * It returns 0 on error, 1 on success.
 */
int commonio_rewind (struct commonio_db *db)
{
	if (!db->isopen) {
		errno = EINVAL;
		return 0;
	}
	db->cursor = NULL;
	return 1;
}

/*
 * commonio_next - Return the next entry of the specified database
 *
 * It returns the next entry, or NULL if no other entries could be found.
 */
/*@observer@*/ /*@null@*/const void *commonio_next (struct commonio_db *db)
{
	void *eptr;

	if (!db->isopen) {
		errno = EINVAL;
		return 0;
	}
	if (NULL == db->cursor) {
		db->cursor = db->head;
	} else {
		db->cursor = db->cursor->next;
	}

	while (NULL != db->cursor) {
		eptr = db->cursor->eptr;
		if (NULL != eptr) {
			return eptr;
		}

		db->cursor = db->cursor->next;
	}
	return NULL;
}

",1,7951
shadow-maint/shadow,954e3d2e7113e9ac06632aee3c69b8d818cc8952,"	const char *mode,
	const struct stat *sb);
",0,7952
ImageMagick/ImageMagick,f9b992dd2a4caab1dace919f9190b2c173a4e18c,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),'enter');

  /*
     Open image file.
   */
  quantum_info=(QuantumInfo *) NULL;
  image = AcquireImage(image_info);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=(ImageInfo *) NULL;
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  if (strncmp(MATLAB_HDR.identific,'MATLAB',6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),'  Endian %c%c',
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, 'IM', 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, 'MI', 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, 'MATLAB', 6))
    {
MATLAB_KO:
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf('pos=%X\n',TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3) ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
           ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,'ImproperImageHeader');
         break;
      default: ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          'MATLAB_HDR.StructureClass %d',MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,'UnsupportedCellTypeInTheMatrix');

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        'MATLAB_HDR.CellType: %.20g',(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,'quantum:format','floating-point');
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,'quantum:format','floating-point');
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, 'IncompatibleSizeOfDouble');
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, 'UnsupportedCellTypeInTheMatrix');
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
      /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              '  MAT set image pixels returns unexpected NULL on a row %u.', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             '  MAT cannot read scanrow %u from a file.', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              '  MAT failed to ImportQuantumPixels for a row %u', (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            '  MAT failed to sync image pixels for a row %u', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),'return');
  if (image==NULL)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader')
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
",1,7953
ImageMagick/ImageMagick,f9b992dd2a4caab1dace919f9190b2c173a4e18c,"static void ReadBlobFloatsLSB(Image * image, size_t len, float *data)
{
  while (len >= 4)
  {
    *data++ = ReadBlobFloat(image);
    len -= sizeof(float);
  }
  if (len > 0)
    (void) SeekBlob(image, len, SEEK_CUR);
}
",0,7954
the-tcpdump-group/tcpdump,2b62d1dda41590db29368ec7ba5f4faf3464765a,"void
icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,
           int fragmented)
{
	char *cp;
	const struct icmp *dp;
        const struct icmp_ext_t *ext_dp;
	const struct ip *ip;
	const char *str, *fmt;
	const struct ip *oip;
	const struct udphdr *ouh;
        const uint8_t *obj_tptr;
        uint32_t raw_label;
        const u_char *snapend_save;
	const struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;
	u_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;
	char buf[MAXHOSTNAMELEN + 100];
	struct cksum_vec vec[1];

	dp = (const struct icmp *)bp;
        ext_dp = (const struct icmp_ext_t *)bp;
	ip = (const struct ip *)bp2;
	str = buf;

	ND_TCHECK(dp->icmp_code);
	switch (dp->icmp_type) {

	case ICMP_ECHO:
	case ICMP_ECHOREPLY:
		ND_TCHECK(dp->icmp_seq);
		(void)snprintf(buf, sizeof(buf), 'echo %s, id %u, seq %u',
                               dp->icmp_type == ICMP_ECHO ?
                               'request' : 'reply',
                               EXTRACT_16BITS(&dp->icmp_id),
                               EXTRACT_16BITS(&dp->icmp_seq));
		break;

	case ICMP_UNREACH:
		ND_TCHECK(dp->icmp_ip.ip_dst);
		switch (dp->icmp_code) {

		case ICMP_UNREACH_PROTOCOL:
			ND_TCHECK(dp->icmp_ip.ip_p);
			(void)snprintf(buf, sizeof(buf),
			    '%s protocol %d unreachable',
			    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),
			    dp->icmp_ip.ip_p);
			break;

		case ICMP_UNREACH_PORT:
			ND_TCHECK(dp->icmp_ip.ip_p);
			oip = &dp->icmp_ip;
			hlen = IP_HL(oip) * 4;
			ouh = (const struct udphdr *)(((const u_char *)oip) + hlen);
			ND_TCHECK(ouh->uh_dport);
			dport = EXTRACT_16BITS(&ouh->uh_dport);
			switch (oip->ip_p) {

			case IPPROTO_TCP:
				(void)snprintf(buf, sizeof(buf),
					'%s tcp port %s unreachable',
					ipaddr_string(ndo, &oip->ip_dst),
					tcpport_string(ndo, dport));
				break;

			case IPPROTO_UDP:
				(void)snprintf(buf, sizeof(buf),
					'%s udp port %s unreachable',
					ipaddr_string(ndo, &oip->ip_dst),
					udpport_string(ndo, dport));
				break;

			default:
				(void)snprintf(buf, sizeof(buf),
					'%s protocol %d port %d unreachable',
					ipaddr_string(ndo, &oip->ip_dst),
					oip->ip_p, dport);
				break;
			}
			break;

		case ICMP_UNREACH_NEEDFRAG:
		    {
			register const struct mtu_discovery *mp;
			mp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;
			mtu = EXTRACT_16BITS(&mp->nexthopmtu);
			if (mtu) {
				(void)snprintf(buf, sizeof(buf),
				    '%s unreachable - need to frag (mtu %d)',
				    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);
			} else {
				(void)snprintf(buf, sizeof(buf),
				    '%s unreachable - need to frag',
				    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));
			}
		    }
			break;

		default:
			fmt = tok2str(unreach2str, '#%d %%s unreachable',
			    dp->icmp_code);
			(void)snprintf(buf, sizeof(buf), fmt,
			    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));
			break;
		}
		break;

	case ICMP_REDIRECT:
		ND_TCHECK(dp->icmp_ip.ip_dst);
		fmt = tok2str(type2str, 'redirect-#%d %%s to net %%s',
		    dp->icmp_code);
		(void)snprintf(buf, sizeof(buf), fmt,
		    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),
		    ipaddr_string(ndo, &dp->icmp_gwaddr));
		break;

	case ICMP_ROUTERADVERT:
	    {
		register const struct ih_rdiscovery *ihp;
		register const struct id_rdiscovery *idp;
		u_int lifetime, num, size;

		(void)snprintf(buf, sizeof(buf), 'router advertisement');
		cp = buf + strlen(buf);

		ihp = (const struct ih_rdiscovery *)&dp->icmp_void;
		ND_TCHECK(*ihp);
		(void)strncpy(cp, ' lifetime ', sizeof(buf) - (cp - buf));
		cp = buf + strlen(buf);
		lifetime = EXTRACT_16BITS(&ihp->ird_lifetime);
		if (lifetime < 60) {
			(void)snprintf(cp, sizeof(buf) - (cp - buf), '%u',
			    lifetime);
		} else if (lifetime < 60 * 60) {
			(void)snprintf(cp, sizeof(buf) - (cp - buf), '%u:%02u',
			    lifetime / 60, lifetime % 60);
		} else {
			(void)snprintf(cp, sizeof(buf) - (cp - buf),
			    '%u:%02u:%02u',
			    lifetime / 3600,
			    (lifetime % 3600) / 60,
			    lifetime % 60);
		}
		cp = buf + strlen(buf);

		num = ihp->ird_addrnum;
		(void)snprintf(cp, sizeof(buf) - (cp - buf), ' %d:', num);
		cp = buf + strlen(buf);

		size = ihp->ird_addrsiz;
		if (size != 2) {
			(void)snprintf(cp, sizeof(buf) - (cp - buf),
			    ' [size %d]', size);
			break;
		}
		idp = (const struct id_rdiscovery *)&dp->icmp_data;
		while (num-- > 0) {
			ND_TCHECK(*idp);
			(void)snprintf(cp, sizeof(buf) - (cp - buf), ' {%s %u}',
			    ipaddr_string(ndo, &idp->ird_addr),
			    EXTRACT_32BITS(&idp->ird_pref));
			cp = buf + strlen(buf);
			++idp;
		}
	    }
		break;

	case ICMP_TIMXCEED:
		ND_TCHECK(dp->icmp_ip.ip_dst);
		switch (dp->icmp_code) {

		case ICMP_TIMXCEED_INTRANS:
			str = 'time exceeded in-transit';
			break;

		case ICMP_TIMXCEED_REASS:
			str = 'ip reassembly time exceeded';
			break;

		default:
			(void)snprintf(buf, sizeof(buf), 'time exceeded-#%d',
			    dp->icmp_code);
			break;
		}
		break;

	case ICMP_PARAMPROB:
		if (dp->icmp_code)
			(void)snprintf(buf, sizeof(buf),
			    'parameter problem - code %d', dp->icmp_code);
		else {
			ND_TCHECK(dp->icmp_pptr);
			(void)snprintf(buf, sizeof(buf),
			    'parameter problem - octet %d', dp->icmp_pptr);
		}
		break;

	case ICMP_MASKREPLY:
		ND_TCHECK(dp->icmp_mask);
		(void)snprintf(buf, sizeof(buf), 'address mask is 0x%08x',
		    EXTRACT_32BITS(&dp->icmp_mask));
		break;

	case ICMP_TSTAMP:
		ND_TCHECK(dp->icmp_seq);
		(void)snprintf(buf, sizeof(buf),
		    'time stamp query id %u seq %u',
		    EXTRACT_16BITS(&dp->icmp_id),
		    EXTRACT_16BITS(&dp->icmp_seq));
		break;

	case ICMP_TSTAMPREPLY:
		ND_TCHECK(dp->icmp_ttime);
		(void)snprintf(buf, sizeof(buf),
		    'time stamp reply id %u seq %u: org %s',
                               EXTRACT_16BITS(&dp->icmp_id),
                               EXTRACT_16BITS(&dp->icmp_seq),
                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));

                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),', recv %s',
                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));
                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),', xmit %s',
                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));
                break;

	default:
		str = tok2str(icmp2str, 'type-#%d', dp->icmp_type);
		break;
	}
	ND_PRINT((ndo, 'ICMP %s, length %u', str, plen));
	if (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */
		uint16_t sum, icmp_sum;

		if (ND_TTEST2(*bp, plen)) {
			vec[0].ptr = (const uint8_t *)(const void *)dp;
			vec[0].len = plen;
			sum = in_cksum(vec, 1);
			if (sum != 0) {
				icmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);
				ND_PRINT((ndo, ' (wrong icmp cksum %x (->%x)!)',
					     icmp_sum,
					     in_cksum_shouldbe(icmp_sum, sum)));
			}
		}
	}

        /*
         * print the remnants of the IP packet.
         * save the snaplength as this may get overidden in the IP printer.
         */
	if (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {
		bp += 8;
		ND_PRINT((ndo, '\n\t'));
		ip = (const struct ip *)bp;
                snapend_save = ndo->ndo_snapend;
		ip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));
                ndo->ndo_snapend = snapend_save;
	}

        /*
         * Attempt to decode the MPLS extensions only for some ICMP types.
         */
        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {

            ND_TCHECK(*ext_dp);

            /*
             * Check first if the mpls extension header shows a non-zero length.
             * If the length field is not set then silently verify the checksum
             * to check if an extension header is present. This is expedient,
             * however not all implementations set the length field proper.
             */
            if (!ext_dp->icmp_length) {
                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
                vec[0].len = plen - ICMP_EXTD_MINLEN;
                if (in_cksum(vec, 1)) {
                    return;
                }
            }

            ND_PRINT((ndo, '\n\tMPLS extension v%u',
                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));

            /*
             * Sanity checking of the header.
             */
            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=
                ICMP_MPLS_EXT_VERSION) {
                ND_PRINT((ndo, ' packet not supported'));
                return;
            }

            hlen = plen - ICMP_EXTD_MINLEN;
            vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
            vec[0].len = hlen;
            ND_PRINT((ndo, ', checksum 0x%04x (%scorrect), length %u',
                   EXTRACT_16BITS(ext_dp->icmp_ext_checksum),
                   in_cksum(vec, 1) ? 'in' : '',
                   hlen));

            hlen -= 4; /* subtract common header size */
            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;

            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {

                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;
                ND_TCHECK(*icmp_mpls_ext_object_header);
                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);
                obj_class_num = icmp_mpls_ext_object_header->class_num;
                obj_ctype = icmp_mpls_ext_object_header->ctype;
                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);

                ND_PRINT((ndo, '\n\t  %s Object (%u), Class-Type: %u, length %u',
                       tok2str(icmp_mpls_ext_obj_values,'unknown',obj_class_num),
                       obj_class_num,
                       obj_ctype,
                       obj_tlen));

                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */

                /* infinite loop protection */
                if ((obj_class_num == 0) ||
                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {
                    return;
                }
                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);

                switch (obj_class_num) {
                case 1:
                    switch(obj_ctype) {
                    case 1:
                        ND_TCHECK2(*obj_tptr, 4);
                        raw_label = EXTRACT_32BITS(obj_tptr);
                        ND_PRINT((ndo, '\n\t    label %u, exp %u', MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));
                        if (MPLS_STACK(raw_label))
                            ND_PRINT((ndo, ', [S]'));
                        ND_PRINT((ndo, ', ttl %u', MPLS_TTL(raw_label)));
                        break;
                    default:
                        print_unknown_data(ndo, obj_tptr, '\n\t    ', obj_tlen);
                    }
                    break;

               /*
                *  FIXME those are the defined objects that lack a decoder
                *  you are welcome to contribute code ;-)
                */
                case 2:
                default:
                    print_unknown_data(ndo, obj_tptr, '\n\t    ', obj_tlen);
                    break;
                }
                if (hlen < obj_tlen)
                    break;
                hlen -= obj_tlen;
                obj_tptr += obj_tlen;
            }
        }

	return;
trunc:
	ND_PRINT((ndo, '[|icmp]'));
}
",1,7955
the-tcpdump-group/tcpdump,2b62d1dda41590db29368ec7ba5f4faf3464765a,"const char *
icmp_tstamp_print(u_int tstamp)
{
    u_int msec,sec,min,hrs;

    static char buf[64];

    msec = tstamp % 1000;
    sec = tstamp / 1000;
    min = sec / 60; sec -= min * 60;
    hrs = min / 60; min -= hrs * 60;
    snprintf(buf, sizeof(buf), '%02u:%02u:%02u.%03u',hrs,min,sec,msec);
    return buf;
}
",0,7956
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"static void
gre_print_0(netdissect_options *ndo, const u_char *bp, u_int length)
{
	u_int len = length;
	uint16_t flags, prot;

	/* 16 bits ND_TCHECKed in gre_print() */
	flags = EXTRACT_16BITS(bp);
        if (ndo->ndo_vflag)
            ND_PRINT((ndo, ', Flags [%s]',
                   bittok2str(gre_flag_values,'none',flags)));

	len -= 2;
	bp += 2;

	ND_TCHECK2(*bp, 2);
	if (len < 2)
		goto trunc;
	prot = EXTRACT_16BITS(bp);
	len -= 2;
	bp += 2;

	if ((flags & GRE_CP) | (flags & GRE_RP)) {
		ND_TCHECK2(*bp, 2);
		if (len < 2)
			goto trunc;
		if (ndo->ndo_vflag)
			ND_PRINT((ndo, ', sum 0x%x', EXTRACT_16BITS(bp)));
		bp += 2;
		len -= 2;

		ND_TCHECK2(*bp, 2);
		if (len < 2)
			goto trunc;
		ND_PRINT((ndo, ', off 0x%x', EXTRACT_16BITS(bp)));
		bp += 2;
		len -= 2;
	}

	if (flags & GRE_KP) {
		ND_TCHECK2(*bp, 4);
		if (len < 4)
			goto trunc;
		ND_PRINT((ndo, ', key=0x%x', EXTRACT_32BITS(bp)));
		bp += 4;
		len -= 4;
	}

	if (flags & GRE_SP) {
		ND_TCHECK2(*bp, 4);
		if (len < 4)
			goto trunc;
		ND_PRINT((ndo, ', seq %u', EXTRACT_32BITS(bp)));
		bp += 4;
		len -= 4;
	}

	if (flags & GRE_RP) {
		for (;;) {
			uint16_t af;
			uint8_t sreoff;
			uint8_t srelen;

			ND_TCHECK2(*bp, 4);
			if (len < 4)
				goto trunc;
			af = EXTRACT_16BITS(bp);
			sreoff = *(bp + 2);
			srelen = *(bp + 3);
			bp += 4;
			len -= 4;

			if (af == 0 && srelen == 0)
				break;

			if (!gre_sre_print(ndo, af, sreoff, srelen, bp, len))
				goto trunc;

			if (len < srelen)
				goto trunc;
			bp += srelen;
			len -= srelen;
		}
	}

        if (ndo->ndo_eflag)
            ND_PRINT((ndo, ', proto %s (0x%04x)',
                   tok2str(ethertype_values,'unknown',prot),
                   prot));

        ND_PRINT((ndo, ', length %u',length));

        if (ndo->ndo_vflag < 1)
            ND_PRINT((ndo, ': ')); /* put in a colon as protocol demarc */
        else
            ND_PRINT((ndo, '\n\t')); /* if verbose go multiline */

	switch (prot) {
	case ETHERTYPE_IP:
	        ip_print(ndo, bp, len);
		break;
	case ETHERTYPE_IPV6:
		ip6_print(ndo, bp, len);
		break;
	case ETHERTYPE_MPLS:
		mpls_print(ndo, bp, len);
		break;
	case ETHERTYPE_IPX:
		ipx_print(ndo, bp, len);
		break;
	case ETHERTYPE_ATALK:
		atalk_print(ndo, bp, len);
		break;
	case ETHERTYPE_GRE_ISO:
		isoclns_print(ndo, bp, len, ndo->ndo_snapend - bp);
		break;
	case ETHERTYPE_TEB:
		ether_print(ndo, bp, len, ndo->ndo_snapend - bp, NULL, NULL);
		break;
	default:
		ND_PRINT((ndo, 'gre-proto-0x%x', prot));
	}
	return;

trunc:
	ND_PRINT((ndo, '%s', tstr));
}
",1,7957
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"int
llc_print(netdissect_options *ndo, const u_char *p, u_int length, u_int caplen,
	  const struct lladdr_info *src, const struct lladdr_info *dst)
{
	uint8_t dsap_field, dsap, ssap_field, ssap;
	uint16_t control;
	int hdrlen;
	int is_u;

	if (caplen < 3) {
		ND_PRINT((ndo, '[|llc]'));
		ND_DEFAULTPRINT((const u_char *)p, caplen);
		return (caplen);
	}
	if (length < 3) {
		ND_PRINT((ndo, '[|llc]'));
		ND_DEFAULTPRINT((const u_char *)p, caplen);
		return (length);
	}

	dsap_field = *p;
	ssap_field = *(p + 1);

	/*
	 * OK, what type of LLC frame is this?  The length
	 * of the control field depends on that - I frames
	 * have a two-byte control field, and U frames have
	 * a one-byte control field.
	 */
	control = *(p + 2);
	if ((control & LLC_U_FMT) == LLC_U_FMT) {
		/*
		 * U frame.
		 */
		is_u = 1;
		hdrlen = 3;	/* DSAP, SSAP, 1-byte control field */
	} else {
		/*
		 * The control field in I and S frames is
		 * 2 bytes...
		 */
		if (caplen < 4) {
			ND_PRINT((ndo, '[|llc]'));
			ND_DEFAULTPRINT((const u_char *)p, caplen);
			return (caplen);
		}
		if (length < 4) {
			ND_PRINT((ndo, '[|llc]'));
			ND_DEFAULTPRINT((const u_char *)p, caplen);
			return (length);
		}

		/*
		 * ...and is little-endian.
		 */
		control = EXTRACT_LE_16BITS(p + 2);
		is_u = 0;
		hdrlen = 4;	/* DSAP, SSAP, 2-byte control field */
	}

	if (ssap_field == LLCSAP_GLOBAL && dsap_field == LLCSAP_GLOBAL) {
		/*
		 * This is an Ethernet_802.3 IPX frame; it has an
		 * 802.3 header (i.e., an Ethernet header where the
		 * type/length field is <= ETHERMTU, i.e. it's a length
		 * field, not a type field), but has no 802.2 header -
		 * the IPX packet starts right after the Ethernet header,
		 * with a signature of two bytes of 0xFF (which is
		 * LLCSAP_GLOBAL).
		 *
		 * (It might also have been an Ethernet_802.3 IPX at
		 * one time, but got bridged onto another network,
		 * such as an 802.11 network; this has appeared in at
		 * least one capture file.)
		 */

            if (ndo->ndo_eflag)
		ND_PRINT((ndo, 'IPX 802.3: '));

            ipx_print(ndo, p, length);
            return (0);		/* no LLC header */
	}

	dsap = dsap_field & ~LLC_IG;
	ssap = ssap_field & ~LLC_GSAP;

	if (ndo->ndo_eflag) {
                ND_PRINT((ndo, 'LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %s',
                       tok2str(llc_values, 'Unknown', dsap),
                       dsap,
                       tok2str(llc_ig_flag_values, 'Unknown', dsap_field & LLC_IG),
                       tok2str(llc_values, 'Unknown', ssap),
                       ssap,
                       tok2str(llc_flag_values, 'Unknown', ssap_field & LLC_GSAP)));

		if (is_u) {
			ND_PRINT((ndo, ', ctrl 0x%02x: ', control));
		} else {
			ND_PRINT((ndo, ', ctrl 0x%04x: ', control));
		}
	}

	/*
	 * Skip LLC header.
	 */
	p += hdrlen;
	length -= hdrlen;
	caplen -= hdrlen;

	if (ssap == LLCSAP_SNAP && dsap == LLCSAP_SNAP
	    && control == LLC_UI) {
		/*
		 * XXX - what *is* the right bridge pad value here?
		 * Does anybody ever bridge one form of LAN traffic
		 * over a networking type that uses 802.2 LLC?
		 */
		if (!snap_print(ndo, p, length, caplen, src, dst, 2)) {
			/*
			 * Unknown packet type; tell our caller, by
			 * returning a negative value, so they
			 * can print the raw packet.
			 */
			return (-(hdrlen + 5));	/* include LLC and SNAP header */
		} else
			return (hdrlen + 5);	/* include LLC and SNAP header */
	}

	if (ssap == LLCSAP_8021D && dsap == LLCSAP_8021D &&
	    control == LLC_UI) {
		stp_print(ndo, p, length);
		return (hdrlen);
	}

	if (ssap == LLCSAP_IP && dsap == LLCSAP_IP &&
	    control == LLC_UI) {
		/*
		 * This is an RFC 948-style IP packet, with
		 * an 802.3 header and an 802.2 LLC header
		 * with the source and destination SAPs being
		 * the IP SAP.
		 */
		ip_print(ndo, p, length);
		return (hdrlen);
	}

	if (ssap == LLCSAP_IPX && dsap == LLCSAP_IPX &&
	    control == LLC_UI) {
		/*
		 * This is an Ethernet_802.2 IPX frame, with an 802.3
		 * header and an 802.2 LLC header with the source and
		 * destination SAPs being the IPX SAP.
		 */
                if (ndo->ndo_eflag)
                        ND_PRINT((ndo, 'IPX 802.2: '));

		ipx_print(ndo, p, length);
		return (hdrlen);
	}

#ifdef ENABLE_SMB
	if (ssap == LLCSAP_NETBEUI && dsap == LLCSAP_NETBEUI
	    && (!(control & LLC_S_FMT) || control == LLC_U_FMT)) {
		/*
		 * we don't actually have a full netbeui parser yet, but the
		 * smb parser can handle many smb-in-netbeui packets, which
		 * is very useful, so we call that
		 *
		 * We don't call it for S frames, however, just I frames
		 * (which are frames that don't have the low-order bit,
		 * LLC_S_FMT, set in the first byte of the control field)
		 * and UI frames (whose control field is just 3, LLC_U_FMT).
		 */
		netbeui_print(ndo, control, p, length);
		return (hdrlen);
	}
#endif
	if (ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS
	    && control == LLC_UI) {
		isoclns_print(ndo, p, length, caplen);
		return (hdrlen);
	}

	if (!ndo->ndo_eflag) {
		if (ssap == dsap) {
			if (src == NULL || dst == NULL)
				ND_PRINT((ndo, '%s ', tok2str(llc_values, 'Unknown DSAP 0x%02x', dsap)));
			else
				ND_PRINT((ndo, '%s > %s %s ',
						(src->addr_string)(ndo, src->addr),
						(dst->addr_string)(ndo, dst->addr),
						tok2str(llc_values, 'Unknown DSAP 0x%02x', dsap)));
		} else {
			if (src == NULL || dst == NULL)
				ND_PRINT((ndo, '%s > %s ',
                                        tok2str(llc_values, 'Unknown SSAP 0x%02x', ssap),
					tok2str(llc_values, 'Unknown DSAP 0x%02x', dsap)));
			else
				ND_PRINT((ndo, '%s %s > %s %s ',
					(src->addr_string)(ndo, src->addr),
                                        tok2str(llc_values, 'Unknown SSAP 0x%02x', ssap),
					(dst->addr_string)(ndo, dst->addr),
					tok2str(llc_values, 'Unknown DSAP 0x%02x', dsap)));
		}
	}

	if (is_u) {
		ND_PRINT((ndo, 'Unnumbered, %s, Flags [%s], length %u',
                       tok2str(llc_cmd_values, '%02x', LLC_U_CMD(control)),
                       tok2str(llc_flag_values,'?',(ssap_field & LLC_GSAP) | (control & LLC_U_POLL)),
                       length + hdrlen));

		if ((control & ~LLC_U_POLL) == LLC_XID) {
			if (length == 0) {
				/*
				 * XID with no payload.
				 * This could, for example, be an SNA
				 * 'short form' XID.
                                 */
				return (hdrlen);
			}
			if (caplen < 1) {
				ND_PRINT((ndo, '[|llc]'));
				if (caplen > 0)
					ND_DEFAULTPRINT((const u_char *)p, caplen);
				return (hdrlen);
			}
			if (*p == LLC_XID_FI) {
				if (caplen < 3 || length < 3) {
					ND_PRINT((ndo, '[|llc]'));
					if (caplen > 0)
						ND_DEFAULTPRINT((const u_char *)p, caplen);
				} else
					ND_PRINT((ndo, ': %02x %02x', p[1], p[2]));
				return (hdrlen);
			}
		}
	} else {
		if ((control & LLC_S_FMT) == LLC_S_FMT) {
			ND_PRINT((ndo, 'Supervisory, %s, rcv seq %u, Flags [%s], length %u',
				tok2str(llc_supervisory_values,'?',LLC_S_CMD(control)),
				LLC_IS_NR(control),
				tok2str(llc_flag_values,'?',(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)),
                                length + hdrlen));
			return (hdrlen);	/* no payload to print */
		} else {
			ND_PRINT((ndo, 'Information, send seq %u, rcv seq %u, Flags [%s], length %u',
				LLC_I_NS(control),
				LLC_IS_NR(control),
				tok2str(llc_flag_values,'?',(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)),
                                length + hdrlen));
		}
	}
	return (-hdrlen);
}
",1,7958
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"u_int
null_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_char *p)
{
	u_int length = h->len;
	u_int caplen = h->caplen;
	u_int family;

	if (caplen < NULL_HDRLEN) {
		ND_PRINT((ndo, '[|null]'));
		return (NULL_HDRLEN);
	}

	memcpy((char *)&family, (const char *)p, sizeof(family));

	/*
	 * This isn't necessarily in our host byte order; if this is
	 * a DLT_LOOP capture, it's in network byte order, and if
	 * this is a DLT_NULL capture from a machine with the opposite
	 * byte-order, it's in the opposite byte order from ours.
	 *
	 * If the upper 16 bits aren't all zero, assume it's byte-swapped.
	 */
	if ((family & 0xFFFF0000) != 0)
		family = SWAPLONG(family);

	if (ndo->ndo_eflag)
		null_hdr_print(ndo, family, length);

	length -= NULL_HDRLEN;
	caplen -= NULL_HDRLEN;
	p += NULL_HDRLEN;

	switch (family) {

	case BSD_AFNUM_INET:
		ip_print(ndo, p, length);
		break;

	case BSD_AFNUM_INET6_BSD:
	case BSD_AFNUM_INET6_FREEBSD:
	case BSD_AFNUM_INET6_DARWIN:
		ip6_print(ndo, p, length);
		break;

	case BSD_AFNUM_ISO:
		isoclns_print(ndo, p, length, caplen);
		break;

	case BSD_AFNUM_APPLETALK:
		atalk_print(ndo, p, length);
		break;

	case BSD_AFNUM_IPX:
		ipx_print(ndo, p, length);
		break;

	default:
		/* unknown AF_ value */
		if (!ndo->ndo_eflag)
			null_hdr_print(ndo, family, length + NULL_HDRLEN);
		if (!ndo->ndo_suppress_default_print)
			ND_DEFAULTPRINT(p, caplen);
	}

	return (NULL_HDRLEN);
}
",1,7959
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"int
ethertype_print(netdissect_options *ndo,
                u_short ether_type, const u_char *p,
                u_int length, u_int caplen,
                const struct lladdr_info *src, const struct lladdr_info *dst)
{
	switch (ether_type) {

	case ETHERTYPE_IP:
	        ip_print(ndo, p, length);
		return (1);

	case ETHERTYPE_IPV6:
		ip6_print(ndo, p, length);
		return (1);

	case ETHERTYPE_ARP:
	case ETHERTYPE_REVARP:
	        arp_print(ndo, p, length, caplen);
		return (1);

	case ETHERTYPE_DN:
		decnet_print(ndo, p, length, caplen);
		return (1);

	case ETHERTYPE_ATALK:
		if (ndo->ndo_vflag)
			ND_PRINT((ndo, 'et1 '));
		atalk_print(ndo, p, length);
		return (1);

	case ETHERTYPE_AARP:
		aarp_print(ndo, p, length);
		return (1);

	case ETHERTYPE_IPX:
		ND_PRINT((ndo, '(NOV-ETHII) '));
		ipx_print(ndo, p, length);
		return (1);

	case ETHERTYPE_ISO:
		if (length == 0 || caplen == 0) {
			ND_PRINT((ndo, ' [|osi]'));
			return (1);
		}
		isoclns_print(ndo, p + 1, length - 1, caplen - 1);
		return(1);

	case ETHERTYPE_PPPOED:
	case ETHERTYPE_PPPOES:
	case ETHERTYPE_PPPOED2:
	case ETHERTYPE_PPPOES2:
		pppoe_print(ndo, p, length);
		return (1);

	case ETHERTYPE_EAPOL:
	        eap_print(ndo, p, length);
		return (1);

	case ETHERTYPE_RRCP:
	        rrcp_print(ndo, p, length, src, dst);
		return (1);

	case ETHERTYPE_PPP:
		if (length) {
			ND_PRINT((ndo, ': '));
			ppp_print(ndo, p, length);
		}
		return (1);

	case ETHERTYPE_MPCP:
	        mpcp_print(ndo, p, length);
		return (1);

	case ETHERTYPE_SLOW:
	        slow_print(ndo, p, length);
		return (1);

	case ETHERTYPE_CFM:
	case ETHERTYPE_CFM_OLD:
		cfm_print(ndo, p, length);
		return (1);

	case ETHERTYPE_LLDP:
		lldp_print(ndo, p, length);
		return (1);

        case ETHERTYPE_NSH:
                nsh_print(ndo, p, length);
                return (1);

        case ETHERTYPE_LOOPBACK:
		loopback_print(ndo, p, length);
                return (1);

	case ETHERTYPE_MPLS:
	case ETHERTYPE_MPLS_MULTI:
		mpls_print(ndo, p, length);
		return (1);

	case ETHERTYPE_TIPC:
		tipc_print(ndo, p, length, caplen);
		return (1);

	case ETHERTYPE_MS_NLB_HB:
		msnlb_print(ndo, p);
		return (1);

        case ETHERTYPE_GEONET_OLD:
        case ETHERTYPE_GEONET:
                geonet_print(ndo, p, length, src);
                return (1);

        case ETHERTYPE_CALM_FAST:
                calm_fast_print(ndo, p, length, src);
                return (1);

	case ETHERTYPE_AOE:
		aoe_print(ndo, p, length);
		return (1);

	case ETHERTYPE_MEDSA:
		medsa_print(ndo, p, length, caplen, src, dst);
		return (1);

	case ETHERTYPE_LAT:
	case ETHERTYPE_SCA:
	case ETHERTYPE_MOPRC:
	case ETHERTYPE_MOPDL:
	case ETHERTYPE_IEEE1905_1:
		/* default_print for now */
	default:
		return (0);
	}
}
",1,7960
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"u_int
chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)
{
	u_int proto;
	const u_char *bp = p;

	if (length < CHDLC_HDRLEN)
		goto trunc;
	ND_TCHECK2(*p, CHDLC_HDRLEN);
	proto = EXTRACT_16BITS(&p[2]);
	if (ndo->ndo_eflag) {
                ND_PRINT((ndo, '%s, ethertype %s (0x%04x), length %u: ',
                       tok2str(chdlc_cast_values, '0x%02x', p[0]),
                       tok2str(ethertype_values, 'Unknown', proto),
                       proto,
                       length));
	}

	length -= CHDLC_HDRLEN;
	p += CHDLC_HDRLEN;

	switch (proto) {
	case ETHERTYPE_IP:
		ip_print(ndo, p, length);
		break;
	case ETHERTYPE_IPV6:
		ip6_print(ndo, p, length);
		break;
	case CHDLC_TYPE_SLARP:
		chdlc_slarp_print(ndo, p, length);
		break;
#if 0
	case CHDLC_TYPE_CDP:
		chdlc_cdp_print(p, length);
		break;
#endif
        case ETHERTYPE_MPLS:
        case ETHERTYPE_MPLS_MULTI:
                mpls_print(ndo, p, length);
		break;
        case ETHERTYPE_ISO:
                /* is the fudge byte set ? lets verify by spotting ISO headers */
                if (length < 2)
                    goto trunc;
                ND_TCHECK_16BITS(p);
                if (*(p+1) == 0x81 ||
                    *(p+1) == 0x82 ||
                    *(p+1) == 0x83)
                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);
                else
                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);
                break;
	default:
                if (!ndo->ndo_eflag)
                        ND_PRINT((ndo, 'unknown CHDLC protocol (0x%04x)', proto));
                break;
	}

	return (CHDLC_HDRLEN);

trunc:
	ND_PRINT((ndo, '[|chdlc]'));
	return ndo->ndo_snapend - bp;
}
",1,7961
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"u_int
fr_print(netdissect_options *ndo,
         register const u_char *p, u_int length)
{
	int ret;
	uint16_t extracted_ethertype;
	u_int dlci;
	u_int addr_len;
	uint16_t nlpid;
	u_int hdr_len;
	uint8_t flags[4];

	ret = parse_q922_addr(ndo, p, &dlci, &addr_len, flags, length);
	if (ret == -1)
		goto trunc;
	if (ret == 0) {
		ND_PRINT((ndo, 'Q.922, invalid address'));
		return 0;
	}

	ND_TCHECK(p[addr_len]);
	if (length < addr_len + 1)
		goto trunc;

	if (p[addr_len] != LLC_UI && dlci != 0) {
                /*
                 * Let's figure out if we have Cisco-style encapsulation,
                 * with an Ethernet type (Cisco HDLC type?) following the
                 * address.
                 */
		if (!ND_TTEST2(p[addr_len], 2) || length < addr_len + 2) {
                        /* no Ethertype */
                        ND_PRINT((ndo, 'UI %02x! ', p[addr_len]));
                } else {
                        extracted_ethertype = EXTRACT_16BITS(p+addr_len);

                        if (ndo->ndo_eflag)
                                fr_hdr_print(ndo, length, addr_len, dlci,
                                    flags, extracted_ethertype);

                        if (ethertype_print(ndo, extracted_ethertype,
                                            p+addr_len+ETHERTYPE_LEN,
                                            length-addr_len-ETHERTYPE_LEN,
                                            ndo->ndo_snapend-p-addr_len-ETHERTYPE_LEN,
                                            NULL, NULL) == 0)
                                /* ether_type not known, probably it wasn't one */
                                ND_PRINT((ndo, 'UI %02x! ', p[addr_len]));
                        else
                                return addr_len + 2;
                }
        }

	ND_TCHECK(p[addr_len+1]);
	if (length < addr_len + 2)
		goto trunc;

	if (p[addr_len + 1] == 0) {
		/*
		 * Assume a pad byte after the control (UI) byte.
		 * A pad byte should only be used with 3-byte Q.922.
		 */
		if (addr_len != 3)
			ND_PRINT((ndo, 'Pad! '));
		hdr_len = addr_len + 1 /* UI */ + 1 /* pad */ + 1 /* NLPID */;
	} else {
		/*
		 * Not a pad byte.
		 * A pad byte should be used with 3-byte Q.922.
		 */
		if (addr_len == 3)
			ND_PRINT((ndo, 'No pad! '));
		hdr_len = addr_len + 1 /* UI */ + 1 /* NLPID */;
	}

        ND_TCHECK(p[hdr_len - 1]);
	if (length < hdr_len)
		goto trunc;
	nlpid = p[hdr_len - 1];

	if (ndo->ndo_eflag)
		fr_hdr_print(ndo, length, addr_len, dlci, flags, nlpid);
	p += hdr_len;
	length -= hdr_len;

	switch (nlpid) {
	case NLPID_IP:
	        ip_print(ndo, p, length);
		break;

	case NLPID_IP6:
		ip6_print(ndo, p, length);
		break;

	case NLPID_CLNP:
	case NLPID_ESIS:
	case NLPID_ISIS:
		isoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1); /* OSI printers need the NLPID field */
		break;

	case NLPID_SNAP:
		if (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {
			/* ether_type not known, print raw packet */
                        if (!ndo->ndo_eflag)
                            fr_hdr_print(ndo, length + hdr_len, hdr_len,
                                         dlci, flags, nlpid);
			if (!ndo->ndo_suppress_default_print)
				ND_DEFAULTPRINT(p - hdr_len, length + hdr_len);
		}
		break;

        case NLPID_Q933:
		q933_print(ndo, p, length);
		break;

        case NLPID_MFR:
                frf15_print(ndo, p, length);
                break;

        case NLPID_PPP:
                ppp_print(ndo, p, length);
                break;

	default:
		if (!ndo->ndo_eflag)
                    fr_hdr_print(ndo, length + hdr_len, addr_len,
				     dlci, flags, nlpid);
		if (!ndo->ndo_xflag)
			ND_DEFAULTPRINT(p, length);
	}

	return hdr_len;

 trunc:
        ND_PRINT((ndo, '[|fr]'));
        return 0;

}
",1,7962
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"void
isoclns_print(netdissect_options *ndo,
              const uint8_t *p, u_int length, u_int caplen)
{
	if (caplen <= 1) { /* enough bytes on the wire ? */
		ND_PRINT((ndo, '|OSI'));
		return;
	}

	if (ndo->ndo_eflag)
		ND_PRINT((ndo, 'OSI NLPID %s (0x%02x): ', tok2str(nlpid_values, 'Unknown', *p), *p));

	switch (*p) {

	case NLPID_CLNP:
		if (!clnp_print(ndo, p, length))
			print_unknown_data(ndo, p, '\n\t', caplen);
		break;

	case NLPID_ESIS:
		esis_print(ndo, p, length);
		return;

	case NLPID_ISIS:
		if (!isis_print(ndo, p, length))
			print_unknown_data(ndo, p, '\n\t', caplen);
		break;

	case NLPID_NULLNS:
		ND_PRINT((ndo, '%slength: %u', ndo->ndo_eflag ? '' : ', ', length));
		break;

	case NLPID_Q933:
		q933_print(ndo, p + 1, length - 1);
		break;

	case NLPID_IP:
		ip_print(ndo, p + 1, length - 1);
		break;

	case NLPID_IP6:
		ip6_print(ndo, p + 1, length - 1);
		break;

	case NLPID_PPP:
		ppp_print(ndo, p + 1, length - 1);
		break;

	default:
		if (!ndo->ndo_eflag)
			ND_PRINT((ndo, 'OSI NLPID 0x%02x unknown', *p));
		ND_PRINT((ndo, '%slength: %u', ndo->ndo_eflag ? '' : ', ', length));
		if (caplen > 1)
			print_unknown_data(ndo, p, '\n\t', caplen);
		break;
	}
}
",1,7963
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"void
mpls_print(netdissect_options *ndo, const u_char *bp, u_int length)
{
	const u_char *p;
	uint32_t label_entry;
	uint16_t label_stack_depth = 0;
	enum mpls_packet_type pt = PT_UNKNOWN;

	p = bp;
	ND_PRINT((ndo, 'MPLS'));
	do {
		ND_TCHECK2(*p, sizeof(label_entry));
		if (length < sizeof(label_entry)) {
			ND_PRINT((ndo, '[|MPLS], length %u', length));
			return;
		}
		label_entry = EXTRACT_32BITS(p);
		ND_PRINT((ndo, '%s(label %u',
		       (label_stack_depth && ndo->ndo_vflag) ? '\n\t' : ' ',
       		       MPLS_LABEL(label_entry)));
		label_stack_depth++;
		if (ndo->ndo_vflag &&
		    MPLS_LABEL(label_entry) < sizeof(mpls_labelname) / sizeof(mpls_labelname[0]))
			ND_PRINT((ndo, ' (%s)', mpls_labelname[MPLS_LABEL(label_entry)]));
		ND_PRINT((ndo, ', exp %u', MPLS_EXP(label_entry)));
		if (MPLS_STACK(label_entry))
			ND_PRINT((ndo, ', [S]'));
		ND_PRINT((ndo, ', ttl %u)', MPLS_TTL(label_entry)));

		p += sizeof(label_entry);
		length -= sizeof(label_entry);
	} while (!MPLS_STACK(label_entry));

	/*
	 * Try to figure out the packet type.
	 */
	switch (MPLS_LABEL(label_entry)) {

	case 0:	/* IPv4 explicit NULL label */
	case 3:	/* IPv4 implicit NULL label */
		pt = PT_IPV4;
		break;

	case 2:	/* IPv6 explicit NULL label */
		pt = PT_IPV6;
		break;

	default:
		/*
		 * Generally there's no indication of protocol in MPLS label
		 * encoding.
		 *
		 * However, draft-hsmit-isis-aal5mux-00.txt describes a
		 * technique for encapsulating IS-IS and IP traffic on the
		 * same ATM virtual circuit; you look at the first payload
		 * byte to determine the network layer protocol, based on
		 * the fact that
		 *
		 *	1) the first byte of an IP header is 0x45-0x4f
		 *	   for IPv4 and 0x60-0x6f for IPv6;
		 *
		 *	2) the first byte of an OSI CLNP packet is 0x81,
		 *	   the first byte of an OSI ES-IS packet is 0x82,
		 *	   and the first byte of an OSI IS-IS packet is
		 *	   0x83;
		 *
		 * so the network layer protocol can be inferred from the
		 * first byte of the packet, if the protocol is one of the
		 * ones listed above.
		 *
		 * Cisco sends control-plane traffic MPLS-encapsulated in
		 * this fashion.
		 */
		ND_TCHECK(*p);
		if (length < 1) {
			/* nothing to print */
			return;
		}
		switch(*p) {

		case 0x45:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4a:
		case 0x4b:
		case 0x4c:
		case 0x4d:
		case 0x4e:
		case 0x4f:
			pt = PT_IPV4;
			break;

		case 0x60:
		case 0x61:
		case 0x62:
		case 0x63:
		case 0x64:
		case 0x65:
		case 0x66:
		case 0x67:
		case 0x68:
		case 0x69:
		case 0x6a:
		case 0x6b:
		case 0x6c:
		case 0x6d:
		case 0x6e:
		case 0x6f:
			pt = PT_IPV6;
			break;

		case 0x81:
		case 0x82:
		case 0x83:
			pt = PT_OSI;
			break;

		default:
			/* ok bail out - we did not figure out what it is*/
			break;
		}
	}

	/*
	 * Print the payload.
	 */
	if (pt == PT_UNKNOWN) {
		if (!ndo->ndo_suppress_default_print)
			ND_DEFAULTPRINT(p, length);
		return;
	}
	ND_PRINT((ndo, ndo->ndo_vflag ? '\n\t' : ' '));
	switch (pt) {

	case PT_IPV4:
		ip_print(ndo, p, length);
		break;

	case PT_IPV6:
		ip6_print(ndo, p, length);
		break;

	case PT_OSI:
		isoclns_print(ndo, p, length, length);
		break;

	default:
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, '[|MPLS]'));
}
",1,7964
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"static void
handle_ppp(netdissect_options *ndo,
           u_int proto, const u_char *p, int length)
{
	if ((proto & 0xff00) == 0x7e00) { /* is this an escape code ? */
		ppp_hdlc(ndo, p - 1, length);
		return;
	}

	switch (proto) {
	case PPP_LCP: /* fall through */
	case PPP_IPCP:
	case PPP_OSICP:
	case PPP_MPLSCP:
	case PPP_IPV6CP:
	case PPP_CCP:
	case PPP_BACP:
		handle_ctrl_proto(ndo, proto, p, length);
		break;
	case PPP_ML:
		handle_mlppp(ndo, p, length);
		break;
	case PPP_CHAP:
		handle_chap(ndo, p, length);
		break;
	case PPP_PAP:
		handle_pap(ndo, p, length);
		break;
	case PPP_BAP:		/* XXX: not yet completed */
		handle_bap(ndo, p, length);
		break;
	case ETHERTYPE_IP:	/*XXX*/
        case PPP_VJNC:
	case PPP_IP:
		ip_print(ndo, p, length);
		break;
	case ETHERTYPE_IPV6:	/*XXX*/
	case PPP_IPV6:
		ip6_print(ndo, p, length);
		break;
	case ETHERTYPE_IPX:	/*XXX*/
	case PPP_IPX:
		ipx_print(ndo, p, length);
		break;
	case PPP_OSI:
		isoclns_print(ndo, p, length, length);
		break;
	case PPP_MPLS_UCAST:
	case PPP_MPLS_MCAST:
		mpls_print(ndo, p, length);
		break;
	case PPP_COMP:
		ND_PRINT((ndo, 'compressed PPP data'));
		break;
	default:
		ND_PRINT((ndo, '%s ', tok2str(ppptype2str, 'unknown PPP protocol (0x%04x)', proto)));
		print_unknown_data(ndo, p, '\n\t', length);
		break;
	}
}
",1,7965
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"u_int
atm_if_print(netdissect_options *ndo,
             const struct pcap_pkthdr *h, const u_char *p)
{
	u_int caplen = h->caplen;
	u_int length = h->len;
	uint32_t llchdr;
	u_int hdrlen = 0;

	if (caplen < 1 || length < 1) {
		ND_PRINT((ndo, '%s', tstr));
		return (caplen);
	}

        /* Cisco Style NLPID ? */
        if (*p == LLC_UI) {
            if (ndo->ndo_eflag)
                ND_PRINT((ndo, 'CNLPID '));
            isoclns_print(ndo, p + 1, length - 1, caplen - 1);
            return hdrlen;
        }

	/*
	 * Must have at least a DSAP, an SSAP, and the first byte of the
	 * control field.
	 */
	if (caplen < 3 || length < 3) {
		ND_PRINT((ndo, '%s', tstr));
		return (caplen);
	}

	/*
	 * Extract the presumed LLC header into a variable, for quick
	 * testing.
	 * Then check for a header that's neither a header for a SNAP
	 * packet nor an RFC 2684 routed NLPID-formatted PDU nor
	 * an 802.2-but-no-SNAP IP packet.
	 */
	llchdr = EXTRACT_24BITS(p);
	if (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&
	    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&
	    llchdr != LLC_UI_HDR(LLCSAP_IP)) {
		/*
		 * XXX - assume 802.6 MAC header from Fore driver.
		 *
		 * Unfortunately, the above list doesn't check for
		 * all known SAPs, doesn't check for headers where
		 * the source and destination SAP aren't the same,
		 * and doesn't check for non-UI frames.  It also
		 * runs the risk of an 802.6 MAC header that happens
		 * to begin with one of those values being
		 * incorrectly treated as an 802.2 header.
		 *
		 * So is that Fore driver still around?  And, if so,
		 * is it still putting 802.6 MAC headers on ATM
		 * packets?  If so, could it be changed to use a
		 * new DLT_IEEE802_6 value if we added it?
		 */
		if (caplen < 20 || length < 20) {
			ND_PRINT((ndo, '%s', tstr));
			return (caplen);
		}
		if (ndo->ndo_eflag)
			ND_PRINT((ndo, '%08x%08x %08x%08x ',
			       EXTRACT_32BITS(p),
			       EXTRACT_32BITS(p+4),
			       EXTRACT_32BITS(p+8),
			       EXTRACT_32BITS(p+12)));
		p += 20;
		length -= 20;
		caplen -= 20;
		hdrlen += 20;
	}
	hdrlen += atm_llc_print(ndo, p, length, caplen);
	return (hdrlen);
}
",1,7966
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"#include 'netdissect.h'
#include 'af.h'

/*
 * The DLT_NULL packet header is 4 bytes long. It contains a host-byte-order
",0,7967
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"
/* Based on UNI3.1 standard by ATM Forum */

/* ATM traffic types based on VPI=0 and (the following VCI */
#define VCI_PPC			0x05	/* Point-to-point signal msg */
#define VCI_BCC			0x02	/* Broadcast signal msg */
#define VCI_OAMF4SC		0x03	/* Segment OAM F4 flow cell */
#define VCI_OAMF4EC		0x04	/* End-to-end OAM F4 flow cell */
#define VCI_METAC		0x01	/* Meta signal msg */
",0,7968
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"
",0,7969
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"static int parse_q922_addr(netdissect_options *ndo,
                           const u_char *p, u_int *dlci,
                           u_int *addr_len, uint8_t *flags, u_int length)
{
	if (!ND_TTEST(p[0]) || length < 1)
		return -1;
	if ((p[0] & FR_EA_BIT))
		return 0;

	if (!ND_TTEST(p[1]) || length < 2)
		return -1;
	*addr_len = 2;
	*dlci = ((p[0] & 0xFC) << 2) | ((p[1] & 0xF0) >> 4);

        flags[0] = p[0] & 0x02; /* populate the first flag fields */
        flags[1] = p[1] & 0x0c;
        flags[2] = 0;           /* clear the rest of the flags */
        flags[3] = 0;

	if (p[1] & FR_EA_BIT)
		return 1;	/* 2-byte Q.922 address */

	p += 2;
	length -= 2;
	if (!ND_TTEST(p[0]) || length < 1)
		return -1;
	(*addr_len)++;		/* 3- or 4-byte Q.922 address */
	if ((p[0] & FR_EA_BIT) == 0) {
		*dlci = (*dlci << 7) | (p[0] >> 1);
		(*addr_len)++;	/* 4-byte Q.922 address */
		p++;
		length--;
	}

	if (!ND_TTEST(p[0]) || length < 1)
		return -1;
	if ((p[0] & FR_EA_BIT) == 0)
		return 0; /* more than 4 bytes of Q.922 address? */

        flags[3] = p[0] & 0x02;

        *dlci = (*dlci << 6) | (p[0] >> 2);

	return 1;
}
",0,7970
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"/*5*/	'rsvd', 'rsvd', 'rsvd', 'rsvd', 'rsvd',
/*10*/	'rsvd', 'rsvd', 'rsvd', 'rsvd', 'rsvd',
/*15*/	'rsvd',
};

",0,7971
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de," */

#ifdef HAVE_CONFIG_H
#include 'config.h'
#endif
",0,7972
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"
#include 'netdissect.h'
#include 'addrtostr.h'
#include 'extract.h'
#include 'ethertype.h'

static const char tstr[] = '[|gre]';

#define	GRE_CP		0x8000		/* checksum present */
",0,7973
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"    { ETHERTYPE_PPPOED,         'PPPoE D' },
    { ETHERTYPE_PPPOES,         'PPPoE S' },
    { ETHERTYPE_EAPOL,          'EAPOL' },
    { ETHERTYPE_RRCP,           'RRCP' },
    { ETHERTYPE_MS_NLB_HB,      'MS NLB heartbeat' },
    { ETHERTYPE_JUMBO,          'Jumbo' },
    { ETHERTYPE_NSH,            'NSH' },
    { ETHERTYPE_LOOPBACK,       'Loopback' },
    { ETHERTYPE_ISO,            'OSI' },
",0,7974
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"static int
print_bacp_config_options(netdissect_options *ndo,
                          const u_char *p, int length)
{
	int len, opt;

	if (length < 2)
		return 0;
	ND_TCHECK2(*p, 2);
	len = p[1];
	opt = p[0];
	if (length < len)
		return 0;
	if (len < 2) {
		ND_PRINT((ndo, '\n\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)',
		          tok2str(bacconfopts_values, 'Unknown', opt),
		          opt,
		          len));
		return 0;
	}

	ND_PRINT((ndo, '\n\t  %s Option (0x%02x), length %u',
	          tok2str(bacconfopts_values, 'Unknown', opt),
	          opt,
	          len));

	switch (opt) {
	case BACPOPT_FPEER:
		if (len != 6) {
			ND_PRINT((ndo, ' (length bogus, should be = 6)'));
			return len;
		}
		ND_TCHECK2(*(p + 2), 4);
		ND_PRINT((ndo, ': Magic-Num 0x%08x', EXTRACT_32BITS(p + 2)));
		break;
	default:
		/*
		 * Unknown option; dump it as raw bytes now if we're
		 * not going to do so below.
		 */
		if (ndo->ndo_vflag < 2)
			print_unknown_data(ndo, &p[2], '\n\t    ', len - 2);
		break;
	}
	if (ndo->ndo_vflag > 1)
		print_unknown_data(ndo, &p[2], '\n\t    ', len - 2); /* exclude TLV header */

	return len;

trunc:
	ND_PRINT((ndo, '[|bacp]'));
	return 0;
}
",0,7975
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"static void
handle_pap(netdissect_options *ndo,
           const u_char *p, int length)
{
	u_int code, len;
	int peerid_len, passwd_len, msg_len;
	const u_char *p0;
	int i;

	p0 = p;
	if (length < 1) {
		ND_PRINT((ndo, '[|pap]'));
		return;
	} else if (length < 4) {
		ND_TCHECK(*p);
		ND_PRINT((ndo, '[|pap 0x%02x]', *p));
		return;
	}

	ND_TCHECK(*p);
	code = *p;
	ND_PRINT((ndo, 'PAP, %s (0x%02x)',
	          tok2str(papcode_values, 'unknown', code),
	          code));
	p++;

	ND_TCHECK(*p);
	ND_PRINT((ndo, ', id %u', *p));		/* ID */
	p++;

	ND_TCHECK2(*p, 2);
	len = EXTRACT_16BITS(p);
	p += 2;

	if ((int)len > length) {
		ND_PRINT((ndo, ', length %u > packet size', len));
		return;
	}
	length = len;
	if (length < (p - p0)) {
		ND_PRINT((ndo, ', length %u < PAP header length', length));
		return;
	}

	switch (code) {
	case PAP_AREQ:
		/* A valid Authenticate-Request is 6 or more octets long. */
		if (len < 6)
			goto trunc;
		if (length - (p - p0) < 1)
			return;
		ND_TCHECK(*p);
		peerid_len = *p;	/* Peer-ID Length */
		p++;
		if (length - (p - p0) < peerid_len)
			return;
		ND_PRINT((ndo, ', Peer '));
		for (i = 0; i < peerid_len; i++) {
			ND_TCHECK(*p);
			safeputchar(ndo, *p++);
		}

		if (length - (p - p0) < 1)
			return;
		ND_TCHECK(*p);
		passwd_len = *p;	/* Password Length */
		p++;
		if (length - (p - p0) < passwd_len)
			return;
		ND_PRINT((ndo, ', Name '));
		for (i = 0; i < passwd_len; i++) {
			ND_TCHECK(*p);
			safeputchar(ndo, *p++);
		}
		break;
	case PAP_AACK:
	case PAP_ANAK:
		/* Although some implementations ignore truncation at
		 * this point and at least one generates a truncated
		 * packet, RFC 1334 section 2.2.2 clearly states that
		 * both AACK and ANAK are at least 5 bytes long.
		 */
		if (len < 5)
			goto trunc;
		if (length - (p - p0) < 1)
			return;
		ND_TCHECK(*p);
		msg_len = *p;		/* Msg-Length */
		p++;
		if (length - (p - p0) < msg_len)
			return;
		ND_PRINT((ndo, ', Msg '));
		for (i = 0; i< msg_len; i++) {
			ND_TCHECK(*p);
			safeputchar(ndo, *p++);
		}
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, '[|pap]'));
}
",0,7976
the-tcpdump-group/tcpdump,1dcd10aceabbc03bf571ea32b892c522cbe923de,"    } oam_ptr;
",0,7977
the-tcpdump-group/tcpdump,b534e304568585707c4a92422aeca25cf908ff02,"static int
juniper_parse_header(netdissect_options *ndo,
                     const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)
{
    const struct juniper_cookie_table_t *lp = juniper_cookie_table;
    u_int idx, jnx_ext_len, jnx_header_len = 0;
    uint8_t tlv_type,tlv_len;
    uint32_t control_word;
    int tlv_value;
    const u_char *tptr;


    l2info->header_len = 0;
    l2info->cookie_len = 0;
    l2info->proto = 0;


    l2info->length = h->len;
    l2info->caplen = h->caplen;
    ND_TCHECK2(p[0], 4);
    l2info->flags = p[3];
    l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;

    if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { /* magic number found ? */
        ND_PRINT((ndo, 'no magic-number found!'));
        return 0;
    }

    if (ndo->ndo_eflag) /* print direction */
        ND_PRINT((ndo, '%3s ', tok2str(juniper_direction_values, '---', l2info->direction)));

    /* magic number + flags */
    jnx_header_len = 4;

    if (ndo->ndo_vflag > 1)
        ND_PRINT((ndo, '\n\tJuniper PCAP Flags [%s]',
               bittok2str(jnx_flag_values, 'none', l2info->flags)));

    /* extensions present ?  - calculate how much bytes to skip */
    if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {

        tptr = p+jnx_header_len;

        /* ok to read extension length ? */
        ND_TCHECK2(tptr[0], 2);
        jnx_ext_len = EXTRACT_16BITS(tptr);
        jnx_header_len += 2;
        tptr +=2;

        /* nail up the total length -
         * just in case something goes wrong
         * with TLV parsing */
        jnx_header_len += jnx_ext_len;

        if (ndo->ndo_vflag > 1)
            ND_PRINT((ndo, ', PCAP Extension(s) total length %u', jnx_ext_len));

        ND_TCHECK2(tptr[0], jnx_ext_len);
        while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {
            tlv_type = *(tptr++);
            tlv_len = *(tptr++);
            tlv_value = 0;

            /* sanity checks */
            if (tlv_type == 0 || tlv_len == 0)
                break;
            if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)
                goto trunc;

            if (ndo->ndo_vflag > 1)
                ND_PRINT((ndo, '\n\t  %s Extension TLV #%u, length %u, value ',
                       tok2str(jnx_ext_tlv_values,'Unknown',tlv_type),
                       tlv_type,
                       tlv_len));

            tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);
            switch (tlv_type) {
            case JUNIPER_EXT_TLV_IFD_NAME:
                /* FIXME */
                break;
            case JUNIPER_EXT_TLV_IFD_MEDIATYPE:
            case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:
                if (tlv_value != -1) {
                    if (ndo->ndo_vflag > 1)
                        ND_PRINT((ndo, '%s (%u)',
                               tok2str(juniper_ifmt_values, 'Unknown', tlv_value),
                               tlv_value));
                }
                break;
            case JUNIPER_EXT_TLV_IFL_ENCAPS:
            case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:
                if (tlv_value != -1) {
                    if (ndo->ndo_vflag > 1)
                        ND_PRINT((ndo, '%s (%u)',
                               tok2str(juniper_ifle_values, 'Unknown', tlv_value),
                               tlv_value));
                }
                break;
            case JUNIPER_EXT_TLV_IFL_IDX: /* fall through */
            case JUNIPER_EXT_TLV_IFL_UNIT:
            case JUNIPER_EXT_TLV_IFD_IDX:
            default:
                if (tlv_value != -1) {
                    if (ndo->ndo_vflag > 1)
                        ND_PRINT((ndo, '%u', tlv_value));
                }
                break;
            }

            tptr+=tlv_len;
            jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;
        }

        if (ndo->ndo_vflag > 1)
            ND_PRINT((ndo, '\n\t-----original packet-----\n\t'));
    }

    if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {
        if (ndo->ndo_eflag)
            ND_PRINT((ndo, 'no-L2-hdr, '));

        /* there is no link-layer present -
         * perform the v4/v6 heuristics
         * to figure out what it is
         */
        ND_TCHECK2(p[jnx_header_len + 4], 1);
        if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,
                               l2info->length - (jnx_header_len + 4)) == 0)
            ND_PRINT((ndo, 'no IP-hdr found!'));

        l2info->header_len=jnx_header_len+4;
        return 0; /* stop parsing the output further */

    }
    l2info->header_len = jnx_header_len;
    p+=l2info->header_len;
    l2info->length -= l2info->header_len;
    l2info->caplen -= l2info->header_len;

    /* search through the cookie table and copy values matching for our PIC type */
    while (lp->s != NULL) {
        if (lp->pictype == l2info->pictype) {

            l2info->cookie_len += lp->cookie_len;

            switch (p[0]) {
            case LS_COOKIE_ID:
                l2info->cookie_type = LS_COOKIE_ID;
                l2info->cookie_len += 2;
                break;
            case AS_COOKIE_ID:
                l2info->cookie_type = AS_COOKIE_ID;
                l2info->cookie_len = 8;
                break;

            default:
                l2info->bundle = l2info->cookie[0];
                break;
            }


#ifdef DLT_JUNIPER_MFR
            /* MFR child links don't carry cookies */
            if (l2info->pictype == DLT_JUNIPER_MFR &&
                (p[0] & MFR_BE_MASK) == MFR_BE_MASK) {
                l2info->cookie_len = 0;
            }
#endif

            l2info->header_len += l2info->cookie_len;
            l2info->length -= l2info->cookie_len;
            l2info->caplen -= l2info->cookie_len;

            if (ndo->ndo_eflag)
                ND_PRINT((ndo, '%s-PIC, cookie-len %u',
                       lp->s,
                       l2info->cookie_len));

            if (l2info->cookie_len > 0) {
                ND_TCHECK2(p[0], l2info->cookie_len);
                if (ndo->ndo_eflag)
                    ND_PRINT((ndo, ', cookie 0x'));
                for (idx = 0; idx < l2info->cookie_len; idx++) {
                    l2info->cookie[idx] = p[idx]; /* copy cookie data */
                    if (ndo->ndo_eflag) ND_PRINT((ndo, '%02x', p[idx]));
                }
            }

            if (ndo->ndo_eflag) ND_PRINT((ndo, ': ')); /* print demarc b/w L2/L3*/


            l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);
            break;
        }
        ++lp;
    }
    p+=l2info->cookie_len;

    /* DLT_ specific parsing */
    switch(l2info->pictype) {
#ifdef DLT_JUNIPER_MLPPP
    case DLT_JUNIPER_MLPPP:
        switch (l2info->cookie_type) {
        case LS_COOKIE_ID:
            l2info->bundle = l2info->cookie[1];
            break;
        case AS_COOKIE_ID:
            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
            break;
        default:
            l2info->bundle = l2info->cookie[0];
            break;
        }
        break;
#endif
#ifdef DLT_JUNIPER_MLFR
    case DLT_JUNIPER_MLFR:
        switch (l2info->cookie_type) {
        case LS_COOKIE_ID:
            l2info->bundle = l2info->cookie[1];
            l2info->proto = EXTRACT_16BITS(p);
            l2info->header_len += 2;
            l2info->length -= 2;
            l2info->caplen -= 2;
            break;
        case AS_COOKIE_ID:
            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
            break;
        default:
            l2info->bundle = l2info->cookie[0];
            l2info->header_len += 2;
            l2info->length -= 2;
            l2info->caplen -= 2;
            break;
        }
        break;
#endif
#ifdef DLT_JUNIPER_MFR
    case DLT_JUNIPER_MFR:
        switch (l2info->cookie_type) {
        case LS_COOKIE_ID:
            l2info->bundle = l2info->cookie[1];
            l2info->proto = EXTRACT_16BITS(p);
            l2info->header_len += 2;
            l2info->length -= 2;
            l2info->caplen -= 2;
            break;
        case AS_COOKIE_ID:
            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
            break;
        default:
            l2info->bundle = l2info->cookie[0];
            break;
        }
        break;
#endif
#ifdef DLT_JUNIPER_ATM2
    case DLT_JUNIPER_ATM2:
        ND_TCHECK2(p[0], 4);
        /* ATM cell relay control word present ? */
        if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {
            control_word = EXTRACT_32BITS(p);
            /* some control word heuristics */
            switch(control_word) {
            case 0: /* zero control word */
            case 0x08000000: /* < JUNOS 7.4 control-word */
            case 0x08380000: /* cntl word plus cell length (56) >= JUNOS 7.4*/
                l2info->header_len += 4;
                break;
            default:
                break;
            }

            if (ndo->ndo_eflag)
                ND_PRINT((ndo, 'control-word 0x%08x ', control_word));
        }
        break;
#endif
#ifdef DLT_JUNIPER_GGSN
    case DLT_JUNIPER_GGSN:
        break;
#endif
#ifdef DLT_JUNIPER_ATM1
    case DLT_JUNIPER_ATM1:
        break;
#endif
#ifdef DLT_JUNIPER_PPP
    case DLT_JUNIPER_PPP:
        break;
#endif
#ifdef DLT_JUNIPER_CHDLC
    case DLT_JUNIPER_CHDLC:
        break;
#endif
#ifdef DLT_JUNIPER_ETHER
    case DLT_JUNIPER_ETHER:
        break;
#endif
#ifdef DLT_JUNIPER_FRELAY
    case DLT_JUNIPER_FRELAY:
        break;
#endif

    default:
        ND_PRINT((ndo, 'Unknown Juniper DLT_ type %u: ', l2info->pictype));
        break;
    }

    if (ndo->ndo_eflag > 1)
        ND_PRINT((ndo, 'hlen %u, proto 0x%04x, ', l2info->header_len, l2info->proto));

    return 1; /* everything went ok so far. continue parsing */
 trunc:
    ND_PRINT((ndo, '[|juniper_hdr], length %u', h->len));
    return 0;
}
",1,7978
the-tcpdump-group/tcpdump,b534e304568585707c4a92422aeca25cf908ff02,"static int
juniper_ppp_heuristic_guess(netdissect_options *ndo,
                            register const u_char *p, u_int length)
{
    switch(EXTRACT_16BITS(p)) {
    case PPP_IP :
    case PPP_OSI :
    case PPP_MPLS_UCAST :
    case PPP_MPLS_MCAST :
    case PPP_IPCP :
    case PPP_OSICP :
    case PPP_MPLSCP :
    case PPP_LCP :
    case PPP_PAP :
    case PPP_CHAP :
    case PPP_ML :
    case PPP_IPV6 :
    case PPP_IPV6CP :
        ppp_print(ndo, p, length);
        break;

    default:
        return 0; /* did not find a ppp header */
        break;
    }
    return 1; /* we printed a ppp packet */
}
",0,7979
ImageMagick/ImageMagick,19dbe11c5060f66abb393d1945107c5f54894fa8,"static MagickBooleanType load_level(Image *image,XCFDocInfo *inDocInfo,
  XCFLayerInfo *inLayerInfo,ExceptionInfo *exception)
{
  int
    destLeft = 0,
    destTop = 0;

  Image*
    tile_image;

  MagickBooleanType
    status;

  MagickOffsetType
    saved_pos,
    offset,
    offset2;

  register ssize_t
    i;

  size_t
    width,
    height,
    ntiles,
    ntile_rows,
    ntile_cols,
    tile_image_width,
    tile_image_height;

  /* start reading the data */
  width=ReadBlobMSBLong(image);
  height=ReadBlobMSBLong(image);

  /* read in the first tile offset.
   *  if it is '0', then this tile level is empty
   *  and we can simply return.
   */
  offset=(MagickOffsetType) ReadBlobMSBLong(image);
  if (offset == 0)
    return(MagickTrue);
  /* Initialise the reference for the in-memory tile-compression
   */
  ntile_rows=(height+TILE_HEIGHT-1)/TILE_HEIGHT;
  ntile_cols=(width+TILE_WIDTH-1)/TILE_WIDTH;
  ntiles=ntile_rows*ntile_cols;
  for (i = 0; i < (ssize_t) ntiles; i++)
  {
    status=MagickFalse;
    if (offset == 0)
      ThrowBinaryException(CorruptImageError,'NotEnoughTiles',image->filename);
    /* save the current position as it is where the
     *  next tile offset is stored.
     */
    saved_pos=TellBlob(image);
    /* read in the offset of the next tile so we can calculate the amount
       of data needed for this tile*/
    offset2=(MagickOffsetType)ReadBlobMSBLong(image);
    /* if the offset is 0 then we need to read in the maximum possible
       allowing for negative compression */
    if (offset2 == 0)
      offset2=(MagickOffsetType) (offset + TILE_WIDTH * TILE_WIDTH * 4* 1.5);
    /* seek to the tile offset */
    if (SeekBlob(image, offset, SEEK_SET) != offset)
      ThrowBinaryException(CorruptImageError,'InsufficientImageDataInFile',
        image->filename);

      /*
        Allocate the image for the tile.  NOTE: the last tile in a row or
        column may not be a full tile!
      */
      tile_image_width=(size_t) (destLeft == (int) ntile_cols-1 ?
        (int) width % TILE_WIDTH : TILE_WIDTH);
      if (tile_image_width == 0)
        tile_image_width=TILE_WIDTH;
      tile_image_height = (size_t) (destTop == (int) ntile_rows-1 ?
        (int) height % TILE_HEIGHT : TILE_HEIGHT);
      if (tile_image_height == 0)
        tile_image_height=TILE_HEIGHT;
      tile_image=CloneImage(inLayerInfo->image,tile_image_width,
        tile_image_height,MagickTrue,exception);

      /* read in the tile */
      switch (inDocInfo->compression)
      {
        case COMPRESS_NONE:
          if (load_tile(image,tile_image,inDocInfo,inLayerInfo,(size_t) (offset2-offset),exception) == 0)
            status=MagickTrue;
          break;
        case COMPRESS_RLE:
          if (load_tile_rle (image,tile_image,inDocInfo,inLayerInfo,
              (int) (offset2-offset),exception) == 0)
            status=MagickTrue;
          break;
        case COMPRESS_ZLIB:
          ThrowBinaryException(CoderError,'ZipCompressNotSupported',
            image->filename)
        case COMPRESS_FRACTAL:
          ThrowBinaryException(CoderError,'FractalCompressNotSupported',
            image->filename)
      }

      /* composite the tile onto the layer's image, and then destroy it */
      (void) CompositeImage(inLayerInfo->image,tile_image,CopyCompositeOp,
        MagickTrue,destLeft * TILE_WIDTH,destTop*TILE_HEIGHT,exception);
      tile_image=DestroyImage(tile_image);

      /* adjust tile position */
      destLeft++;
      if (destLeft >= (int) ntile_cols)
        {
          destLeft = 0;
          destTop++;
        }
      if (status != MagickFalse)
        return(MagickFalse);
      /* restore the saved position so we'll be ready to
       *  read the next offset.
       */
      offset=SeekBlob(image, saved_pos, SEEK_SET);
      /* read in the offset of the next tile */
      offset=(MagickOffsetType) ReadBlobMSBLong(image);
    }
  if (offset != 0)
    ThrowBinaryException(CorruptImageError,'CorruptImage',image->filename)
  return(MagickTrue);
}
",1,7980
ImageMagick/ImageMagick,19dbe11c5060f66abb393d1945107c5f54894fa8,"static MagickBooleanType load_hierarchy(Image *image,XCFDocInfo *inDocInfo,
   XCFLayerInfo *inLayer, ExceptionInfo *exception)
{
  MagickOffsetType
    saved_pos,
    offset,
    junk;

  size_t
    width,
    height,
    bytes_per_pixel;

  width=ReadBlobMSBLong(image);
  (void) width;
  height=ReadBlobMSBLong(image);
  (void) height;
  bytes_per_pixel=inDocInfo->bytes_per_pixel=ReadBlobMSBLong(image);
  (void) bytes_per_pixel;

  /* load in the levels...we make sure that the number of levels
   *  calculated when the TileManager was created is the same
   *  as the number of levels found in the file.
   */
  offset=(MagickOffsetType) ReadBlobMSBLong(image);  /* top level */

  /* discard offsets for layers below first, if any.
   */
  do
  {
    junk=(MagickOffsetType) ReadBlobMSBLong(image);
  }
  while (junk != 0);

  /* save the current position as it is where the
   *  next level offset is stored.
   */
  saved_pos=TellBlob(image);

  /* seek to the level offset */
  if (SeekBlob(image, offset, SEEK_SET) != offset)
    ThrowBinaryException(CorruptImageError,'InsufficientImageDataInFile',
      image->filename);

  /* read in the level */
  if (load_level (image, inDocInfo, inLayer, exception) == 0)
    return(MagickFalse);
  /* restore the saved position so we'll be ready to
   *  read the next offset.
   */
  offset=SeekBlob(image, saved_pos, SEEK_SET);
  return(MagickTrue);
}
",0,7981
ImageMagick/ImageMagick,5304ae14655a67b9a3db00563fe44d9abd6de4f0,"static unsigned char *SFWScan(const unsigned char *p,const unsigned char *q,
  const unsigned char *target,const size_t length)
{
  register ssize_t
    i;

  if ((p+length) < q)
    while (p < q)
    {
      for (i=0; i < (ssize_t) length; i++)
        if (p[i] != target[i])
          break;
      if (i == (ssize_t) length)
        return((unsigned char *) p);
      p++;
    }
  return((unsigned char *) NULL);
}
",1,7982
ImageMagick/ImageMagick,5304ae14655a67b9a3db00563fe44d9abd6de4f0,"static MagickBooleanType IsSFW(const unsigned char *magick,const size_t length)
{
  if (length < 5)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick,'SFW94',5) == 0)
    return(MagickTrue);
  return(MagickFalse);
}
",0,7983
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_ke_print(netdissect_options *ndo, u_char tpay _U_,
	       const struct isakmp_gen *ext, u_int item_len _U_,
	       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,
	       uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,'%s:', NPSTR(ISAKMP_NPTYPE_KE)));

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,' key len=%d', ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_KE)));
	return NULL;
}
",1,7984
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,
		 const struct isakmp_gen *ext, u_int item_len,
		 const u_char *ep _U_, uint32_t phase _U_,
		 uint32_t doi0 _U_,
		 uint32_t proto0 _U_, int depth _U_)
{
	const struct ikev1_pl_cert *p;
	struct ikev1_pl_cert cert;
	static const char *certstr[] = {
		'none',	'pkcs7', 'pgp', 'dns',
		'x509sign', 'x509ke', 'kerberos', 'crl',
		'arl', 'spki', 'x509attr',
	};

	ND_PRINT((ndo,'%s:', NPSTR(ISAKMP_NPTYPE_CERT)));

	p = (const struct ikev1_pl_cert *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&cert, ext, sizeof(cert));
	ND_PRINT((ndo,' len=%d', item_len - 4));
	ND_PRINT((ndo,' type=%s', STR_OR_ID((cert.encode), certstr)));
	if (2 < ndo->ndo_vflag && 4 < item_len) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))
			goto trunc;
	}
	return (const u_char *)ext + item_len;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_CERT)));
	return NULL;
}
",1,7985
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_cr_print(netdissect_options *ndo, u_char tpay _U_,
	       const struct isakmp_gen *ext, u_int item_len,
	       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi0 _U_,
	       uint32_t proto0 _U_, int depth _U_)
{
	const struct ikev1_pl_cert *p;
	struct ikev1_pl_cert cert;
	static const char *certstr[] = {
		'none',	'pkcs7', 'pgp', 'dns',
		'x509sign', 'x509ke', 'kerberos', 'crl',
		'arl', 'spki', 'x509attr',
	};

	ND_PRINT((ndo,'%s:', NPSTR(ISAKMP_NPTYPE_CR)));

	p = (const struct ikev1_pl_cert *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&cert, ext, sizeof(cert));
	ND_PRINT((ndo,' len=%d', item_len - 4));
	ND_PRINT((ndo,' type=%s', STR_OR_ID((cert.encode), certstr)));
	if (2 < ndo->ndo_vflag && 4 < item_len) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))
			goto trunc;
	}
	return (const u_char *)ext + item_len;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_CR)));
	return NULL;
}
",1,7986
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,
		 const struct isakmp_gen *ext, u_int item_len _U_,
		 const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,
		 uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,'%s:', NPSTR(ISAKMP_NPTYPE_HASH)));

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,' len=%d', ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_HASH)));
	return NULL;
}
",1,7987
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext, u_int item_len _U_,
		const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,'%s:', NPSTR(ISAKMP_NPTYPE_SIG)));

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,' len=%d', ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_SIG)));
	return NULL;
}
",1,7988
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,'%s:', NPSTR(ISAKMP_NPTYPE_VID)));

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,' len=%d', ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_VID)));
	return NULL;
}
",1,7989
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_gen_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext)
{
	struct isakmp_gen e;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ikev2_pay_print(ndo, NPSTR(tpay), e.critical);

	ND_PRINT((ndo,' len=%d', ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return NULL;
}
",1,7990
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_p_print(netdissect_options *ndo, u_char tpay _U_, int pcount _U_,
	      const struct isakmp_gen *ext, u_int oprop_length,
	      const u_char *ep, int depth)
{
	const struct ikev2_p *p;
	struct ikev2_p prop;
	u_int prop_length;
	const u_char *cp;
	int i;
	int tcount;
	u_char np;
	struct isakmp_gen e;
	u_int item_len;

	p = (const struct ikev2_p *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&prop, ext, sizeof(prop));

	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_P), prop.h.critical);

	/*
	 * ikev2_sa_print() guarantees that this is >= 4.
	 */
	prop_length = oprop_length - 4;
	ND_PRINT((ndo,' #%u protoid=%s transform=%d len=%u',
		  prop.p_no,  PROTOIDSTR(prop.prot_id),
		  prop.num_t, oprop_length));
	cp = (const u_char *)(p + 1);

	if (prop.spi_size) {
		if (prop_length < prop.spi_size)
			goto toolong;
		ND_PRINT((ndo,' spi='));
		if (!rawprint(ndo, (const uint8_t *)cp, prop.spi_size))
			goto trunc;
		cp += prop.spi_size;
		prop_length -= prop.spi_size;
	}

	/*
	 * Print the transforms.
	 */
	tcount = 0;
	for (np = ISAKMP_NPTYPE_T; np != 0; np = e.np) {
		tcount++;
		ext = (const struct isakmp_gen *)cp;
		if (prop_length < sizeof(*ext))
			goto toolong;
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		/*
		 * Since we can't have a payload length of less than 4 bytes,
		 * we need to bail out here if the generic header is nonsensical
		 * or truncated, otherwise we could loop forever processing
		 * zero-length items or otherwise misdissect the packet.
		 */
		item_len = ntohs(e.len);
		if (item_len <= 4)
			goto trunc;

		if (prop_length < item_len)
			goto toolong;
		ND_TCHECK2(*cp, item_len);

		depth++;
		ND_PRINT((ndo,'\n'));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,'    '));
		ND_PRINT((ndo,'('));
		if (np == ISAKMP_NPTYPE_T) {
			cp = ikev2_t_print(ndo, tcount, ext, item_len, ep);
			if (cp == NULL) {
				/* error, already reported */
				return NULL;
			}
		} else {
			ND_PRINT((ndo, '%s', NPSTR(np)));
			cp += item_len;
		}
		ND_PRINT((ndo,')'));
		depth--;
		prop_length -= item_len;
	}
	return cp;
toolong:
	/*
	 * Skip the rest of the proposal.
	 */
	cp += prop_length;
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_P)));
	return cp;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_P)));
	return NULL;
}
",1,7991
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_sa_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext1,
		u_int osa_length, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth)
{
	const struct isakmp_gen *ext;
	struct isakmp_gen e;
	u_int sa_length;
	const u_char *cp;
	int i;
	int pcount;
	u_char np;
	u_int item_len;

	ND_TCHECK(*ext1);
	UNALIGNED_MEMCPY(&e, ext1, sizeof(e));
	ikev2_pay_print(ndo, 'sa', e.critical);

	/*
	 * ikev2_sub0_print() guarantees that this is >= 4.
	 */
	osa_length= ntohs(e.len);
	sa_length = osa_length - 4;
	ND_PRINT((ndo,' len=%d', sa_length));

	/*
	 * Print the payloads.
	 */
	cp = (const u_char *)(ext1 + 1);
	pcount = 0;
	for (np = ISAKMP_NPTYPE_P; np != 0; np = e.np) {
		pcount++;
		ext = (const struct isakmp_gen *)cp;
		if (sa_length < sizeof(*ext))
			goto toolong;
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		/*
		 * Since we can't have a payload length of less than 4 bytes,
		 * we need to bail out here if the generic header is nonsensical
		 * or truncated, otherwise we could loop forever processing
		 * zero-length items or otherwise misdissect the packet.
		 */
		item_len = ntohs(e.len);
		if (item_len <= 4)
			goto trunc;

		if (sa_length < item_len)
			goto toolong;
		ND_TCHECK2(*cp, item_len);

		depth++;
		ND_PRINT((ndo,'\n'));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,'    '));
		ND_PRINT((ndo,'('));
		if (np == ISAKMP_NPTYPE_P) {
			cp = ikev2_p_print(ndo, np, pcount, ext, item_len,
					   ep, depth);
			if (cp == NULL) {
				/* error, already reported */
				return NULL;
			}
		} else {
			ND_PRINT((ndo, '%s', NPSTR(np)));
			cp += item_len;
		}
		ND_PRINT((ndo,')'));
		depth--;
		sa_length -= item_len;
	}
	return cp;
toolong:
	/*
	 * Skip the rest of the SA.
	 */
	cp += sa_length;
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return cp;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return NULL;
}
",1,7992
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_ke_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct ikev2_ke ke;
	const struct ikev2_ke *k;

	k = (const struct ikev2_ke *)ext;
	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&ke, ext, sizeof(ke));
	ikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);

	ND_PRINT((ndo,' len=%u group=%s', ntohs(ke.h.len) - 8,
		  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));

	if (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(ke.h.len);
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return NULL;
}
",1,7993
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_ID_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct ikev2_id id;
	int id_len, idtype_len, i;
	unsigned int dumpascii, dumphex;
	const unsigned char *typedata;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&id, ext, sizeof(id));
	ikev2_pay_print(ndo, NPSTR(tpay), id.h.critical);

	id_len = ntohs(id.h.len);

	ND_PRINT((ndo,' len=%d', id_len - 4));
	if (2 < ndo->ndo_vflag && 4 < id_len) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), id_len - 4))
			goto trunc;
	}

	idtype_len =id_len - sizeof(struct ikev2_id);
	dumpascii = 0;
	dumphex   = 0;
	typedata  = (const unsigned char *)(ext)+sizeof(struct ikev2_id);

	switch(id.type) {
	case ID_IPV4_ADDR:
		ND_PRINT((ndo, ' ipv4:'));
		dumphex=1;
		break;
	case ID_FQDN:
		ND_PRINT((ndo, ' fqdn:'));
		dumpascii=1;
		break;
	case ID_RFC822_ADDR:
		ND_PRINT((ndo, ' rfc822:'));
		dumpascii=1;
		break;
	case ID_IPV6_ADDR:
		ND_PRINT((ndo, ' ipv6:'));
		dumphex=1;
		break;
	case ID_DER_ASN1_DN:
		ND_PRINT((ndo, ' dn:'));
		dumphex=1;
		break;
	case ID_DER_ASN1_GN:
		ND_PRINT((ndo, ' gn:'));
		dumphex=1;
		break;
	case ID_KEY_ID:
		ND_PRINT((ndo, ' keyid:'));
		dumphex=1;
		break;
	}

	if(dumpascii) {
		ND_TCHECK2(*typedata, idtype_len);
		for(i=0; i<idtype_len; i++) {
			if(ND_ISPRINT(typedata[i])) {
				ND_PRINT((ndo, '%c', typedata[i]));
			} else {
				ND_PRINT((ndo, '.'));
			}
		}
	}
	if(dumphex) {
		if (!rawprint(ndo, (const uint8_t *)typedata, idtype_len))
			goto trunc;
	}

	return (const u_char *)ext + id_len;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return NULL;
}
",1,7994
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_auth_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct ikev2_auth a;
	const char *v2_auth[]={ 'invalid', 'rsasig',
				'shared-secret', 'dsssig' };
	const u_char *authdata = (const u_char*)ext + sizeof(a);
	unsigned int len;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&a, ext, sizeof(a));
	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
	len = ntohs(a.h.len);

	/*
	 * Our caller has ensured that the length is >= 4.
	 */
	ND_PRINT((ndo,' len=%u method=%s', len-4,
		  STR_OR_ID(a.auth_method, v2_auth)));
	if (len > 4) {
		if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, ' authdata=('));
			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
				goto trunc;
			ND_PRINT((ndo, ') '));
		} else if (ndo->ndo_vflag) {
			if (!ike_show_somedata(ndo, authdata, ep))
				goto trunc;
		}
	}

	return (const u_char *)ext + len;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return NULL;
}
",1,7995
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_vid_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;
	const u_char *vid;
	int i, len;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ikev2_pay_print(ndo, NPSTR(tpay), e.critical);
	ND_PRINT((ndo,' len=%d vid=', ntohs(e.len) - 4));

	vid = (const u_char *)(ext+1);
	len = ntohs(e.len) - 4;
	ND_TCHECK2(*vid, len);
	for(i=0; i<len; i++) {
		if(ND_ISPRINT(vid[i])) ND_PRINT((ndo, '%c', vid[i]));
		else ND_PRINT((ndo, '.'));
	}
	if (2 < ndo->ndo_vflag && 4 < len) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return NULL;
}
",1,7996
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,'\n'));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,'    '));
		ND_PRINT((ndo,'('));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,')'));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(np)));
	return NULL;
}
",1,7997
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_sub_print(netdissect_options *ndo,
		struct isakmp *base,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;
	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,'\n'));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,'    '));
		ND_PRINT((ndo,'('));
		cp = ikev2_sub0_print(ndo, base, np,
				      ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,')'));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(np)));
	return NULL;
}
",1,7998
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static void
hexprint(netdissect_options *ndo, const uint8_t *loc, size_t len)
{
	const uint8_t *p;
	size_t i;

	p = loc;
	for (i = 0; i < len; i++)
		ND_PRINT((ndo,'%02x', p[i] & 0xff));
}
",0,7999
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static int ike_show_somedata(netdissect_options *ndo,
			     const u_char *cp, const u_char *ep)
{
	/* there is too much data, just show some of it */
	const u_char *end = ep - 20;
	int  elen = 20;
	int   len = ep - cp;
	if(len > 10) {
		len = 10;
	}

	/* really shouldn't happen because of above */
	if(end < cp + len) {
		end = cp+len;
		elen = ep - end;
	}

	ND_PRINT((ndo,' data=('));
	if(!rawprint(ndo, (const uint8_t *)(cp), len)) goto trunc;
	ND_PRINT((ndo, '...'));
	if(elen) {
		if(!rawprint(ndo, (const uint8_t *)(end), elen)) goto trunc;
	}
	ND_PRINT((ndo,')'));
	return 1;

trunc:
	return 0;
}
",0,8000
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_d_print(netdissect_options *ndo, u_char tpay _U_,
	      const struct isakmp_gen *ext, u_int item_len _U_,
	      const u_char *ep _U_, uint32_t phase _U_, uint32_t doi0 _U_,
	      uint32_t proto0 _U_, int depth _U_)
{
	const struct ikev1_pl_d *p;
	struct ikev1_pl_d d;
	const uint8_t *q;
	uint32_t doi;
	uint32_t proto;
	int i;

	ND_PRINT((ndo,'%s:', NPSTR(ISAKMP_NPTYPE_D)));

	p = (const struct ikev1_pl_d *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&d, ext, sizeof(d));
	doi = ntohl(d.doi);
	proto = d.prot_id;
	if (doi != 1) {
		ND_PRINT((ndo,' doi=%u', doi));
		ND_PRINT((ndo,' proto=%u', proto));
	} else {
		ND_PRINT((ndo,' doi=ipsec'));
		ND_PRINT((ndo,' proto=%s', PROTOIDSTR(proto)));
	}
	ND_PRINT((ndo,' spilen=%u', d.spi_size));
	ND_PRINT((ndo,' nspi=%u', ntohs(d.num_spi)));
	ND_PRINT((ndo,' spi='));
	q = (const uint8_t *)(p + 1);
	for (i = 0; i < ntohs(d.num_spi); i++) {
		if (i != 0)
			ND_PRINT((ndo,','));
		if (!rawprint(ndo, (const uint8_t *)q, d.spi_size))
			goto trunc;
		q += d.spi_size;
	}
	return q;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_D)));
	return NULL;
}
",0,8001
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static void
ikev2_pay_print(netdissect_options *ndo, const char *payname, int critical)
{
	ND_PRINT((ndo,'%s%s:', payname, critical&0x80 ? '[C]' : ''));
}
",0,8002
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static void
cookie_record(cookie_t *in, const u_char *bp2)
{
	int i;
	const struct ip *ip;
	const struct ip6_hdr *ip6;

	i = cookie_find(in);
	if (0 <= i) {
		ninitiator = (i + 1) % MAXINITIATORS;
		return;
	}

	ip = (const struct ip *)bp2;
	switch (IP_V(ip)) {
	case 4:
		cookiecache[ninitiator].version = 4;
		UNALIGNED_MEMCPY(&cookiecache[ninitiator].iaddr.in4, &ip->ip_src, sizeof(struct in_addr));
		UNALIGNED_MEMCPY(&cookiecache[ninitiator].raddr.in4, &ip->ip_dst, sizeof(struct in_addr));
		break;
	case 6:
		ip6 = (const struct ip6_hdr *)bp2;
		cookiecache[ninitiator].version = 6;
		UNALIGNED_MEMCPY(&cookiecache[ninitiator].iaddr.in6, &ip6->ip6_src, sizeof(struct in6_addr));
		UNALIGNED_MEMCPY(&cookiecache[ninitiator].raddr.in6, &ip6->ip6_dst, sizeof(struct in6_addr));
		break;
	default:
		return;
	}
	UNALIGNED_MEMCPY(&cookiecache[ninitiator].initiator, in, sizeof(*in));
	ninitiator = (ninitiator + 1) % MAXINITIATORS;
}
",0,8003
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_cert_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	return ikev2_gen_print(ndo, tpay, ext);
}
",0,8004
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_nonce_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ikev2_pay_print(ndo, 'nonce', e.critical);

	ND_PRINT((ndo,' len=%d', ntohs(e.len) - 4));
	if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,' nonce=('));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
		ND_PRINT((ndo,') '));
	} else if(ndo->ndo_vflag && 4 < ntohs(e.len)) {
		if(!ike_show_somedata(ndo, (const u_char *)(ext+1), ep)) goto trunc;
	}

	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return NULL;
}
",0,8005
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_e_print(netdissect_options *ndo,
#ifndef HAVE_LIBCRYPTO
	      _U_
#endif
	      struct isakmp *base,
	      u_char tpay,
	      const struct isakmp_gen *ext,
	      u_int item_len _U_, const u_char *ep _U_,
#ifndef HAVE_LIBCRYPTO
	      _U_
#endif
	      uint32_t phase,
#ifndef HAVE_LIBCRYPTO
	      _U_
#endif
	      uint32_t doi,
#ifndef HAVE_LIBCRYPTO
	      _U_
#endif
	      uint32_t proto,
#ifndef HAVE_LIBCRYPTO
	      _U_
#endif
	      int depth)
{
	struct isakmp_gen e;
	const u_char *dat;
	volatile int dlen;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ikev2_pay_print(ndo, NPSTR(tpay), e.critical);

	dlen = ntohs(e.len)-4;

	ND_PRINT((ndo,' len=%d', dlen));
	if (2 < ndo->ndo_vflag && 4 < dlen) {
		ND_PRINT((ndo,' '));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), dlen))
			goto trunc;
	}

	dat = (const u_char *)(ext+1);
	ND_TCHECK2(*dat, dlen);

#ifdef HAVE_LIBCRYPTO
	/* try to decypt it! */
	if(esp_print_decrypt_buffer_by_ikev2(ndo,
					     base->flags & ISAKMP_FLAG_I,
					     base->i_ck, base->r_ck,
					     dat, dat+dlen)) {

		ext = (const struct isakmp_gen *)ndo->ndo_packetp;

		/* got it decrypted, print stuff inside. */
		ikev2_sub_print(ndo, base, e.np, ext, ndo->ndo_snapend,
				phase, doi, proto, depth+1);
	}
#endif


	/* always return NULL, because E must be at end, and NP refers
	 * to what was inside.
	 */
	return NULL;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(tpay)));
	return NULL;
}
",0,8006
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_cp_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	return ikev2_gen_print(ndo, tpay, ext);
}
",0,8007
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev1_id_print(netdissect_options *ndo, u_char tpay _U_,
	       const struct isakmp_gen *ext, u_int item_len,
	       const u_char *ep _U_, uint32_t phase, uint32_t doi _U_,
	       uint32_t proto _U_, int depth _U_)
{
#define USE_IPSECDOI_IN_PHASE1	1
	const struct ikev1_pl_id *p;
	struct ikev1_pl_id id;
	static const char *idtypestr[] = {
		'IPv4', 'IPv4net', 'IPv6', 'IPv6net',
	};
	static const char *ipsecidtypestr[] = {
		NULL, 'IPv4', 'FQDN', 'user FQDN', 'IPv4net', 'IPv6',
		'IPv6net', 'IPv4range', 'IPv6range', 'ASN1 DN', 'ASN1 GN',
		'keyid',
	};
	int len;
	const u_char *data;

	ND_PRINT((ndo,'%s:', NPSTR(ISAKMP_NPTYPE_ID)));

	p = (const struct ikev1_pl_id *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&id, ext, sizeof(id));
	if (sizeof(*p) < item_len) {
		data = (const u_char *)(p + 1);
		len = item_len - sizeof(*p);
	} else {
		data = NULL;
		len = 0;
	}

#if 0 /*debug*/
	ND_PRINT((ndo,' [phase=%d doi=%d proto=%d]', phase, doi, proto));
#endif
	switch (phase) {
#ifndef USE_IPSECDOI_IN_PHASE1
	case 1:
#endif
	default:
		ND_PRINT((ndo,' idtype=%s', STR_OR_ID(id.d.id_type, idtypestr)));
		ND_PRINT((ndo,' doi_data=%u',
			  (uint32_t)(ntohl(id.d.doi_data) & 0xffffff)));
		break;

#ifdef USE_IPSECDOI_IN_PHASE1
	case 1:
#endif
	case 2:
	    {
		const struct ipsecdoi_id *doi_p;
		struct ipsecdoi_id doi_id;
		const char *p_name;

		doi_p = (const struct ipsecdoi_id *)ext;
		ND_TCHECK(*doi_p);
		UNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id));
		ND_PRINT((ndo,' idtype=%s', STR_OR_ID(doi_id.type, ipsecidtypestr)));
		/* A protocol ID of 0 DOES NOT mean IPPROTO_IP! */
		if (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL)
			ND_PRINT((ndo,' protoid=%s', p_name));
		else
			ND_PRINT((ndo,' protoid=%u', doi_id.proto_id));
		ND_PRINT((ndo,' port=%d', ntohs(doi_id.port)));
		if (!len)
			break;
		if (data == NULL)
			goto trunc;
		ND_TCHECK2(*data, len);
		switch (doi_id.type) {
		case IPSECDOI_ID_IPV4_ADDR:
			if (len < 4)
				ND_PRINT((ndo,' len=%d [bad: < 4]', len));
			else
				ND_PRINT((ndo,' len=%d %s', len, ipaddr_string(ndo, data)));
			len = 0;
			break;
		case IPSECDOI_ID_FQDN:
		case IPSECDOI_ID_USER_FQDN:
		    {
			int i;
			ND_PRINT((ndo,' len=%d ', len));
			for (i = 0; i < len; i++)
				safeputchar(ndo, data[i]);
			len = 0;
			break;
		    }
		case IPSECDOI_ID_IPV4_ADDR_SUBNET:
		    {
			const u_char *mask;
			if (len < 8)
				ND_PRINT((ndo,' len=%d [bad: < 8]', len));
			else {
				mask = data + sizeof(struct in_addr);
				ND_PRINT((ndo,' len=%d %s/%u.%u.%u.%u', len,
					  ipaddr_string(ndo, data),
					  mask[0], mask[1], mask[2], mask[3]));
			}
			len = 0;
			break;
		    }
		case IPSECDOI_ID_IPV6_ADDR:
			if (len < 16)
				ND_PRINT((ndo,' len=%d [bad: < 16]', len));
			else
				ND_PRINT((ndo,' len=%d %s', len, ip6addr_string(ndo, data)));
			len = 0;
			break;
		case IPSECDOI_ID_IPV6_ADDR_SUBNET:
		    {
			const u_char *mask;
			if (len < 32)
				ND_PRINT((ndo,' len=%d [bad: < 32]', len));
			else {
				mask = (const u_char *)(data + sizeof(struct in6_addr));
				/*XXX*/
				ND_PRINT((ndo,' len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x', len,
					  ip6addr_string(ndo, data),
					  mask[0], mask[1], mask[2], mask[3],
					  mask[4], mask[5], mask[6], mask[7],
					  mask[8], mask[9], mask[10], mask[11],
					  mask[12], mask[13], mask[14], mask[15]));
			}
			len = 0;
			break;
		    }
		case IPSECDOI_ID_IPV4_ADDR_RANGE:
			if (len < 8)
				ND_PRINT((ndo,' len=%d [bad: < 8]', len));
			else {
				ND_PRINT((ndo,' len=%d %s-%s', len,
					  ipaddr_string(ndo, data),
					  ipaddr_string(ndo, data + sizeof(struct in_addr))));
			}
			len = 0;
			break;
		case IPSECDOI_ID_IPV6_ADDR_RANGE:
			if (len < 32)
				ND_PRINT((ndo,' len=%d [bad: < 32]', len));
			else {
				ND_PRINT((ndo,' len=%d %s-%s', len,
					  ip6addr_string(ndo, data),
					  ip6addr_string(ndo, data + sizeof(struct in6_addr))));
			}
			len = 0;
			break;
		case IPSECDOI_ID_DER_ASN1_DN:
		case IPSECDOI_ID_DER_ASN1_GN:
		case IPSECDOI_ID_KEY_ID:
			break;
		}
		break;
	    }
	}
	if (data && len) {
		ND_PRINT((ndo,' len=%d', len));
		if (2 < ndo->ndo_vflag) {
			ND_PRINT((ndo,' '));
			if (!rawprint(ndo, (const uint8_t *)data, len))
				goto trunc;
		}
	}
	return (const u_char *)ext + item_len;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_ID)));
	return NULL;
}
",0,8008
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static char *numstr(int);
",0,8010
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ike_sub0_print(netdissect_options *ndo,
		 u_char np, const struct isakmp_gen *ext, const u_char *ep,

	       uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	struct isakmp_gen e;
	u_int item_len;

	cp = (const u_char *)ext;
	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));

	/*
	 * Since we can't have a payload length of less than 4 bytes,
	 * we need to bail out here if the generic header is nonsensical
	 * or truncated, otherwise we could loop forever processing
	 * zero-length items or otherwise misdissect the packet.
	 */
	item_len = ntohs(e.len);
	if (item_len <= 4)
		return NULL;

	if (NPFUNC(np)) {
		/*
		 * XXX - what if item_len is too short, or too long,
		 * for this payload type?
		 */
		cp = (*npfunc[np])(ndo, np, ext, item_len, ep, phase, doi, proto, depth);
	} else {
		ND_PRINT((ndo,'%s', NPSTR(np)));
		cp += item_len;
	}

	return cp;
trunc:
	ND_PRINT((ndo,' [|isakmp]'));
	return NULL;
}
",0,8011
the-tcpdump-group/tcpdump,8dca25d26c7ca2caf6138267f6f17111212c156e,"static const u_char *
ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	const struct ikev2_n *p;
	struct ikev2_n n;
	const u_char *cp;
	u_char showspi, showsomedata;
	const char *notify_name;
	uint32_t type;

	p = (const struct ikev2_n *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);

	showspi = 1;
	showsomedata=0;
	notify_name=NULL;

	ND_PRINT((ndo,' prot_id=%s', PROTOIDSTR(n.prot_id)));

	type = ntohs(n.type);

	/* notify space is annoying sparse */
	switch(type) {
	case IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:
		notify_name = 'unsupported_critical_payload';
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_IKE_SPI:
		notify_name = 'invalid_ike_spi';
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_MAJOR_VERSION:
		notify_name = 'invalid_major_version';
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_SYNTAX:
		notify_name = 'invalid_syntax';
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_MESSAGE_ID:
		notify_name = 'invalid_message_id';
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_SPI:
		notify_name = 'invalid_spi';
		showspi = 1;
		break;

	case IV2_NOTIFY_NO_PROPOSAL_CHOSEN:
		notify_name = 'no_protocol_chosen';
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_KE_PAYLOAD:
		notify_name = 'invalid_ke_payload';
		showspi = 1;
		break;

	case IV2_NOTIFY_AUTHENTICATION_FAILED:
		notify_name = 'authentication_failed';
		showspi = 1;
		break;

	case IV2_NOTIFY_SINGLE_PAIR_REQUIRED:
		notify_name = 'single_pair_required';
		showspi = 1;
		break;

	case IV2_NOTIFY_NO_ADDITIONAL_SAS:
		notify_name = 'no_additional_sas';
		showspi = 0;
		break;

	case IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:
		notify_name = 'internal_address_failure';
		showspi = 0;
		break;

	case IV2_NOTIFY_FAILED_CP_REQUIRED:
		notify_name = 'failed:cp_required';
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_SELECTORS:
		notify_name = 'invalid_selectors';
		showspi = 0;
		break;

	case IV2_NOTIFY_INITIAL_CONTACT:
		notify_name = 'initial_contact';
		showspi = 0;
		break;

	case IV2_NOTIFY_SET_WINDOW_SIZE:
		notify_name = 'set_window_size';
		showspi = 0;
		break;

	case IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:
		notify_name = 'additional_ts_possible';
		showspi = 0;
		break;

	case IV2_NOTIFY_IPCOMP_SUPPORTED:
		notify_name = 'ipcomp_supported';
		showspi = 0;
		break;

	case IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:
		notify_name = 'nat_detection_source_ip';
		showspi = 1;
		break;

	case IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:
		notify_name = 'nat_detection_destination_ip';
		showspi = 1;
		break;

	case IV2_NOTIFY_COOKIE:
		notify_name = 'cookie';
		showspi = 1;
		showsomedata= 1;
		break;

	case IV2_NOTIFY_USE_TRANSPORT_MODE:
		notify_name = 'use_transport_mode';
		showspi = 0;
		break;

	case IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:
		notify_name = 'http_cert_lookup_supported';
		showspi = 0;
		break;

	case IV2_NOTIFY_REKEY_SA:
		notify_name = 'rekey_sa';
		showspi = 1;
		break;

	case IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:
		notify_name = 'tfc_padding_not_supported';
		showspi = 0;
		break;

	case IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:
		notify_name = 'non_first_fragment_also';
		showspi = 0;
		break;

	default:
		if (type < 8192) {
			notify_name='error';
		} else if(type < 16384) {
			notify_name='private-error';
		} else if(type < 40960) {
			notify_name='status';
		} else {
			notify_name='private-status';
		}
	}

	if(notify_name) {
		ND_PRINT((ndo,' type=%u(%s)', type, notify_name));
	}


	if (showspi && n.spi_size) {
		ND_PRINT((ndo,' spi='));
		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
			goto trunc;
	}

	cp = (const u_char *)(p + 1) + n.spi_size;

	if (cp < ep) {
		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
			ND_PRINT((ndo,' data=('));
			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
				goto trunc;

			ND_PRINT((ndo,')'));
		} else if (showsomedata) {
			if (!ike_show_somedata(ndo, cp, ep))
				goto trunc;
		}
	}

	return (const u_char *)ext + item_len;
trunc:
	ND_PRINT((ndo,' [|%s]', NPSTR(ISAKMP_NPTYPE_N)));
	return NULL;
}
",0,8013
acpica/acpica,4a0243ecb4c94e2d73510d096c5ea4d0711fc6c0,"ACPI_STATUS
AcpiPsCompleteFinalOp (
    ACPI_WALK_STATE         *WalkState,
    ACPI_PARSE_OBJECT       *Op,
    ACPI_STATUS             Status)
{
    ACPI_STATUS             Status2;


    ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);


    /*
     * Complete the last Op (if not completed), and clear the scope stack.
     * It is easily possible to end an AML 'package' with an unbounded number
     * of open scopes (such as when several ASL blocks are closed with
     * sequential closing braces). We want to terminate each one cleanly.
     */
    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, 'AML package complete at Op %p\n', Op));
    do
    {
        if (Op)
        {
            if (WalkState->AscendingCallback != NULL)
            {
                WalkState->Op = Op;
                WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
                WalkState->Opcode = Op->Common.AmlOpcode;

                Status = WalkState->AscendingCallback (WalkState);
                Status = AcpiPsNextParseState (WalkState, Op, Status);
                if (Status == AE_CTRL_PENDING)
                {
                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
                    if (ACPI_FAILURE (Status))
                    {
                        return_ACPI_STATUS (Status);
                    }
                }

                if (Status == AE_CTRL_TERMINATE)
                {
                    Status = AE_OK;

                    /* Clean up */
                    do
                    {
                        if (Op)
                        {
                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
                            if (ACPI_FAILURE (Status2))
                            {
                                return_ACPI_STATUS (Status2);
                            }
                        }

                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
                            &WalkState->ArgTypes, &WalkState->ArgCount);

                    } while (Op);

                    return_ACPI_STATUS (Status);
                }

                else if (ACPI_FAILURE (Status))
                {
                    /* First error is most important */

                    (void) AcpiPsCompleteThisOp (WalkState, Op);
                    return_ACPI_STATUS (Status);
                }
            }

            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status2))
            {
                return_ACPI_STATUS (Status2);
            }
        }

        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
            &WalkState->ArgCount);

    } while (Op);

    return_ACPI_STATUS (Status);
}
",1,8015
acpica/acpica,4a0243ecb4c94e2d73510d096c5ea4d0711fc6c0,"ACPI_STATUS
AcpiPsBuildNamedOp (
    ACPI_WALK_STATE         *WalkState,
    UINT8                   *AmlOpStart,
    ACPI_PARSE_OBJECT       *UnnamedOp,
    ACPI_PARSE_OBJECT       **Op)
{
    ACPI_STATUS             Status = AE_OK;
    ACPI_PARSE_OBJECT       *Arg = NULL;


    ACPI_FUNCTION_TRACE_PTR (PsBuildNamedOp, WalkState);


    UnnamedOp->Common.Value.Arg = NULL;
    UnnamedOp->Common.ArgListLength = 0;
    UnnamedOp->Common.AmlOpcode = WalkState->Opcode;

    /*
     * Get and append arguments until we find the node that contains
     * the name (the type ARGP_NAME).
     */
    while (GET_CURRENT_ARG_TYPE (WalkState->ArgTypes) &&
          (GET_CURRENT_ARG_TYPE (WalkState->ArgTypes) != ARGP_NAME))
    {
        ASL_CV_CAPTURE_COMMENTS (WalkState);
        Status = AcpiPsGetNextArg (WalkState, &(WalkState->ParserState),
            GET_CURRENT_ARG_TYPE (WalkState->ArgTypes), &Arg);
        if (ACPI_FAILURE (Status))
        {
            return_ACPI_STATUS (Status);
        }

        AcpiPsAppendArg (UnnamedOp, Arg);
        INCREMENT_ARG_LIST (WalkState->ArgTypes);
    }

    /* are there any inline comments associated with the NameSeg?? If so, save this. */

    ASL_CV_CAPTURE_COMMENTS (WalkState);

#ifdef ACPI_ASL_COMPILER
    if (AcpiGbl_CurrentInlineComment != NULL)
    {
        UnnamedOp->Common.NameComment = AcpiGbl_CurrentInlineComment;
        AcpiGbl_CurrentInlineComment = NULL;
    }
#endif

    /*
     * Make sure that we found a NAME and didn't run out of arguments
     */
    if (!GET_CURRENT_ARG_TYPE (WalkState->ArgTypes))
    {
        return_ACPI_STATUS (AE_AML_NO_OPERAND);
    }

    /* We know that this arg is a name, move to next arg */

    INCREMENT_ARG_LIST (WalkState->ArgTypes);

    /*
     * Find the object. This will either insert the object into
     * the namespace or simply look it up
     */
    WalkState->Op = NULL;

    Status = WalkState->DescendingCallback (WalkState, Op);
    if (ACPI_FAILURE (Status))
    {
        if (Status != AE_CTRL_TERMINATE)
        {
            ACPI_EXCEPTION ((AE_INFO, Status, 'During name lookup/catalog'));
        }
        return_ACPI_STATUS (Status);
    }

    if (!*Op)
    {
        return_ACPI_STATUS (AE_CTRL_PARSE_CONTINUE);
    }

    Status = AcpiPsNextParseState (WalkState, *Op, Status);
    if (ACPI_FAILURE (Status))
    {
        if (Status == AE_CTRL_PENDING)
        {
            Status = AE_CTRL_PARSE_PENDING;
        }
        return_ACPI_STATUS (Status);
    }

    AcpiPsAppendArg (*Op, UnnamedOp->Common.Value.Arg);

#ifdef ACPI_ASL_COMPILER

    /* save any comments that might be associated with UnnamedOp. */

    (*Op)->Common.InlineComment     = UnnamedOp->Common.InlineComment;
    (*Op)->Common.EndNodeComment    = UnnamedOp->Common.EndNodeComment;
    (*Op)->Common.CloseBraceComment = UnnamedOp->Common.CloseBraceComment;
    (*Op)->Common.NameComment       = UnnamedOp->Common.NameComment;
    (*Op)->Common.CommentList       = UnnamedOp->Common.CommentList;
    (*Op)->Common.EndBlkComment     = UnnamedOp->Common.EndBlkComment;
    (*Op)->Common.CvFilename        = UnnamedOp->Common.CvFilename;
    (*Op)->Common.CvParentFilename  = UnnamedOp->Common.CvParentFilename;
    (*Op)->Named.Aml                = UnnamedOp->Common.Aml;

    UnnamedOp->Common.InlineComment     = NULL;
    UnnamedOp->Common.EndNodeComment    = NULL;
    UnnamedOp->Common.CloseBraceComment = NULL;
    UnnamedOp->Common.NameComment       = NULL;
    UnnamedOp->Common.CommentList       = NULL;
    UnnamedOp->Common.EndBlkComment     = NULL;
#endif

    if ((*Op)->Common.AmlOpcode == AML_REGION_OP ||
        (*Op)->Common.AmlOpcode == AML_DATA_REGION_OP)
    {
        /*
         * Defer final parsing of an OperationRegion body, because we don't
         * have enough info in the first pass to parse it correctly (i.e.,
         * there may be method calls within the TermArg elements of the body.)
         *
         * However, we must continue parsing because the opregion is not a
         * standalone package -- we don't know where the end is at this point.
         *
         * (Length is unknown until parse of the body complete)
         */
        (*Op)->Named.Data = AmlOpStart;
        (*Op)->Named.Length = 0;
    }

    return_ACPI_STATUS (AE_OK);
}
",0,8016
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"	struct zsock_addrinfo *ai = ai_arr + state->idx;
	int socktype = SOCK_STREAM;
	int proto;

	NET_DBG('dns status: %d', status);

	if (info == NULL) {
		if (status == DNS_EAI_ALLDONE) {
			status = 0;
",1,8017
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"	memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);
	ai->ai_addr = &ai->_ai_addr;
	ai->ai_addrlen = info->ai_addrlen;
	memcpy(&ai->_ai_canonname, &info->ai_canonname,
	       sizeof(ai->_ai_canonname));
	ai->ai_canonname = ai->_ai_canonname;
	ai->ai_family = info->ai_family;

	if (state->hints) {
",1,8018
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"	struct getaddrinfo_state *state = user_data;
	struct zsock_addrinfo *ai = ai_arr + state->idx;
	int socktype = SOCK_STREAM;
	int proto;

",1,8019
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"		k_sem_give(&state->sem);
		return;
	}

	memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);
",1,8020
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"static void dns_resolve_cb(enum dns_resolve_status status,
			   struct dns_addrinfo *info, void *user_data)
{
	struct getaddrinfo_state *state = user_data;
	struct zsock_addrinfo *ai = ai_arr + state->idx;
	int socktype = SOCK_STREAM;
	int proto;

	NET_DBG('dns status: %d', status);

	if (info == NULL) {
		if (status == DNS_EAI_ALLDONE) {
			status = 0;
		}
		state->status = status;
		k_sem_give(&state->sem);
		return;
	}

	memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);
	ai->ai_addr = &ai->_ai_addr;
	ai->ai_addrlen = info->ai_addrlen;
	memcpy(&ai->_ai_canonname, &info->ai_canonname,
	       sizeof(ai->_ai_canonname));
	ai->ai_canonname = ai->_ai_canonname;
	ai->ai_family = info->ai_family;

	if (state->hints) {
		if (state->hints->ai_socktype) {
			socktype = state->hints->ai_socktype;
		}
	}

	proto = IPPROTO_TCP;
	if (socktype == SOCK_DGRAM) {
		proto = IPPROTO_UDP;
	}

	ai->ai_socktype = socktype;
	ai->ai_protocol = proto;

	state->idx++;
}
",1,8021
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"int zsock_getaddrinfo(const char *host, const char *service,
		      const struct zsock_addrinfo *hints,
		      struct zsock_addrinfo **res)
{
	int family = AF_UNSPEC;
	long int port;
	int st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;

	if (hints) {
		family = hints->ai_family;
	}

	port = strtol(service, NULL, 10);
	if (port < 1 || port > 65535) {
		return DNS_EAI_NONAME;
	}

	ai_state.hints = hints;
	ai_state.idx = 0;
	k_sem_init(&ai_state.sem, 0, UINT_MAX);

	/* Link entries in advance */
	ai_arr[0].ai_next = &ai_arr[1];

	/* Execute if AF_UNSPEC or AF_INET4 */
	if (family != AF_INET6) {
		dns_get_addr_info(host, DNS_QUERY_TYPE_A, NULL,
				  dns_resolve_cb, &ai_state, 1000);
		k_sem_take(&ai_state.sem, K_FOREVER);
		net_sin(&ai_arr[ai_state.idx - 1]._ai_addr)->sin_port =
								htons(port);
		st1 = ai_state.status;
	}

	/* Execute if AF_UNSPEC or AF_INET6 */
	if (family != AF_INET) {
		dns_get_addr_info(host, DNS_QUERY_TYPE_AAAA, NULL,
				  dns_resolve_cb, &ai_state, 1000);
		k_sem_take(&ai_state.sem, K_FOREVER);
		net_sin6(&ai_arr[ai_state.idx - 1]._ai_addr)->sin6_port =
								htons(port);
		st2 = ai_state.status;
	}

	/* If both attempts failed, it's error */
	if (st1 && st2) {
		if (st1 != DNS_EAI_ADDRFAMILY) {
			return st1;
		}
		return st2;
	}

	/* Mark entry as last */
	ai_arr[ai_state.idx - 1].ai_next = NULL;

	*res = ai_arr;

	return 0;
}
",1,8022
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"	int family = AF_UNSPEC;
	long int port;
	int st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;
",0,8023
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"	state->idx++;
}

",0,8024
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"
	if (info == NULL) {
		if (status == DNS_EAI_ALLDONE) {
			status = 0;
		}
",0,8025
zephyrproject-rtos/zephyr,3953714a9b8508aca72ab93991e8468ba508aa4b,"	}

",0,8027
ImageMagick/ImageMagick,dfefe8de5068a547ae4097c69456f02f93935164,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),'enter');

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);
  image2 = (Image *) NULL;

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  if (strncmp(MATLAB_HDR.identific,'MATLAB',6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),'  Endian %c%c',
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, 'IM', 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, 'MI', 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, 'MATLAB', 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf('pos=%X\n',TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,'ImproperImageHeader');
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, 'MultidimensionalMatricesAreNotSupported');
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          'MATLAB_HDR.StructureClass %d',MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,'UnsupportedCellTypeInTheMatrix');

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        'MATLAB_HDR.CellType: %.20g',(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,'quantum:format','floating-point');
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,'quantum:format','floating-point');
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, 'IncompatibleSizeOfDouble');
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, 'UnsupportedCellTypeInTheMatrix');
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              '  MAT set image pixels returns unexpected NULL on a row %u.', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             '  MAT cannot read scanrow %u from a file.', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              '  MAT failed to ImportQuantumPixels for a row %u', (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            '  MAT failed to sync image pixels for a row %u', (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          if (tmp == image2)
            image2=(Image *) NULL;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),'return');
  if ((image != image2) && (image2 != (Image *) NULL))
    image2=DestroyImage(image2);
  if (image == (Image *) NULL)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader')
  return(image);
}
",1,8029
ImageMagick/ImageMagick,dfefe8de5068a547ae4097c69456f02f93935164,"static void InsertComplexDoubleRow(Image *image,double *p,int y,double MinVal,
  double MaxVal,ExceptionInfo *exception)
{

  double f;
  int x;
  register Quantum *q;

  if (MinVal == 0)
    MinVal = -1;
  if (MaxVal == 0)
    MaxVal = 1;

  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    return;
  for (x = 0; x < (ssize_t) image->columns; x++)
  {
    if (*p > 0)
    {
      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));
      if (f + GetPixelRed(image,q) > QuantumRange)
        SetPixelRed(image,QuantumRange,q);
      else
        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);
      if ((int) f / 2.0 > GetPixelGreen(image,q))
        {
          SetPixelGreen(image,0,q);
          SetPixelBlue(image,0,q);
        }
      else
        {
          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);
          SetPixelGreen(image,GetPixelBlue(image,q),q);
        }
    }
    if (*p < 0)
    {
      f = (*p / MaxVal) * (QuantumRange-GetPixelBlue(image,q));
      if (f+GetPixelBlue(image,q) > QuantumRange)
        SetPixelBlue(image,QuantumRange,q);
      else
        SetPixelBlue(image,GetPixelBlue(image,q)+(int) f,q);
      if ((int) f / 2.0 > GetPixelGreen(image,q))
        {
          SetPixelRed(image,0,q);
          SetPixelGreen(image,0,q);
        }
      else
        {
          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);
          SetPixelGreen(image,GetPixelRed(image,q),q);
        }
    }
    p++;
    q+=GetPixelChannels(image);
  }
  if (!SyncAuthenticPixels(image,exception))
    return;
  return;
}
",0,8030
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"#ifdef MAKEFILE_DTD_PATH
  MAKEFILE_DTD_PATH ,
#endif
  '/usr/local/share/libofx/dtd',
  '/usr/share/libofx/dtd',
  '~'
};
const unsigned int READ_BUFFER_SIZE = 1024;

/** @brief File pre-processing of OFX AND for OFC files
*
* Takes care of comment striping, dtd locating, etc.
*/
int ofx_proc_file(LibofxContextPtr ctx, const char * p_filename)
{
  LibofxContext *libofx_context;
  bool ofx_start = false;
  bool ofx_end = false;
  bool file_is_xml = false;

  ifstream input_file;
  ofstream tmp_file;
  char buffer[READ_BUFFER_SIZE];
  char *iconv_buffer;
  string s_buffer;
  char *filenames[3];
  char tmp_filename[256];
  int tmp_file_fd;
#ifdef HAVE_ICONV
  iconv_t conversion_descriptor;
#endif
  libofx_context = (LibofxContext*)ctx;

  if (p_filename != NULL && strcmp(p_filename, '') != 0)
  {
    message_out(DEBUG, string('ofx_proc_file():Opening file: ') + p_filename);

    input_file.open(p_filename);
    if (!input_file)
    {
      message_out(ERROR, 'ofx_proc_file():Unable to open the input file ' + string(p_filename));
    }
",1,8031
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"  char buffer[READ_BUFFER_SIZE];
  char *iconv_buffer;
  string s_buffer;
  char *filenames[3];
  char tmp_filename[256];
  int tmp_file_fd;
#ifdef HAVE_ICONV
  iconv_t conversion_descriptor;
#endif
  libofx_context = (LibofxContext*)ctx;

  if (p_filename != NULL && strcmp(p_filename, '') != 0)
  {
",1,8032
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"            size_t outbytesleft = inbytesleft * 2 - 1;
            iconv_buffer = (char*) malloc (inbytesleft * 2);
            memset(iconv_buffer, 0, inbytesleft * 2);
#if defined(OS_WIN32) || defined(__sun) || defined(__NetBSD__)
            const char * inchar = (const char *)s_buffer.c_str();
#else
            char * inchar = (char *)s_buffer.c_str();
",1,8033
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"            if (iconv_retval == -1)
            {
              message_out(ERROR, 'ofx_proc_file(): Conversion error');
",1,8034
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"  char buffer[READ_BUFFER_SIZE];
  char *iconv_buffer;
  string s_buffer;
",1,8035
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"int ofx_proc_file(LibofxContextPtr ctx, const char * p_filename)
{
  LibofxContext *libofx_context;
  bool ofx_start = false;
  bool ofx_end = false;
  bool file_is_xml = false;

  ifstream input_file;
  ofstream tmp_file;
  char buffer[READ_BUFFER_SIZE];
  char *iconv_buffer;
  string s_buffer;
  char *filenames[3];
  char tmp_filename[256];
  int tmp_file_fd;
#ifdef HAVE_ICONV
  iconv_t conversion_descriptor;
#endif
  libofx_context = (LibofxContext*)ctx;

  if (p_filename != NULL && strcmp(p_filename, '') != 0)
  {
    message_out(DEBUG, string('ofx_proc_file():Opening file: ') + p_filename);

    input_file.open(p_filename);
    if (!input_file)
    {
      message_out(ERROR, 'ofx_proc_file():Unable to open the input file ' + string(p_filename));
    }

    mkTempFileName('libofxtmpXXXXXX', tmp_filename, sizeof(tmp_filename));

    message_out(DEBUG, 'ofx_proc_file(): Creating temp file: ' + string(tmp_filename));
    tmp_file_fd = mkstemp(tmp_filename);
    if (tmp_file_fd)
    {
      tmp_file.open(tmp_filename);
      if (!tmp_file)
      {
        message_out(ERROR, 'ofx_proc_file():Unable to open the created temp file ' + string(tmp_filename));
        return -1;
      }
    }
    else
    {
      message_out(ERROR, 'ofx_proc_file():Unable to create a temp file at ' + string(tmp_filename));
      return -1;
    }

    if (input_file && tmp_file)
    {
      int header_separator_idx;
      string header_name;
      string header_value;
      string ofx_encoding;
      string ofx_charset;
      do
      {
        s_buffer.clear();
        bool end_of_line = false;
        do
        {
          input_file.get(buffer, sizeof(buffer), '\n');
          //cout<< 'got: \'' << buffer<<'\'\n';
          s_buffer.append(buffer);

          // Watch out: If input_file is in eof(), any subsequent read or
          // peek() will fail and we must exit this loop.
          if (input_file.eof())
            break;

          //cout<<'input_file.gcount(): '<<input_file.gcount()<< ' s_buffer.size=' << s_buffer.size()<<' sizeof(buffer): '<<sizeof(buffer) << ' peek=\'' << int(input_file.peek()) << '\'' <<endl;
          if (input_file.fail()) // If no characters were extracted above, the failbit is set.
          {
            // No characters extracted means that we've reached the newline
            // delimiter (because we already checked for EOF). We will check
            // for and remove that newline in the next if-clause, but must
            // remove the failbit so that peek() will work again.
            input_file.clear();
          }

          // Is the next character really the newline?
          if (input_file.peek() == '\n')
          {
            // Yes. Then discard that newline character from the stream and
            // append it manually to the output string.
            input_file.get();
            s_buffer.append('\n');
            end_of_line = true; // We found the end-of-line.
          }
        }
        // Continue reading as long as we're not at EOF *and* we've not yet
        // reached an end-of-line.
        while (!input_file.eof() && !end_of_line);

        if (ofx_start == false && (s_buffer.find('<?xml') != string::npos))
        {
          message_out(DEBUG, 'ofx_proc_file(): File is an actual XML file, iconv conversion will be skipped.');
          file_is_xml = true;
        }

        int ofx_start_idx;
        if (ofx_start == false &&
            (
              (libofx_context->currentFileType() == OFX &&
               ((ofx_start_idx = s_buffer.find('<OFX>')) !=
                string::npos || (ofx_start_idx = s_buffer.find('<ofx>')) != string::npos))
              || (libofx_context->currentFileType() == OFC &&
                  ((ofx_start_idx = s_buffer.find('<OFC>')) != string::npos ||
                   (ofx_start_idx = s_buffer.find('<ofc>')) != string::npos))
            )
           )
        {
          ofx_start = true;
          if (file_is_xml == false)
          {
            s_buffer.erase(0, ofx_start_idx); //Fix for really broken files that don't have a newline after the header.
          }
          message_out(DEBUG, 'ofx_proc_file():<OFX> or <OFC> has been found');

          if (file_is_xml == true)
          {
            static char sp_charset_fixed[] = 'SP_CHARSET_FIXED=1';
            if (putenv(sp_charset_fixed) != 0)
            {
              message_out(ERROR, 'ofx_proc_file(): putenv failed');
            }
            /* Normally the following would be 'xml'.
             * Unfortunately, opensp's generic api will garble UTF-8 if this is
             * set to xml.  So we set any single byte encoding to avoid messing
             * up UTF-8.  Unfortunately this means that non-UTF-8 files will not
             * get properly translated.  We'd need to manually detect the
             * encoding in the XML header and convert the xml with iconv like we
             * do for SGML to work around the problem.  Most unfortunate. */
            static char sp_encoding[] = 'SP_ENCODING=ms-dos';
            if (putenv(sp_encoding) != 0)
            {
              message_out(ERROR, 'ofx_proc_file(): putenv failed');
            }
          }
          else
          {
            static char sp_charset_fixed[] = 'SP_CHARSET_FIXED=1';
            if (putenv(sp_charset_fixed) != 0)
            {
              message_out(ERROR, 'ofx_proc_file(): putenv failed');
            }
            static char sp_encoding[] = 'SP_ENCODING=ms-dos'; //Any single byte encoding will do, we don't want opensp messing up UTF-8;
            if (putenv(sp_encoding) != 0)
            {
              message_out(ERROR, 'ofx_proc_file(): putenv failed');
            }
#ifdef HAVE_ICONV
            string fromcode;
            string tocode;
            if (ofx_encoding.compare('USASCII') == 0)
            {
              if (ofx_charset.compare('ISO-8859-1') == 0 || ofx_charset.compare('8859-1') == 0)
              {
                //Only 'ISO-8859-1' is actually a legal value, but since the banks follows the spec SO well...
                fromcode = 'ISO-8859-1';
              }
              else if (ofx_charset.compare('1252') == 0 || ofx_charset.compare('CP1252') == 0)
              {
                //Only '1252' is actually a legal value, but since the banks follows the spec SO well...
                fromcode = 'CP1252';
              }
              else if (ofx_charset.compare('NONE') == 0)
              {
                fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;
              }
              else
              {
                fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;
              }
            }
            else if (ofx_encoding.compare('UTF-8') == 0 || ofx_encoding.compare('UNICODE') == 0)
            {
              //While 'UNICODE' isn't a legal value, some cyrilic files do specify it as such...
              fromcode = 'UTF-8';
            }
            else
            {
              fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;
            }
            tocode = LIBOFX_DEFAULT_OUTPUT_ENCODING;
            message_out(DEBUG, 'ofx_proc_file(): Setting up iconv for fromcode: ' + fromcode + ', tocode: ' + tocode);
            conversion_descriptor = iconv_open (tocode.c_str(), fromcode.c_str());
#endif
          }
        }
        else
        {
          //We are still in the headers
          if ((header_separator_idx = s_buffer.find(':')) != string::npos)
          {
            //Header processing
            header_name.assign(s_buffer.substr(0, header_separator_idx));
            header_value.assign(s_buffer.substr(header_separator_idx + 1));
            while ( header_value[header_value.length() -1 ] == '\n' ||
                    header_value[header_value.length() -1 ] == '\r' )
              header_value.erase(header_value.length() - 1);
            message_out(DEBUG, 'ofx_proc_file():Header: ' + header_name + ' with value: ' + header_value + ' has been found');
            if (header_name.compare('ENCODING') == 0)
            {
              ofx_encoding.assign(header_value);
            }
            if (header_name.compare('CHARSET') == 0)
            {
              ofx_charset.assign(header_value);
            }
          }
        }

        if (file_is_xml == true || (ofx_start == true && ofx_end == false))
        {
          if (ofx_start == true)
          {
            /* The above test won't help us if the <OFX> tag is on the same line
             * as the xml header, but as opensp can't be used to parse it anyway
             * this isn't a great loss for now.
             */
            s_buffer = sanitize_proprietary_tags(s_buffer);
          }
          //cout<< s_buffer<<'\n';
          if (file_is_xml == false)
          {
#ifdef HAVE_ICONV
            size_t inbytesleft = strlen(s_buffer.c_str());
            size_t outbytesleft = inbytesleft * 2 - 1;
            iconv_buffer = (char*) malloc (inbytesleft * 2);
            memset(iconv_buffer, 0, inbytesleft * 2);
#if defined(OS_WIN32) || defined(__sun) || defined(__NetBSD__)
            const char * inchar = (const char *)s_buffer.c_str();
#else
            char * inchar = (char *)s_buffer.c_str();
#endif
            char * outchar = iconv_buffer;
            int iconv_retval = iconv (conversion_descriptor,
                                      &inchar, &inbytesleft,
                                      &outchar, &outbytesleft);
            if (iconv_retval == -1)
            {
              message_out(ERROR, 'ofx_proc_file(): Conversion error');
            }
            s_buffer = iconv_buffer;
            free (iconv_buffer);
#endif
          }
          //cout << s_buffer << '\n';
          tmp_file.write(s_buffer.c_str(), s_buffer.length());
        }

        if (ofx_start == true &&
            (
              (libofx_context->currentFileType() == OFX &&
               ((ofx_start_idx = s_buffer.find('</OFX>')) != string::npos ||
                (ofx_start_idx = s_buffer.find('</ofx>')) != string::npos))
              || (libofx_context->currentFileType() == OFC &&
                  ((ofx_start_idx = s_buffer.find('</OFC>')) != string::npos ||
                   (ofx_start_idx = s_buffer.find('</ofc>')) != string::npos))
            )
           )
        {
          ofx_end = true;
          message_out(DEBUG, 'ofx_proc_file():</OFX> or </OFC>  has been found');
        }

      }
      while (!input_file.eof() && !input_file.bad());
    }
    input_file.close();
    tmp_file.close();
#ifdef HAVE_ICONV
    if (file_is_xml == false)
    {
      iconv_close(conversion_descriptor);
    }
#endif
    char filename_openspdtd[255];
    char filename_dtd[255];
    char filename_ofx[255];
    strncpy(filename_openspdtd, find_dtd(ctx, OPENSPDCL_FILENAME).c_str(), 255); //The opensp sgml dtd file
    if (libofx_context->currentFileType() == OFX)
    {
      strncpy(filename_dtd, find_dtd(ctx, OFX160DTD_FILENAME).c_str(), 255); //The ofx dtd file
    }
    else if (libofx_context->currentFileType() == OFC)
    {
      strncpy(filename_dtd, find_dtd(ctx, OFCDTD_FILENAME).c_str(), 255); //The ofc dtd file
    }
    else
    {
      message_out(ERROR, string('ofx_proc_file(): Error unknown file format for the OFX parser'));
    }

    if ((string)filename_dtd != '' && (string)filename_openspdtd != '')
    {
      strncpy(filename_ofx, tmp_filename, 255); //The processed ofx file
      filenames[0] = filename_openspdtd;
      filenames[1] = filename_dtd;
      filenames[2] = filename_ofx;
      if (libofx_context->currentFileType() == OFX)
      {
        ofx_proc_sgml(libofx_context, 3, filenames);
      }
      else if (libofx_context->currentFileType() == OFC)
      {
        ofc_proc_sgml(libofx_context, 3, filenames);
      }
      else
      {
        message_out(ERROR, string('ofx_proc_file(): Error unknown file format for the OFX parser'));
      }
      if (remove(tmp_filename) != 0)
      {
        message_out(ERROR, 'ofx_proc_file(): Error deleting temporary file ' + string(tmp_filename));
      }
    }
    else
    {
      message_out(ERROR, 'ofx_proc_file(): FATAL: Missing DTD, aborting');
    }
  }
  else
  {
    message_out(ERROR, 'ofx_proc_file():No input file specified');
  }
  return 0;
}
",1,8036
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"             * encoding in the XML header and convert the xml with iconv like we
             * do for SGML to work around the problem.  Most unfortunate. */
            static char sp_encoding[] = 'SP_ENCODING=ms-dos';
",0,8037
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"      string ofx_charset;
      do
      {
",0,8038
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"            {
              message_out(ERROR, 'ofx_proc_file(): putenv failed');
            }
",0,8039
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"          else
          {
            static char sp_charset_fixed[] = 'SP_CHARSET_FIXED=1';
",0,8040
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"};
const unsigned int READ_BUFFER_SIZE = 1024;

",0,8041
libofx/libofx,fad8418f34094de42e1307113598e0e8bee0a2bd,"  iconv_t conversion_descriptor;
#endif
  libofx_context = (LibofxContext*)ctx;
",0,8042
torvalds/linux,6c85501f2fabcfc4fc6ed976543d252c4eaf4be9,"SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
	struct waitid_info info = {.status = 0};
	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
	int signo = 0;
	if (err > 0) {
		signo = SIGCHLD;
		err = 0;
	}

	if (!err) {
		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
			return -EFAULT;
	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}
",1,8043
torvalds/linux,6c85501f2fabcfc4fc6ed976543d252c4eaf4be9,"	}
}

static void delayed_put_task_struct(struct rcu_head *rhp)
{
	struct task_struct *tsk = container_of(rhp, struct task_struct, rcu);

	perf_event_delayed_put(tsk);
",0,8044
ImageMagick/ImageMagick,9bad9cd6752bf8dc5825f555fd1117855bd2fc47,"static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image
    *image;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  register IndexPacket
    *indexes;

  register PixelPacket
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  SGIInfo
    iris_info;

  size_t
    bytes_per_pixel,
    quantum;

  ssize_t
    count,
    y,
    z;

  unsigned char
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read SGI raster header.
  */
  iris_info.magic=ReadBlobMSBShort(image);
  do
  {
    /*
      Verify SGI identifier.
    */
    if (iris_info.magic != 0x01DA)
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    iris_info.storage=(unsigned char) ReadBlobByte(image);
    switch (iris_info.storage)
    {
      case 0x00: image->compression=NoCompression; break;
      case 0x01: image->compression=RLECompression; break;
      default:
        ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    }
    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);
    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    iris_info.dimension=ReadBlobMSBShort(image);
    if ((iris_info.dimension == 0) || (iris_info.dimension > 3)) 
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    iris_info.columns=ReadBlobMSBShort(image);
    iris_info.rows=ReadBlobMSBShort(image);
    iris_info.depth=ReadBlobMSBShort(image);
    if ((iris_info.depth == 0) || (iris_info.depth > 4))
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    iris_info.minimum_value=ReadBlobMSBLong(image);
    iris_info.maximum_value=ReadBlobMSBLong(image);
    iris_info.sans=ReadBlobMSBLong(image);
    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)
      iris_info.name);
    if ((size_t) count != sizeof(iris_info.name))
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    iris_info.name[sizeof(iris_info.name)-1]='\0';
    if (*iris_info.name != '\0')
      (void) SetImageProperty(image,'label',iris_info.name);
    iris_info.pixel_format=ReadBlobMSBLong(image);
    if (iris_info.pixel_format != 0)
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);
    if ((size_t) count != sizeof(iris_info.filler))
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    image->columns=iris_info.columns;
    image->rows=iris_info.rows;
    image->matte=iris_info.depth == 4 ? MagickTrue : MagickFalse;
    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);
    if (iris_info.pixel_format == 0)
      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,
        MAGICKCORE_QUANTUM_DEPTH);
    if (iris_info.depth < 3)
      {
        image->storage_class=PseudoClass;
        image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256);
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    /*
      Allocate SGI pixels.
    */
    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;
    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;
    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)
        (4*bytes_per_pixel*number_pixels)))
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*
      bytes_per_pixel*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    if ((int) iris_info.storage != 0x01)
      {
        unsigned char
          *scanline;

        /*
          Read standard image format.
        */
        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,
          bytes_per_pixel*sizeof(*scanline));
        if (scanline == (unsigned char *) NULL)
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
          }
        for (z=0; z < (ssize_t) iris_info.depth; z++)
        {
          p=pixels+bytes_per_pixel*z;
          for (y=0; y < (ssize_t) iris_info.rows; y++)
          {
            (void) ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);
            if (EOFBlob(image) != MagickFalse)
              break;
            if (bytes_per_pixel == 2)
              for (x=0; x < (ssize_t) iris_info.columns; x++)
              {
                *p=scanline[2*x];
                *(p+1)=scanline[2*x+1];
                p+=8;
              }
            else
              for (x=0; x < (ssize_t) iris_info.columns; x++)
              {
                *p=scanline[x];
                p+=4;
              }
          }
        }
        scanline=(unsigned char *) RelinquishMagickMemory(scanline);
      }
    else
      {
        MemoryInfo
          *packet_info;

        size_t
          *runlength;

        ssize_t
          offset,
          *offsets;

        unsigned char
          *packets;

        unsigned int
          data_order;

        /*
          Read runlength-encoded image format.
        */
        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,
          iris_info.depth*sizeof(*offsets));
        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,
          iris_info.depth*sizeof(*runlength));
        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*
          sizeof(*packets));
        if ((offsets == (ssize_t *) NULL) ||
            (runlength == (size_t *) NULL) ||
            (packet_info == (MemoryInfo *) NULL))
          {
            offsets=(ssize_t *) RelinquishMagickMemory(offsets);
            runlength=(size_t *) RelinquishMagickMemory(runlength);
            if (packet_info != (MemoryInfo *) NULL)
              packet_info=RelinquishVirtualMemory(packet_info);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
          }
        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);
        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
          offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image);
        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
        {
          runlength[i]=ReadBlobMSBLong(image);
          if (runlength[i] > (4*(size_t) iris_info.columns+10))
            {
              offsets=(ssize_t *) RelinquishMagickMemory(offsets);
              runlength=(size_t *) RelinquishMagickMemory(runlength);
              packet_info=RelinquishVirtualMemory(packet_info);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,'ImproperImageHeader');
            }
        }
        /*
          Check data order.
        */
        offset=0;
        data_order=0;
        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)
          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)
          {
            if (offsets[y+z*iris_info.rows] < offset)
              data_order=1;
            offset=offsets[y+z*iris_info.rows];
          }
        offset=(ssize_t) TellBlob(image);
        if (data_order == 1)
          {
            for (z=0; z < (ssize_t) iris_info.depth; z++)
            {
              p=pixels;
              for (y=0; y < (ssize_t) iris_info.rows; y++)
              {
                if (offset != offsets[y+z*iris_info.rows])
                  {
                    offset=offsets[y+z*iris_info.rows];
                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,
                      SEEK_SET);
                  }
                (void) ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],
                  packets);
                if (EOFBlob(image) != MagickFalse)
                  break;
                offset+=(ssize_t) runlength[y+z*iris_info.rows];
                status=SGIDecode(bytes_per_pixel,(ssize_t)
                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,
                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);
                if (status == MagickFalse)
                  {
                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);
                    runlength=(size_t *) RelinquishMagickMemory(runlength);
                    packet_info=RelinquishVirtualMemory(packet_info);
                    pixel_info=RelinquishVirtualMemory(pixel_info);
                    ThrowReaderException(CorruptImageError,
                      'ImproperImageHeader');
                  }
                p+=(iris_info.columns*4*bytes_per_pixel);
              }
            }
          }
        else
          {
            MagickOffsetType
              position;

            position=TellBlob(image);
            p=pixels;
            for (y=0; y < (ssize_t) iris_info.rows; y++)
            {
              for (z=0; z < (ssize_t) iris_info.depth; z++)
              {
                if (offset != offsets[y+z*iris_info.rows])
                  {
                    offset=offsets[y+z*iris_info.rows];
                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,
                      SEEK_SET);
                  }
                (void) ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],
                  packets);
                if (EOFBlob(image) != MagickFalse)
                  break;
                offset+=(ssize_t) runlength[y+z*iris_info.rows];
                status=SGIDecode(bytes_per_pixel,(ssize_t)
                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,
                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);
                if (status == MagickFalse)
                  {
                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);
                    runlength=(size_t *) RelinquishMagickMemory(runlength);
                    packet_info=RelinquishVirtualMemory(packet_info);
                    pixel_info=RelinquishVirtualMemory(pixel_info);
                    ThrowReaderException(CorruptImageError,
                      'ImproperImageHeader');
                  }
              }
              p+=(iris_info.columns*4*bytes_per_pixel);
            }
            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);
          }
        packet_info=RelinquishVirtualMemory(packet_info);
        runlength=(size_t *) RelinquishMagickMemory(runlength);
        offsets=(ssize_t *) RelinquishMagickMemory(offsets);
      }
    /*
      Convert SGI raster image to pixel packets.
    */
    if (image->storage_class == DirectClass)
      {
        /*
          Convert SGI image to DirectClass pixel packets.
        */
        if (bytes_per_pixel == 2)
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              p=pixels+(image->rows-y-1)*8*image->columns;
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (PixelPacket *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                  ((*(p+0) << 8) | (*(p+1)))));
                SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                  ((*(p+2) << 8) | (*(p+3)))));
                SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                  ((*(p+4) << 8) | (*(p+5)))));
                SetPixelOpacity(q,OpaqueOpacity);
                if (image->matte != MagickFalse)
                  SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)
                    ((*(p+6) << 8) | (*(p+7)))));
                p+=8;
                q++;
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
          }
        else
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            p=pixels+(image->rows-y-1)*4*image->columns;
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (PixelPacket *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleCharToQuantum(*p));
              q->green=ScaleCharToQuantum(*(p+1));
              q->blue=ScaleCharToQuantum(*(p+2));
              SetPixelOpacity(q,OpaqueOpacity);
              if (image->matte != MagickFalse)
                SetPixelAlpha(q,ScaleCharToQuantum(*(p+3)));
              p+=4;
              q++;
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
      }
    else
      {
        /*
          Create grayscale map.
        */
        if (AcquireImageColormap(image,image->colors) == MagickFalse)
          ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
        /*
          Convert SGI image to PseudoClass pixel packets.
        */
        if (bytes_per_pixel == 2)
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              p=pixels+(image->rows-y-1)*8*image->columns;
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (PixelPacket *) NULL)
                break;
              indexes=GetAuthenticIndexQueue(image);
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                quantum=(*p << 8);
                quantum|=(*(p+1));
                SetPixelIndex(indexes+x,quantum);
                p+=8;
                q++;
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
          }
        else
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            p=pixels+(image->rows-y-1)*4*image->columns;
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (PixelPacket *) NULL)
              break;
            indexes=GetAuthenticIndexQueue(image);
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelIndex(indexes+x,*p);
              p+=4;
              q++;
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        (void) SyncImage(image);
      }
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,'UnexpectedEndOfFile',
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    iris_info.magic=ReadBlobMSBShort(image);
    if (iris_info.magic == 0x01DA)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (iris_info.magic == 0x01DA);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",1,8045
ImageMagick/ImageMagick,9bad9cd6752bf8dc5825f555fd1117855bd2fc47,"static MagickBooleanType SGIDecode(const size_t bytes_per_pixel,
  ssize_t number_packets,unsigned char *packets,ssize_t number_pixels,
  unsigned char *pixels)
{
  register unsigned char
    *p,
    *q;

  size_t
    pixel;

  ssize_t
    count;

  p=packets;
  q=pixels;
  if (bytes_per_pixel == 2)
    {
      for ( ; number_pixels > 0; )
      {
        if (number_packets-- == 0)
          return(MagickFalse);
        pixel=(size_t) (*p++) << 8;
        pixel|=(*p++);
        count=(ssize_t) (pixel & 0x7f);
        if (count == 0)
          break;
        if (count > (ssize_t) number_pixels)
          return(MagickFalse);
        number_pixels-=count;
        if ((pixel & 0x80) != 0)
          for ( ; count != 0; count--)
          {
            if (number_packets-- == 0)
              return(MagickFalse);
            *q=(*p++);
            *(q+1)=(*p++);
            q+=8;
          }
        else
          {
            if (number_packets-- == 0)
              return(MagickFalse);
            pixel=(size_t) (*p++) << 8;
            pixel|=(*p++);
            for ( ; count != 0; count--)
            {
              *q=(unsigned char) (pixel >> 8);
              *(q+1)=(unsigned char) pixel;
              q+=8;
            }
          }
      }
      return(MagickTrue);
    }
  for ( ; number_pixels > 0; )
  {
    if (number_packets-- == 0)
      return(MagickFalse);
    pixel=(size_t) (*p++);
    count=(ssize_t) (pixel & 0x7f);
    if (count == 0)
      break;
    if (count > (ssize_t) number_pixels)
      return(MagickFalse);
    number_pixels-=count;
    if ((pixel & 0x80) != 0)
      for ( ; count != 0; count--)
      {
        if (number_packets-- == 0)
          return(MagickFalse);
        *q=(*p++);
        q+=4;
      }
    else
      {
        if (number_packets-- == 0)
          return(MagickFalse);
        pixel=(size_t) (*p++);
        for ( ; count != 0; count--)
        {
          *q=(unsigned char) pixel;
          q+=4;
        }
      }
  }
  return(MagickTrue);
}
",0,8046
ImageMagick/ImageMagick,10aae21bf9dac47e16d8fcde7eba7f7f9d1e52f8,"static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))
#define LSBFirstOrder(x,y)  (((y) << 8) | (x))

  Image
    *image,
    *meta_image;

  int
    number_extensionss=0;

  MagickBooleanType
    status;

  RectangleInfo
    page;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    delay,
    dispose,
    duration,
    global_colors,
    image_count,
    iterations,
    one;

  ssize_t
    count,
    opacity;

  unsigned char
    background,
    c,
    flag,
    *global_colormap,
    header[MaxTextExtent],
    magick[12];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a GIF file.
  */
  count=ReadBlob(image,6,magick);
  if ((count != 6) || ((LocaleNCompare((char *) magick,'GIF87',5) != 0) &&
      (LocaleNCompare((char *) magick,'GIF89',5) != 0)))
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  page.width=ReadBlobLSBShort(image);
  page.height=ReadBlobLSBShort(image);
  flag=(unsigned char) ReadBlobByte(image);
  background=(unsigned char) ReadBlobByte(image);
  c=(unsigned char) ReadBlobByte(image);  /* reserved */
  one=1;
  global_colors=one << (((size_t) flag & 0x07)+1);
  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
    MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
  if (global_colormap == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
  if (BitSet((int) flag,0x80) != 0)
    {
      count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);
      if (count != (ssize_t) (3*global_colors))
        {
          global_colormap=(unsigned char *) RelinquishMagickMemory(
            global_colormap);
          ThrowReaderException(CorruptImageError,'InsufficientImageDataInFile');
        }
    }
  delay=0;
  dispose=0;
  duration=0;
  iterations=1;
  opacity=(-1);
  image_count=0;
  meta_image=AcquireImage(image_info);  /* metadata container */
  for ( ; ; )
  {
    count=ReadBlob(image,1,&c);
    if (count != 1)
      break;
    if (c == (unsigned char) ';')
      break;  /* terminator */
    if (c == (unsigned char) '!')
      {
        /*
          GIF Extension block.
        */

        count=ReadBlob(image,1,&c);
        if (count != 1)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              'UnableToReadExtensionBlock');
          }
        switch (c)
        {
          case 0xf9:
          {
            /*
              Read graphics control extension.
            */
            while (ReadBlobBlock(image,header) != 0) ;
            dispose=(size_t) (header[0] >> 2);
            delay=(size_t) ((header[2] << 8) | header[1]);
            if ((ssize_t) (header[0] & 0x01) == 0x01)
              opacity=(ssize_t) header[3];
            break;
          }
          case 0xfe:
          {
            char
              *comments;

            size_t
              length;

            /*
              Read comment extension.
            */
            comments=AcquireString((char *) NULL);
            for (length=0; ; length+=count)
            {
              count=ReadBlobBlock(image,header);
              if (count == 0)
                break;
              header[count]='\0';
              (void) ConcatenateString(&comments,(const char *) header);
            }
            (void) SetImageProperty(meta_image,'comment',comments);
            comments=DestroyString(comments);
            break;
          }
          case 0xff:
          {
            MagickBooleanType
              loop;

            /*
              Read Netscape Loop extension.
            */
            loop=MagickFalse;
            if (ReadBlobBlock(image,header) != 0)
              loop=LocaleNCompare((char *) header,'NETSCAPE2.0',11) == 0 ?
                MagickTrue : MagickFalse;
            if (loop != MagickFalse)
              {
                while (ReadBlobBlock(image,header) != 0)
                  iterations=(size_t) ((header[2] << 8) | header[1]);
                break;
              }
            else
              {
                char
                  name[MaxTextExtent];

                int
                  block_length,
                  info_length,
                  reserved_length;

                MagickBooleanType
                  i8bim,
                  icc,
                  iptc,
                  magick;

                StringInfo
                  *profile;

                unsigned char
                  *info;

                /*
                  Store GIF application extension as a generic profile.
                */
                icc=LocaleNCompare((char *) header,'ICCRGBG1012',11) == 0 ?
                  MagickTrue : MagickFalse;
                magick=LocaleNCompare((char *) header,'ImageMagick',11) == 0 ?
                  MagickTrue : MagickFalse;
                i8bim=LocaleNCompare((char *) header,'MGK8BIM0000',11) == 0 ?
                  MagickTrue : MagickFalse;
                iptc=LocaleNCompare((char *) header,'MGKIPTC0000',11) == 0 ?
                  MagickTrue : MagickFalse;
                number_extensionss++;
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  '    Reading GIF application extension');
                info=(unsigned char *) AcquireQuantumMemory(255UL,
                  sizeof(*info));
                if (info == (unsigned char *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      'MemoryAllocationFailed');
                  }
                reserved_length=255;
                for (info_length=0; ; )
                {
                  block_length=(int) ReadBlobBlock(image,&info[info_length]);
                  if (block_length == 0)
                    break;
                  info_length+=block_length;
                  if (info_length > (reserved_length-255))
                    {
                      reserved_length+=4096;
                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)
                        reserved_length,sizeof(*info));
                      if (info == (unsigned char *) NULL)
                        {
                          meta_image=DestroyImage(meta_image);
                          ThrowReaderException(ResourceLimitError,
                            'MemoryAllocationFailed');
                        }
                    }
                }
                profile=BlobToStringInfo(info,(size_t) info_length);
                if (profile == (StringInfo *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      'MemoryAllocationFailed');
                  }
                if (i8bim != MagickFalse)
                  (void) CopyMagickString(name,'8bim',sizeof(name));
                else if (icc != MagickFalse)
                  (void) CopyMagickString(name,'icc',sizeof(name));
                else if (iptc != MagickFalse)
                  (void) CopyMagickString(name,'iptc',sizeof(name));
                else if (magick != MagickFalse)
                  {
                    (void) CopyMagickString(name,'magick',sizeof(name));
                    meta_image->gamma=StringToDouble((char *) info+6,
                      (char **) NULL);
                  }
                else
                  (void) FormatLocaleString(name,sizeof(name),'gif:%.11s',
                    header);
                info=(unsigned char *) RelinquishMagickMemory(info);
                if (magick == MagickFalse)
                  (void) SetImageProfile(meta_image,name,profile);
                profile=DestroyStringInfo(profile);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  '      profile name=%s',name);
              }
            break;
          }
          default:
          {
            while (ReadBlobBlock(image,header) != 0) ;
            break;
          }
        }
      }
    if (c != (unsigned char) ',')
      continue;
    if (image_count != 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
      }
    image_count++;
    /*
      Read image attributes.
    */
    meta_image->scene=image->scene;
    (void) CloneImageProperties(image,meta_image);
    DestroyImageProperties(meta_image);
    (void) CloneImageProfiles(image,meta_image);
    DestroyImageProfiles(meta_image);
    image->storage_class=PseudoClass;
    image->compression=LZWCompression;
    page.x=(ssize_t) ReadBlobLSBShort(image);
    page.y=(ssize_t) ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    image->depth=8;
    flag=(unsigned char) ReadBlobByte(image);
    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;
    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<
      ((size_t) (flag & 0x07)+1);
    if (opacity >= (ssize_t) image->colors)
      opacity=(-1);
    image->page.width=page.width;
    image->page.height=page.height;
    image->page.y=page.y;
    image->page.x=page.x;
    image->delay=delay;
    image->iterations=iterations;
    image->ticks_per_second=100;
    image->dispose=(DisposeType) dispose;
    image->matte=opacity >= 0 ? MagickTrue : MagickFalse;
    delay=0;
    dispose=0;
    if ((image->columns == 0) || (image->rows == 0))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,'NegativeOrZeroImageSize');
      }
    /*
      Inititialize colormap.
    */
    if (AcquireImageColormap(image,image->colors) == MagickFalse)
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
      }
    if (BitSet((int) flag,0x80) == 0)
      {
        /*
          Use global colormap.
        */
        p=global_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(*p++);
          image->colormap[i].green=ScaleCharToQuantum(*p++);
          image->colormap[i].blue=ScaleCharToQuantum(*p++);
          if (i == opacity)
            {
              image->colormap[i].opacity=(Quantum) TransparentOpacity;
              image->transparent_color=image->colormap[opacity];
            }
        }
        image->background_color=image->colormap[MagickMin((ssize_t) background,
          (ssize_t) image->colors-1)];
      }
    else
      {
        unsigned char
          *colormap;

        /*
          Read local colormap.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*
          sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
          }
        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);
        if (count != (ssize_t) (3*image->colors))
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              'InsufficientImageDataInFile');
          }
        p=colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(*p++);
          image->colormap[i].green=ScaleCharToQuantum(*p++);
          image->colormap[i].blue=ScaleCharToQuantum(*p++);
          if (i == opacity)
            image->colormap[i].opacity=(Quantum) TransparentOpacity;
        }
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    if (image->gamma == 1.0)
      {
        for (i=0; i < (ssize_t) image->colors; i++)
          if (IsGrayPixel(image->colormap+i) == MagickFalse)
            break;
        (void) SetImageColorspace(image,i == (ssize_t) image->colors ?
          GRAYColorspace : RGBColorspace);
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    /*
      Decode image.
    */
    if (image_info->ping != MagickFalse)
      status=PingGIFImage(image);
    else
      status=DecodeImage(image,opacity);
    if ((image_info->ping == MagickFalse) && (status == MagickFalse))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,'CorruptImage');
      }
    duration+=image->delay*image->iterations;
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    opacity=(-1);
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-
      1,image->scene);
    if (status == MagickFalse)
      break;
  }
  image->duration=duration;
  meta_image=DestroyImage(meta_image);
  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);
  if ((image->columns == 0) || (image->rows == 0))
    ThrowReaderException(CorruptImageError,'NegativeOrZeroImageSize');
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",1,8047
ImageMagick/ImageMagick,10aae21bf9dac47e16d8fcde7eba7f7f9d1e52f8,"static MagickBooleanType PingGIFImage(Image *image)
{
  unsigned char
    buffer[256],
    length,
    data_size;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',image->filename);
  if (ReadBlob(image,1,&data_size) != 1)
    ThrowBinaryException(CorruptImageError,'CorruptImage',image->filename);
  if (data_size > MaximumLZWBits)
    ThrowBinaryException(CorruptImageError,'CorruptImage',image->filename);
  if (ReadBlob(image,1,&length) != 1)
    ThrowBinaryException(CorruptImageError,'CorruptImage',image->filename);
  while (length != 0)
  {
    if (ReadBlob(image,length,buffer) != (ssize_t) length)
      ThrowBinaryException(CorruptImageError,'CorruptImage',image->filename);
    if (ReadBlob(image,1,&length) != 1)
      ThrowBinaryException(CorruptImageError,'CorruptImage',image->filename);
  }
  return(MagickTrue);
}
",0,8048
ImageMagick/ImageMagick,2130bf6f89ded32ef0c88a11694f107c52566c53,"static Image *ReadWPGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  typedef struct
  {
    size_t FileId;
    MagickOffsetType DataOffset;
    unsigned int ProductType;
    unsigned int FileType;
    unsigned char MajorVersion;
    unsigned char MinorVersion;
    unsigned int EncryptKey;
    unsigned int Reserved;
  } WPGHeader;

  typedef struct
  {
    unsigned char RecType;
    size_t RecordLength;
  } WPGRecord;

  typedef struct
  {
    unsigned char Class;
    unsigned char RecType;
    size_t Extension;
    size_t RecordLength;
  } WPG2Record;

  typedef struct
  {
    unsigned  HorizontalUnits;
    unsigned  VerticalUnits;
    unsigned char PosSizePrecision;
  } WPG2Start;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType1;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned char Depth;
    unsigned char Compression;
  } WPG2BitmapType1;

  typedef struct
  {
    unsigned int RotAngle;
    unsigned int LowLeftX;
    unsigned int LowLeftY;
    unsigned int UpRightX;
    unsigned int UpRightY;
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType2;

  typedef struct
  {
    unsigned int StartIndex;
    unsigned int NumOfEntries;
  } WPGColorMapRec;

  /*
  typedef struct {
    size_t PS_unknown1;
    unsigned int PS_unknown2;
    unsigned int PS_unknown3;
  } WPGPSl1Record;  
  */

  Image
    *image;

  unsigned int
    status;

  WPGHeader
    Header;

  WPGRecord
    Rec;

  WPG2Record
    Rec2;

  WPG2Start StartWPG;

  WPGBitmapType1
    BitmapHeader1;

  WPG2BitmapType1
    Bitmap2Header1;

  WPGBitmapType2
    BitmapHeader2;

  WPGColorMapRec
    WPG_Palette;

  int
    i,
    bpp,
    WPG2Flags;

  ssize_t
    ldblk;

  size_t
    one;

  unsigned char
    *BImgBuff;

  tCTM CTM;         /*current transform matrix*/

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  one=1;
  image=AcquireImage(image_info,exception);
  image->depth=8;
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read WPG image.
  */
  Header.FileId=ReadBlobLSBLong(image);
  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);
  Header.ProductType=ReadBlobLSBShort(image);
  Header.FileType=ReadBlobLSBShort(image);
  Header.MajorVersion=ReadBlobByte(image);
  Header.MinorVersion=ReadBlobByte(image);
  Header.EncryptKey=ReadBlobLSBShort(image);
  Header.Reserved=ReadBlobLSBShort(image);

  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  if (Header.EncryptKey!=0)
    ThrowReaderException(CoderError,'EncryptedWPGImageFileNotSupported');

  image->columns = 1;
  image->rows = 1;
  image->colors = 0;
  bpp=0;
  BitmapHeader2.RotAngle=0;
  Rec2.RecordLength=0;

  switch(Header.FileType)
    {
    case 1:     /* WPG level 1 */
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec.RecType=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rd_WP_DWORD(image,&Rec.RecordLength);
          if (Rec.RecordLength > GetBlobSize(image))
            ThrowReaderException(CorruptImageError,'ImproperImageHeader');
          if(EOFBlob(image))
            break;

          Header.DataOffset=TellBlob(image)+Rec.RecordLength;

          switch(Rec.RecType)
            {
            case 0x0B: /* bitmap type 1 */
              BitmapHeader1.Width=ReadBlobLSBShort(image);
              BitmapHeader1.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))
                ThrowReaderException(CorruptImageError,'ImproperImageHeader');
              BitmapHeader1.Depth=ReadBlobLSBShort(image);
              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader1.VertRes=ReadBlobLSBShort(image);

              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)
                {
                  image->units=PixelsPerCentimeterResolution;
                  image->resolution.x=BitmapHeader1.HorzRes/470.0;
                  image->resolution.y=BitmapHeader1.VertRes/470.0;
                }
              image->columns=BitmapHeader1.Width;
              image->rows=BitmapHeader1.Height;
              bpp=BitmapHeader1.Depth;

              goto UnpackRaster;

            case 0x0E:  /*Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2) / 3)
                ThrowReaderException(CorruptImageError,'InvalidColormapIndex');
              image->colors=WPG_Palette.NumOfEntries;
              if (!AcquireImageColormap(image,image->colors,exception))
                goto NoMemory;
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                }
              break;
     
            case 0x11:  /* Start PS l1 */
              if(Rec.RecordLength > 8)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+8,   /* skip PS header in the wpg */
                  (ssize_t) Rec.RecordLength-8,exception);
              break;     

            case 0x14:  /* bitmap type 2 */
              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);
              BitmapHeader2.Width=ReadBlobLSBShort(image);
              BitmapHeader2.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))
                ThrowReaderException(CorruptImageError,'ImproperImageHeader');
              BitmapHeader2.Depth=ReadBlobLSBShort(image);
              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader2.VertRes=ReadBlobLSBShort(image);

              image->units=PixelsPerCentimeterResolution;
              image->page.width=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);
              image->page.height=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);
              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);
              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);
              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)
                {
                  image->resolution.x=BitmapHeader2.HorzRes/470.0;
                  image->resolution.y=BitmapHeader2.VertRes/470.0;
                }
              image->columns=BitmapHeader2.Width;
              image->rows=BitmapHeader2.Height;
              bpp=BitmapHeader2.Depth;

            UnpackRaster:      
              status=SetImageExtent(image,image->columns,image->rows,exception);
              if (status == MagickFalse)
                break;
              if ((image->colors == 0) && (bpp <= 16))
                {
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors,exception))
                    {
                    NoMemory:
                      ThrowReaderException(ResourceLimitError,
                        'MemoryAllocationFailed');
                    }
                  /* printf('Load default colormap \n'); */
                  for (i=0; (i < (int) image->colors) && (i < 256); i++)
                    {               
                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);
                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);
                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);
                    }
                }
              else
                {
                  if (bpp < 24)
                    if ( (image->colors < (one << bpp)) && (bpp != 24) )
                      image->colormap=(PixelInfo *) ResizeQuantumMemory(
                        image->colormap,(size_t) (one << bpp),
                        sizeof(*image->colormap));
                }
          
              if (bpp == 1)
                {
                  if(image->colormap[0].red==0 &&
                     image->colormap[0].green==0 &&
                     image->colormap[0].blue==0 &&
                     image->colormap[1].red==0 &&
                     image->colormap[1].green==0 &&
                     image->colormap[1].blue==0)
                    {  /* fix crippled monochrome palette */
                      image->colormap[1].red =
                        image->colormap[1].green =
                        image->colormap[1].blue = QuantumRange;
                    }
                }      

              if(UnpackWPGRaster(image,bpp,exception) < 0)
                /* The raster cannot be unpacked */
                {
                DecompressionFailed:
                  ThrowReaderException(CoderError,'UnableToDecompressImage');
                    }

              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)
                {  
                  /* flop command */
                  if(BitmapHeader2.RotAngle & 0x8000)
                    {
                      Image
                        *flop_image;

                      flop_image = FlopImage(image, exception);
                      if (flop_image != (Image *) NULL) {
                        DuplicateBlob(flop_image,image);
                        ReplaceImageInList(&image,flop_image);
                      }
                    }
                  /* flip command */
                  if(BitmapHeader2.RotAngle & 0x2000)
                    {
                      Image
                        *flip_image;

                      flip_image = FlipImage(image, exception);
                      if (flip_image != (Image *) NULL) {
                        DuplicateBlob(flip_image,image);
                        ReplaceImageInList(&image,flip_image);
                      }
                    }
                  /* rotate command */
                  if(BitmapHeader2.RotAngle & 0x0FFF)
                    {
                      Image
                        *rotate_image;

                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &
                        0x0FFF), exception);
                      if (rotate_image != (Image *) NULL) {
                        DuplicateBlob(rotate_image,image);
                        ReplaceImageInList(&image,rotate_image);
                      }
                    }
                }

              /* Allocate next image structure. */
              AcquireNextImage(image_info,image,exception);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x1B:  /* Postscript l2 */
              if(Rec.RecordLength>0x3C)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */
                  (ssize_t) Rec.RecordLength-0x3C,exception);
              break;
            }
        }
      break;

    case 2:  /* WPG level 2 */
      (void) memset(CTM,0,sizeof(CTM));
      StartWPG.PosSizePrecision = 0;
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec2.Class=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rec2.RecType=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rd_WP_DWORD(image,&Rec2.Extension);
          Rd_WP_DWORD(image,&Rec2.RecordLength);
          if(EOFBlob(image))
            break;

          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;

          switch(Rec2.RecType)
            {
      case 1:
              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);
              StartWPG.VerticalUnits=ReadBlobLSBShort(image);
              StartWPG.PosSizePrecision=ReadBlobByte(image);
              break;
            case 0x0C:    /* Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2) / 3)
                ThrowReaderException(CorruptImageError,'InvalidColormapIndex');
              image->colors=WPG_Palette.NumOfEntries;
              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
                ThrowReaderException(ResourceLimitError,
                  'MemoryAllocationFailed');
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  (void) ReadBlobByte(image);   /*Opacity??*/
                }
              break;
            case 0x0E:
              Bitmap2Header1.Width=ReadBlobLSBShort(image);
              Bitmap2Header1.Height=ReadBlobLSBShort(image);
              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))
                ThrowReaderException(CorruptImageError,'ImproperImageHeader');
              Bitmap2Header1.Depth=ReadBlobByte(image);
              Bitmap2Header1.Compression=ReadBlobByte(image);

              if(Bitmap2Header1.Compression > 1)
                continue; /*Unknown compression method */
              switch(Bitmap2Header1.Depth)
                {
                case 1:
                  bpp=1;
                  break;
                case 2:
                  bpp=2;
                  break;
                case 3:
                  bpp=4;
                  break;
                case 4:
                  bpp=8;
                  break;
                case 8:
                  bpp=24;
                  break;
                default:
                  continue;  /*Ignore raster with unknown depth*/
                }
              image->columns=Bitmap2Header1.Width;
              image->rows=Bitmap2Header1.Height;
              status=SetImageExtent(image,image->columns,image->rows,exception);
              if (status == MagickFalse)
                break;
              if ((image->colors == 0) && (bpp != 24))
                {
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors,exception))
                    goto NoMemory;
                }
              else
                {
                  if(bpp < 24)
                    if( image->colors<(one << bpp) && bpp!=24 )
                      image->colormap=(PixelInfo *) ResizeQuantumMemory(
                       image->colormap,(size_t) (one << bpp),
                       sizeof(*image->colormap));
                }


              switch(Bitmap2Header1.Compression)
                {
                case 0:    /*Uncompressed raster*/
                  {
                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);
                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)
                      ldblk+1,sizeof(*BImgBuff));
                    if (BImgBuff == (unsigned char *) NULL)
                      goto NoMemory;

                    for(i=0; i< (ssize_t) image->rows; i++)
                      {
                        (void) ReadBlob(image,ldblk,BImgBuff);
                        InsertRow(image,BImgBuff,i,bpp,exception);
                      }

                    if(BImgBuff)
                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                    break;
                  }
                case 1:    /*RLE for WPG2 */
                  {
                    if( UnpackWPG2Raster(image,bpp,exception) < 0)
                      goto DecompressionFailed;
                    break;
                  }   
                }

              if(CTM[0][0]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flop_image;

                  flop_image = FlopImage(image, exception);
                  if (flop_image != (Image *) NULL) {
                    DuplicateBlob(flop_image,image);
                    ReplaceImageInList(&image,flop_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;
                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;
                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);
                     Tx(1,2)=0;   Tx(2,2)=1; */
                }
              if(CTM[1][1]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flip_image;

                   flip_image = FlipImage(image, exception);
                   if (flip_image != (Image *) NULL) {
                     DuplicateBlob(flip_image,image);
                     ReplaceImageInList(&image,flip_image);
                    }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     float_matrix Tx(3,3);
                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;
                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;
                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);
                     Tx(2,2)=1; */
              }


              /* Allocate next image structure. */
              AcquireNextImage(image_info,image,exception);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x12:  /* Postscript WPG2*/
        i=ReadBlobLSBShort(image);
              if(Rec2.RecordLength > (unsigned int) i)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+i,    /*skip PS header in the wpg2*/
                  (ssize_t) (Rec2.RecordLength-i-2),exception);
              break;

      case 0x1B:          /*bitmap rectangle*/
              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);
              (void) WPG2Flags;
              break;
            }
        }

      break;

    default:
      {
         ThrowReaderException(CoderError,'DataEncodingSchemeIsNotSupported');
      }
   }

 Finish:
  (void) CloseBlob(image);

  {
    Image
      *p;

    ssize_t
      scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }
    /*
      Fix scene numbers.
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=(size_t) scene++;
  }
  if (image == (Image *) NULL)
    ThrowReaderException(CorruptImageError,
      'ImageFileDoesNotContainAnyImageData');
  return(image);
}
",1,8049
ImageMagick/ImageMagick,2130bf6f89ded32ef0c88a11694f107c52566c53,"static int UnpackWPGRaster(Image *image,int bpp,ExceptionInfo *exception)
{
  int
    x,
    y,
    i;

  unsigned char
    bbuf,
    *BImgBuff,
    RunCount;

  ssize_t
    ldblk;

  x=0;
  y=0;

  ldblk=(ssize_t) ((bpp*image->columns+7)/8);
  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,
    8*sizeof(*BImgBuff));
  if(BImgBuff==NULL) return(-2);

  while(y<(ssize_t) image->rows)
    {
      int
        c;

      c=ReadBlobByte(image);
      if (c == EOF)
        break;
      bbuf=(unsigned char) c;
      RunCount=bbuf & 0x7F;
      if(bbuf & 0x80)
        {
          if(RunCount)  /* repeat next byte runcount * */
            {
              bbuf=ReadBlobByte(image);
              for(i=0;i<(int) RunCount;i++) InsertByte(bbuf);
            }
          else {  /* read next byte as RunCount; repeat 0xFF runcount* */
            c=ReadBlobByte(image);
            if (c < 0)
              break;
            RunCount=(unsigned char) c;
            for(i=0;i<(int) RunCount;i++) InsertByte(0xFF);
          }
        }
      else {
        if(RunCount)   /* next runcount byte are readed directly */
          {
            for(i=0;i < (int) RunCount;i++)
              {
                bbuf=ReadBlobByte(image);
                InsertByte(bbuf);
              }
          }
        else {  /* repeat previous line runcount* */
          c=ReadBlobByte(image);
          if (c < 0)
            break;
          RunCount=(unsigned char) c;
          if(x) {    /* attempt to duplicate row from x position: */
            /* I do not know what to do here */
            BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
            return(-3);
          }
          for(i=0;i < (int) RunCount;i++)
            {
              x=0;
              y++;    /* Here I need to duplicate previous row RUNCOUNT* */
              if(y<2) continue;
              if(y>(ssize_t) image->rows)
                {
                  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                  return(-4);
                }
              InsertRow(image,BImgBuff,y-1,bpp,exception);
            }
        }
      }
      if (EOFBlob(image) != MagickFalse)
        break;
    }
  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
  return(y <(ssize_t) image->rows ? -5 : 0);
}
",0,8050
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"	case 'y':
	case 'z':	goto yy170;
	case 'e':	goto yy1429;
",1,8051
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"	case ')':	goto yy164;
	case '0':
	case '1':	goto yy1391;
",1,8052
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"	case 'e':	goto yy1386;
	case 'H':
	case 'h':	goto yy1387;
",1,8053
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"	case 'o':	goto yy1388;
	case 'U':
	case 'u':	goto yy1389;
",1,8054
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"				goto yy165;
			} else {
				if (yych <= 'O') goto yy1312;
",1,8055
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"				if (yych <= 'e') goto yy1351;
				if (yych <= 'h') goto yy170;
				goto yy1352;
",1,8056
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"		} else {
			if (yych <= 'q') {
				if (yych == 'o') goto yy1353;
",1,8057
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)
{
	uchar *cursor = s->cur;
	char *str, *ptr = NULL;

std:
	s->tok = cursor;
	s->len = 0;
#line 965 'ext/date/lib/parse_date.re'



#line 846 '<stdout>'
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 100,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		100,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0, 128,  64, 160,  96,   0, 
		  2,   2,   2,   2,   2,   2,   2,   2, 
		  2,   2,   0,   0,   0,   0,   0,   0, 
		  0,   8,   8,   8,   8,   8,   8,   8, 
		  8,   8,   8,   8,   8,   8,   8,   8, 
		  8,   8,   8,   8,   8,   8,   8,   8, 
		  8,   8,   8,   0,   0,   0,   0,   0, 
		  0,  24,  24,  24,  88,  24,  24,  24, 
		 88,  24,  24,  24,  24,  24,  88,  24, 
		 24,  24,  88,  88,  88,  24,  24,  24, 
		 24,  24,  24,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	YYDEBUG(0, *YYCURSOR);
	if ((YYLIMIT - YYCURSOR) < 33) YYFILL(33);
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:
	case '\n':	goto yy51;
	case '\t':
	case ' ':	goto yy48;
	case '(':	goto yy45;
	case '+':
	case '-':	goto yy30;
	case ',':
	case '.':	goto yy50;
	case '0':	goto yy25;
	case '1':	goto yy26;
	case '2':	goto yy27;
	case '3':	goto yy28;
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy29;
	case '@':	goto yy11;
	case 'A':	goto yy36;
	case 'B':	goto yy17;
	case 'C':
	case 'H':
	case 'K':
	case 'Q':
	case 'R':
	case 'U':
	case 'Z':	goto yy46;
	case 'D':	goto yy40;
	case 'E':	goto yy21;
	case 'F':	goto yy13;
	case 'G':	goto yy44;
	case 'I':	goto yy31;
	case 'J':	goto yy34;
	case 'L':	goto yy15;
	case 'M':	goto yy7;
	case 'N':	goto yy5;
	case 'O':	goto yy38;
	case 'P':	goto yy23;
	case 'S':	goto yy19;
	case 'T':	goto yy9;
	case 'V':	goto yy32;
	case 'W':	goto yy42;
	case 'X':	goto yy33;
	case 'Y':	goto yy2;
	case 'a':	goto yy37;
	case 'b':	goto yy18;
	case 'c':
	case 'g':
	case 'h':
	case 'i':
	case 'k':
	case 'q':
	case 'r':
	case 'u':
	case 'v':
	case 'x':
	case 'z':	goto yy47;
	case 'd':	goto yy41;
	case 'e':	goto yy22;
	case 'f':	goto yy14;
	case 'j':	goto yy35;
	case 'l':	goto yy16;
	case 'm':	goto yy8;
	case 'n':	goto yy6;
	case 'o':	goto yy39;
	case 'p':	goto yy24;
	case 's':	goto yy20;
	case 't':	goto yy10;
	case 'w':	goto yy43;
	case 'y':	goto yy4;
	default:	goto yy53;
	}
yy2:
	YYDEBUG(2, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= 'E') {
		if (yych <= ')') {
			if (yych >= ')') goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy165;
			goto yy1521;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy165;
			if (yych >= 'a') goto yy170;
		} else {
			if (yych <= 'e') goto yy1530;
			if (yych <= 'z') goto yy170;
		}
	}
yy3:
	YYDEBUG(3, *YYCURSOR);
#line 1673 'ext/date/lib/parse_date.re'
	{
		int tz_not_found;
		DEBUG_OUTPUT('tzcorrection | tz');
		TIMELIB_INIT;
		TIMELIB_HAVE_TZ();
		s->time->z = timelib_parse_zone((char **) &ptr, &s->time->dst, s->time, &tz_not_found, s->tzdb, tz_get_wrapper);
		if (tz_not_found) {
			add_error(s, 'The timezone could not be found in the database');
		}
		TIMELIB_DEINIT;
		return TIMELIB_TIMEZONE;
	}
#line 997 '<stdout>'
yy4:
	YYDEBUG(4, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy165;
			goto yy1521;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'e') goto yy1521;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy5:
	YYDEBUG(5, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= 'D') {
			if (yych == ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') goto yy1492;
				goto yy165;
			} else {
				if (yych <= 'I') goto yy1493;
				if (yych <= 'N') goto yy165;
				goto yy1491;
			}
		}
	} else {
		if (yych <= 'h') {
			if (yych <= '`') {
				if (yych <= 'Z') goto yy165;
				goto yy3;
			} else {
				if (yych == 'e') goto yy1508;
				goto yy170;
			}
		} else {
			if (yych <= 'n') {
				if (yych <= 'i') goto yy1509;
				goto yy170;
			} else {
				if (yych <= 'o') goto yy1507;
				if (yych <= 'z') goto yy170;
				goto yy3;
			}
		}
	}
yy6:
	YYDEBUG(6, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= 'D') {
			if (yych == ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') goto yy1492;
				goto yy165;
			} else {
				if (yych <= 'I') goto yy1493;
				if (yych <= 'N') goto yy165;
				goto yy1491;
			}
		}
	} else {
		if (yych <= 'h') {
			if (yych <= '`') {
				if (yych <= 'Z') goto yy165;
				goto yy3;
			} else {
				if (yych == 'e') goto yy1492;
				goto yy165;
			}
		} else {
			if (yych <= 'n') {
				if (yych <= 'i') goto yy1493;
				goto yy165;
			} else {
				if (yych <= 'o') goto yy1491;
				if (yych <= 'z') goto yy165;
				goto yy3;
			}
		}
	}
yy7:
	YYDEBUG(7, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= 'A') {
			if (yych == ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy1461;
		} else {
			if (yych == 'I') goto yy1462;
			if (yych <= 'N') goto yy165;
			goto yy1463;
		}
	} else {
		if (yych <= 'h') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1476;
			goto yy170;
		} else {
			if (yych <= 'n') {
				if (yych <= 'i') goto yy1477;
				goto yy170;
			} else {
				if (yych <= 'o') goto yy1478;
				if (yych <= 'z') goto yy170;
				goto yy3;
			}
		}
	}
yy8:
	YYDEBUG(8, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= 'A') {
			if (yych == ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy1461;
		} else {
			if (yych == 'I') goto yy1462;
			if (yych <= 'N') goto yy165;
			goto yy1463;
		}
	} else {
		if (yych <= 'h') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1461;
			goto yy165;
		} else {
			if (yych <= 'n') {
				if (yych <= 'i') goto yy1462;
				goto yy165;
			} else {
				if (yych <= 'o') goto yy1463;
				if (yych <= 'z') goto yy165;
				goto yy3;
			}
		}
	}
yy9:
	YYDEBUG(9, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case ')':	goto yy164;
	case '0':
	case '1':	goto yy1391;
	case '2':	goto yy1392;
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy1393;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'F':
	case 'G':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'V':
	case 'X':
	case 'Y':
	case 'Z':	goto yy165;
	case 'E':	goto yy1386;
	case 'H':	goto yy1387;
	case 'O':	goto yy1388;
	case 'U':	goto yy1389;
	case 'W':	goto yy1390;
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'f':
	case 'g':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'v':
	case 'x':
	case 'y':
	case 'z':	goto yy170;
	case 'e':	goto yy1429;
	case 'h':	goto yy1430;
	case 'o':	goto yy1431;
	case 'u':	goto yy1432;
	case 'w':	goto yy1433;
	default:	goto yy3;
	}
yy10:
	YYDEBUG(10, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case ')':	goto yy164;
	case '0':
	case '1':	goto yy1391;
	case '2':	goto yy1392;
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy1393;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'F':
	case 'G':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'V':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'f':
	case 'g':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'v':
	case 'x':
	case 'y':
	case 'z':	goto yy165;
	case 'E':
	case 'e':	goto yy1386;
	case 'H':
	case 'h':	goto yy1387;
	case 'O':
	case 'o':	goto yy1388;
	case 'U':
	case 'u':	goto yy1389;
	case 'W':
	case 'w':	goto yy1390;
	default:	goto yy3;
	}
yy11:
	YYDEBUG(11, *YYCURSOR);
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '-') goto yy1374;
	if (yych <= '/') goto yy12;
	if (yych <= '9') goto yy1375;
yy12:
	YYDEBUG(12, *YYCURSOR);
#line 1768 'ext/date/lib/parse_date.re'
	{
		add_error(s, 'Unexpected character');
		goto std;
	}
#line 1311 '<stdout>'
yy13:
	YYDEBUG(13, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= 'E') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych <= '@') goto yy3;
				if (yych <= 'D') goto yy165;
				goto yy1310;
			}
		} else {
			if (yych <= 'N') {
				if (yych == 'I') goto yy1311;
				goto yy165;
			} else {
				if (yych <= 'O') goto yy1312;
				if (yych <= 'Q') goto yy165;
				goto yy1313;
			}
		}
	} else {
		if (yych <= 'i') {
			if (yych <= 'd') {
				if (yych <= 'Z') goto yy165;
				if (yych <= '`') goto yy3;
				goto yy170;
			} else {
				if (yych <= 'e') goto yy1351;
				if (yych <= 'h') goto yy170;
				goto yy1352;
			}
		} else {
			if (yych <= 'q') {
				if (yych == 'o') goto yy1353;
				goto yy170;
			} else {
				if (yych <= 'r') goto yy1354;
				if (yych <= 'z') goto yy170;
				goto yy3;
			}
		}
	}
yy14:
	YYDEBUG(14, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= 'E') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych <= '@') goto yy3;
				if (yych <= 'D') goto yy165;
				goto yy1310;
			}
		} else {
			if (yych <= 'N') {
				if (yych == 'I') goto yy1311;
				goto yy165;
			} else {
				if (yych <= 'O') goto yy1312;
				if (yych <= 'Q') goto yy165;
				goto yy1313;
			}
		}
	} else {
		if (yych <= 'i') {
			if (yych <= 'd') {
				if (yych <= 'Z') goto yy165;
				if (yych <= '`') goto yy3;
				goto yy165;
			} else {
				if (yych <= 'e') goto yy1310;
				if (yych <= 'h') goto yy165;
				goto yy1311;
			}
		} else {
			if (yych <= 'q') {
				if (yych == 'o') goto yy1312;
				goto yy165;
			} else {
				if (yych <= 'r') goto yy1313;
				if (yych <= 'z') goto yy165;
				goto yy3;
			}
		}
	}
yy15:
	YYDEBUG(15, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
		goto yy1296;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy165;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1307;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy16:
	YYDEBUG(16, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
		goto yy1296;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy165;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1296;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy17:
	YYDEBUG(17, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
		goto yy1276;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy165;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1293;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy18:
	YYDEBUG(18, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
		goto yy1276;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy165;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1276;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy19:
	YYDEBUG(19, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= 'D') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych <= '@') goto yy3;
				if (yych <= 'A') goto yy1219;
				goto yy165;
			}
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') goto yy1218;
				goto yy165;
			} else {
				if (yych <= 'I') goto yy1220;
				if (yych <= 'T') goto yy165;
				goto yy1221;
			}
		}
	} else {
		if (yych <= 'e') {
			if (yych <= '`') {
				if (yych <= 'Z') goto yy165;
				goto yy3;
			} else {
				if (yych <= 'a') goto yy1248;
				if (yych <= 'd') goto yy170;
				goto yy1247;
			}
		} else {
			if (yych <= 't') {
				if (yych == 'i') goto yy1249;
				goto yy170;
			} else {
				if (yych <= 'u') goto yy1250;
				if (yych <= 'z') goto yy170;
				goto yy3;
			}
		}
	}
yy20:
	YYDEBUG(20, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= 'D') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych <= '@') goto yy3;
				if (yych <= 'A') goto yy1219;
				goto yy165;
			}
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') goto yy1218;
				goto yy165;
			} else {
				if (yych <= 'I') goto yy1220;
				if (yych <= 'T') goto yy165;
				goto yy1221;
			}
		}
	} else {
		if (yych <= 'e') {
			if (yych <= '`') {
				if (yych <= 'Z') goto yy165;
				goto yy3;
			} else {
				if (yych <= 'a') goto yy1219;
				if (yych <= 'd') goto yy165;
				goto yy1218;
			}
		} else {
			if (yych <= 't') {
				if (yych == 'i') goto yy1220;
				goto yy165;
			} else {
				if (yych <= 'u') goto yy1221;
				if (yych <= 'z') goto yy165;
				goto yy3;
			}
		}
	}
yy21:
	YYDEBUG(21, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == 'I') goto yy1188;
			if (yych <= 'K') goto yy165;
			goto yy1189;
		}
	} else {
		if (yych <= 'i') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			if (yych <= 'h') goto yy170;
			goto yy1206;
		} else {
			if (yych == 'l') goto yy1207;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy22:
	YYDEBUG(22, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == 'I') goto yy1188;
			if (yych <= 'K') goto yy165;
			goto yy1189;
		}
	} else {
		if (yych <= 'i') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			if (yych <= 'h') goto yy165;
			goto yy1188;
		} else {
			if (yych == 'l') goto yy1189;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy23:
	YYDEBUG(23, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy165;
			goto yy1062;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy170;
		} else {
			if (yych <= 'r') goto yy1181;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy24:
	YYDEBUG(24, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy165;
			goto yy1062;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'r') goto yy1062;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy25:
	YYDEBUG(25, *YYCURSOR);
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '`') {
		if (yych <= '@') {
			if (yych <= '-') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy1016;
					goto yy12;
				} else {
					if (yych <= ' ') goto yy1018;
					if (yych <= ',') goto yy12;
					goto yy437;
				}
			} else {
				if (yych <= '0') {
					if (yych <= '.') goto yy1028;
					if (yych <= '/') goto yy436;
					goto yy1061;
				} else {
					if (yych <= '9') goto yy1060;
					if (yych <= ':') goto yy1029;
					goto yy12;
				}
			}
		} else {
			if (yych <= 'G') {
				if (yych <= 'D') {
					if (yych <= 'A') goto yy1018;
					if (yych <= 'C') goto yy12;
					goto yy1018;
				} else {
					if (yych == 'F') goto yy1018;
					goto yy12;
				}
			} else {
				if (yych <= 'O') {
					if (yych <= 'J') goto yy1018;
					if (yych <= 'L') goto yy12;
					goto yy1018;
				} else {
					if (yych <= 'R') goto yy12;
					if (yych <= 'Y') goto yy1018;
					goto yy12;
				}
			}
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'g') {
				if (yych <= 'd') {
					if (yych <= 'a') goto yy1018;
					if (yych <= 'c') goto yy12;
					goto yy1018;
				} else {
					if (yych == 'f') goto yy1018;
					goto yy12;
				}
			} else {
				if (yych <= 'j') {
					if (yych == 'i') goto yy12;
					goto yy1018;
				} else {
					if (yych <= 'l') goto yy12;
					if (yych <= 'm') goto yy1018;
					goto yy434;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'r') {
					if (yych <= 'o') goto yy1018;
					if (yych <= 'q') goto yy12;
					goto yy435;
				} else {
					if (yych <= 's') goto yy429;
					if (yych <= 't') goto yy432;
					goto yy1018;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy1018;
					goto yy12;
				} else {
					if (yych <= 'y') goto yy1018;
					if (yych == 0xC2) goto yy1018;
					goto yy12;
				}
			}
		}
	}
yy26:
	YYDEBUG(26, *YYCURSOR);
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '`') {
		if (yych <= '@') {
			if (yych <= '-') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy424;
					goto yy12;
				} else {
					if (yych <= ' ') goto yy426;
					if (yych <= ',') goto yy12;
					goto yy437;
				}
			} else {
				if (yych <= '2') {
					if (yych <= '.') goto yy438;
					if (yych <= '/') goto yy436;
					goto yy1060;
				} else {
					if (yych <= '9') goto yy1027;
					if (yych <= ':') goto yy447;
					goto yy12;
				}
			}
		} else {
			if (yych <= 'G') {
				if (yych <= 'D') {
					if (yych <= 'A') goto yy426;
					if (yych <= 'C') goto yy12;
					goto yy426;
				} else {
					if (yych == 'F') goto yy426;
					goto yy12;
				}
			} else {
				if (yych <= 'P') {
					if (yych <= 'J') goto yy426;
					if (yych <= 'L') goto yy12;
					goto yy426;
				} else {
					if (yych <= 'R') goto yy12;
					if (yych <= 'Y') goto yy426;
					goto yy12;
				}
			}
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'g') {
				if (yych <= 'd') {
					if (yych <= 'a') goto yy426;
					if (yych <= 'c') goto yy12;
					goto yy426;
				} else {
					if (yych == 'f') goto yy426;
					goto yy12;
				}
			} else {
				if (yych <= 'j') {
					if (yych == 'i') goto yy12;
					goto yy426;
				} else {
					if (yych <= 'l') goto yy12;
					if (yych <= 'm') goto yy426;
					goto yy434;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'r') {
					if (yych <= 'p') goto yy426;
					if (yych <= 'q') goto yy12;
					goto yy435;
				} else {
					if (yych <= 's') goto yy429;
					if (yych <= 't') goto yy432;
					goto yy426;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy426;
					goto yy12;
				} else {
					if (yych <= 'y') goto yy426;
					if (yych == 0xC2) goto yy426;
					goto yy12;
				}
			}
		}
	}
yy27:
	YYDEBUG(27, *YYCURSOR);
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '`') {
		if (yych <= '@') {
			if (yych <= '-') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy424;
					goto yy12;
				} else {
					if (yych <= ' ') goto yy426;
					if (yych <= ',') goto yy12;
					goto yy437;
				}
			} else {
				if (yych <= '4') {
					if (yych <= '.') goto yy438;
					if (yych <= '/') goto yy436;
					goto yy1027;
				} else {
					if (yych <= '9') goto yy1014;
					if (yych <= ':') goto yy447;
					goto yy12;
				}
			}
		} else {
			if (yych <= 'G') {
				if (yych <= 'D') {
					if (yych <= 'A') goto yy426;
					if (yych <= 'C') goto yy12;
					goto yy426;
				} else {
					if (yych == 'F') goto yy426;
					goto yy12;
				}
			} else {
				if (yych <= 'P') {
					if (yych <= 'J') goto yy426;
					if (yych <= 'L') goto yy12;
					goto yy426;
				} else {
					if (yych <= 'R') goto yy12;
					if (yych <= 'Y') goto yy426;
					goto yy12;
				}
			}
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'g') {
				if (yych <= 'd') {
					if (yych <= 'a') goto yy426;
					if (yych <= 'c') goto yy12;
					goto yy426;
				} else {
					if (yych == 'f') goto yy426;
					goto yy12;
				}
			} else {
				if (yych <= 'j') {
					if (yych == 'i') goto yy12;
					goto yy426;
				} else {
					if (yych <= 'l') goto yy12;
					if (yych <= 'm') goto yy426;
					goto yy434;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'r') {
					if (yych <= 'p') goto yy426;
					if (yych <= 'q') goto yy12;
					goto yy435;
				} else {
					if (yych <= 's') goto yy429;
					if (yych <= 't') goto yy432;
					goto yy426;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy426;
					goto yy12;
				} else {
					if (yych <= 'y') goto yy426;
					if (yych == 0xC2) goto yy426;
					goto yy12;
				}
			}
		}
	}
yy28:
	YYDEBUG(28, *YYCURSOR);
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '`') {
		if (yych <= '@') {
			if (yych <= '-') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy424;
					goto yy12;
				} else {
					if (yych <= ' ') goto yy426;
					if (yych <= ',') goto yy12;
					goto yy437;
				}
			} else {
				if (yych <= '1') {
					if (yych <= '.') goto yy438;
					if (yych <= '/') goto yy436;
					goto yy1014;
				} else {
					if (yych <= '9') goto yy433;
					if (yych <= ':') goto yy447;
					goto yy12;
				}
			}
		} else {
			if (yych <= 'G') {
				if (yych <= 'D') {
					if (yych <= 'A') goto yy426;
					if (yych <= 'C') goto yy12;
					goto yy426;
				} else {
					if (yych == 'F') goto yy426;
					goto yy12;
				}
			} else {
				if (yych <= 'P') {
					if (yych <= 'J') goto yy426;
					if (yych <= 'L') goto yy12;
					goto yy426;
				} else {
					if (yych <= 'R') goto yy12;
					if (yych <= 'Y') goto yy426;
					goto yy12;
				}
			}
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'g') {
				if (yych <= 'd') {
					if (yych <= 'a') goto yy426;
					if (yych <= 'c') goto yy12;
					goto yy426;
				} else {
					if (yych == 'f') goto yy426;
					goto yy12;
				}
			} else {
				if (yych <= 'j') {
					if (yych == 'i') goto yy12;
					goto yy426;
				} else {
					if (yych <= 'l') goto yy12;
					if (yych <= 'm') goto yy426;
					goto yy434;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'r') {
					if (yych <= 'p') goto yy426;
					if (yych <= 'q') goto yy12;
					goto yy435;
				} else {
					if (yych <= 's') goto yy429;
					if (yych <= 't') goto yy432;
					goto yy426;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy426;
					goto yy12;
				} else {
					if (yych <= 'y') goto yy426;
					if (yych == 0xC2) goto yy426;
					goto yy12;
				}
			}
		}
	}
yy29:
	YYDEBUG(29, *YYCURSOR);
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'a') {
		if (yych <= 'A') {
			if (yych <= '-') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy424;
					goto yy12;
				} else {
					if (yych <= ' ') goto yy426;
					if (yych <= ',') goto yy12;
					goto yy437;
				}
			} else {
				if (yych <= '9') {
					if (yych <= '.') goto yy438;
					if (yych <= '/') goto yy436;
					goto yy433;
				} else {
					if (yych <= ':') goto yy447;
					if (yych <= '@') goto yy12;
					goto yy426;
				}
			}
		} else {
			if (yych <= 'J') {
				if (yych <= 'E') {
					if (yych == 'D') goto yy426;
					goto yy12;
				} else {
					if (yych == 'G') goto yy12;
					goto yy426;
				}
			} else {
				if (yych <= 'R') {
					if (yych <= 'L') goto yy12;
					if (yych <= 'P') goto yy426;
					goto yy12;
				} else {
					if (yych <= 'Y') goto yy426;
					if (yych <= '`') goto yy12;
					goto yy426;
				}
			}
		}
	} else {
		if (yych <= 'p') {
			if (yych <= 'h') {
				if (yych <= 'e') {
					if (yych == 'd') goto yy426;
					goto yy12;
				} else {
					if (yych == 'g') goto yy12;
					goto yy426;
				}
			} else {
				if (yych <= 'l') {
					if (yych == 'j') goto yy426;
					goto yy12;
				} else {
					if (yych == 'n') goto yy434;
					goto yy426;
				}
			}
		} else {
			if (yych <= 'v') {
				if (yych <= 's') {
					if (yych <= 'q') goto yy12;
					if (yych <= 'r') goto yy435;
					goto yy429;
				} else {
					if (yych <= 't') goto yy432;
					if (yych <= 'u') goto yy426;
					goto yy12;
				}
			} else {
				if (yych <= 'y') {
					if (yych == 'x') goto yy12;
					goto yy426;
				} else {
					if (yych == 0xC2) goto yy426;
					goto yy12;
				}
			}
		}
	}
yy30:
	YYDEBUG(30, *YYCURSOR);
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 4) {
		goto yy57;
	}
	switch (yych) {
	case '+':
	case '-':	goto yy404;
	case '0':
	case '1':	goto yy401;
	case '2':	goto yy402;
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy403;
	default:	goto yy12;
	}
yy31:
	YYDEBUG(31, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy3;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy3;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy3;
			} else {
				if (yych == '/') goto yy3;
				goto yy220;
			}
		}
	} else {
		if (yych <= 'V') {
			if (yych <= 'H') {
				if (yych <= '@') goto yy3;
				goto yy165;
			} else {
				if (yych <= 'I') goto yy400;
				if (yych <= 'U') goto yy165;
				goto yy399;
			}
		} else {
			if (yych <= 'Z') {
				if (yych == 'X') goto yy399;
				goto yy165;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy170;
				goto yy3;
			}
		}
	}
yy32:
	YYDEBUG(32, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy3;
			goto yy220;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy220;
		}
	} else {
		if (yych <= 'H') {
			if (yych <= '/') goto yy3;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'Z') {
				if (yych <= 'I') goto yy396;
				goto yy165;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy170;
				goto yy3;
			}
		}
	}
yy33:
	YYDEBUG(33, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy3;
			goto yy220;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy220;
		}
	} else {
		if (yych <= 'H') {
			if (yych <= '/') goto yy3;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'Z') {
				if (yych <= 'I') goto yy394;
				goto yy165;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy170;
				goto yy3;
			}
		}
	}
yy34:
	YYDEBUG(34, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych <= 'A') goto yy377;
			if (yych <= 'T') goto yy165;
			goto yy376;
		}
	} else {
		if (yych <= 'a') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy386;
		} else {
			if (yych == 'u') goto yy385;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy35:
	YYDEBUG(35, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych <= 'A') goto yy377;
			if (yych <= 'T') goto yy165;
			goto yy376;
		}
	} else {
		if (yych <= 'a') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy377;
		} else {
			if (yych == 'u') goto yy376;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy36:
	YYDEBUG(36, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= 'F') {
			if (yych == ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'O') {
				if (yych <= 'G') goto yy355;
				goto yy165;
			} else {
				if (yych <= 'P') goto yy354;
				if (yych <= 'T') goto yy165;
				goto yy353;
			}
		}
	} else {
		if (yych <= 'o') {
			if (yych <= '`') {
				if (yych <= 'Z') goto yy165;
				goto yy3;
			} else {
				if (yych == 'g') goto yy367;
				goto yy170;
			}
		} else {
			if (yych <= 't') {
				if (yych <= 'p') goto yy366;
				goto yy170;
			} else {
				if (yych <= 'u') goto yy365;
				if (yych <= 'z') goto yy170;
				goto yy3;
			}
		}
	}
yy37:
	YYDEBUG(37, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= 'F') {
			if (yych == ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'O') {
				if (yych <= 'G') goto yy355;
				goto yy165;
			} else {
				if (yych <= 'P') goto yy354;
				if (yych <= 'T') goto yy165;
				goto yy353;
			}
		}
	} else {
		if (yych <= 'o') {
			if (yych <= '`') {
				if (yych <= 'Z') goto yy165;
				goto yy3;
			} else {
				if (yych == 'g') goto yy355;
				goto yy165;
			}
		} else {
			if (yych <= 't') {
				if (yych <= 'p') goto yy354;
				goto yy165;
			} else {
				if (yych <= 'u') goto yy353;
				if (yych <= 'z') goto yy165;
				goto yy3;
			}
		}
	}
yy38:
	YYDEBUG(38, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'C') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'B') goto yy165;
			goto yy343;
		}
	} else {
		if (yych <= 'b') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy170;
		} else {
			if (yych <= 'c') goto yy348;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy39:
	YYDEBUG(39, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'C') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'B') goto yy165;
			goto yy343;
		}
	} else {
		if (yych <= 'b') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'c') goto yy343;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy40:
	YYDEBUG(40, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy165;
			goto yy216;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy170;
		} else {
			if (yych <= 'e') goto yy334;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy41:
	YYDEBUG(41, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy165;
			goto yy216;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'e') goto yy216;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy42:
	YYDEBUG(42, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy165;
			goto yy189;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy170;
		} else {
			if (yych <= 'e') goto yy203;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy43:
	YYDEBUG(43, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy165;
			goto yy189;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy165;
			if (yych <= '`') goto yy3;
			goto yy165;
		} else {
			if (yych <= 'e') goto yy189;
			if (yych <= 'z') goto yy165;
			goto yy3;
		}
	}
yy44:
	YYDEBUG(44, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
		goto yy165;
	} else {
		if (yych <= 'Z') {
			if (yych <= 'M') goto yy181;
			goto yy165;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy170;
			goto yy3;
		}
	}
yy45:
	YYDEBUG(45, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') goto yy12;
	if (yych <= 'Z') goto yy180;
	if (yych <= '`') goto yy12;
	if (yych <= 'z') goto yy180;
	goto yy12;
yy46:
	YYDEBUG(46, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Z') goto yy165;
		if (yych <= '`') goto yy3;
		if (yych <= 'z') goto yy170;
		goto yy3;
	}
yy47:
	YYDEBUG(47, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Z') goto yy165;
		if (yych <= '`') goto yy3;
		if (yych <= 'z') goto yy165;
		goto yy3;
	}
yy48:
	YYDEBUG(48, *YYCURSOR);
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 4) {
		goto yy57;
	}
	if (yych <= '/') goto yy49;
	if (yych <= '9') goto yy54;
yy49:
	YYDEBUG(49, *YYCURSOR);
#line 1757 'ext/date/lib/parse_date.re'
	{
		goto std;
	}
#line 2559 '<stdout>'
yy50:
	YYDEBUG(50, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy49;
yy51:
	YYDEBUG(51, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(52, *YYCURSOR);
#line 1762 'ext/date/lib/parse_date.re'
	{
		s->pos = cursor; s->line++;
		goto std;
	}
#line 2573 '<stdout>'
yy53:
	YYDEBUG(53, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy12;
yy54:
	YYDEBUG(54, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 12) YYFILL(12);
	yych = *YYCURSOR;
	YYDEBUG(55, *YYCURSOR);
	if (yybm[0+yych] & 2) {
		goto yy54;
	}
	if (yych <= 'X') {
		if (yych <= 'G') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy59;
				if (yych >= ' ') goto yy59;
			} else {
				if (yych <= 'D') {
					if (yych >= 'D') goto yy66;
				} else {
					if (yych == 'F') goto yy67;
				}
			}
		} else {
			if (yych <= 'S') {
				if (yych <= 'L') {
					if (yych <= 'H') goto yy65;
				} else {
					if (yych <= 'M') goto yy61;
					if (yych >= 'S') goto yy64;
				}
			} else {
				if (yych <= 'U') {
					if (yych <= 'T') goto yy70;
					goto yy63;
				} else {
					if (yych == 'W') goto yy69;
				}
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'f') {
				if (yych <= 'c') {
					if (yych <= 'Y') goto yy68;
				} else {
					if (yych <= 'd') goto yy66;
					if (yych >= 'f') goto yy67;
				}
			} else {
				if (yych <= 'h') {
					if (yych >= 'h') goto yy65;
				} else {
					if (yych == 'm') goto yy61;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 't') {
					if (yych <= 's') goto yy64;
					goto yy70;
				} else {
					if (yych <= 'u') goto yy63;
					if (yych >= 'w') goto yy69;
				}
			} else {
				if (yych <= 'y') {
					if (yych >= 'y') goto yy68;
				} else {
					if (yych == 0xC2) goto yy62;
				}
			}
		}
	}
yy56:
	YYDEBUG(56, *YYCURSOR);
	YYCURSOR = YYMARKER;
	if (yyaccept <= 16) {
		if (yyaccept <= 8) {
			if (yyaccept <= 4) {
				if (yyaccept <= 2) {
					if (yyaccept <= 1) {
						if (yyaccept == 0) {
							goto yy3;
						} else {
							goto yy12;
						}
					} else {
						goto yy49;
					}
				} else {
					if (yyaccept == 3) {
						goto yy74;
					} else {
						goto yy191;
					}
				}
			} else {
				if (yyaccept <= 6) {
					if (yyaccept == 5) {
						goto yy218;
					} else {
						goto yy232;
					}
				} else {
					if (yyaccept == 7) {
						goto yy246;
					} else {
						goto yy357;
					}
				}
			}
		} else {
			if (yyaccept <= 12) {
				if (yyaccept <= 10) {
					if (yyaccept == 9) {
						goto yy440;
					} else {
						goto yy455;
					}
				} else {
					if (yyaccept == 11) {
						goto yy576;
					} else {
						goto yy621;
					}
				}
			} else {
				if (yyaccept <= 14) {
					if (yyaccept == 13) {
						goto yy631;
					} else {
						goto yy728;
					}
				} else {
					if (yyaccept == 15) {
						goto yy748;
					} else {
						goto yy779;
					}
				}
			}
		}
	} else {
		if (yyaccept <= 25) {
			if (yyaccept <= 21) {
				if (yyaccept <= 19) {
					if (yyaccept <= 18) {
						if (yyaccept == 17) {
							goto yy786;
						} else {
							goto yy813;
						}
					} else {
						goto yy758;
					}
				} else {
					if (yyaccept == 20) {
						goto yy419;
					} else {
						goto yy938;
					}
				}
			} else {
				if (yyaccept <= 23) {
					if (yyaccept == 22) {
						goto yy807;
					} else {
						goto yy1032;
					}
				} else {
					if (yyaccept == 24) {
						goto yy1040;
					} else {
						goto yy1084;
					}
				}
			}
		} else {
			if (yyaccept <= 29) {
				if (yyaccept <= 27) {
					if (yyaccept == 26) {
						goto yy1108;
					} else {
						goto yy1284;
					}
				} else {
					if (yyaccept == 28) {
						goto yy1377;
					} else {
						goto yy1415;
					}
				}
			} else {
				if (yyaccept <= 31) {
					if (yyaccept == 30) {
						goto yy1418;
					} else {
						goto yy1498;
					}
				} else {
					if (yyaccept == 32) {
						goto yy1506;
					} else {
						goto yy1529;
					}
				}
			}
		}
	}
yy57:
	YYDEBUG(57, *YYCURSOR);
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	YYDEBUG(58, *YYCURSOR);
	if (yybm[0+yych] & 4) {
		goto yy57;
	}
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy54;
	goto yy56;
yy59:
	YYDEBUG(59, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 12) YYFILL(12);
	yych = *YYCURSOR;
yy60:
	YYDEBUG(60, *YYCURSOR);
	if (yych <= 'X') {
		if (yych <= 'G') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy59;
				if (yych <= 0x1F) goto yy56;
				goto yy59;
			} else {
				if (yych <= 'D') {
					if (yych <= 'C') goto yy56;
					goto yy66;
				} else {
					if (yych == 'F') goto yy67;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'S') {
				if (yych <= 'L') {
					if (yych <= 'H') goto yy65;
					goto yy56;
				} else {
					if (yych <= 'M') goto yy61;
					if (yych <= 'R') goto yy56;
					goto yy64;
				}
			} else {
				if (yych <= 'U') {
					if (yych <= 'T') goto yy70;
					goto yy63;
				} else {
					if (yych == 'W') goto yy69;
					goto yy56;
				}
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'f') {
				if (yych <= 'c') {
					if (yych <= 'Y') goto yy68;
					goto yy56;
				} else {
					if (yych <= 'd') goto yy66;
					if (yych <= 'e') goto yy56;
					goto yy67;
				}
			} else {
				if (yych <= 'h') {
					if (yych <= 'g') goto yy56;
					goto yy65;
				} else {
					if (yych != 'm') goto yy56;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 't') {
					if (yych <= 's') goto yy64;
					goto yy70;
				} else {
					if (yych <= 'u') goto yy63;
					if (yych <= 'v') goto yy56;
					goto yy69;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy56;
					goto yy68;
				} else {
					if (yych == 0xC2) goto yy62;
					goto yy56;
				}
			}
		}
	}
yy61:
	YYDEBUG(61, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= 'N') {
			if (yych == 'I') goto yy138;
			goto yy56;
		} else {
			if (yych <= 'O') goto yy137;
			if (yych <= 'R') goto yy56;
			goto yy139;
		}
	} else {
		if (yych <= 'n') {
			if (yych == 'i') goto yy138;
			goto yy56;
		} else {
			if (yych <= 'o') goto yy137;
			if (yych == 's') goto yy139;
			goto yy56;
		}
	}
yy62:
	YYDEBUG(62, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 0xB5) goto yy134;
	goto yy56;
yy63:
	YYDEBUG(63, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy132;
	if (yych == 's') goto yy132;
	goto yy56;
yy64:
	YYDEBUG(64, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= 'D') {
			if (yych == 'A') goto yy119;
			goto yy56;
		} else {
			if (yych <= 'E') goto yy120;
			if (yych <= 'T') goto yy56;
			goto yy118;
		}
	} else {
		if (yych <= 'd') {
			if (yych == 'a') goto yy119;
			goto yy56;
		} else {
			if (yych <= 'e') goto yy120;
			if (yych == 'u') goto yy118;
			goto yy56;
		}
	}
yy65:
	YYDEBUG(65, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy116;
	if (yych == 'o') goto yy116;
	goto yy56;
yy66:
	YYDEBUG(66, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy115;
	if (yych == 'a') goto yy115;
	goto yy56;
yy67:
	YYDEBUG(67, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych == 'O') goto yy100;
		if (yych <= 'Q') goto yy56;
		goto yy99;
	} else {
		if (yych <= 'o') {
			if (yych <= 'n') goto yy56;
			goto yy100;
		} else {
			if (yych == 'r') goto yy99;
			goto yy56;
		}
	}
yy68:
	YYDEBUG(68, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy96;
	if (yych == 'e') goto yy96;
	goto yy56;
yy69:
	YYDEBUG(69, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy84;
	if (yych == 'e') goto yy84;
	goto yy56;
yy70:
	YYDEBUG(70, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'H') goto yy71;
		if (yych <= 'T') goto yy56;
		goto yy72;
	} else {
		if (yych <= 'h') {
			if (yych <= 'g') goto yy56;
		} else {
			if (yych == 'u') goto yy72;
			goto yy56;
		}
	}
yy71:
	YYDEBUG(71, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'U') goto yy79;
	if (yych == 'u') goto yy79;
	goto yy56;
yy72:
	YYDEBUG(72, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy73;
	if (yych != 'e') goto yy56;
yy73:
	YYDEBUG(73, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'S') goto yy75;
	if (yych == 's') goto yy75;
yy74:
	YYDEBUG(74, *YYCURSOR);
#line 1741 'ext/date/lib/parse_date.re'
	{
		timelib_ull i;
		DEBUG_OUTPUT('relative');
		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();

		while(*ptr) {
			i = timelib_get_unsigned_nr((char **) &ptr, 24);
			timelib_eat_spaces((char **) &ptr);
			timelib_set_relative((char **) &ptr, i, 1, s);
		}
		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 3024 '<stdout>'
yy75:
	YYDEBUG(75, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy76;
	if (yych != 'd') goto yy56;
yy76:
	YYDEBUG(76, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy77;
	if (yych != 'a') goto yy56;
yy77:
	YYDEBUG(77, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy78;
	if (yych != 'y') goto yy56;
yy78:
	YYDEBUG(78, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy74;
yy79:
	YYDEBUG(79, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'R') goto yy80;
	if (yych != 'r') goto yy74;
yy80:
	YYDEBUG(80, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy81;
	if (yych != 's') goto yy56;
yy81:
	YYDEBUG(81, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy82;
	if (yych != 'd') goto yy56;
yy82:
	YYDEBUG(82, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy83;
	if (yych != 'a') goto yy56;
yy83:
	YYDEBUG(83, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy78;
	if (yych == 'y') goto yy78;
	goto yy56;
yy84:
	YYDEBUG(84, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= 'C') goto yy56;
		if (yych <= 'D') goto yy86;
	} else {
		if (yych <= 'c') goto yy56;
		if (yych <= 'd') goto yy86;
		if (yych >= 'f') goto yy56;
	}
	YYDEBUG(85, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'K') goto yy92;
	if (yych == 'k') goto yy92;
	goto yy56;
yy86:
	YYDEBUG(86, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'N') goto yy87;
	if (yych != 'n') goto yy74;
yy87:
	YYDEBUG(87, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy88;
	if (yych != 'e') goto yy56;
yy88:
	YYDEBUG(88, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy89;
	if (yych != 's') goto yy56;
yy89:
	YYDEBUG(89, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy90;
	if (yych != 'd') goto yy56;
yy90:
	YYDEBUG(90, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy91;
	if (yych != 'a') goto yy56;
yy91:
	YYDEBUG(91, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy78;
	if (yych == 'y') goto yy78;
	goto yy56;
yy92:
	YYDEBUG(92, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych == 'D') goto yy93;
		if (yych <= 'R') goto yy74;
		goto yy78;
	} else {
		if (yych <= 'd') {
			if (yych <= 'c') goto yy74;
		} else {
			if (yych == 's') goto yy78;
			goto yy74;
		}
	}
yy93:
	YYDEBUG(93, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy94;
	if (yych != 'a') goto yy56;
yy94:
	YYDEBUG(94, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy95;
	if (yych != 'y') goto yy56;
yy95:
	YYDEBUG(95, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy78;
	if (yych == 's') goto yy78;
	goto yy74;
yy96:
	YYDEBUG(96, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy97;
	if (yych != 'a') goto yy56;
yy97:
	YYDEBUG(97, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy98;
	if (yych != 'r') goto yy56;
yy98:
	YYDEBUG(98, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy78;
	if (yych == 's') goto yy78;
	goto yy74;
yy99:
	YYDEBUG(99, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy112;
	if (yych == 'i') goto yy112;
	goto yy56;
yy100:
	YYDEBUG(100, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy101;
	if (yych != 'r') goto yy56;
yy101:
	YYDEBUG(101, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy102;
	if (yych != 't') goto yy56;
yy102:
	YYDEBUG(102, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych == 'H') goto yy104;
		if (yych <= 'M') goto yy56;
	} else {
		if (yych <= 'h') {
			if (yych <= 'g') goto yy56;
			goto yy104;
		} else {
			if (yych != 'n') goto yy56;
		}
	}
	YYDEBUG(103, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy109;
	if (yych == 'i') goto yy109;
	goto yy56;
yy104:
	YYDEBUG(104, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy105;
	if (yych != 'n') goto yy56;
yy105:
	YYDEBUG(105, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy106;
	if (yych != 'i') goto yy56;
yy106:
	YYDEBUG(106, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy107;
	if (yych != 'g') goto yy56;
yy107:
	YYDEBUG(107, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy108;
	if (yych != 'h') goto yy56;
yy108:
	YYDEBUG(108, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy98;
	if (yych == 't') goto yy98;
	goto yy56;
yy109:
	YYDEBUG(109, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy110;
	if (yych != 'g') goto yy56;
yy110:
	YYDEBUG(110, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy111;
	if (yych != 'h') goto yy56;
yy111:
	YYDEBUG(111, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy98;
	if (yych == 't') goto yy98;
	goto yy56;
yy112:
	YYDEBUG(112, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'D') goto yy113;
	if (yych != 'd') goto yy74;
yy113:
	YYDEBUG(113, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy114;
	if (yych != 'a') goto yy56;
yy114:
	YYDEBUG(114, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy78;
	if (yych == 'y') goto yy78;
	goto yy56;
yy115:
	YYDEBUG(115, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy98;
	if (yych == 'y') goto yy98;
	goto yy56;
yy116:
	YYDEBUG(116, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'U') goto yy117;
	if (yych != 'u') goto yy56;
yy117:
	YYDEBUG(117, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy98;
	if (yych == 'r') goto yy98;
	goto yy56;
yy118:
	YYDEBUG(118, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy129;
	if (yych == 'n') goto yy129;
	goto yy56;
yy119:
	YYDEBUG(119, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy124;
	if (yych == 't') goto yy124;
	goto yy56;
yy120:
	YYDEBUG(120, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy121;
	if (yych != 'c') goto yy56;
yy121:
	YYDEBUG(121, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych == 'O') goto yy122;
		if (yych <= 'R') goto yy74;
		goto yy78;
	} else {
		if (yych <= 'o') {
			if (yych <= 'n') goto yy74;
		} else {
			if (yych == 's') goto yy78;
			goto yy74;
		}
	}
yy122:
	YYDEBUG(122, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy123;
	if (yych != 'n') goto yy56;
yy123:
	YYDEBUG(123, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy98;
	if (yych == 'd') goto yy98;
	goto yy56;
yy124:
	YYDEBUG(124, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'U') goto yy125;
	if (yych != 'u') goto yy74;
yy125:
	YYDEBUG(125, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy126;
	if (yych != 'r') goto yy56;
yy126:
	YYDEBUG(126, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy127;
	if (yych != 'd') goto yy56;
yy127:
	YYDEBUG(127, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy128;
	if (yych != 'a') goto yy56;
yy128:
	YYDEBUG(128, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy78;
	if (yych == 'y') goto yy78;
	goto yy56;
yy129:
	YYDEBUG(129, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'D') goto yy130;
	if (yych != 'd') goto yy74;
yy130:
	YYDEBUG(130, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy131;
	if (yych != 'a') goto yy56;
yy131:
	YYDEBUG(131, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy78;
	if (yych == 'y') goto yy78;
	goto yy56;
yy132:
	YYDEBUG(132, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy133;
	if (yych != 'e') goto yy56;
yy133:
	YYDEBUG(133, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy98;
	if (yych == 'c') goto yy98;
	goto yy56;
yy134:
	YYDEBUG(134, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy135;
	if (yych != 's') goto yy56;
yy135:
	YYDEBUG(135, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'E') goto yy136;
	if (yych != 'e') goto yy74;
yy136:
	YYDEBUG(136, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy98;
	if (yych == 'c') goto yy98;
	goto yy56;
yy137:
	YYDEBUG(137, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy160;
	if (yych == 'n') goto yy160;
	goto yy56;
yy138:
	YYDEBUG(138, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= 'K') {
			if (yych == 'C') goto yy142;
			goto yy56;
		} else {
			if (yych <= 'L') goto yy141;
			if (yych <= 'M') goto yy56;
			goto yy143;
		}
	} else {
		if (yych <= 'k') {
			if (yych == 'c') goto yy142;
			goto yy56;
		} else {
			if (yych <= 'l') goto yy141;
			if (yych == 'n') goto yy143;
			goto yy56;
		}
	}
yy139:
	YYDEBUG(139, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'E') goto yy140;
	if (yych != 'e') goto yy74;
yy140:
	YYDEBUG(140, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy98;
	if (yych == 'c') goto yy98;
	goto yy56;
yy141:
	YYDEBUG(141, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'L') goto yy153;
	if (yych == 'l') goto yy153;
	goto yy56;
yy142:
	YYDEBUG(142, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy146;
	if (yych == 'r') goto yy146;
	goto yy56;
yy143:
	YYDEBUG(143, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'U') {
		if (yych == 'S') goto yy78;
		if (yych <= 'T') goto yy74;
	} else {
		if (yych <= 's') {
			if (yych <= 'r') goto yy74;
			goto yy78;
		} else {
			if (yych != 'u') goto yy74;
		}
	}
	YYDEBUG(144, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy145;
	if (yych != 't') goto yy56;
yy145:
	YYDEBUG(145, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy98;
	if (yych == 'e') goto yy98;
	goto yy56;
yy146:
	YYDEBUG(146, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy147;
	if (yych != 'o') goto yy56;
yy147:
	YYDEBUG(147, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy148;
	if (yych != 's') goto yy56;
yy148:
	YYDEBUG(148, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy149;
	if (yych != 'e') goto yy56;
yy149:
	YYDEBUG(149, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy150;
	if (yych != 'c') goto yy56;
yy150:
	YYDEBUG(150, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy151;
	if (yych != 'o') goto yy56;
yy151:
	YYDEBUG(151, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy152;
	if (yych != 'n') goto yy56;
yy152:
	YYDEBUG(152, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy98;
	if (yych == 'd') goto yy98;
	goto yy56;
yy153:
	YYDEBUG(153, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy154;
	if (yych != 'i') goto yy56;
yy154:
	YYDEBUG(154, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy155;
	if (yych != 's') goto yy56;
yy155:
	YYDEBUG(155, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy156;
	if (yych != 'e') goto yy56;
yy156:
	YYDEBUG(156, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy157;
	if (yych != 'c') goto yy56;
yy157:
	YYDEBUG(157, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy158;
	if (yych != 'o') goto yy56;
yy158:
	YYDEBUG(158, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy159;
	if (yych != 'n') goto yy56;
yy159:
	YYDEBUG(159, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy98;
	if (yych == 'd') goto yy98;
	goto yy56;
yy160:
	YYDEBUG(160, *YYCURSOR);
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych == 'D') goto yy161;
		if (yych <= 'S') goto yy74;
		goto yy162;
	} else {
		if (yych <= 'd') {
			if (yych <= 'c') goto yy74;
		} else {
			if (yych == 't') goto yy162;
			goto yy74;
		}
	}
yy161:
	YYDEBUG(161, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy163;
	if (yych == 'a') goto yy163;
	goto yy56;
yy162:
	YYDEBUG(162, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy98;
	if (yych == 'h') goto yy98;
	goto yy56;
yy163:
	YYDEBUG(163, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy78;
	if (yych == 'y') goto yy78;
	goto yy56;
yy164:
	YYDEBUG(164, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy3;
yy165:
	YYDEBUG(165, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Z') goto yy166;
		if (yych <= '`') goto yy3;
		if (yych >= '{') goto yy3;
	}
yy166:
	YYDEBUG(166, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Z') goto yy167;
		if (yych <= '`') goto yy3;
		if (yych >= '{') goto yy3;
	}
yy167:
	YYDEBUG(167, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Z') goto yy168;
		if (yych <= '`') goto yy3;
		if (yych >= '{') goto yy3;
	}
yy168:
	YYDEBUG(168, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Z') goto yy169;
		if (yych <= '`') goto yy3;
		if (yych >= '{') goto yy3;
	}
yy169:
	YYDEBUG(169, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == ')') goto yy164;
	goto yy3;
yy170:
	YYDEBUG(170, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			goto yy172;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy3;
			if (yych <= 'Z') goto yy166;
			goto yy3;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy3;
			if (yych >= '{') goto yy3;
		}
	}
yy171:
	YYDEBUG(171, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy3;
			if (yych <= 'Z') goto yy167;
			goto yy3;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy175;
			goto yy3;
		}
	}
yy172:
	YYDEBUG(172, *YYCURSOR);
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 8) {
		goto yy173;
	}
	goto yy56;
yy173:
	YYDEBUG(173, *YYCURSOR);
	yyaccept = 0;
	YYMARKER = ++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	YYDEBUG(174, *YYCURSOR);
	if (yybm[0+yych] & 8) {
		goto yy173;
	}
	if (yych <= '.') {
		if (yych == '-') goto yy172;
		goto yy3;
	} else {
		if (yych <= '/') goto yy172;
		if (yych == '_') goto yy172;
		goto yy3;
	}
yy175:
	YYDEBUG(175, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			goto yy172;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy3;
			if (yych <= 'Z') goto yy168;
			goto yy3;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy3;
			if (yych >= '{') goto yy3;
		}
	}
yy176:
	YYDEBUG(176, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			goto yy172;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy3;
			if (yych <= 'Z') goto yy169;
			goto yy3;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy3;
			if (yych >= '{') goto yy3;
		}
	}
yy177:
	YYDEBUG(177, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= '-') {
		if (yych == ')') goto yy164;
		if (yych <= ',') goto yy3;
		goto yy172;
	} else {
		if (yych <= '/') {
			if (yych <= '.') goto yy3;
			goto yy172;
		} else {
			if (yych == '_') goto yy172;
			goto yy3;
		}
	}
yy178:
	YYDEBUG(178, *YYCURSOR);
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy179:
	YYDEBUG(179, *YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= '.') {
		if (yych == '-') goto yy172;
		goto yy56;
	} else {
		if (yych <= '/') goto yy172;
		if (yych == '_') goto yy172;
		goto yy56;
	}
yy180:
	YYDEBUG(180, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Z') goto yy165;
		if (yych <= '`') goto yy3;
		if (yych <= 'z') goto yy165;
		goto yy3;
	}
yy181:
	YYDEBUG(181, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
		goto yy166;
	} else {
		if (yych <= 'Z') {
			if (yych >= 'U') goto yy166;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
	YYDEBUG(182, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych != '+') goto yy3;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '-') goto yy183;
			if (yych <= '@') goto yy3;
			goto yy167;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy183:
	YYDEBUG(183, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy184;
	if (yych <= '2') goto yy185;
	if (yych <= '9') goto yy186;
	goto yy56;
yy184:
	YYDEBUG(184, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy3;
	if (yych <= '9') goto yy186;
	if (yych <= ':') goto yy187;
	goto yy3;
yy185:
	YYDEBUG(185, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '5') {
		if (yych <= '/') goto yy3;
		if (yych >= '5') goto yy188;
	} else {
		if (yych <= '9') goto yy164;
		if (yych <= ':') goto yy187;
		goto yy3;
	}
yy186:
	YYDEBUG(186, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy3;
	if (yych <= '5') goto yy188;
	if (yych <= '9') goto yy164;
	if (yych >= ';') goto yy3;
yy187:
	YYDEBUG(187, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy3;
	if (yych <= '5') goto yy188;
	if (yych <= '9') goto yy164;
	goto yy3;
yy188:
	YYDEBUG(188, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy3;
	if (yych <= '9') goto yy164;
	goto yy3;
yy189:
	YYDEBUG(189, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych <= 'C') goto yy166;
			if (yych >= 'E') goto yy192;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'd') goto yy190;
			if (yych <= 'e') goto yy192;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy190:
	YYDEBUG(190, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= 'N') {
		if (yych <= ')') {
			if (yych >= ')') goto yy164;
		} else {
			if (yych <= '@') goto yy191;
			if (yych <= 'M') goto yy167;
			goto yy198;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy167;
			if (yych >= 'a') goto yy167;
		} else {
			if (yych <= 'n') goto yy198;
			if (yych <= 'z') goto yy167;
		}
	}
yy191:
	YYDEBUG(191, *YYCURSOR);
#line 1604 'ext/date/lib/parse_date.re'
	{
		const timelib_relunit* relunit;
		DEBUG_OUTPUT('daytext');
		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();
		TIMELIB_HAVE_WEEKDAY_RELATIVE();
		TIMELIB_UNHAVE_TIME();
		relunit = timelib_lookup_relunit((char**) &ptr);
		s->time->relative.weekday = relunit->multiplier;
		if (s->time->relative.weekday_behavior != 2) {
			s->time->relative.weekday_behavior = 1;
		}

		TIMELIB_DEINIT;
		return TIMELIB_WEEKDAY;
	}
#line 3944 '<stdout>'
yy192:
	YYDEBUG(192, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'K') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'J') goto yy167;
		}
	} else {
		if (yych <= 'j') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'k') goto yy193;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy193:
	YYDEBUG(193, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'C') goto yy168;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'd') goto yy194;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy194:
	YYDEBUG(194, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy169;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy195;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy195:
	YYDEBUG(195, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'X') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Y') goto yy196;
		if (yych != 'y') goto yy3;
	}
yy196:
	YYDEBUG(196, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy197;
	if (yych != 's') goto yy191;
yy197:
	YYDEBUG(197, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy191;
yy198:
	YYDEBUG(198, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy168;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'e') goto yy199;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy199:
	YYDEBUG(199, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'R') goto yy169;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 's') goto yy200;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy200:
	YYDEBUG(200, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'D') goto yy201;
		if (yych != 'd') goto yy3;
	}
yy201:
	YYDEBUG(201, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy202;
	if (yych != 'a') goto yy56;
yy202:
	YYDEBUG(202, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy197;
	if (yych == 'y') goto yy197;
	goto yy56;
yy203:
	YYDEBUG(203, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych <= '/') {
				if (yych <= '.') goto yy3;
				goto yy172;
			} else {
				if (yych <= '@') goto yy3;
				if (yych <= 'C') goto yy166;
				goto yy190;
			}
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') {
				if (yych <= 'E') goto yy192;
				goto yy166;
			} else {
				if (yych == '_') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 'd') {
				if (yych <= 'c') goto yy171;
			} else {
				if (yych <= 'e') goto yy205;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
	YYDEBUG(204, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy191;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy191;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy198;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy191;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy191;
				goto yy175;
			} else {
				if (yych <= 'n') goto yy211;
				if (yych <= 'z') goto yy175;
				goto yy191;
			}
		}
	}
yy205:
	YYDEBUG(205, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'J') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'K') goto yy193;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'j') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'k') goto yy206;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy206:
	YYDEBUG(206, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy194;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'd') goto yy207;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy207:
	YYDEBUG(207, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy195;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy208;
			if (yych <= 'z') goto yy177;
			goto yy3;
		}
	}
yy208:
	YYDEBUG(208, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Y') goto yy196;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'y') goto yy209;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy209:
	YYDEBUG(209, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '.') {
			if (yych == '-') goto yy172;
			goto yy191;
		} else {
			if (yych <= '/') goto yy172;
			if (yych <= 'R') goto yy191;
			goto yy197;
		}
	} else {
		if (yych <= '`') {
			if (yych == '_') goto yy172;
			goto yy191;
		} else {
			if (yych == 's') goto yy210;
			if (yych <= 'z') goto yy178;
			goto yy191;
		}
	}
yy210:
	YYDEBUG(210, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= '.') {
		if (yych == '-') goto yy172;
		goto yy191;
	} else {
		if (yych <= '/') goto yy172;
		if (yych == '_') goto yy172;
		goto yy191;
	}
yy211:
	YYDEBUG(211, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy199;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'e') goto yy212;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy212:
	YYDEBUG(212, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'S') goto yy200;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'r') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 's') goto yy213;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy213:
	YYDEBUG(213, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'D') goto yy201;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'd') goto yy214;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy214:
	YYDEBUG(214, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy202;
	if (yych != 'a') goto yy179;
	YYDEBUG(215, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy197;
	if (yych == 'y') goto yy210;
	goto yy179;
yy216:
	YYDEBUG(216, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'C') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'B') goto yy166;
		}
	} else {
		if (yych <= 'b') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'c') goto yy217;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy217:
	YYDEBUG(217, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych >= '\t') goto yy220;
			} else {
				if (yych == ' ') goto yy220;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
			} else {
				if (yych == 'E') goto yy225;
				goto yy167;
			}
		} else {
			if (yych <= 'd') {
				if (yych >= 'a') goto yy167;
			} else {
				if (yych <= 'e') goto yy225;
				if (yych <= 'z') goto yy167;
			}
		}
	}
yy218:
	YYDEBUG(218, *YYCURSOR);
#line 1663 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('monthtext');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->m = timelib_lookup_month((char **) &ptr);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_TEXT;
	}
#line 4473 '<stdout>'
yy219:
	YYDEBUG(219, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 23) YYFILL(23);
	yych = *YYCURSOR;
yy220:
	YYDEBUG(220, *YYCURSOR);
	if (yybm[0+yych] & 32) {
		goto yy219;
	}
	if (yych <= '/') goto yy56;
	if (yych <= '2') goto yy222;
	if (yych <= '3') goto yy223;
	if (yych <= '9') goto yy224;
	goto yy56;
yy221:
	YYDEBUG(221, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy220;
	if (yych <= '0') goto yy324;
	if (yych <= '2') goto yy325;
	if (yych <= '3') goto yy326;
	goto yy220;
yy222:
	YYDEBUG(222, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy238;
				goto yy56;
			} else {
				if (yych <= '\t') goto yy236;
				if (yych <= 0x1F) goto yy56;
				goto yy236;
			}
		} else {
			if (yych <= '-') {
				if (yych == ',') goto yy236;
				goto yy56;
			} else {
				if (yych <= '.') goto yy236;
				if (yych <= '/') goto yy56;
				goto yy323;
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'd') {
				if (yych <= 'c') goto yy56;
				goto yy236;
			} else {
				if (yych == 'h') goto yy236;
				goto yy56;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'n') goto yy233;
				if (yych <= 'q') goto yy56;
				goto yy234;
			} else {
				if (yych <= 's') goto yy231;
				if (yych <= 't') goto yy235;
				goto yy56;
			}
		}
	}
yy223:
	YYDEBUG(223, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '1') {
		if (yych <= ' ') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy238;
				goto yy56;
			} else {
				if (yych <= '\t') goto yy236;
				if (yych <= 0x1F) goto yy56;
				goto yy236;
			}
		} else {
			if (yych <= '-') {
				if (yych == ',') goto yy236;
				goto yy56;
			} else {
				if (yych <= '.') goto yy236;
				if (yych <= '/') goto yy56;
				goto yy323;
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'd') {
				if (yych <= '9') goto yy230;
				if (yych <= 'c') goto yy56;
				goto yy236;
			} else {
				if (yych == 'h') goto yy236;
				goto yy56;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'n') goto yy233;
				if (yych <= 'q') goto yy56;
				goto yy234;
			} else {
				if (yych <= 's') goto yy231;
				if (yych <= 't') goto yy235;
				goto yy56;
			}
		}
	}
yy224:
	YYDEBUG(224, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy238;
				goto yy56;
			} else {
				if (yych <= '\t') goto yy236;
				if (yych <= 0x1F) goto yy56;
				goto yy236;
			}
		} else {
			if (yych <= '-') {
				if (yych == ',') goto yy236;
				goto yy56;
			} else {
				if (yych <= '.') goto yy236;
				if (yych <= '/') goto yy56;
				goto yy230;
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'd') {
				if (yych <= 'c') goto yy56;
				goto yy236;
			} else {
				if (yych == 'h') goto yy236;
				goto yy56;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'n') goto yy233;
				if (yych <= 'q') goto yy56;
				goto yy234;
			} else {
				if (yych <= 's') goto yy231;
				if (yych <= 't') goto yy235;
				goto yy56;
			}
		}
	}
yy225:
	YYDEBUG(225, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'M') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'L') goto yy168;
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'm') goto yy226;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy226:
	YYDEBUG(226, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'B') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'A') goto yy169;
		}
	} else {
		if (yych <= 'a') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'b') goto yy227;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy227:
	YYDEBUG(227, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'E') goto yy228;
		if (yych != 'e') goto yy3;
	}
yy228:
	YYDEBUG(228, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy229;
	if (yych != 'r') goto yy56;
yy229:
	YYDEBUG(229, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy220;
		if (yych <= 0x1F) goto yy218;
		goto yy220;
	} else {
		if (yych <= '.') {
			if (yych <= ',') goto yy218;
			goto yy220;
		} else {
			if (yych <= '/') goto yy218;
			if (yych <= '9') goto yy220;
			goto yy218;
		}
	}
yy230:
	YYDEBUG(230, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy320;
	goto yy56;
yy231:
	YYDEBUG(231, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 't') goto yy319;
	goto yy237;
yy232:
	YYDEBUG(232, *YYCURSOR);
#line 1409 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('datetextual | datenoyear');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_TEXT;
	}
#line 4735 '<stdout>'
yy233:
	YYDEBUG(233, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'd') goto yy319;
	goto yy237;
yy234:
	YYDEBUG(234, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'd') goto yy319;
	goto yy237;
yy235:
	YYDEBUG(235, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'h') goto yy319;
	goto yy237;
yy236:
	YYDEBUG(236, *YYCURSOR);
	yyaccept = 6;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 18) YYFILL(18);
	yych = *YYCURSOR;
yy237:
	YYDEBUG(237, *YYCURSOR);
	if (yybm[0+yych] & 64) {
		goto yy236;
	}
	if (yych <= '2') {
		if (yych <= '/') goto yy232;
		if (yych <= '0') goto yy310;
		if (yych <= '1') goto yy311;
		goto yy312;
	} else {
		if (yych <= '9') goto yy313;
		if (yych == 'T') goto yy239;
		goto yy232;
	}
yy238:
	YYDEBUG(238, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '0') {
			if (yych <= '/') goto yy232;
			goto yy240;
		} else {
			if (yych <= '1') goto yy241;
			if (yych <= '2') goto yy242;
			goto yy243;
		}
	} else {
		if (yych <= 'T') {
			if (yych <= 'S') goto yy232;
		} else {
			if (yych != 't') goto yy232;
		}
	}
yy239:
	YYDEBUG(239, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy308;
	if (yych <= '2') goto yy309;
	if (yych <= '9') goto yy298;
	goto yy56;
yy240:
	YYDEBUG(240, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') {
		if (yych == '.') goto yy299;
		goto yy56;
	} else {
		if (yych <= '0') goto yy298;
		if (yych <= '9') goto yy243;
		if (yych <= ':') goto yy299;
		goto yy56;
	}
yy241:
	YYDEBUG(241, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') {
		if (yych == '.') goto yy244;
		goto yy56;
	} else {
		if (yych <= '2') goto yy243;
		if (yych <= '9') goto yy298;
		if (yych <= ':') goto yy244;
		goto yy56;
	}
yy242:
	YYDEBUG(242, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') {
		if (yych == '.') goto yy244;
		goto yy56;
	} else {
		if (yych <= '4') goto yy298;
		if (yych == ':') goto yy244;
		goto yy56;
	}
yy243:
	YYDEBUG(243, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '.') goto yy244;
	if (yych != ':') goto yy56;
yy244:
	YYDEBUG(244, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy245;
	if (yych <= '9') goto yy247;
	goto yy56;
yy245:
	YYDEBUG(245, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy248;
	} else {
		if (yych <= '9') goto yy291;
		if (yych <= ':') goto yy248;
	}
yy246:
	YYDEBUG(246, *YYCURSOR);
#line 1711 'ext/date/lib/parse_date.re'
	{
		int tz_not_found;
		DEBUG_OUTPUT('dateshortwithtimeshort | dateshortwithtimelong | dateshortwithtimelongtz');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->d = timelib_get_nr((char **) &ptr, 2);

		TIMELIB_HAVE_TIME();
		s->time->h = timelib_get_nr((char **) &ptr, 2);
		s->time->i = timelib_get_nr((char **) &ptr, 2);
		if (*ptr == ':') {
			s->time->s = timelib_get_nr((char **) &ptr, 2);

			if (*ptr == '.') {
				s->time->f = timelib_get_frac_nr((char **) &ptr, 8);
			}
		}

		if (*ptr != '\0') {
			s->time->z = timelib_parse_zone((char **) &ptr, &s->time->dst, s->time, &tz_not_found, s->tzdb, tz_get_wrapper);
			if (tz_not_found) {
				add_error(s, 'The timezone could not be found in the database');
			}
		}
		TIMELIB_DEINIT;
		return TIMELIB_SHORTDATE_WITH_TIME;
	}
#line 4891 '<stdout>'
yy247:
	YYDEBUG(247, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy248;
	if (yych != ':') goto yy246;
yy248:
	YYDEBUG(248, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy249;
	if (yych <= '6') goto yy250;
	if (yych <= '9') goto yy251;
	goto yy56;
yy249:
	YYDEBUG(249, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy246;
	if (yych <= '9') goto yy252;
	goto yy246;
yy250:
	YYDEBUG(250, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '0') goto yy252;
	goto yy246;
yy251:
	YYDEBUG(251, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy246;
yy252:
	YYDEBUG(252, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '*') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy254;
			goto yy246;
		} else {
			if (yych <= ' ') goto yy254;
			if (yych == '(') goto yy254;
			goto yy246;
		}
	} else {
		if (yych <= '@') {
			if (yych == ',') goto yy246;
			if (yych <= '-') goto yy254;
			goto yy246;
		} else {
			if (yych <= 'Z') goto yy254;
			if (yych <= '`') goto yy246;
			if (yych <= 'z') goto yy254;
			goto yy246;
		}
	}
yy253:
	YYDEBUG(253, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = *YYCURSOR;
yy254:
	YYDEBUG(254, *YYCURSOR);
	if (yych <= '@') {
		if (yych <= '\'') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy56;
				goto yy253;
			} else {
				if (yych == ' ') goto yy253;
				goto yy56;
			}
		} else {
			if (yych <= '+') {
				if (yych <= '(') goto yy257;
				if (yych <= '*') goto yy56;
				goto yy256;
			} else {
				if (yych == '-') goto yy256;
				goto yy56;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= 'G') {
				if (yych <= 'A') goto yy258;
				if (yych <= 'F') goto yy259;
			} else {
				if (yych == 'P') goto yy258;
				goto yy259;
			}
		} else {
			if (yych <= 'o') {
				if (yych <= '`') goto yy56;
				if (yych <= 'a') goto yy260;
				goto yy261;
			} else {
				if (yych <= 'p') goto yy260;
				if (yych <= 'z') goto yy261;
				goto yy56;
			}
		}
	}
yy255:
	YYDEBUG(255, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych == ')') goto yy251;
		if (yych <= '@') goto yy246;
		goto yy262;
	} else {
		if (yych <= 'Z') {
			if (yych <= 'M') goto yy289;
			goto yy262;
		} else {
			if (yych <= '`') goto yy246;
			if (yych <= 'z') goto yy273;
			goto yy246;
		}
	}
yy256:
	YYDEBUG(256, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy284;
	if (yych <= '2') goto yy285;
	if (yych <= '9') goto yy286;
	goto yy56;
yy257:
	YYDEBUG(257, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') goto yy56;
	if (yych <= 'Z') goto yy261;
	if (yych <= '`') goto yy56;
	if (yych <= 'z') goto yy261;
	goto yy56;
yy258:
	YYDEBUG(258, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'L') {
		if (yych <= '-') {
			if (yych == ')') goto yy251;
			goto yy246;
		} else {
			if (yych <= '.') goto yy267;
			if (yych <= '@') goto yy246;
			goto yy262;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'M') goto yy268;
			if (yych <= 'Z') goto yy262;
			goto yy246;
		} else {
			if (yych == 'm') goto yy283;
			if (yych <= 'z') goto yy273;
			goto yy246;
		}
	}
yy259:
	YYDEBUG(259, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy251;
		goto yy246;
	} else {
		if (yych <= 'Z') goto yy262;
		if (yych <= '`') goto yy246;
		if (yych <= 'z') goto yy273;
		goto yy246;
	}
yy260:
	YYDEBUG(260, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'L') {
		if (yych <= '-') {
			if (yych == ')') goto yy251;
			goto yy246;
		} else {
			if (yych <= '.') goto yy267;
			if (yych <= '@') goto yy246;
			goto yy262;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'M') goto yy268;
			if (yych <= 'Z') goto yy262;
			goto yy246;
		} else {
			if (yych == 'm') goto yy268;
			if (yych <= 'z') goto yy262;
			goto yy246;
		}
	}
yy261:
	YYDEBUG(261, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy251;
		goto yy246;
	} else {
		if (yych <= 'Z') goto yy262;
		if (yych <= '`') goto yy246;
		if (yych >= '{') goto yy246;
	}
yy262:
	YYDEBUG(262, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy251;
		goto yy246;
	} else {
		if (yych <= 'Z') goto yy263;
		if (yych <= '`') goto yy246;
		if (yych >= '{') goto yy246;
	}
yy263:
	YYDEBUG(263, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy251;
		goto yy246;
	} else {
		if (yych <= 'Z') goto yy264;
		if (yych <= '`') goto yy246;
		if (yych >= '{') goto yy246;
	}
yy264:
	YYDEBUG(264, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy251;
		goto yy246;
	} else {
		if (yych <= 'Z') goto yy265;
		if (yych <= '`') goto yy246;
		if (yych >= '{') goto yy246;
	}
yy265:
	YYDEBUG(265, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych == ')') goto yy251;
		goto yy246;
	} else {
		if (yych <= 'Z') goto yy266;
		if (yych <= '`') goto yy246;
		if (yych >= '{') goto yy246;
	}
yy266:
	YYDEBUG(266, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == ')') goto yy251;
	goto yy246;
yy267:
	YYDEBUG(267, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy272;
	if (yych == 'm') goto yy272;
	goto yy56;
yy268:
	YYDEBUG(268, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ')') {
		if (yych <= '\t') {
			if (yych <= 0x00) goto yy270;
			if (yych <= 0x08) goto yy246;
			goto yy270;
		} else {
			if (yych == ' ') goto yy270;
			if (yych <= '(') goto yy246;
			goto yy251;
		}
	} else {
		if (yych <= '@') {
			if (yych != '.') goto yy246;
		} else {
			if (yych <= 'Z') goto yy263;
			if (yych <= '`') goto yy246;
			if (yych <= 'z') goto yy263;
			goto yy246;
		}
	}
yy269:
	YYDEBUG(269, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '\t') {
		if (yych <= 0x00) goto yy270;
		if (yych <= 0x08) goto yy56;
	} else {
		if (yych != ' ') goto yy56;
	}
yy270:
	YYDEBUG(270, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(271, *YYCURSOR);
#line 1687 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('dateshortwithtimeshort12 | dateshortwithtimelong12');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->d = timelib_get_nr((char **) &ptr, 2);

		TIMELIB_HAVE_TIME();
		s->time->h = timelib_get_nr((char **) &ptr, 2);
		s->time->i = timelib_get_nr((char **) &ptr, 2);
		if (*ptr == ':' || *ptr == '.') {
			s->time->s = timelib_get_nr((char **) &ptr, 2);

			if (*ptr == '.') {
				s->time->f = timelib_get_frac_nr((char **) &ptr, 8);
			}
		}

		s->time->h += timelib_meridian((char **) &ptr, s->time->h);
		TIMELIB_DEINIT;
		return TIMELIB_SHORTDATE_WITH_TIME;
	}
#line 5212 '<stdout>'
yy272:
	YYDEBUG(272, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych <= 0x00) goto yy270;
		if (yych == '\t') goto yy270;
		goto yy56;
	} else {
		if (yych <= ' ') goto yy270;
		if (yych == '.') goto yy269;
		goto yy56;
	}
yy273:
	YYDEBUG(273, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy251;
			goto yy246;
		} else {
			if (yych == '.') goto yy246;
			goto yy275;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy246;
			if (yych <= 'Z') goto yy263;
			goto yy246;
		} else {
			if (yych <= '_') goto yy275;
			if (yych <= '`') goto yy246;
			if (yych >= '{') goto yy246;
		}
	}
yy274:
	YYDEBUG(274, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy251;
			goto yy246;
		} else {
			if (yych == '.') goto yy246;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy246;
			if (yych <= 'Z') goto yy264;
			goto yy246;
		} else {
			if (yych <= '_') goto yy275;
			if (yych <= '`') goto yy246;
			if (yych <= 'z') goto yy278;
			goto yy246;
		}
	}
yy275:
	YYDEBUG(275, *YYCURSOR);
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '@') goto yy56;
	if (yych <= 'Z') goto yy276;
	if (yych <= '`') goto yy56;
	if (yych >= '{') goto yy56;
yy276:
	YYDEBUG(276, *YYCURSOR);
	yyaccept = 7;
	YYMARKER = ++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	YYDEBUG(277, *YYCURSOR);
	if (yych <= '@') {
		if (yych <= '-') {
			if (yych <= ',') goto yy246;
			goto yy275;
		} else {
			if (yych == '/') goto yy275;
			goto yy246;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Z') goto yy276;
			if (yych <= '^') goto yy246;
			goto yy275;
		} else {
			if (yych <= '`') goto yy246;
			if (yych <= 'z') goto yy276;
			goto yy246;
		}
	}
yy278:
	YYDEBUG(278, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy251;
			goto yy246;
		} else {
			if (yych == '.') goto yy246;
			goto yy275;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy246;
			if (yych <= 'Z') goto yy265;
			goto yy246;
		} else {
			if (yych <= '_') goto yy275;
			if (yych <= '`') goto yy246;
			if (yych >= '{') goto yy246;
		}
	}
	YYDEBUG(279, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy251;
			goto yy246;
		} else {
			if (yych == '.') goto yy246;
			goto yy275;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy246;
			if (yych <= 'Z') goto yy266;
			goto yy246;
		} else {
			if (yych <= '_') goto yy275;
			if (yych <= '`') goto yy246;
			if (yych >= '{') goto yy246;
		}
	}
	YYDEBUG(280, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ')') {
			if (yych <= '(') goto yy246;
			goto yy251;
		} else {
			if (yych == '-') goto yy275;
			goto yy246;
		}
	} else {
		if (yych <= '_') {
			if (yych <= '/') goto yy275;
			if (yych <= '^') goto yy246;
			goto yy275;
		} else {
			if (yych <= '`') goto yy246;
			if (yych >= '{') goto yy246;
		}
	}
yy281:
	YYDEBUG(281, *YYCURSOR);
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	YYDEBUG(282, *YYCURSOR);
	if (yych <= '/') {
		if (yych == '-') goto yy275;
		if (yych <= '.') goto yy56;
		goto yy275;
	} else {
		if (yych <= '_') {
			if (yych <= '^') goto yy56;
			goto yy275;
		} else {
			if (yych <= '`') goto yy56;
			if (yych <= 'z') goto yy281;
			goto yy56;
		}
	}
yy283:
	YYDEBUG(283, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '-') {
		if (yych <= 0x1F) {
			if (yych <= 0x00) goto yy270;
			if (yych == '\t') goto yy270;
			goto yy246;
		} else {
			if (yych <= '(') {
				if (yych <= ' ') goto yy270;
				goto yy246;
			} else {
				if (yych <= ')') goto yy251;
				if (yych <= ',') goto yy246;
				goto yy275;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '.') goto yy269;
			if (yych <= '/') goto yy275;
			if (yych <= '@') goto yy246;
			goto yy263;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy246;
				goto yy275;
			} else {
				if (yych <= '`') goto yy246;
				if (yych <= 'z') goto yy274;
				goto yy246;
			}
		}
	}
yy284:
	YYDEBUG(284, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy246;
	if (yych <= '9') goto yy286;
	if (yych <= ':') goto yy287;
	goto yy246;
yy285:
	YYDEBUG(285, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '5') {
		if (yych <= '/') goto yy246;
		if (yych >= '5') goto yy288;
	} else {
		if (yych <= '9') goto yy251;
		if (yych <= ':') goto yy287;
		goto yy246;
	}
yy286:
	YYDEBUG(286, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy246;
	if (yych <= '5') goto yy288;
	if (yych <= '9') goto yy251;
	if (yych >= ';') goto yy246;
yy287:
	YYDEBUG(287, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy246;
	if (yych <= '5') goto yy288;
	if (yych <= '9') goto yy251;
	goto yy246;
yy288:
	YYDEBUG(288, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy246;
	if (yych <= '9') goto yy251;
	goto yy246;
yy289:
	YYDEBUG(289, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych == ')') goto yy251;
		if (yych <= '@') goto yy246;
		goto yy263;
	} else {
		if (yych <= 'Z') {
			if (yych >= 'U') goto yy263;
		} else {
			if (yych <= '`') goto yy246;
			if (yych <= 'z') goto yy263;
			goto yy246;
		}
	}
	YYDEBUG(290, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= ')') {
			if (yych <= '(') goto yy246;
			goto yy251;
		} else {
			if (yych == '+') goto yy256;
			goto yy246;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '-') goto yy256;
			if (yych <= '@') goto yy246;
			goto yy264;
		} else {
			if (yych <= '`') goto yy246;
			if (yych <= 'z') goto yy264;
			goto yy246;
		}
	}
yy291:
	YYDEBUG(291, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ':') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy292;
			if (yych <= 0x1F) goto yy246;
		} else {
			if (yych == '.') goto yy248;
			if (yych <= '9') goto yy246;
			goto yy248;
		}
	} else {
		if (yych <= 'P') {
			if (yych == 'A') goto yy294;
			if (yych <= 'O') goto yy246;
			goto yy294;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy246;
				goto yy294;
			} else {
				if (yych == 'p') goto yy294;
				goto yy246;
			}
		}
	}
yy292:
	YYDEBUG(292, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	YYDEBUG(293, *YYCURSOR);
	if (yych <= 'A') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy292;
			goto yy56;
		} else {
			if (yych <= ' ') goto yy292;
			if (yych <= '@') goto yy56;
		}
	} else {
		if (yych <= '`') {
			if (yych != 'P') goto yy56;
		} else {
			if (yych <= 'a') goto yy294;
			if (yych != 'p') goto yy56;
		}
	}
yy294:
	YYDEBUG(294, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych != '.') goto yy56;
	} else {
		if (yych <= 'M') goto yy296;
		if (yych == 'm') goto yy296;
		goto yy56;
	}
	YYDEBUG(295, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy296;
	if (yych != 'm') goto yy56;
yy296:
	YYDEBUG(296, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych <= 0x00) goto yy270;
		if (yych == '\t') goto yy270;
		goto yy56;
	} else {
		if (yych <= ' ') goto yy270;
		if (yych != '.') goto yy56;
	}
	YYDEBUG(297, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '\t') {
		if (yych <= 0x00) goto yy270;
		if (yych <= 0x08) goto yy56;
		goto yy270;
	} else {
		if (yych == ' ') goto yy270;
		goto yy56;
	}
yy298:
	YYDEBUG(298, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '.') goto yy299;
	if (yych != ':') goto yy56;
yy299:
	YYDEBUG(299, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy300;
	if (yych <= '9') goto yy301;
	goto yy56;
yy300:
	YYDEBUG(300, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy302;
		goto yy246;
	} else {
		if (yych <= '9') goto yy301;
		if (yych <= ':') goto yy302;
		goto yy246;
	}
yy301:
	YYDEBUG(301, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy302;
	if (yych != ':') goto yy246;
yy302:
	YYDEBUG(302, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy303;
	if (yych <= '6') goto yy304;
	if (yych <= '9') goto yy251;
	goto yy56;
yy303:
	YYDEBUG(303, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy246;
	if (yych <= '9') goto yy305;
	goto yy246;
yy304:
	YYDEBUG(304, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '0') goto yy246;
yy305:
	YYDEBUG(305, *YYCURSOR);
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '*') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy307;
			goto yy246;
		} else {
			if (yych <= ' ') goto yy307;
			if (yych == '(') goto yy307;
			goto yy246;
		}
	} else {
		if (yych <= '@') {
			if (yych == ',') goto yy246;
			if (yych <= '-') goto yy307;
			goto yy246;
		} else {
			if (yych <= 'Z') goto yy307;
			if (yych <= '`') goto yy246;
			if (yych <= 'z') goto yy307;
			goto yy246;
		}
	}
yy306:
	YYDEBUG(306, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = *YYCURSOR;
yy307:
	YYDEBUG(307, *YYCURSOR);
	if (yych <= '+') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy306;
			if (yych <= 0x1F) goto yy56;
			goto yy306;
		} else {
			if (yych == '(') goto yy257;
			if (yych <= '*') goto yy56;
			goto yy256;
		}
	} else {
		if (yych <= 'F') {
			if (yych == '-') goto yy256;
			if (yych <= '@') goto yy56;
			goto yy259;
		} else {
			if (yych <= 'Z') {
				if (yych <= 'G') goto yy255;
				goto yy259;
			} else {
				if (yych <= '`') goto yy56;
				if (yych <= 'z') goto yy261;
				goto yy56;
			}
		}
	}
yy308:
	YYDEBUG(308, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') {
		if (yych == '.') goto yy299;
		goto yy56;
	} else {
		if (yych <= '9') goto yy298;
		if (yych <= ':') goto yy299;
		goto yy56;
	}
yy309:
	YYDEBUG(309, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') {
		if (yych == '.') goto yy299;
		goto yy56;
	} else {
		if (yych <= '4') goto yy298;
		if (yych == ':') goto yy299;
		goto yy56;
	}
yy310:
	YYDEBUG(310, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy299;
		goto yy232;
	} else {
		if (yych <= '0') goto yy317;
		if (yych <= '9') goto yy318;
		if (yych <= ':') goto yy299;
		goto yy232;
	}
yy311:
	YYDEBUG(311, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy244;
		goto yy232;
	} else {
		if (yych <= '2') goto yy318;
		if (yych <= '9') goto yy317;
		if (yych <= ':') goto yy244;
		goto yy232;
	}
yy312:
	YYDEBUG(312, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy244;
		goto yy232;
	} else {
		if (yych <= '4') goto yy317;
		if (yych <= '9') goto yy314;
		if (yych <= ':') goto yy244;
		goto yy232;
	}
yy313:
	YYDEBUG(313, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy244;
		goto yy232;
	} else {
		if (yych <= '9') goto yy314;
		if (yych <= ':') goto yy244;
		goto yy232;
	}
yy314:
	YYDEBUG(314, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy232;
	if (yych >= ':') goto yy232;
yy315:
	YYDEBUG(315, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy232;
	if (yych >= ':') goto yy232;
	YYDEBUG(316, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy232;
yy317:
	YYDEBUG(317, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy299;
		goto yy232;
	} else {
		if (yych <= '9') goto yy315;
		if (yych <= ':') goto yy299;
		goto yy232;
	}
yy318:
	YYDEBUG(318, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy244;
		goto yy232;
	} else {
		if (yych <= '9') goto yy315;
		if (yych <= ':') goto yy244;
		goto yy232;
	}
yy319:
	YYDEBUG(319, *YYCURSOR);
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x00) goto yy238;
	goto yy237;
yy320:
	YYDEBUG(320, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(321, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(322, *YYCURSOR);
#line 1381 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('datenoday');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		s->time->d = 1;
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_NO_DAY;
	}
#line 5832 '<stdout>'
yy323:
	YYDEBUG(323, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy238;
				goto yy56;
			} else {
				if (yych <= '\t') goto yy236;
				if (yych <= 0x1F) goto yy56;
				goto yy236;
			}
		} else {
			if (yych <= '-') {
				if (yych == ',') goto yy236;
				goto yy56;
			} else {
				if (yych <= '.') goto yy236;
				if (yych <= '/') goto yy56;
				goto yy320;
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'd') {
				if (yych <= 'c') goto yy56;
				goto yy236;
			} else {
				if (yych == 'h') goto yy236;
				goto yy56;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'n') goto yy233;
				if (yych <= 'q') goto yy56;
				goto yy234;
			} else {
				if (yych <= 's') goto yy231;
				if (yych <= 't') goto yy235;
				goto yy56;
			}
		}
	}
yy324:
	YYDEBUG(324, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy238;
				goto yy56;
			} else {
				if (yych <= '\t') goto yy236;
				if (yych <= 0x1F) goto yy56;
				goto yy236;
			}
		} else {
			if (yych <= '-') {
				if (yych == ',') goto yy236;
				goto yy56;
			} else {
				if (yych <= '.') goto yy236;
				if (yych <= '/') goto yy56;
				goto yy327;
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'd') {
				if (yych <= 'c') goto yy56;
				goto yy236;
			} else {
				if (yych == 'h') goto yy236;
				goto yy56;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'n') goto yy233;
				if (yych <= 'q') goto yy56;
				goto yy234;
			} else {
				if (yych <= 's') goto yy231;
				if (yych <= 't') goto yy235;
				goto yy56;
			}
		}
	}
yy325:
	YYDEBUG(325, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy238;
				goto yy56;
			} else {
				if (yych <= '\t') goto yy236;
				if (yych <= 0x1F) goto yy56;
				goto yy236;
			}
		} else {
			if (yych <= '-') {
				if (yych == ',') goto yy236;
				goto yy56;
			} else {
				if (yych <= '.') goto yy236;
				if (yych <= '/') goto yy56;
				goto yy327;
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'd') {
				if (yych <= 'c') goto yy56;
				goto yy236;
			} else {
				if (yych == 'h') goto yy236;
				goto yy56;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'n') goto yy233;
				if (yych <= 'q') goto yy56;
				goto yy234;
			} else {
				if (yych <= 's') goto yy231;
				if (yych <= 't') goto yy235;
				goto yy56;
			}
		}
	}
yy326:
	YYDEBUG(326, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '1') {
		if (yych <= ' ') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy238;
				goto yy56;
			} else {
				if (yych <= '\t') goto yy236;
				if (yych <= 0x1F) goto yy56;
				goto yy236;
			}
		} else {
			if (yych <= '-') {
				if (yych == ',') goto yy236;
				goto yy56;
			} else {
				if (yych <= '.') goto yy236;
				if (yych <= '/') goto yy56;
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'd') {
				if (yych <= '9') goto yy230;
				if (yych <= 'c') goto yy56;
				goto yy236;
			} else {
				if (yych == 'h') goto yy236;
				goto yy56;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'n') goto yy233;
				if (yych <= 'q') goto yy56;
				goto yy234;
			} else {
				if (yych <= 's') goto yy231;
				if (yych <= 't') goto yy235;
				goto yy56;
			}
		}
	}
yy327:
	YYDEBUG(327, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy238;
				goto yy56;
			} else {
				if (yych <= '\t') goto yy236;
				if (yych <= 0x1F) goto yy56;
				goto yy236;
			}
		} else {
			if (yych <= '-') {
				if (yych <= '+') goto yy56;
				if (yych <= ',') goto yy236;
			} else {
				if (yych <= '.') goto yy236;
				if (yych <= '/') goto yy56;
				goto yy320;
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'd') {
				if (yych <= 'c') goto yy56;
				goto yy236;
			} else {
				if (yych == 'h') goto yy236;
				goto yy56;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'n') goto yy233;
				if (yych <= 'q') goto yy56;
				goto yy234;
			} else {
				if (yych <= 's') goto yy231;
				if (yych <= 't') goto yy235;
				goto yy56;
			}
		}
	}
	YYDEBUG(328, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(329, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '/') goto yy330;
	if (yych <= '9') goto yy331;
yy330:
	YYDEBUG(330, *YYCURSOR);
#line 1525 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('pgtextshort');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_PG_TEXT;
	}
#line 6076 '<stdout>'
yy331:
	YYDEBUG(331, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy330;
	if (yych >= ':') goto yy330;
	YYDEBUG(332, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy330;
	if (yych >= ':') goto yy330;
	YYDEBUG(333, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy330;
yy334:
	YYDEBUG(334, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'B') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'C') goto yy217;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'b') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'c') goto yy335;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy335:
	YYDEBUG(335, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'D') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'E') goto yy225;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 'd') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'e') goto yy337;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy336:
	YYDEBUG(336, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 8) {
		goto yy173;
	}
	if (yych <= '/') goto yy220;
	if (yych <= '0') goto yy324;
	if (yych <= '2') goto yy325;
	if (yych <= '3') goto yy326;
	goto yy220;
yy337:
	YYDEBUG(337, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'L') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'M') goto yy226;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'l') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'm') goto yy338;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy338:
	YYDEBUG(338, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'A') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'B') goto yy227;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'b') goto yy339;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy339:
	YYDEBUG(339, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'E') goto yy228;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'e') goto yy340;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy340:
	YYDEBUG(340, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy229;
	if (yych != 'r') goto yy179;
yy341:
	YYDEBUG(341, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= '-') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy220;
			goto yy218;
		} else {
			if (yych <= ' ') goto yy220;
			if (yych <= ',') goto yy218;
		}
	} else {
		if (yych <= '9') {
			if (yych == '/') goto yy172;
			goto yy220;
		} else {
			if (yych == '_') goto yy172;
			goto yy218;
		}
	}
yy342:
	YYDEBUG(342, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 8) {
		goto yy173;
	}
	goto yy220;
yy343:
	YYDEBUG(343, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy166;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 't') goto yy344;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy344:
	YYDEBUG(344, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'O') goto yy167;
			}
		} else {
			if (yych <= 'n') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'o') goto yy345;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy345:
	YYDEBUG(345, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'B') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'A') goto yy168;
		}
	} else {
		if (yych <= 'a') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'b') goto yy346;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy346:
	YYDEBUG(346, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy169;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'e') goto yy347;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy347:
	YYDEBUG(347, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Q') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'R') goto yy229;
		if (yych == 'r') goto yy229;
		goto yy3;
	}
yy348:
	YYDEBUG(348, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy344;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 't') goto yy349;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy349:
	YYDEBUG(349, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'N') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'O') goto yy345;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 'n') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'o') goto yy350;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy350:
	YYDEBUG(350, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'A') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'B') goto yy346;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'b') goto yy351;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy351:
	YYDEBUG(351, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy347;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'e') goto yy352;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy352:
	YYDEBUG(352, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'R') goto yy229;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'r') goto yy341;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy353:
	YYDEBUG(353, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'G') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'F') goto yy166;
			goto yy361;
		}
	} else {
		if (yych <= 'f') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'g') goto yy361;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy354:
	YYDEBUG(354, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy166;
			goto yy358;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'r') goto yy358;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy355:
	YYDEBUG(355, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'N') goto yy166;
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'o') goto yy356;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy356:
	YYDEBUG(356, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '@') {
		if (yych == ')') goto yy164;
	} else {
		if (yych <= 'Z') goto yy167;
		if (yych <= '`') goto yy357;
		if (yych <= 'z') goto yy167;
	}
yy357:
	YYDEBUG(357, *YYCURSOR);
#line 1583 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('ago');
		TIMELIB_INIT;
		s->time->relative.y = 0 - s->time->relative.y;
		s->time->relative.m = 0 - s->time->relative.m;
		s->time->relative.d = 0 - s->time->relative.d;
		s->time->relative.h = 0 - s->time->relative.h;
		s->time->relative.i = 0 - s->time->relative.i;
		s->time->relative.s = 0 - s->time->relative.s;
		s->time->relative.weekday = 0 - s->time->relative.weekday;
		if (s->time->relative.weekday == 0) {
			s->time->relative.weekday = -7;
		}
		if (s->time->relative.have_special_relative && s->time->relative.special.type == TIMELIB_SPECIAL_WEEKDAY) {
			s->time->relative.special.amount = 0 - s->time->relative.special.amount;
		}
		TIMELIB_DEINIT;
		return TIMELIB_AGO;
	}
#line 6678 '<stdout>'
yy358:
	YYDEBUG(358, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'I') goto yy167;
			}
		} else {
			if (yych <= 'h') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'i') goto yy359;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy359:
	YYDEBUG(359, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'K') goto yy168;
		}
	} else {
		if (yych <= 'k') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'l') goto yy360;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy360:
	YYDEBUG(360, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy220;
			goto yy218;
		} else {
			if (yych <= ' ') goto yy220;
			if (yych == ')') goto yy164;
			goto yy218;
		}
	} else {
		if (yych <= '@') {
			if (yych == '/') goto yy218;
			if (yych <= '9') goto yy220;
			goto yy218;
		} else {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy218;
			if (yych <= 'z') goto yy169;
			goto yy218;
		}
	}
yy361:
	YYDEBUG(361, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'U') goto yy167;
			}
		} else {
			if (yych <= 't') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'u') goto yy362;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy362:
	YYDEBUG(362, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'R') goto yy168;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 's') goto yy363;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy363:
	YYDEBUG(363, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy169;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 't') goto yy364;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy364:
	YYDEBUG(364, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '(') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy218;
			goto yy220;
		} else {
			if (yych == ' ') goto yy220;
			goto yy218;
		}
	} else {
		if (yych <= '.') {
			if (yych <= ')') goto yy164;
			if (yych <= ',') goto yy218;
			goto yy220;
		} else {
			if (yych <= '/') goto yy218;
			if (yych <= '9') goto yy220;
			goto yy218;
		}
	}
yy365:
	YYDEBUG(365, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'F') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'G') goto yy361;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'f') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'g') goto yy372;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy366:
	YYDEBUG(366, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'R') goto yy358;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'r') goto yy369;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy367:
	YYDEBUG(367, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'N') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'O') goto yy356;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'n') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'o') goto yy368;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy368:
	YYDEBUG(368, *YYCURSOR);
	yyaccept = 8;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy357;
		} else {
			if (yych == '.') goto yy357;
			goto yy172;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy357;
			if (yych <= 'Z') goto yy167;
			goto yy357;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy357;
			if (yych <= 'z') goto yy175;
			goto yy357;
		}
	}
yy369:
	YYDEBUG(369, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'H') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'I') goto yy359;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 'h') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'i') goto yy370;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy370:
	YYDEBUG(370, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'K') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'L') goto yy360;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'k') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'l') goto yy371;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy371:
	YYDEBUG(371, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy218;
			goto yy220;
		} else {
			if (yych <= ')') {
				if (yych <= '(') goto yy218;
				goto yy164;
			} else {
				if (yych <= ',') goto yy218;
				if (yych <= '-') goto yy342;
				goto yy220;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '/') goto yy172;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy218;
			goto yy169;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy218;
				goto yy172;
			} else {
				if (yych <= '`') goto yy218;
				if (yych <= 'z') goto yy177;
				goto yy218;
			}
		}
	}
yy372:
	YYDEBUG(372, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'T') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'U') goto yy362;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 't') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'u') goto yy373;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy373:
	YYDEBUG(373, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'S') goto yy363;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'r') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 's') goto yy374;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy374:
	YYDEBUG(374, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy364;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 't') goto yy375;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy375:
	YYDEBUG(375, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= ',') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy220;
			goto yy218;
		} else {
			if (yych <= ' ') goto yy220;
			if (yych == ')') goto yy164;
			goto yy218;
		}
	} else {
		if (yych <= '/') {
			if (yych <= '-') goto yy342;
			if (yych <= '.') goto yy220;
			goto yy172;
		} else {
			if (yych <= '9') goto yy220;
			if (yych == '_') goto yy172;
			goto yy218;
		}
	}
yy376:
	YYDEBUG(376, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == 'L') goto yy383;
			if (yych <= 'M') goto yy166;
			goto yy382;
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			if (yych <= 'k') goto yy166;
			goto yy383;
		} else {
			if (yych == 'n') goto yy382;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy377:
	YYDEBUG(377, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy166;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'n') goto yy378;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy378:
	YYDEBUG(378, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'U') goto yy167;
			}
		} else {
			if (yych <= 't') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'u') goto yy379;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy379:
	YYDEBUG(379, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy168;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy380;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy380:
	YYDEBUG(380, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy169;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'r') goto yy381;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy381:
	YYDEBUG(381, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'X') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Y') goto yy229;
		if (yych == 'y') goto yy229;
		goto yy3;
	}
yy382:
	YYDEBUG(382, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych == 'E') goto yy384;
				goto yy167;
			}
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'e') goto yy384;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy383:
	YYDEBUG(383, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'Y') goto yy167;
			}
		} else {
			if (yych <= 'x') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'y') goto yy384;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy384:
	YYDEBUG(384, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy220;
			goto yy218;
		} else {
			if (yych <= ' ') goto yy220;
			if (yych == ')') goto yy164;
			goto yy218;
		}
	} else {
		if (yych <= '@') {
			if (yych == '/') goto yy218;
			if (yych <= '9') goto yy220;
			goto yy218;
		} else {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy218;
			if (yych <= 'z') goto yy168;
			goto yy218;
		}
	}
yy385:
	YYDEBUG(385, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '.') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych == '-') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= '@') {
				if (yych <= '/') goto yy172;
				goto yy3;
			} else {
				if (yych == 'L') goto yy383;
				goto yy166;
			}
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') {
				if (yych <= 'N') goto yy382;
				goto yy166;
			} else {
				if (yych == '_') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 'm') {
				if (yych == 'l') goto yy392;
				goto yy171;
			} else {
				if (yych <= 'n') goto yy391;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy386:
	YYDEBUG(386, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy378;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'n') goto yy387;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy387:
	YYDEBUG(387, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'T') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'U') goto yy379;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 't') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'u') goto yy388;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy388:
	YYDEBUG(388, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy380;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy389;
			if (yych <= 'z') goto yy176;
			goto yy3;
		}
	}
yy389:
	YYDEBUG(389, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'R') goto yy381;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'r') goto yy390;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy390:
	YYDEBUG(390, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Y') goto yy229;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'y') goto yy341;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy391:
	YYDEBUG(391, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'D') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'E') goto yy384;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 'd') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'e') goto yy393;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy392:
	YYDEBUG(392, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'X') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'Y') goto yy384;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 'x') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'y') goto yy393;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy393:
	YYDEBUG(393, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy218;
			goto yy220;
		} else {
			if (yych <= ')') {
				if (yych <= '(') goto yy218;
				goto yy164;
			} else {
				if (yych <= ',') goto yy218;
				if (yych <= '-') goto yy342;
				goto yy220;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '/') goto yy172;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy218;
			goto yy168;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy218;
				goto yy172;
			} else {
				if (yych <= '`') goto yy218;
				if (yych <= 'z') goto yy176;
				goto yy218;
			}
		}
	}
yy394:
	YYDEBUG(394, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy3;
			goto yy220;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy220;
		}
	} else {
		if (yych <= 'H') {
			if (yych <= '/') goto yy3;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'Z') {
				if (yych >= 'J') goto yy166;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy166;
				goto yy3;
			}
		}
	}
yy395:
	YYDEBUG(395, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy220;
			goto yy3;
		} else {
			if (yych <= ' ') goto yy220;
			if (yych == ')') goto yy164;
			goto yy3;
		}
	} else {
		if (yych <= '@') {
			if (yych == '/') goto yy3;
			if (yych <= '9') goto yy220;
			goto yy3;
		} else {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy396:
	YYDEBUG(396, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy3;
			goto yy220;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy220;
		}
	} else {
		if (yych <= 'H') {
			if (yych <= '/') goto yy3;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'Z') {
				if (yych >= 'J') goto yy166;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy166;
				goto yy3;
			}
		}
	}
	YYDEBUG(397, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy3;
			goto yy220;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy220;
		}
	} else {
		if (yych <= 'H') {
			if (yych <= '/') goto yy3;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'Z') {
				if (yych >= 'J') goto yy167;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy167;
				goto yy3;
			}
		}
	}
	YYDEBUG(398, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy220;
			goto yy3;
		} else {
			if (yych <= ' ') goto yy220;
			if (yych == ')') goto yy164;
			goto yy3;
		}
	} else {
		if (yych <= '@') {
			if (yych == '/') goto yy3;
			if (yych <= '9') goto yy220;
			goto yy3;
		} else {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy399:
	YYDEBUG(399, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy220;
			goto yy3;
		} else {
			if (yych <= ' ') goto yy220;
			if (yych == ')') goto yy164;
			goto yy3;
		}
	} else {
		if (yych <= '@') {
			if (yych == '/') goto yy3;
			if (yych <= '9') goto yy220;
			goto yy3;
		} else {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy400:
	YYDEBUG(400, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy3;
			goto yy220;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy220;
		}
	} else {
		if (yych <= 'H') {
			if (yych <= '/') goto yy3;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'Z') {
				if (yych <= 'I') goto yy395;
				goto yy166;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy166;
				goto yy3;
			}
		}
	}
yy401:
	YYDEBUG(401, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'D') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy3;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy3;
					goto yy421;
				} else {
					if (yych <= ':') goto yy187;
					if (yych <= 'C') goto yy3;
					goto yy60;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych <= 'F') {
					if (yych <= 'E') goto yy3;
					goto yy60;
				} else {
					if (yych == 'H') goto yy60;
					goto yy3;
				}
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy3;
				} else {
					if (yych == 'V') goto yy3;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy3;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
yy402:
	YYDEBUG(402, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'V') {
		if (yych <= 'C') {
			if (yych <= '/') {
				if (yych <= '\t') {
					if (yych <= 0x08) goto yy3;
					goto yy60;
				} else {
					if (yych == ' ') goto yy60;
					goto yy3;
				}
			} else {
				if (yych <= '5') {
					if (yych <= '4') goto yy421;
					goto yy406;
				} else {
					if (yych <= '9') goto yy407;
					if (yych <= ':') goto yy187;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy60;
					goto yy3;
				} else {
					if (yych == 'G') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'M') {
					if (yych <= 'L') goto yy3;
					goto yy60;
				} else {
					if (yych <= 'R') goto yy3;
					if (yych <= 'U') goto yy60;
					goto yy3;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych <= 'X') {
					if (yych <= 'W') goto yy60;
					goto yy3;
				} else {
					if (yych <= 'Y') goto yy60;
					if (yych <= 'c') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
yy403:
	YYDEBUG(403, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'V') {
		if (yych <= 'C') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy3;
				goto yy60;
			} else {
				if (yych <= '5') {
					if (yych <= '/') goto yy3;
					goto yy406;
				} else {
					if (yych <= '9') goto yy407;
					if (yych <= ':') goto yy187;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy60;
					goto yy3;
				} else {
					if (yych == 'G') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'M') {
					if (yych <= 'L') goto yy3;
					goto yy60;
				} else {
					if (yych <= 'R') goto yy3;
					if (yych <= 'U') goto yy60;
					goto yy3;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych <= 'X') {
					if (yych <= 'W') goto yy60;
					goto yy3;
				} else {
					if (yych <= 'Y') goto yy60;
					if (yych <= 'c') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
yy404:
	YYDEBUG(404, *YYCURSOR);
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	YYDEBUG(405, *YYCURSOR);
	if (yybm[0+yych] & 4) {
		goto yy57;
	}
	if (yych <= ',') {
		if (yych == '+') goto yy404;
		goto yy56;
	} else {
		if (yych <= '-') goto yy404;
		if (yych <= '/') goto yy56;
		if (yych <= '9') goto yy54;
		goto yy56;
	}
yy406:
	YYDEBUG(406, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy3;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy3;
					goto yy420;
				} else {
					if (yych == 'D') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy3;
				if (yych <= 'H') goto yy60;
				goto yy3;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy3;
				} else {
					if (yych == 'V') goto yy3;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy3;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
yy407:
	YYDEBUG(407, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy3;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy3;
				} else {
					if (yych == 'D') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy3;
				if (yych <= 'H') goto yy60;
				goto yy3;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy3;
				} else {
					if (yych == 'V') goto yy3;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy3;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
	YYDEBUG(408, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych >= ':') goto yy60;
yy409:
	YYDEBUG(409, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 2) {
		goto yy54;
	}
	if (yych != '-') goto yy60;
yy410:
	YYDEBUG(410, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy411;
	if (yych <= '1') goto yy412;
	goto yy56;
yy411:
	YYDEBUG(411, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy413;
	goto yy56;
yy412:
	YYDEBUG(412, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '3') goto yy56;
yy413:
	YYDEBUG(413, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '-') goto yy56;
	YYDEBUG(414, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy415;
	if (yych <= '2') goto yy416;
	if (yych <= '3') goto yy417;
	goto yy56;
yy415:
	YYDEBUG(415, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy418;
	goto yy56;
yy416:
	YYDEBUG(416, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy418;
	goto yy56;
yy417:
	YYDEBUG(417, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '2') goto yy56;
yy418:
	YYDEBUG(418, *YYCURSOR);
	++YYCURSOR;
yy419:
	YYDEBUG(419, *YYCURSOR);
#line 1286 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('iso8601date4 | iso8601date2 | iso8601dateslash | dateslash');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_unsigned_nr((char **) &ptr, 4);
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		TIMELIB_DEINIT;
		return TIMELIB_ISO_DATE;
	}
#line 8472 '<stdout>'
yy420:
	YYDEBUG(420, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy3;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy3;
					goto yy409;
				} else {
					if (yych == 'D') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy3;
				if (yych <= 'H') goto yy60;
				goto yy3;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy3;
				} else {
					if (yych == 'V') goto yy3;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy3;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
yy421:
	YYDEBUG(421, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'V') {
		if (yych <= 'C') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy3;
				goto yy60;
			} else {
				if (yych <= '5') {
					if (yych <= '/') goto yy3;
				} else {
					if (yych <= '9') goto yy420;
					if (yych <= ':') goto yy187;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy60;
					goto yy3;
				} else {
					if (yych == 'G') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'M') {
					if (yych <= 'L') goto yy3;
					goto yy60;
				} else {
					if (yych <= 'R') goto yy3;
					if (yych <= 'U') goto yy60;
					goto yy3;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych <= 'X') {
					if (yych <= 'W') goto yy60;
					goto yy3;
				} else {
					if (yych <= 'Y') goto yy60;
					if (yych <= 'c') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
	YYDEBUG(422, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy3;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy3;
				} else {
					if (yych == 'D') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy3;
				if (yych <= 'H') goto yy60;
				goto yy3;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy3;
				} else {
					if (yych == 'V') goto yy3;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy3;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
	YYDEBUG(423, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 2) {
		goto yy54;
	}
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy3;
				goto yy60;
			} else {
				if (yych <= '-') {
					if (yych <= ',') goto yy3;
					goto yy410;
				} else {
					if (yych == 'D') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy3;
				if (yych <= 'H') goto yy60;
				goto yy3;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy3;
				} else {
					if (yych == 'V') goto yy3;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy3;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy3;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy3;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy3;
				} else {
					if (yych == 'v') goto yy3;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy3;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy3;
				}
			}
		}
	}
yy424:
	YYDEBUG(424, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy426;
	if (yych <= '0') goto yy700;
	if (yych <= '1') goto yy701;
	if (yych <= '9') goto yy702;
	goto yy426;
yy425:
	YYDEBUG(425, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 13) YYFILL(13);
	yych = *YYCURSOR;
yy426:
	YYDEBUG(426, *YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'G') {
			if (yych <= '.') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy425;
					goto yy56;
				} else {
					if (yych <= ' ') goto yy425;
					if (yych <= ',') goto yy56;
					goto yy541;
				}
			} else {
				if (yych <= 'C') {
					if (yych == 'A') goto yy444;
					goto yy56;
				} else {
					if (yych <= 'D') goto yy430;
					if (yych == 'F') goto yy431;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'O') {
				if (yych <= 'J') {
					if (yych <= 'H') goto yy65;
					if (yych <= 'I') goto yy439;
					goto yy443;
				} else {
					if (yych <= 'L') goto yy56;
					if (yych <= 'M') goto yy427;
					if (yych <= 'N') goto yy446;
					goto yy445;
				}
			} else {
				if (yych <= 'S') {
					if (yych <= 'P') goto yy448;
					if (yych <= 'R') goto yy56;
					goto yy428;
				} else {
					if (yych <= 'T') goto yy70;
					if (yych <= 'U') goto yy63;
					if (yych <= 'V') goto yy441;
					goto yy69;
				}
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'e') {
				if (yych <= '`') {
					if (yych <= 'X') goto yy442;
					if (yych <= 'Y') goto yy68;
					goto yy56;
				} else {
					if (yych <= 'a') goto yy444;
					if (yych == 'd') goto yy430;
					goto yy56;
				}
			} else {
				if (yych <= 'h') {
					if (yych <= 'f') goto yy431;
					if (yych <= 'g') goto yy56;
					goto yy65;
				} else {
					if (yych == 'j') goto yy443;
					if (yych <= 'l') goto yy56;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'p') {
					if (yych <= 'n') goto yy446;
					if (yych <= 'o') goto yy445;
					goto yy448;
				} else {
					if (yych <= 'r') goto yy56;
					if (yych <= 's') goto yy428;
					if (yych <= 't') goto yy70;
					goto yy63;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy69;
					goto yy56;
				} else {
					if (yych <= 'y') goto yy68;
					if (yych == 0xC2) goto yy62;
					goto yy56;
				}
			}
		}
	}
yy427:
	YYDEBUG(427, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= 'I') {
			if (yych == 'A') goto yy556;
			if (yych <= 'H') goto yy56;
			goto yy138;
		} else {
			if (yych == 'O') goto yy137;
			if (yych <= 'R') goto yy56;
			goto yy139;
		}
	} else {
		if (yych <= 'i') {
			if (yych == 'a') goto yy556;
			if (yych <= 'h') goto yy56;
			goto yy138;
		} else {
			if (yych <= 'o') {
				if (yych <= 'n') goto yy56;
				goto yy137;
			} else {
				if (yych == 's') goto yy139;
				goto yy56;
			}
		}
	}
yy428:
	YYDEBUG(428, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= 'D') {
			if (yych == 'A') goto yy119;
			goto yy56;
		} else {
			if (yych <= 'E') goto yy1013;
			if (yych <= 'T') goto yy56;
			goto yy118;
		}
	} else {
		if (yych <= 'd') {
			if (yych == 'a') goto yy119;
			goto yy56;
		} else {
			if (yych <= 'e') goto yy1013;
			if (yych == 'u') goto yy118;
			goto yy56;
		}
	}
yy429:
	YYDEBUG(429, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '`') {
		if (yych <= 'D') {
			if (yych == 'A') goto yy119;
			goto yy56;
		} else {
			if (yych <= 'E') goto yy1013;
			if (yych == 'U') goto yy118;
			goto yy56;
		}
	} else {
		if (yych <= 'e') {
			if (yych <= 'a') goto yy119;
			if (yych <= 'd') goto yy56;
			goto yy1013;
		} else {
			if (yych <= 's') goto yy56;
			if (yych <= 't') goto yy693;
			if (yych <= 'u') goto yy118;
			goto yy56;
		}
	}
yy430:
	YYDEBUG(430, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych == 'A') goto yy115;
		if (yych <= 'D') goto yy56;
		goto yy543;
	} else {
		if (yych <= 'a') {
			if (yych <= '`') goto yy56;
			goto yy115;
		} else {
			if (yych == 'e') goto yy543;
			goto yy56;
		}
	}
yy431:
	YYDEBUG(431, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= 'N') {
			if (yych == 'E') goto yy559;
			goto yy56;
		} else {
			if (yych <= 'O') goto yy100;
			if (yych <= 'Q') goto yy56;
			goto yy99;
		}
	} else {
		if (yych <= 'n') {
			if (yych == 'e') goto yy559;
			goto yy56;
		} else {
			if (yych <= 'o') goto yy100;
			if (yych == 'r') goto yy99;
			goto yy56;
		}
	}
yy432:
	YYDEBUG(432, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'H') goto yy71;
		if (yych <= 'T') goto yy56;
		goto yy72;
	} else {
		if (yych <= 'h') {
			if (yych <= 'g') goto yy56;
			goto yy1012;
		} else {
			if (yych == 'u') goto yy72;
			goto yy56;
		}
	}
yy433:
	YYDEBUG(433, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '-') goto yy706;
	if (yych <= '/') goto yy60;
	if (yych <= '9') goto yy705;
	goto yy60;
yy434:
	YYDEBUG(434, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'c') {
		if (yych == 'O') goto yy494;
		goto yy56;
	} else {
		if (yych <= 'd') goto yy693;
		if (yych == 'o') goto yy494;
		goto yy56;
	}
yy435:
	YYDEBUG(435, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy693;
	goto yy56;
yy436:
	YYDEBUG(436, *YYCURSOR);
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':	goto yy630;
	case '3':	goto yy632;
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy633;
	case 'A':
	case 'a':	goto yy637;
	case 'D':
	case 'd':	goto yy641;
	case 'F':
	case 'f':	goto yy635;
	case 'J':
	case 'j':	goto yy634;
	case 'M':
	case 'm':	goto yy636;
	case 'N':
	case 'n':	goto yy640;
	case 'O':
	case 'o':	goto yy639;
	case 'S':
	case 's':	goto yy638;
	default:	goto yy56;
	}
yy437:
	YYDEBUG(437, *YYCURSOR);
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':	goto yy580;
	case '1':	goto yy581;
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy582;
	case 'A':
	case 'a':	goto yy586;
	case 'D':
	case 'd':	goto yy590;
	case 'F':
	case 'f':	goto yy584;
	case 'J':
	case 'j':	goto yy583;
	case 'M':
	case 'm':	goto yy585;
	case 'N':
	case 'n':	goto yy589;
	case 'O':
	case 'o':	goto yy588;
	case 'S':
	case 's':	goto yy587;
	default:	goto yy542;
	}
yy438:
	YYDEBUG(438, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '1') {
		if (yych <= '/') goto yy542;
		if (yych <= '0') goto yy532;
		goto yy533;
	} else {
		if (yych <= '5') goto yy534;
		if (yych <= '9') goto yy535;
		goto yy542;
	}
yy439:
	YYDEBUG(439, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '.') goto yy496;
		}
	} else {
		if (yych <= 'U') {
			if (yych <= '9') goto yy498;
			if (yych == 'I') goto yy531;
		} else {
			if (yych == 'W') goto yy440;
			if (yych <= 'X') goto yy504;
		}
	}
yy440:
	YYDEBUG(440, *YYCURSOR);
#line 1423 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('datenoyearrev');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		timelib_skip_day_suffix((char **) &ptr);
		s->time->m = timelib_get_month((char **) &ptr);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_TEXT;
	}
#line 9127 '<stdout>'
yy441:
	YYDEBUG(441, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy440;
			goto yy496;
		} else {
			if (yych == ' ') goto yy496;
			goto yy440;
		}
	} else {
		if (yych <= '9') {
			if (yych <= '.') goto yy496;
			if (yych <= '/') goto yy440;
			goto yy498;
		} else {
			if (yych == 'I') goto yy529;
			goto yy440;
		}
	}
yy442:
	YYDEBUG(442, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy440;
			goto yy496;
		} else {
			if (yych == ' ') goto yy496;
			goto yy440;
		}
	} else {
		if (yych <= '9') {
			if (yych <= '.') goto yy496;
			if (yych <= '/') goto yy440;
			goto yy498;
		} else {
			if (yych == 'I') goto yy528;
			goto yy440;
		}
	}
yy443:
	YYDEBUG(443, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'A') goto yy521;
		if (yych <= 'T') goto yy56;
		goto yy520;
	} else {
		if (yych <= 'a') {
			if (yych <= '`') goto yy56;
			goto yy521;
		} else {
			if (yych == 'u') goto yy520;
			goto yy56;
		}
	}
yy444:
	YYDEBUG(444, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= 'L') {
			if (yych == '.') goto yy449;
			goto yy56;
		} else {
			if (yych <= 'M') goto yy450;
			if (yych == 'P') goto yy514;
			goto yy56;
		}
	} else {
		if (yych <= 'o') {
			if (yych <= 'U') goto yy513;
			if (yych == 'm') goto yy450;
			goto yy56;
		} else {
			if (yych <= 'p') goto yy514;
			if (yych == 'u') goto yy513;
			goto yy56;
		}
	}
yy445:
	YYDEBUG(445, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy508;
	if (yych == 'c') goto yy508;
	goto yy56;
yy446:
	YYDEBUG(446, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy494;
	if (yych == 'o') goto yy494;
	goto yy56;
yy447:
	YYDEBUG(447, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy454;
	if (yych <= '9') goto yy456;
	goto yy56;
yy448:
	YYDEBUG(448, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych != '.') goto yy56;
	} else {
		if (yych <= 'M') goto yy450;
		if (yych == 'm') goto yy450;
		goto yy56;
	}
yy449:
	YYDEBUG(449, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy450;
	if (yych != 'm') goto yy56;
yy450:
	YYDEBUG(450, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych <= 0x00) goto yy452;
		if (yych == '\t') goto yy452;
		goto yy56;
	} else {
		if (yych <= ' ') goto yy452;
		if (yych != '.') goto yy56;
	}
	YYDEBUG(451, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '\t') {
		if (yych <= 0x00) goto yy452;
		if (yych <= 0x08) goto yy56;
	} else {
		if (yych != ' ') goto yy56;
	}
yy452:
	YYDEBUG(452, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(453, *YYCURSOR);
#line 1141 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('timetiny12 | timeshort12 | timelong12');
		TIMELIB_INIT;
		TIMELIB_HAVE_TIME();
		s->time->h = timelib_get_nr((char **) &ptr, 2);
		if (*ptr == ':' || *ptr == '.') {
			s->time->i = timelib_get_nr((char **) &ptr, 2);
			if (*ptr == ':' || *ptr == '.') {
				s->time->s = timelib_get_nr((char **) &ptr, 2);
			}
		}
		s->time->h += timelib_meridian((char **) &ptr, s->time->h);
		TIMELIB_DEINIT;
		return TIMELIB_TIME12;
	}
#line 9284 '<stdout>'
yy454:
	YYDEBUG(454, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy457;
	} else {
		if (yych <= '9') goto yy471;
		if (yych <= ':') goto yy457;
	}
yy455:
	YYDEBUG(455, *YYCURSOR);
#line 1178 'ext/date/lib/parse_date.re'
	{
		int tz_not_found;
		DEBUG_OUTPUT('timeshort24 | timelong24 | iso8601long');
		TIMELIB_INIT;
		TIMELIB_HAVE_TIME();
		s->time->h = timelib_get_nr((char **) &ptr, 2);
		s->time->i = timelib_get_nr((char **) &ptr, 2);
		if (*ptr == ':' || *ptr == '.') {
			s->time->s = timelib_get_nr((char **) &ptr, 2);

			if (*ptr == '.') {
				s->time->f = timelib_get_frac_nr((char **) &ptr, 8);
			}
		}

		if (*ptr != '\0') {
			s->time->z = timelib_parse_zone((char **) &ptr, &s->time->dst, s->time, &tz_not_found, s->tzdb, tz_get_wrapper);
			if (tz_not_found) {
				add_error(s, 'The timezone could not be found in the database');
			}
		}
		TIMELIB_DEINIT;
		return TIMELIB_TIME24_WITH_ZONE;
	}
#line 9322 '<stdout>'
yy456:
	YYDEBUG(456, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy457;
	if (yych != ':') goto yy455;
yy457:
	YYDEBUG(457, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy458;
	if (yych <= '6') goto yy459;
	if (yych <= '9') goto yy460;
	goto yy56;
yy458:
	YYDEBUG(458, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych <= '/') goto yy455;
	if (yych <= '9') goto yy464;
	goto yy455;
yy459:
	YYDEBUG(459, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych == '0') goto yy464;
	goto yy455;
yy460:
	YYDEBUG(460, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych != '.') goto yy455;
yy461:
	YYDEBUG(461, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
yy462:
	YYDEBUG(462, *YYCURSOR);
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	YYDEBUG(463, *YYCURSOR);
	if (yych <= '/') goto yy455;
	if (yych <= '9') goto yy462;
	goto yy455;
yy464:
	YYDEBUG(464, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= 0x1F) {
			if (yych != '\t') goto yy455;
		} else {
			if (yych <= ' ') goto yy465;
			if (yych == '.') goto yy461;
			goto yy455;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'A') goto yy467;
			if (yych == 'P') goto yy467;
			goto yy455;
		} else {
			if (yych <= 'a') goto yy467;
			if (yych == 'p') goto yy467;
			goto yy455;
		}
	}
yy465:
	YYDEBUG(465, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	YYDEBUG(466, *YYCURSOR);
	if (yych <= 'A') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy465;
			goto yy56;
		} else {
			if (yych <= ' ') goto yy465;
			if (yych <= '@') goto yy56;
		}
	} else {
		if (yych <= '`') {
			if (yych != 'P') goto yy56;
		} else {
			if (yych <= 'a') goto yy467;
			if (yych != 'p') goto yy56;
		}
	}
yy467:
	YYDEBUG(467, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych != '.') goto yy56;
	} else {
		if (yych <= 'M') goto yy469;
		if (yych == 'm') goto yy469;
		goto yy56;
	}
	YYDEBUG(468, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy469;
	if (yych != 'm') goto yy56;
yy469:
	YYDEBUG(469, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych <= 0x00) goto yy452;
		if (yych == '\t') goto yy452;
		goto yy56;
	} else {
		if (yych <= ' ') goto yy452;
		if (yych != '.') goto yy56;
	}
	YYDEBUG(470, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '\t') {
		if (yych <= 0x00) goto yy452;
		if (yych <= 0x08) goto yy56;
		goto yy452;
	} else {
		if (yych == ' ') goto yy452;
		goto yy56;
	}
yy471:
	YYDEBUG(471, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ':') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy472;
			if (yych <= 0x1F) goto yy455;
		} else {
			if (yych == '.') goto yy457;
			if (yych <= '9') goto yy455;
			goto yy475;
		}
	} else {
		if (yych <= 'P') {
			if (yych == 'A') goto yy474;
			if (yych <= 'O') goto yy455;
			goto yy474;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy455;
				goto yy474;
			} else {
				if (yych == 'p') goto yy474;
				goto yy455;
			}
		}
	}
yy472:
	YYDEBUG(472, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	YYDEBUG(473, *YYCURSOR);
	if (yych <= 'A') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy472;
			goto yy56;
		} else {
			if (yych <= ' ') goto yy472;
			if (yych <= '@') goto yy56;
		}
	} else {
		if (yych <= '`') {
			if (yych != 'P') goto yy56;
		} else {
			if (yych <= 'a') goto yy474;
			if (yych != 'p') goto yy56;
		}
	}
yy474:
	YYDEBUG(474, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych == '.') goto yy491;
		goto yy56;
	} else {
		if (yych <= 'M') goto yy492;
		if (yych == 'm') goto yy492;
		goto yy56;
	}
yy475:
	YYDEBUG(475, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy476;
	if (yych <= '6') goto yy477;
	if (yych <= '9') goto yy460;
	goto yy56;
yy476:
	YYDEBUG(476, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych <= '/') goto yy455;
	if (yych <= '9') goto yy478;
	goto yy455;
yy477:
	YYDEBUG(477, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych != '0') goto yy455;
yy478:
	YYDEBUG(478, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ':') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy465;
			if (yych <= 0x1F) goto yy455;
			goto yy465;
		} else {
			if (yych == '.') goto yy479;
			if (yych <= '9') goto yy455;
			goto yy480;
		}
	} else {
		if (yych <= 'P') {
			if (yych == 'A') goto yy467;
			if (yych <= 'O') goto yy455;
			goto yy467;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy455;
				goto yy467;
			} else {
				if (yych == 'p') goto yy467;
				goto yy455;
			}
		}
	}
yy479:
	YYDEBUG(479, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy489;
	goto yy56;
yy480:
	YYDEBUG(480, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
yy481:
	YYDEBUG(481, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	YYDEBUG(482, *YYCURSOR);
	if (yych <= 'O') {
		if (yych <= '9') {
			if (yych <= '/') goto yy56;
			goto yy481;
		} else {
			if (yych != 'A') goto yy56;
		}
	} else {
		if (yych <= 'a') {
			if (yych <= 'P') goto yy483;
			if (yych <= '`') goto yy56;
		} else {
			if (yych != 'p') goto yy56;
		}
	}
yy483:
	YYDEBUG(483, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych != '.') goto yy56;
	} else {
		if (yych <= 'M') goto yy485;
		if (yych == 'm') goto yy485;
		goto yy56;
	}
	YYDEBUG(484, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy485;
	if (yych != 'm') goto yy56;
yy485:
	YYDEBUG(485, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych <= 0x00) goto yy487;
		if (yych == '\t') goto yy487;
		goto yy56;
	} else {
		if (yych <= ' ') goto yy487;
		if (yych != '.') goto yy56;
	}
	YYDEBUG(486, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '\t') {
		if (yych <= 0x00) goto yy487;
		if (yych <= 0x08) goto yy56;
	} else {
		if (yych != ' ') goto yy56;
	}
yy487:
	YYDEBUG(487, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(488, *YYCURSOR);
#line 1158 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('mssqltime');
		TIMELIB_INIT;
		TIMELIB_HAVE_TIME();
		s->time->h = timelib_get_nr((char **) &ptr, 2);
		s->time->i = timelib_get_nr((char **) &ptr, 2);
		if (*ptr == ':' || *ptr == '.') {
			s->time->s = timelib_get_nr((char **) &ptr, 2);

			if (*ptr == ':' || *ptr == '.') {
				s->time->f = timelib_get_frac_nr((char **) &ptr, 8);
			}
		}
		timelib_eat_spaces((char **) &ptr);
		s->time->h += timelib_meridian((char **) &ptr, s->time->h);
		TIMELIB_DEINIT;
		return TIMELIB_TIME24_WITH_ZONE;
	}
#line 9651 '<stdout>'
yy489:
	YYDEBUG(489, *YYCURSOR);
	yyaccept = 10;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	YYDEBUG(490, *YYCURSOR);
	if (yych <= 'O') {
		if (yych <= '9') {
			if (yych <= '/') goto yy455;
			goto yy489;
		} else {
			if (yych == 'A') goto yy483;
			goto yy455;
		}
	} else {
		if (yych <= 'a') {
			if (yych <= 'P') goto yy483;
			if (yych <= '`') goto yy455;
			goto yy483;
		} else {
			if (yych == 'p') goto yy483;
			goto yy455;
		}
	}
yy491:
	YYDEBUG(491, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy492;
	if (yych != 'm') goto yy56;
yy492:
	YYDEBUG(492, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych <= 0x00) goto yy452;
		if (yych == '\t') goto yy452;
		goto yy56;
	} else {
		if (yych <= ' ') goto yy452;
		if (yych != '.') goto yy56;
	}
	YYDEBUG(493, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '\t') {
		if (yych <= 0x00) goto yy452;
		if (yych <= 0x08) goto yy56;
		goto yy452;
	} else {
		if (yych == ' ') goto yy452;
		goto yy56;
	}
yy494:
	YYDEBUG(494, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'V') goto yy495;
	if (yych != 'v') goto yy56;
yy495:
	YYDEBUG(495, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych != '\t') goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
		}
	} else {
		if (yych <= 'D') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'E') goto yy500;
			if (yych == 'e') goto yy500;
			goto yy440;
		}
	}
yy496:
	YYDEBUG(496, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
yy497:
	YYDEBUG(497, *YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy496;
		if (yych <= 0x1F) goto yy56;
		goto yy496;
	} else {
		if (yych <= '.') {
			if (yych <= ',') goto yy56;
			goto yy496;
		} else {
			if (yych <= '/') goto yy56;
			if (yych >= ':') goto yy56;
		}
	}
yy498:
	YYDEBUG(498, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '/') goto yy499;
	if (yych <= '9') goto yy505;
yy499:
	YYDEBUG(499, *YYCURSOR);
#line 1340 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('datefull');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		timelib_skip_day_suffix((char **) &ptr);
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_FULL;
	}
#line 9771 '<stdout>'
yy500:
	YYDEBUG(500, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy501;
	if (yych != 'm') goto yy56;
yy501:
	YYDEBUG(501, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy502;
	if (yych != 'b') goto yy56;
yy502:
	YYDEBUG(502, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy503;
	if (yych != 'e') goto yy56;
yy503:
	YYDEBUG(503, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy504;
	if (yych != 'r') goto yy56;
yy504:
	YYDEBUG(504, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy496;
		if (yych <= 0x1F) goto yy440;
		goto yy496;
	} else {
		if (yych <= '.') {
			if (yych <= ',') goto yy440;
			goto yy496;
		} else {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		}
	}
yy505:
	YYDEBUG(505, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy499;
	if (yych >= ':') goto yy499;
yy506:
	YYDEBUG(506, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy499;
	if (yych >= ':') goto yy499;
	YYDEBUG(507, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy499;
yy508:
	YYDEBUG(508, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy509;
	if (yych != 't') goto yy56;
yy509:
	YYDEBUG(509, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'N') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'O') goto yy510;
			if (yych != 'o') goto yy440;
		}
	}
yy510:
	YYDEBUG(510, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy511;
	if (yych != 'b') goto yy56;
yy511:
	YYDEBUG(511, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy512;
	if (yych != 'e') goto yy56;
yy512:
	YYDEBUG(512, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy504;
	if (yych == 'r') goto yy504;
	goto yy56;
yy513:
	YYDEBUG(513, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy517;
	if (yych == 'g') goto yy517;
	goto yy56;
yy514:
	YYDEBUG(514, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy515;
	if (yych != 'r') goto yy56;
yy515:
	YYDEBUG(515, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'H') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'I') goto yy516;
			if (yych != 'i') goto yy440;
		}
	}
yy516:
	YYDEBUG(516, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'L') goto yy504;
	if (yych == 'l') goto yy504;
	goto yy56;
yy517:
	YYDEBUG(517, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'T') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'U') goto yy518;
			if (yych != 'u') goto yy440;
		}
	}
yy518:
	YYDEBUG(518, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy519;
	if (yych != 's') goto yy56;
yy519:
	YYDEBUG(519, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy504;
	if (yych == 't') goto yy504;
	goto yy56;
yy520:
	YYDEBUG(520, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych == 'L') goto yy527;
		if (yych <= 'M') goto yy56;
		goto yy526;
	} else {
		if (yych <= 'l') {
			if (yych <= 'k') goto yy56;
			goto yy527;
		} else {
			if (yych == 'n') goto yy526;
			goto yy56;
		}
	}
yy521:
	YYDEBUG(521, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy522;
	if (yych != 'n') goto yy56;
yy522:
	YYDEBUG(522, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'T') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'U') goto yy523;
			if (yych != 'u') goto yy440;
		}
	}
yy523:
	YYDEBUG(523, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy524;
	if (yych != 'a') goto yy56;
yy524:
	YYDEBUG(524, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy525;
	if (yych != 'r') goto yy56;
yy525:
	YYDEBUG(525, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy504;
	if (yych == 'y') goto yy504;
	goto yy56;
yy526:
	YYDEBUG(526, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'D') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'E') goto yy504;
			if (yych == 'e') goto yy504;
			goto yy440;
		}
	}
yy527:
	YYDEBUG(527, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'X') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'Y') goto yy504;
			if (yych == 'y') goto yy504;
			goto yy440;
		}
	}
yy528:
	YYDEBUG(528, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy440;
			goto yy496;
		} else {
			if (yych == ' ') goto yy496;
			goto yy440;
		}
	} else {
		if (yych <= '9') {
			if (yych <= '.') goto yy496;
			if (yych <= '/') goto yy440;
			goto yy498;
		} else {
			if (yych == 'I') goto yy504;
			goto yy440;
		}
	}
yy529:
	YYDEBUG(529, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy440;
			goto yy496;
		} else {
			if (yych == ' ') goto yy496;
			goto yy440;
		}
	} else {
		if (yych <= '9') {
			if (yych <= '.') goto yy496;
			if (yych <= '/') goto yy440;
			goto yy498;
		} else {
			if (yych != 'I') goto yy440;
		}
	}
	YYDEBUG(530, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy440;
			goto yy496;
		} else {
			if (yych == ' ') goto yy496;
			goto yy440;
		}
	} else {
		if (yych <= '9') {
			if (yych <= '.') goto yy496;
			if (yych <= '/') goto yy440;
			goto yy498;
		} else {
			if (yych == 'I') goto yy504;
			goto yy440;
		}
	}
yy531:
	YYDEBUG(531, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy440;
			goto yy496;
		} else {
			if (yych == ' ') goto yy496;
			goto yy440;
		}
	} else {
		if (yych <= '9') {
			if (yych <= '.') goto yy496;
			if (yych <= '/') goto yy440;
			goto yy498;
		} else {
			if (yych == 'I') goto yy504;
			goto yy440;
		}
	}
yy532:
	YYDEBUG(532, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ',') goto yy455;
		if (yych <= '-') goto yy566;
		goto yy565;
	} else {
		if (yych <= '/') goto yy455;
		if (yych <= '9') goto yy579;
		if (yych <= ':') goto yy457;
		goto yy455;
	}
yy533:
	YYDEBUG(533, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') goto yy455;
		if (yych <= '-') goto yy566;
		if (yych <= '.') goto yy565;
		goto yy455;
	} else {
		if (yych <= '2') goto yy579;
		if (yych <= '9') goto yy578;
		if (yych <= ':') goto yy457;
		goto yy455;
	}
yy534:
	YYDEBUG(534, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ',') goto yy455;
		if (yych <= '-') goto yy566;
		goto yy565;
	} else {
		if (yych <= '/') goto yy455;
		if (yych <= '9') goto yy578;
		if (yych <= ':') goto yy457;
		goto yy455;
	}
yy535:
	YYDEBUG(535, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ',') goto yy455;
		if (yych <= '-') goto yy566;
		goto yy565;
	} else {
		if (yych == ':') goto yy457;
		goto yy455;
	}
yy536:
	YYDEBUG(536, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy559;
	if (yych == 'e') goto yy559;
	goto yy56;
yy537:
	YYDEBUG(537, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy556;
	if (yych == 'a') goto yy556;
	goto yy56;
yy538:
	YYDEBUG(538, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'P') goto yy514;
		if (yych <= 'T') goto yy56;
		goto yy513;
	} else {
		if (yych <= 'p') {
			if (yych <= 'o') goto yy56;
			goto yy514;
		} else {
			if (yych == 'u') goto yy513;
			goto yy56;
		}
	}
yy539:
	YYDEBUG(539, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy549;
	if (yych == 'e') goto yy549;
	goto yy56;
yy540:
	YYDEBUG(540, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy543;
	if (yych == 'e') goto yy543;
	goto yy56;
yy541:
	YYDEBUG(541, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 13) YYFILL(13);
	yych = *YYCURSOR;
yy542:
	YYDEBUG(542, *YYCURSOR);
	switch (yych) {
	case '\t':
	case ' ':
	case '-':
	case '.':	goto yy541;
	case 'A':
	case 'a':	goto yy538;
	case 'D':
	case 'd':	goto yy540;
	case 'F':
	case 'f':	goto yy536;
	case 'I':	goto yy439;
	case 'J':
	case 'j':	goto yy443;
	case 'M':
	case 'm':	goto yy537;
	case 'N':
	case 'n':	goto yy446;
	case 'O':
	case 'o':	goto yy445;
	case 'S':
	case 's':	goto yy539;
	case 'V':	goto yy441;
	case 'X':	goto yy442;
	default:	goto yy56;
	}
yy543:
	YYDEBUG(543, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy544;
	if (yych != 'c') goto yy56;
yy544:
	YYDEBUG(544, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'D') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'E') goto yy545;
			if (yych != 'e') goto yy440;
		}
	}
yy545:
	YYDEBUG(545, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy546;
	if (yych != 'm') goto yy56;
yy546:
	YYDEBUG(546, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy547;
	if (yych != 'b') goto yy56;
yy547:
	YYDEBUG(547, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy548;
	if (yych != 'e') goto yy56;
yy548:
	YYDEBUG(548, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy504;
	if (yych == 'r') goto yy504;
	goto yy56;
yy549:
	YYDEBUG(549, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'P') goto yy550;
	if (yych != 'p') goto yy56;
yy550:
	YYDEBUG(550, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'S') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'T') goto yy551;
			if (yych != 't') goto yy440;
		}
	}
yy551:
	YYDEBUG(551, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'D') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'E') goto yy552;
			if (yych != 'e') goto yy440;
		}
	}
yy552:
	YYDEBUG(552, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy553;
	if (yych != 'm') goto yy56;
yy553:
	YYDEBUG(553, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy554;
	if (yych != 'b') goto yy56;
yy554:
	YYDEBUG(554, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy555;
	if (yych != 'e') goto yy56;
yy555:
	YYDEBUG(555, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy504;
	if (yych == 'r') goto yy504;
	goto yy56;
yy556:
	YYDEBUG(556, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych == 'R') goto yy557;
		if (yych <= 'X') goto yy56;
		goto yy504;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy56;
		} else {
			if (yych == 'y') goto yy504;
			goto yy56;
		}
	}
yy557:
	YYDEBUG(557, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'B') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'C') goto yy558;
			if (yych != 'c') goto yy440;
		}
	}
yy558:
	YYDEBUG(558, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy504;
	if (yych == 'h') goto yy504;
	goto yy56;
yy559:
	YYDEBUG(559, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy560;
	if (yych != 'b') goto yy56;
yy560:
	YYDEBUG(560, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			goto yy496;
		}
	} else {
		if (yych <= 'Q') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'R') goto yy561;
			if (yych != 'r') goto yy440;
		}
	}
yy561:
	YYDEBUG(561, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'U') goto yy562;
	if (yych != 'u') goto yy56;
yy562:
	YYDEBUG(562, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy563;
	if (yych != 'a') goto yy56;
yy563:
	YYDEBUG(563, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy564;
	if (yych != 'r') goto yy56;
yy564:
	YYDEBUG(564, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy504;
	if (yych == 'y') goto yy504;
	goto yy56;
yy565:
	YYDEBUG(565, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy572;
	if (yych <= '6') goto yy573;
	if (yych <= '9') goto yy574;
	goto yy56;
yy566:
	YYDEBUG(566, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(567, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
yy568:
	YYDEBUG(568, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
yy569:
	YYDEBUG(569, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(570, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(571, *YYCURSOR);
#line 1355 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('pointed date YYYY');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->y = timelib_get_nr((char **) &ptr, 4);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_FULL_POINTED;
	}
#line 10518 '<stdout>'
yy572:
	YYDEBUG(572, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych <= '/') goto yy455;
	if (yych <= '9') goto yy577;
	goto yy455;
yy573:
	YYDEBUG(573, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy461;
		goto yy455;
	} else {
		if (yych <= '0') goto yy577;
		if (yych <= '9') goto yy575;
		goto yy455;
	}
yy574:
	YYDEBUG(574, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych <= '/') goto yy455;
	if (yych >= ':') goto yy455;
yy575:
	YYDEBUG(575, *YYCURSOR);
	yyaccept = 11;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy576;
	if (yych <= '9') goto yy569;
yy576:
	YYDEBUG(576, *YYCURSOR);
#line 1367 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('pointed date YY');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->y = timelib_get_nr_ex((char **) &ptr, 2, &length);
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_FULL_POINTED;
	}
#line 10567 '<stdout>'
yy577:
	YYDEBUG(577, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy465;
			if (yych <= 0x1F) goto yy455;
			goto yy465;
		} else {
			if (yych == '.') goto yy461;
			if (yych <= '/') goto yy455;
			goto yy569;
		}
	} else {
		if (yych <= 'P') {
			if (yych == 'A') goto yy467;
			if (yych <= 'O') goto yy455;
			goto yy467;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy455;
				goto yy467;
			} else {
				if (yych == 'p') goto yy467;
				goto yy455;
			}
		}
	}
yy578:
	YYDEBUG(578, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ':') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy472;
			if (yych <= 0x1F) goto yy455;
			goto yy472;
		} else {
			if (yych == '.') goto yy457;
			if (yych <= '9') goto yy455;
			goto yy457;
		}
	} else {
		if (yych <= 'P') {
			if (yych == 'A') goto yy474;
			if (yych <= 'O') goto yy455;
			goto yy474;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy455;
				goto yy474;
			} else {
				if (yych == 'p') goto yy474;
				goto yy455;
			}
		}
	}
yy579:
	YYDEBUG(579, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ':') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy472;
			if (yych <= 0x1F) goto yy455;
			goto yy472;
		} else {
			if (yych <= '-') {
				if (yych <= ',') goto yy455;
				goto yy566;
			} else {
				if (yych <= '.') goto yy565;
				if (yych <= '9') goto yy455;
				goto yy457;
			}
		}
	} else {
		if (yych <= 'P') {
			if (yych == 'A') goto yy474;
			if (yych <= 'O') goto yy455;
			goto yy474;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy455;
				goto yy474;
			} else {
				if (yych == 'p') goto yy474;
				goto yy455;
			}
		}
	}
yy580:
	YYDEBUG(580, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') {
		if (yych <= ',') goto yy56;
		if (yych <= '-') goto yy619;
		goto yy566;
	} else {
		if (yych <= '/') goto yy56;
		if (yych <= '9') goto yy582;
		goto yy56;
	}
yy581:
	YYDEBUG(581, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') {
		if (yych <= ',') goto yy56;
		if (yych <= '-') goto yy619;
		goto yy566;
	} else {
		if (yych <= '/') goto yy56;
		if (yych >= '3') goto yy56;
	}
yy582:
	YYDEBUG(582, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= ',') goto yy56;
	if (yych <= '-') goto yy619;
	if (yych <= '.') goto yy566;
	goto yy56;
yy583:
	YYDEBUG(583, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'A') goto yy615;
		if (yych <= 'T') goto yy56;
		goto yy614;
	} else {
		if (yych <= 'a') {
			if (yych <= '`') goto yy56;
			goto yy615;
		} else {
			if (yych == 'u') goto yy614;
			goto yy56;
		}
	}
yy584:
	YYDEBUG(584, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy612;
	if (yych == 'e') goto yy612;
	goto yy56;
yy585:
	YYDEBUG(585, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy609;
	if (yych == 'a') goto yy609;
	goto yy56;
yy586:
	YYDEBUG(586, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'P') goto yy606;
		if (yych <= 'T') goto yy56;
		goto yy605;
	} else {
		if (yych <= 'p') {
			if (yych <= 'o') goto yy56;
			goto yy606;
		} else {
			if (yych == 'u') goto yy605;
			goto yy56;
		}
	}
yy587:
	YYDEBUG(587, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy602;
	if (yych == 'e') goto yy602;
	goto yy56;
yy588:
	YYDEBUG(588, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy600;
	if (yych == 'c') goto yy600;
	goto yy56;
yy589:
	YYDEBUG(589, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy598;
	if (yych == 'o') goto yy598;
	goto yy56;
yy590:
	YYDEBUG(590, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy591;
	if (yych != 'e') goto yy56;
yy591:
	YYDEBUG(591, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy592;
	if (yych != 'c') goto yy56;
yy592:
	YYDEBUG(592, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych >= '.') goto yy496;
		}
	} else {
		if (yych <= 'D') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'E') goto yy545;
			if (yych == 'e') goto yy545;
			goto yy440;
		}
	}
yy593:
	YYDEBUG(593, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy497;
	if (yych <= '0') goto yy594;
	if (yych <= '2') goto yy595;
	if (yych <= '3') goto yy596;
	goto yy497;
yy594:
	YYDEBUG(594, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy499;
	if (yych <= '9') goto yy597;
	goto yy499;
yy595:
	YYDEBUG(595, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy499;
	if (yych <= '9') goto yy597;
	goto yy499;
yy596:
	YYDEBUG(596, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy499;
	if (yych <= '1') goto yy597;
	if (yych <= '9') goto yy505;
	goto yy499;
yy597:
	YYDEBUG(597, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy499;
	if (yych <= '9') goto yy506;
	goto yy499;
yy598:
	YYDEBUG(598, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'V') goto yy599;
	if (yych != 'v') goto yy56;
yy599:
	YYDEBUG(599, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'D') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'E') goto yy500;
			if (yych == 'e') goto yy500;
			goto yy440;
		}
	}
yy600:
	YYDEBUG(600, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy601;
	if (yych != 't') goto yy56;
yy601:
	YYDEBUG(601, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'N') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'O') goto yy510;
			if (yych == 'o') goto yy510;
			goto yy440;
		}
	}
yy602:
	YYDEBUG(602, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'P') goto yy603;
	if (yych != 'p') goto yy56;
yy603:
	YYDEBUG(603, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'S') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'T') goto yy604;
			if (yych != 't') goto yy440;
		}
	}
yy604:
	YYDEBUG(604, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'D') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'E') goto yy552;
			if (yych == 'e') goto yy552;
			goto yy440;
		}
	}
yy605:
	YYDEBUG(605, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy608;
	if (yych == 'g') goto yy608;
	goto yy56;
yy606:
	YYDEBUG(606, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy607;
	if (yych != 'r') goto yy56;
yy607:
	YYDEBUG(607, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'H') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'I') goto yy516;
			if (yych == 'i') goto yy516;
			goto yy440;
		}
	}
yy608:
	YYDEBUG(608, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'T') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'U') goto yy518;
			if (yych == 'u') goto yy518;
			goto yy440;
		}
	}
yy609:
	YYDEBUG(609, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych == 'R') goto yy610;
		if (yych <= 'X') goto yy56;
		goto yy611;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy56;
		} else {
			if (yych == 'y') goto yy611;
			goto yy56;
		}
	}
yy610:
	YYDEBUG(610, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'B') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'C') goto yy558;
			if (yych == 'c') goto yy558;
			goto yy440;
		}
	}
yy611:
	YYDEBUG(611, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy440;
			goto yy496;
		} else {
			if (yych == ' ') goto yy496;
			goto yy440;
		}
	} else {
		if (yych <= '.') {
			if (yych <= '-') goto yy593;
			goto yy496;
		} else {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		}
	}
yy612:
	YYDEBUG(612, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy613;
	if (yych != 'b') goto yy56;
yy613:
	YYDEBUG(613, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'Q') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'R') goto yy561;
			if (yych == 'r') goto yy561;
			goto yy440;
		}
	}
yy614:
	YYDEBUG(614, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych == 'L') goto yy618;
		if (yych <= 'M') goto yy56;
		goto yy617;
	} else {
		if (yych <= 'l') {
			if (yych <= 'k') goto yy56;
			goto yy618;
		} else {
			if (yych == 'n') goto yy617;
			goto yy56;
		}
	}
yy615:
	YYDEBUG(615, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy616;
	if (yych != 'n') goto yy56;
yy616:
	YYDEBUG(616, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'T') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'U') goto yy523;
			if (yych == 'u') goto yy523;
			goto yy440;
		}
	}
yy617:
	YYDEBUG(617, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'D') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'E') goto yy504;
			if (yych == 'e') goto yy504;
			goto yy440;
		}
	}
yy618:
	YYDEBUG(618, *YYCURSOR);
	yyaccept = 9;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy496;
			goto yy440;
		} else {
			if (yych <= ' ') goto yy496;
			if (yych <= ',') goto yy440;
			if (yych <= '-') goto yy593;
			goto yy496;
		}
	} else {
		if (yych <= 'X') {
			if (yych <= '/') goto yy440;
			if (yych <= '9') goto yy498;
			goto yy440;
		} else {
			if (yych <= 'Y') goto yy504;
			if (yych == 'y') goto yy504;
			goto yy440;
		}
	}
yy619:
	YYDEBUG(619, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '2') goto yy620;
	if (yych <= '3') goto yy622;
	if (yych <= '9') goto yy623;
	goto yy56;
yy620:
	YYDEBUG(620, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '9') goto yy629;
		if (yych >= 'n') goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych >= 'r') goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
		}
	}
yy621:
	YYDEBUG(621, *YYCURSOR);
#line 1326 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('gnudateshort');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_ISO_DATE;
	}
#line 11221 '<stdout>'
yy622:
	YYDEBUG(622, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '1') {
			if (yych <= '/') goto yy621;
			goto yy629;
		} else {
			if (yych <= '9') goto yy568;
			if (yych <= 'm') goto yy621;
			goto yy625;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy623:
	YYDEBUG(623, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '9') goto yy568;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy624:
	YYDEBUG(624, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 't') goto yy628;
	goto yy56;
yy625:
	YYDEBUG(625, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy628;
	goto yy56;
yy626:
	YYDEBUG(626, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy628;
	goto yy56;
yy627:
	YYDEBUG(627, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != 'h') goto yy56;
yy628:
	YYDEBUG(628, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy621;
yy629:
	YYDEBUG(629, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '9') goto yy569;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy630:
	YYDEBUG(630, *YYCURSOR);
	yyaccept = 13;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') {
			if (yych >= '/') goto yy687;
		} else {
			if (yych <= '9') goto yy633;
			if (yych >= 'n') goto yy684;
		}
	} else {
		if (yych <= 'r') {
			if (yych >= 'r') goto yy685;
		} else {
			if (yych <= 's') goto yy683;
			if (yych <= 't') goto yy686;
		}
	}
yy631:
	YYDEBUG(631, *YYCURSOR);
#line 1270 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('americanshort | american');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		if (*ptr == '/') {
			s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
			TIMELIB_PROCESS_YEAR(s->time->y, length);
		}
		TIMELIB_DEINIT;
		return TIMELIB_AMERICAN;
	}
#line 11342 '<stdout>'
yy632:
	YYDEBUG(632, *YYCURSOR);
	yyaccept = 13;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') {
			if (yych <= '.') goto yy631;
			goto yy687;
		} else {
			if (yych <= '1') goto yy633;
			if (yych <= 'm') goto yy631;
			goto yy684;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy631;
			goto yy685;
		} else {
			if (yych <= 's') goto yy683;
			if (yych <= 't') goto yy686;
			goto yy631;
		}
	}
yy633:
	YYDEBUG(633, *YYCURSOR);
	yyaccept = 13;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych == '/') goto yy687;
		if (yych <= 'm') goto yy631;
		goto yy684;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy631;
			goto yy685;
		} else {
			if (yych <= 's') goto yy683;
			if (yych <= 't') goto yy686;
			goto yy631;
		}
	}
yy634:
	YYDEBUG(634, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'A') goto yy682;
		if (yych <= 'T') goto yy56;
		goto yy681;
	} else {
		if (yych <= 'a') {
			if (yych <= '`') goto yy56;
			goto yy682;
		} else {
			if (yych == 'u') goto yy681;
			goto yy56;
		}
	}
yy635:
	YYDEBUG(635, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy680;
	if (yych == 'e') goto yy680;
	goto yy56;
yy636:
	YYDEBUG(636, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy679;
	if (yych == 'a') goto yy679;
	goto yy56;
yy637:
	YYDEBUG(637, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'P') goto yy678;
		if (yych <= 'T') goto yy56;
		goto yy677;
	} else {
		if (yych <= 'p') {
			if (yych <= 'o') goto yy56;
			goto yy678;
		} else {
			if (yych == 'u') goto yy677;
			goto yy56;
		}
	}
yy638:
	YYDEBUG(638, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy675;
	if (yych == 'e') goto yy675;
	goto yy56;
yy639:
	YYDEBUG(639, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy674;
	if (yych == 'c') goto yy674;
	goto yy56;
yy640:
	YYDEBUG(640, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy673;
	if (yych == 'o') goto yy673;
	goto yy56;
yy641:
	YYDEBUG(641, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy642;
	if (yych != 'e') goto yy56;
yy642:
	YYDEBUG(642, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy643;
	if (yych != 'c') goto yy56;
yy643:
	YYDEBUG(643, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '/') goto yy56;
yy644:
	YYDEBUG(644, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(645, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(646, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(647, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(648, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(649, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy650;
	if (yych <= '2') goto yy651;
	goto yy56;
yy650:
	YYDEBUG(650, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy652;
	goto yy56;
yy651:
	YYDEBUG(651, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '5') goto yy56;
yy652:
	YYDEBUG(652, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(653, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '6') goto yy56;
	YYDEBUG(654, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(655, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(656, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy657;
	if (yych <= '6') goto yy658;
	goto yy56;
yy657:
	YYDEBUG(657, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy659;
	goto yy56;
yy658:
	YYDEBUG(658, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '0') goto yy56;
yy659:
	YYDEBUG(659, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '\t') goto yy660;
	if (yych != ' ') goto yy56;
yy660:
	YYDEBUG(660, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = *YYCURSOR;
	YYDEBUG(661, *YYCURSOR);
	if (yych <= '*') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy56;
			goto yy660;
		} else {
			if (yych == ' ') goto yy660;
			goto yy56;
		}
	} else {
		if (yych <= '-') {
			if (yych == ',') goto yy56;
			goto yy663;
		} else {
			if (yych != 'G') goto yy56;
		}
	}
	YYDEBUG(662, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy671;
	goto yy56;
yy663:
	YYDEBUG(663, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy664;
	if (yych <= '2') goto yy666;
	if (yych <= '9') goto yy667;
	goto yy56;
yy664:
	YYDEBUG(664, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '/') goto yy665;
	if (yych <= '9') goto yy667;
	if (yych <= ':') goto yy668;
yy665:
	YYDEBUG(665, *YYCURSOR);
#line 1553 'ext/date/lib/parse_date.re'
	{
		int tz_not_found;
		DEBUG_OUTPUT('clf');
		TIMELIB_INIT;
		TIMELIB_HAVE_TIME();
		TIMELIB_HAVE_DATE();
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->y = timelib_get_nr((char **) &ptr, 4);
		s->time->h = timelib_get_nr((char **) &ptr, 2);
		s->time->i = timelib_get_nr((char **) &ptr, 2);
		s->time->s = timelib_get_nr((char **) &ptr, 2);
		s->time->z = timelib_parse_zone((char **) &ptr, &s->time->dst, s->time, &tz_not_found, s->tzdb, tz_get_wrapper);
		if (tz_not_found) {
			add_error(s, 'The timezone could not be found in the database');
		}
		TIMELIB_DEINIT;
		return TIMELIB_CLF;
	}
#line 11595 '<stdout>'
yy666:
	YYDEBUG(666, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '5') {
		if (yych <= '/') goto yy665;
		if (yych >= '5') goto yy669;
	} else {
		if (yych <= '9') goto yy670;
		if (yych <= ':') goto yy668;
		goto yy665;
	}
yy667:
	YYDEBUG(667, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy665;
	if (yych <= '5') goto yy669;
	if (yych <= '9') goto yy670;
	if (yych >= ';') goto yy665;
yy668:
	YYDEBUG(668, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy665;
	if (yych <= '5') goto yy669;
	if (yych <= '9') goto yy670;
	goto yy665;
yy669:
	YYDEBUG(669, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy665;
	if (yych >= ':') goto yy665;
yy670:
	YYDEBUG(670, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy665;
yy671:
	YYDEBUG(671, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != 'T') goto yy56;
	YYDEBUG(672, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '+') goto yy663;
	if (yych == '-') goto yy663;
	goto yy56;
yy673:
	YYDEBUG(673, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'V') goto yy643;
	if (yych == 'v') goto yy643;
	goto yy56;
yy674:
	YYDEBUG(674, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy643;
	if (yych == 't') goto yy643;
	goto yy56;
yy675:
	YYDEBUG(675, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'P') goto yy676;
	if (yych != 'p') goto yy56;
yy676:
	YYDEBUG(676, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych == '/') goto yy644;
		goto yy56;
	} else {
		if (yych <= 'T') goto yy643;
		if (yych == 't') goto yy643;
		goto yy56;
	}
yy677:
	YYDEBUG(677, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy643;
	if (yych == 'g') goto yy643;
	goto yy56;
yy678:
	YYDEBUG(678, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy643;
	if (yych == 'r') goto yy643;
	goto yy56;
yy679:
	YYDEBUG(679, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych == 'R') goto yy643;
		if (yych <= 'X') goto yy56;
		goto yy643;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy56;
			goto yy643;
		} else {
			if (yych == 'y') goto yy643;
			goto yy56;
		}
	}
yy680:
	YYDEBUG(680, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy643;
	if (yych == 'b') goto yy643;
	goto yy56;
yy681:
	YYDEBUG(681, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych == 'L') goto yy643;
		if (yych <= 'M') goto yy56;
		goto yy643;
	} else {
		if (yych <= 'l') {
			if (yych <= 'k') goto yy56;
			goto yy643;
		} else {
			if (yych == 'n') goto yy643;
			goto yy56;
		}
	}
yy682:
	YYDEBUG(682, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy643;
	if (yych == 'n') goto yy643;
	goto yy56;
yy683:
	YYDEBUG(683, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 't') goto yy692;
	goto yy56;
yy684:
	YYDEBUG(684, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy692;
	goto yy56;
yy685:
	YYDEBUG(685, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy692;
	goto yy56;
yy686:
	YYDEBUG(686, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'h') goto yy692;
	goto yy56;
yy687:
	YYDEBUG(687, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(688, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy631;
	if (yych >= ':') goto yy631;
	YYDEBUG(689, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy631;
	if (yych >= ':') goto yy631;
	YYDEBUG(690, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy631;
	if (yych >= ':') goto yy631;
	YYDEBUG(691, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy631;
yy692:
	YYDEBUG(692, *YYCURSOR);
	yyaccept = 13;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '/') goto yy687;
	goto yy631;
yy693:
	YYDEBUG(693, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= ',') {
		if (yych == '\t') goto yy695;
		goto yy542;
	} else {
		if (yych <= '-') goto yy696;
		if (yych <= '.') goto yy695;
		if (yych >= '0') goto yy542;
	}
yy694:
	YYDEBUG(694, *YYCURSOR);
	yych = *++YYCURSOR;
	switch (yych) {
	case 'A':
	case 'a':	goto yy637;
	case 'D':
	case 'd':	goto yy641;
	case 'F':
	case 'f':	goto yy635;
	case 'J':
	case 'j':	goto yy634;
	case 'M':
	case 'm':	goto yy636;
	case 'N':
	case 'n':	goto yy640;
	case 'O':
	case 'o':	goto yy639;
	case 'S':
	case 's':	goto yy638;
	default:	goto yy56;
	}
yy695:
	YYDEBUG(695, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy542;
	if (yych <= '0') goto yy700;
	if (yych <= '1') goto yy701;
	if (yych <= '9') goto yy702;
	goto yy542;
yy696:
	YYDEBUG(696, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy542;
	if (yych <= '0') goto yy697;
	if (yych <= '1') goto yy698;
	if (yych <= '9') goto yy699;
	goto yy542;
yy697:
	YYDEBUG(697, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= ',') goto yy56;
	if (yych <= '.') goto yy566;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy699;
	goto yy56;
yy698:
	YYDEBUG(698, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= ',') goto yy56;
	if (yych <= '.') goto yy566;
	if (yych <= '/') goto yy56;
	if (yych >= '3') goto yy56;
yy699:
	YYDEBUG(699, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= ',') goto yy56;
	if (yych <= '.') goto yy566;
	goto yy56;
yy700:
	YYDEBUG(700, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') {
		if (yych <= ',') goto yy56;
		if (yych <= '-') goto yy566;
		goto yy703;
	} else {
		if (yych <= '/') goto yy56;
		if (yych <= '9') goto yy702;
		goto yy56;
	}
yy701:
	YYDEBUG(701, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') {
		if (yych <= ',') goto yy56;
		if (yych <= '-') goto yy566;
		goto yy703;
	} else {
		if (yych <= '/') goto yy56;
		if (yych >= '3') goto yy56;
	}
yy702:
	YYDEBUG(702, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= ',') goto yy56;
	if (yych <= '-') goto yy566;
	if (yych >= '/') goto yy56;
yy703:
	YYDEBUG(703, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(704, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy575;
	goto yy56;
yy705:
	YYDEBUG(705, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '-') goto yy749;
	if (yych <= '/') goto yy60;
	if (yych <= '9') goto yy747;
	goto yy60;
yy706:
	YYDEBUG(706, *YYCURSOR);
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':	goto yy715;
	case '1':	goto yy716;
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy717;
	case 'A':
	case 'a':	goto yy710;
	case 'D':
	case 'd':	goto yy714;
	case 'F':
	case 'f':	goto yy708;
	case 'J':
	case 'j':	goto yy707;
	case 'M':
	case 'm':	goto yy709;
	case 'N':
	case 'n':	goto yy713;
	case 'O':
	case 'o':	goto yy712;
	case 'S':
	case 's':	goto yy711;
	default:	goto yy56;
	}
yy707:
	YYDEBUG(707, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'A') goto yy746;
		if (yych <= 'T') goto yy56;
		goto yy745;
	} else {
		if (yych <= 'a') {
			if (yych <= '`') goto yy56;
			goto yy746;
		} else {
			if (yych == 'u') goto yy745;
			goto yy56;
		}
	}
yy708:
	YYDEBUG(708, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy744;
	if (yych == 'e') goto yy744;
	goto yy56;
yy709:
	YYDEBUG(709, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy743;
	if (yych == 'a') goto yy743;
	goto yy56;
yy710:
	YYDEBUG(710, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'P') goto yy742;
		if (yych <= 'T') goto yy56;
		goto yy741;
	} else {
		if (yych <= 'p') {
			if (yych <= 'o') goto yy56;
			goto yy742;
		} else {
			if (yych == 'u') goto yy741;
			goto yy56;
		}
	}
yy711:
	YYDEBUG(711, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy739;
	if (yych == 'e') goto yy739;
	goto yy56;
yy712:
	YYDEBUG(712, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy738;
	if (yych == 'c') goto yy738;
	goto yy56;
yy713:
	YYDEBUG(713, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy737;
	if (yych == 'o') goto yy737;
	goto yy56;
yy714:
	YYDEBUG(714, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy729;
	if (yych == 'e') goto yy729;
	goto yy56;
yy715:
	YYDEBUG(715, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '-') goto yy718;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy722;
	goto yy56;
yy716:
	YYDEBUG(716, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '-') goto yy718;
	if (yych <= '/') goto yy56;
	if (yych <= '2') goto yy722;
	goto yy56;
yy717:
	YYDEBUG(717, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '-') goto yy56;
yy718:
	YYDEBUG(718, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '2') goto yy719;
	if (yych <= '3') goto yy720;
	if (yych <= '9') goto yy721;
	goto yy56;
yy719:
	YYDEBUG(719, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '9') goto yy721;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy720:
	YYDEBUG(720, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '1') goto yy721;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy721:
	YYDEBUG(721, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'q') {
		if (yych == 'n') goto yy625;
		goto yy621;
	} else {
		if (yych <= 'r') goto yy626;
		if (yych <= 's') goto yy624;
		if (yych <= 't') goto yy627;
		goto yy621;
	}
yy722:
	YYDEBUG(722, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '-') goto yy56;
	YYDEBUG(723, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '2') {
		if (yych <= '/') goto yy56;
		if (yych >= '1') goto yy725;
	} else {
		if (yych <= '3') goto yy726;
		if (yych <= '9') goto yy721;
		goto yy56;
	}
	YYDEBUG(724, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '9') goto yy727;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy725:
	YYDEBUG(725, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '9') goto yy727;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy726:
	YYDEBUG(726, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '1') goto yy727;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy727:
	YYDEBUG(727, *YYCURSOR);
	yyaccept = 14;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'q') {
		if (yych == 'n') goto yy625;
	} else {
		if (yych <= 'r') goto yy626;
		if (yych <= 's') goto yy624;
		if (yych <= 't') goto yy627;
	}
yy728:
	YYDEBUG(728, *YYCURSOR);
#line 1298 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('iso8601date2');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_ISO_DATE;
	}
#line 12158 '<stdout>'
yy729:
	YYDEBUG(729, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy730;
	if (yych != 'c') goto yy56;
yy730:
	YYDEBUG(730, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '-') goto yy56;
yy731:
	YYDEBUG(731, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy732;
	if (yych <= '2') goto yy733;
	if (yych <= '3') goto yy734;
	goto yy56;
yy732:
	YYDEBUG(732, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy735;
	goto yy56;
yy733:
	YYDEBUG(733, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy735;
	goto yy56;
yy734:
	YYDEBUG(734, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '2') goto yy56;
yy735:
	YYDEBUG(735, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(736, *YYCURSOR);
#line 1539 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('pgtextreverse');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_PG_TEXT;
	}
#line 12210 '<stdout>'
yy737:
	YYDEBUG(737, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'V') goto yy730;
	if (yych == 'v') goto yy730;
	goto yy56;
yy738:
	YYDEBUG(738, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy730;
	if (yych == 't') goto yy730;
	goto yy56;
yy739:
	YYDEBUG(739, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'P') goto yy740;
	if (yych != 'p') goto yy56;
yy740:
	YYDEBUG(740, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych == '-') goto yy731;
		goto yy56;
	} else {
		if (yych <= 'T') goto yy730;
		if (yych == 't') goto yy730;
		goto yy56;
	}
yy741:
	YYDEBUG(741, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy730;
	if (yych == 'g') goto yy730;
	goto yy56;
yy742:
	YYDEBUG(742, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy730;
	if (yych == 'r') goto yy730;
	goto yy56;
yy743:
	YYDEBUG(743, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych == 'R') goto yy730;
		if (yych <= 'X') goto yy56;
		goto yy730;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy56;
			goto yy730;
		} else {
			if (yych == 'y') goto yy730;
			goto yy56;
		}
	}
yy744:
	YYDEBUG(744, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy730;
	if (yych == 'b') goto yy730;
	goto yy56;
yy745:
	YYDEBUG(745, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych == 'L') goto yy730;
		if (yych <= 'M') goto yy56;
		goto yy730;
	} else {
		if (yych <= 'l') {
			if (yych <= 'k') goto yy56;
			goto yy730;
		} else {
			if (yych == 'n') goto yy730;
			goto yy56;
		}
	}
yy746:
	YYDEBUG(746, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy730;
	if (yych == 'n') goto yy730;
	goto yy56;
yy747:
	YYDEBUG(747, *YYCURSOR);
	yyaccept = 15;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'O') {
		if (yych <= '3') {
			if (yych <= '-') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy755;
				} else {
					if (yych <= ' ') goto yy755;
					if (yych >= '-') goto yy752;
				}
			} else {
				if (yych <= '0') {
					if (yych <= '.') goto yy756;
					if (yych <= '/') goto yy753;
					goto yy769;
				} else {
					if (yych <= '1') goto yy770;
					if (yych <= '2') goto yy772;
					goto yy773;
				}
			}
		} else {
			if (yych <= 'D') {
				if (yych <= '@') {
					if (yych <= '9') goto yy54;
					if (yych <= ':') goto yy771;
				} else {
					if (yych <= 'A') goto yy755;
					if (yych >= 'D') goto yy755;
				}
			} else {
				if (yych <= 'G') {
					if (yych == 'F') goto yy755;
				} else {
					if (yych <= 'J') goto yy755;
					if (yych >= 'M') goto yy755;
				}
			}
		}
	} else {
		if (yych <= 'h') {
			if (yych <= 'a') {
				if (yych <= 'W') {
					if (yych <= 'R') goto yy748;
					if (yych <= 'V') goto yy755;
					goto yy774;
				} else {
					if (yych <= 'Y') goto yy755;
					if (yych >= 'a') goto yy755;
				}
			} else {
				if (yych <= 'e') {
					if (yych == 'd') goto yy755;
				} else {
					if (yych != 'g') goto yy755;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'l') {
					if (yych == 'j') goto yy755;
				} else {
					if (yych <= 'o') goto yy755;
					if (yych >= 's') goto yy755;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy755;
				} else {
					if (yych <= 'y') goto yy755;
					if (yych == 0xC2) goto yy755;
				}
			}
		}
	}
yy748:
	YYDEBUG(748, *YYCURSOR);
#line 1574 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('year4');
		TIMELIB_INIT;
		s->time->y = timelib_get_nr((char **) &ptr, 4);
		TIMELIB_DEINIT;
		return TIMELIB_CLF;
	}
#line 12383 '<stdout>'
yy749:
	YYDEBUG(749, *YYCURSOR);
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':	goto yy750;
	case '1':	goto yy751;
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy717;
	case 'A':
	case 'a':	goto yy710;
	case 'D':
	case 'd':	goto yy714;
	case 'F':
	case 'f':	goto yy708;
	case 'J':
	case 'j':	goto yy707;
	case 'M':
	case 'm':	goto yy709;
	case 'N':
	case 'n':	goto yy713;
	case 'O':
	case 'o':	goto yy712;
	case 'S':
	case 's':	goto yy711;
	default:	goto yy56;
	}
yy750:
	YYDEBUG(750, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '-') goto yy718;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy717;
	goto yy56;
yy751:
	YYDEBUG(751, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '-') goto yy718;
	if (yych <= '/') goto yy56;
	if (yych <= '2') goto yy717;
	goto yy56;
yy752:
	YYDEBUG(752, *YYCURSOR);
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':	goto yy937;
	case '1':	goto yy939;
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy940;
	case 'A':
	case 'a':	goto yy931;
	case 'D':
	case 'd':	goto yy935;
	case 'F':
	case 'f':	goto yy929;
	case 'J':
	case 'j':	goto yy928;
	case 'M':
	case 'm':	goto yy930;
	case 'N':
	case 'n':	goto yy934;
	case 'O':
	case 'o':	goto yy933;
	case 'S':
	case 's':	goto yy932;
	case 'W':	goto yy936;
	default:	goto yy903;
	}
yy753:
	YYDEBUG(753, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy911;
	if (yych <= '1') goto yy912;
	if (yych <= '9') goto yy913;
	goto yy56;
yy754:
	YYDEBUG(754, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 12) YYFILL(12);
	yych = *YYCURSOR;
yy755:
	YYDEBUG(755, *YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'G') {
			if (yych <= '.') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy754;
					goto yy56;
				} else {
					if (yych <= ' ') goto yy754;
					if (yych <= ',') goto yy56;
					goto yy902;
				}
			} else {
				if (yych <= 'C') {
					if (yych == 'A') goto yy764;
					goto yy56;
				} else {
					if (yych <= 'D') goto yy768;
					if (yych == 'F') goto yy762;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'N') {
				if (yych <= 'J') {
					if (yych <= 'H') goto yy65;
					if (yych <= 'I') goto yy757;
					goto yy761;
				} else {
					if (yych <= 'L') goto yy56;
					if (yych <= 'M') goto yy763;
					goto yy767;
				}
			} else {
				if (yych <= 'S') {
					if (yych <= 'O') goto yy766;
					if (yych <= 'R') goto yy56;
					goto yy765;
				} else {
					if (yych <= 'T') goto yy70;
					if (yych <= 'U') goto yy63;
					if (yych <= 'V') goto yy759;
					goto yy69;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych <= '`') {
					if (yych <= 'X') goto yy760;
					if (yych <= 'Y') goto yy68;
					goto yy56;
				} else {
					if (yych <= 'a') goto yy764;
					if (yych <= 'c') goto yy56;
					goto yy768;
				}
			} else {
				if (yych <= 'g') {
					if (yych == 'f') goto yy762;
					goto yy56;
				} else {
					if (yych <= 'h') goto yy65;
					if (yych == 'j') goto yy761;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'o') {
					if (yych <= 'm') goto yy763;
					if (yych <= 'n') goto yy767;
					goto yy766;
				} else {
					if (yych <= 'r') goto yy56;
					if (yych <= 's') goto yy765;
					if (yych <= 't') goto yy70;
					goto yy63;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy69;
					goto yy56;
				} else {
					if (yych <= 'y') goto yy68;
					if (yych == 0xC2) goto yy62;
					goto yy56;
				}
			}
		}
	}
yy756:
	YYDEBUG(756, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy903;
	if (yych <= '0') goto yy895;
	if (yych <= '2') goto yy896;
	if (yych <= '3') goto yy897;
	goto yy903;
yy757:
	YYDEBUG(757, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= 'U') {
		if (yych == 'I') goto yy894;
	} else {
		if (yych == 'W') goto yy758;
		if (yych <= 'X') goto yy848;
	}
yy758:
	YYDEBUG(758, *YYCURSOR);
#line 1395 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('datenodayrev');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		s->time->m = timelib_get_month((char **) &ptr);
		s->time->d = 1;
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_NO_DAY;
	}
#line 12601 '<stdout>'
yy759:
	YYDEBUG(759, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy892;
	goto yy758;
yy760:
	YYDEBUG(760, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy891;
	goto yy758;
yy761:
	YYDEBUG(761, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'A') goto yy884;
		if (yych <= 'T') goto yy56;
		goto yy883;
	} else {
		if (yych <= 'a') {
			if (yych <= '`') goto yy56;
			goto yy884;
		} else {
			if (yych == 'u') goto yy883;
			goto yy56;
		}
	}
yy762:
	YYDEBUG(762, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= 'N') {
			if (yych == 'E') goto yy877;
			goto yy56;
		} else {
			if (yych <= 'O') goto yy100;
			if (yych <= 'Q') goto yy56;
			goto yy99;
		}
	} else {
		if (yych <= 'n') {
			if (yych == 'e') goto yy877;
			goto yy56;
		} else {
			if (yych <= 'o') goto yy100;
			if (yych == 'r') goto yy99;
			goto yy56;
		}
	}
yy763:
	YYDEBUG(763, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= 'I') {
			if (yych == 'A') goto yy874;
			if (yych <= 'H') goto yy56;
			goto yy138;
		} else {
			if (yych == 'O') goto yy137;
			if (yych <= 'R') goto yy56;
			goto yy139;
		}
	} else {
		if (yych <= 'i') {
			if (yych == 'a') goto yy874;
			if (yych <= 'h') goto yy56;
			goto yy138;
		} else {
			if (yych <= 'o') {
				if (yych <= 'n') goto yy56;
				goto yy137;
			} else {
				if (yych == 's') goto yy139;
				goto yy56;
			}
		}
	}
yy764:
	YYDEBUG(764, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'P') goto yy868;
		if (yych <= 'T') goto yy56;
		goto yy867;
	} else {
		if (yych <= 'p') {
			if (yych <= 'o') goto yy56;
			goto yy868;
		} else {
			if (yych == 'u') goto yy867;
			goto yy56;
		}
	}
yy765:
	YYDEBUG(765, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= 'D') {
			if (yych == 'A') goto yy119;
			goto yy56;
		} else {
			if (yych <= 'E') goto yy860;
			if (yych <= 'T') goto yy56;
			goto yy118;
		}
	} else {
		if (yych <= 'd') {
			if (yych == 'a') goto yy119;
			goto yy56;
		} else {
			if (yych <= 'e') goto yy860;
			if (yych == 'u') goto yy118;
			goto yy56;
		}
	}
yy766:
	YYDEBUG(766, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy855;
	if (yych == 'c') goto yy855;
	goto yy56;
yy767:
	YYDEBUG(767, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy849;
	if (yych == 'o') goto yy849;
	goto yy56;
yy768:
	YYDEBUG(768, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych == 'A') goto yy115;
		if (yych <= 'D') goto yy56;
		goto yy842;
	} else {
		if (yych <= 'a') {
			if (yych <= '`') goto yy56;
			goto yy115;
		} else {
			if (yych == 'e') goto yy842;
			goto yy56;
		}
	}
yy769:
	YYDEBUG(769, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '0') goto yy839;
	if (yych <= '9') goto yy840;
	goto yy60;
yy770:
	YYDEBUG(770, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '2') goto yy808;
	if (yych <= '9') goto yy787;
	goto yy60;
yy771:
	YYDEBUG(771, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy788;
	if (yych <= '1') goto yy789;
	goto yy56;
yy772:
	YYDEBUG(772, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '9') goto yy787;
	goto yy60;
yy773:
	YYDEBUG(773, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '5') goto yy783;
	if (yych <= '6') goto yy784;
	if (yych <= '9') goto yy54;
	goto yy60;
yy774:
	YYDEBUG(774, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '5') {
		if (yych <= '/') goto yy56;
		if (yych <= '0') goto yy775;
		if (yych <= '4') goto yy776;
		goto yy777;
	} else {
		if (yych <= 'E') {
			if (yych <= 'D') goto yy56;
			goto yy84;
		} else {
			if (yych == 'e') goto yy84;
			goto yy56;
		}
	}
yy775:
	YYDEBUG(775, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '0') goto yy56;
	if (yych <= '9') goto yy778;
	goto yy56;
yy776:
	YYDEBUG(776, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy778;
	goto yy56;
yy777:
	YYDEBUG(777, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '4') goto yy56;
yy778:
	YYDEBUG(778, *YYCURSOR);
	yyaccept = 16;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '-') goto yy780;
	if (yych <= '/') goto yy779;
	if (yych <= '7') goto yy781;
yy779:
	YYDEBUG(779, *YYCURSOR);
#line 1506 'ext/date/lib/parse_date.re'
	{
		timelib_sll w, d;
		DEBUG_OUTPUT('isoweek');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		TIMELIB_HAVE_RELATIVE();

		s->time->y = timelib_get_nr((char **) &ptr, 4);
		w = timelib_get_nr((char **) &ptr, 2);
		d = 1;
		s->time->m = 1;
		s->time->d = 1;
		s->time->relative.d = timelib_daynr_from_weeknr(s->time->y, w, d);

		TIMELIB_DEINIT;
		return TIMELIB_ISO_WEEK;
	}
#line 12840 '<stdout>'
yy780:
	YYDEBUG(780, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '8') goto yy56;
yy781:
	YYDEBUG(781, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(782, *YYCURSOR);
#line 1487 'ext/date/lib/parse_date.re'
	{
		timelib_sll w, d;
		DEBUG_OUTPUT('isoweekday');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		TIMELIB_HAVE_RELATIVE();

		s->time->y = timelib_get_nr((char **) &ptr, 4);
		w = timelib_get_nr((char **) &ptr, 2);
		d = timelib_get_nr((char **) &ptr, 1);
		s->time->m = 1;
		s->time->d = 1;
		s->time->relative.d = timelib_daynr_from_weeknr(s->time->y, w, d);

		TIMELIB_DEINIT;
		return TIMELIB_ISO_WEEK;
	}
#line 12868 '<stdout>'
yy783:
	YYDEBUG(783, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '9') goto yy785;
	goto yy60;
yy784:
	YYDEBUG(784, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '6') goto yy785;
	if (yych <= '9') goto yy54;
	goto yy60;
yy785:
	YYDEBUG(785, *YYCURSOR);
	yyaccept = 17;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 2) {
		goto yy54;
	}
	if (yych <= 'X') {
		if (yych <= 'F') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych >= ' ') goto yy60;
			} else {
				if (yych == 'D') goto yy60;
				if (yych >= 'F') goto yy60;
			}
		} else {
			if (yych <= 'M') {
				if (yych == 'H') goto yy60;
				if (yych >= 'M') goto yy60;
			} else {
				if (yych <= 'U') {
					if (yych >= 'S') goto yy60;
				} else {
					if (yych == 'W') goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'e') {
				if (yych <= 'Y') goto yy60;
				if (yych == 'd') goto yy60;
			} else {
				if (yych <= 'g') {
					if (yych <= 'f') goto yy60;
				} else {
					if (yych <= 'h') goto yy60;
					if (yych >= 'm') goto yy60;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') goto yy786;
				if (yych != 'v') goto yy60;
			} else {
				if (yych <= 'y') {
					if (yych >= 'y') goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
				}
			}
		}
	}
yy786:
	YYDEBUG(786, *YYCURSOR);
#line 1473 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('pgydotd');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		s->time->d = timelib_get_nr((char **) &ptr, 3);
		s->time->m = 1;
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_PG_YEARDAY;
	}
#line 12951 '<stdout>'
yy787:
	YYDEBUG(787, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '9') goto yy785;
	goto yy60;
yy788:
	YYDEBUG(788, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy790;
	goto yy56;
yy789:
	YYDEBUG(789, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '3') goto yy56;
yy790:
	YYDEBUG(790, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(791, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy792;
	if (yych <= '2') goto yy793;
	if (yych <= '3') goto yy794;
	goto yy56;
yy792:
	YYDEBUG(792, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy795;
	goto yy56;
yy793:
	YYDEBUG(793, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy795;
	goto yy56;
yy794:
	YYDEBUG(794, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '2') goto yy56;
yy795:
	YYDEBUG(795, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ' ') goto yy56;
	YYDEBUG(796, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy797;
	if (yych <= '2') goto yy798;
	goto yy56;
yy797:
	YYDEBUG(797, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy799;
	goto yy56;
yy798:
	YYDEBUG(798, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '5') goto yy56;
yy799:
	YYDEBUG(799, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(800, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '6') goto yy56;
	YYDEBUG(801, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(802, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(803, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy804;
	if (yych <= '6') goto yy805;
	goto yy56;
yy804:
	YYDEBUG(804, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy806;
	goto yy56;
yy805:
	YYDEBUG(805, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '0') goto yy56;
yy806:
	YYDEBUG(806, *YYCURSOR);
	++YYCURSOR;
yy807:
	YYDEBUG(807, *YYCURSOR);
#line 1447 'ext/date/lib/parse_date.re'
	{
		int tz_not_found;
		DEBUG_OUTPUT('xmlrpc | xmlrpcnocolon | soap | wddx | exif');
		TIMELIB_INIT;
		TIMELIB_HAVE_TIME();
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_nr((char **) &ptr, 4);
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		s->time->h = timelib_get_nr((char **) &ptr, 2);
		s->time->i = timelib_get_nr((char **) &ptr, 2);
		s->time->s = timelib_get_nr((char **) &ptr, 2);
		if (*ptr == '.') {
			s->time->f = timelib_get_frac_nr((char **) &ptr, 9);
			if (*ptr) { /* timezone is optional */
				s->time->z = timelib_parse_zone((char **) &ptr, &s->time->dst, s->time, &tz_not_found, s->tzdb, tz_get_wrapper);
				if (tz_not_found) {
					add_error(s, 'The timezone could not be found in the database');
				}
			}
		}
		TIMELIB_DEINIT;
		return TIMELIB_XMLRPC_SOAP;
	}
#line 13079 '<stdout>'
yy808:
	YYDEBUG(808, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '2') {
		if (yych <= '/') goto yy60;
		if (yych >= '1') goto yy810;
	} else {
		if (yych <= '3') goto yy811;
		if (yych <= '9') goto yy785;
		goto yy60;
	}
yy809:
	YYDEBUG(809, *YYCURSOR);
	yyaccept = 17;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy786;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy786;
					goto yy812;
				} else {
					if (yych == 'D') goto yy60;
					goto yy786;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy786;
				if (yych <= 'H') goto yy60;
				goto yy786;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy786;
				} else {
					if (yych == 'V') goto yy786;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy786;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy786;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy786;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy786;
				} else {
					if (yych == 'v') goto yy786;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy786;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy786;
				}
			}
		}
	}
yy810:
	YYDEBUG(810, *YYCURSOR);
	yyaccept = 17;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy786;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy786;
					goto yy812;
				} else {
					if (yych == 'D') goto yy60;
					goto yy786;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy786;
				if (yych <= 'H') goto yy60;
				goto yy786;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy786;
				} else {
					if (yych == 'V') goto yy786;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy786;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy786;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy786;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy786;
				} else {
					if (yych == 'v') goto yy786;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy786;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy786;
				}
			}
		}
	}
yy811:
	YYDEBUG(811, *YYCURSOR);
	yyaccept = 17;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'D') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy786;
				goto yy60;
			} else {
				if (yych <= '1') {
					if (yych <= '/') goto yy786;
				} else {
					if (yych <= '9') goto yy54;
					if (yych <= 'C') goto yy786;
					goto yy60;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych <= 'F') {
					if (yych <= 'E') goto yy786;
					goto yy60;
				} else {
					if (yych == 'H') goto yy60;
					goto yy786;
				}
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy786;
				} else {
					if (yych == 'V') goto yy786;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy786;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy786;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy786;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy786;
				} else {
					if (yych == 'v') goto yy786;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy786;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy786;
				}
			}
		}
	}
yy812:
	YYDEBUG(812, *YYCURSOR);
	yyaccept = 18;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 2) {
		goto yy54;
	}
	if (yych <= 'X') {
		if (yych <= 'G') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy59;
				if (yych >= ' ') goto yy59;
			} else {
				if (yych <= 'D') {
					if (yych >= 'D') goto yy66;
				} else {
					if (yych == 'F') goto yy67;
				}
			}
		} else {
			if (yych <= 'S') {
				if (yych <= 'L') {
					if (yych <= 'H') goto yy65;
				} else {
					if (yych <= 'M') goto yy61;
					if (yych >= 'S') goto yy64;
				}
			} else {
				if (yych <= 'U') {
					if (yych <= 'T') goto yy814;
					goto yy63;
				} else {
					if (yych == 'W') goto yy69;
				}
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'f') {
				if (yych <= 'c') {
					if (yych <= 'Y') goto yy68;
				} else {
					if (yych <= 'd') goto yy66;
					if (yych >= 'f') goto yy67;
				}
			} else {
				if (yych <= 'h') {
					if (yych >= 'h') goto yy65;
				} else {
					if (yych == 'm') goto yy61;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 't') {
					if (yych <= 's') goto yy64;
					goto yy815;
				} else {
					if (yych <= 'u') goto yy63;
					if (yych >= 'w') goto yy69;
				}
			} else {
				if (yych <= 'y') {
					if (yych >= 'y') goto yy68;
				} else {
					if (yych == 0xC2) goto yy62;
				}
			}
		}
	}
yy813:
	YYDEBUG(813, *YYCURSOR);
#line 1435 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('datenocolon');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_nr((char **) &ptr, 4);
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->d = timelib_get_nr((char **) &ptr, 2);
		TIMELIB_DEINIT;
		return TIMELIB_DATE_NOCOLON;
	}
#line 13385 '<stdout>'
yy814:
	YYDEBUG(814, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= '2') {
			if (yych <= '/') goto yy56;
			if (yych <= '1') goto yy829;
			goto yy830;
		} else {
			if (yych <= '9') goto yy831;
			if (yych <= 'G') goto yy56;
			goto yy71;
		}
	} else {
		if (yych <= 'g') {
			if (yych == 'U') goto yy72;
			goto yy56;
		} else {
			if (yych <= 'h') goto yy71;
			if (yych == 'u') goto yy72;
			goto yy56;
		}
	}
yy815:
	YYDEBUG(815, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= '2') {
			if (yych <= '/') goto yy56;
			if (yych >= '2') goto yy817;
		} else {
			if (yych <= '9') goto yy818;
			if (yych <= 'G') goto yy56;
			goto yy71;
		}
	} else {
		if (yych <= 'g') {
			if (yych == 'U') goto yy72;
			goto yy56;
		} else {
			if (yych <= 'h') goto yy71;
			if (yych == 'u') goto yy72;
			goto yy56;
		}
	}
	YYDEBUG(816, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy823;
	if (yych <= '9') goto yy818;
	goto yy56;
yy817:
	YYDEBUG(817, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '4') goto yy823;
	if (yych <= '5') goto yy819;
	goto yy56;
yy818:
	YYDEBUG(818, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '6') goto yy56;
yy819:
	YYDEBUG(819, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
yy820:
	YYDEBUG(820, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy821;
	if (yych <= '6') goto yy822;
	goto yy56;
yy821:
	YYDEBUG(821, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy806;
	goto yy56;
yy822:
	YYDEBUG(822, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '0') goto yy806;
	goto yy56;
yy823:
	YYDEBUG(823, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy824;
	if (yych <= '9') goto yy820;
	goto yy56;
yy824:
	YYDEBUG(824, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy825;
	if (yych <= '6') goto yy826;
	if (yych <= '9') goto yy820;
	goto yy56;
yy825:
	YYDEBUG(825, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy827;
	if (yych <= '6') goto yy828;
	if (yych <= '9') goto yy806;
	goto yy56;
yy826:
	YYDEBUG(826, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy827;
	if (yych <= '5') goto yy821;
	if (yych <= '6') goto yy822;
	goto yy56;
yy827:
	YYDEBUG(827, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy807;
	if (yych <= '9') goto yy806;
	goto yy807;
yy828:
	YYDEBUG(828, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '0') goto yy806;
	goto yy807;
yy829:
	YYDEBUG(829, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy838;
	if (yych <= '9') goto yy831;
	if (yych <= ':') goto yy832;
	goto yy56;
yy830:
	YYDEBUG(830, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '5') {
		if (yych <= '/') goto yy56;
		if (yych <= '4') goto yy838;
		goto yy819;
	} else {
		if (yych == ':') goto yy832;
		goto yy56;
	}
yy831:
	YYDEBUG(831, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy819;
	if (yych != ':') goto yy56;
yy832:
	YYDEBUG(832, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= '6') goto yy56;
	YYDEBUG(833, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(834, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(835, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy836;
	if (yych <= '6') goto yy837;
	goto yy56;
yy836:
	YYDEBUG(836, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy806;
	goto yy56;
yy837:
	YYDEBUG(837, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '0') goto yy806;
	goto yy56;
yy838:
	YYDEBUG(838, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy824;
	if (yych <= '9') goto yy820;
	if (yych <= ':') goto yy832;
	goto yy56;
yy839:
	YYDEBUG(839, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '2') {
		if (yych <= '/') goto yy60;
		if (yych <= '0') goto yy841;
		goto yy810;
	} else {
		if (yych <= '3') goto yy811;
		if (yych <= '9') goto yy785;
		goto yy60;
	}
yy840:
	YYDEBUG(840, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '2') {
		if (yych <= '/') goto yy60;
		if (yych <= '0') goto yy809;
		goto yy810;
	} else {
		if (yych <= '3') goto yy811;
		if (yych <= '9') goto yy785;
		goto yy60;
	}
yy841:
	YYDEBUG(841, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '9') goto yy812;
	goto yy60;
yy842:
	YYDEBUG(842, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy843;
	if (yych != 'c') goto yy56;
yy843:
	YYDEBUG(843, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'E') goto yy844;
	if (yych != 'e') goto yy758;
yy844:
	YYDEBUG(844, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy845;
	if (yych != 'm') goto yy56;
yy845:
	YYDEBUG(845, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy846;
	if (yych != 'b') goto yy56;
yy846:
	YYDEBUG(846, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy847;
	if (yych != 'e') goto yy56;
yy847:
	YYDEBUG(847, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy848;
	if (yych != 'r') goto yy56;
yy848:
	YYDEBUG(848, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy758;
yy849:
	YYDEBUG(849, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'V') goto yy850;
	if (yych != 'v') goto yy56;
yy850:
	YYDEBUG(850, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'E') goto yy851;
	if (yych != 'e') goto yy758;
yy851:
	YYDEBUG(851, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy852;
	if (yych != 'm') goto yy56;
yy852:
	YYDEBUG(852, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy853;
	if (yych != 'b') goto yy56;
yy853:
	YYDEBUG(853, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy854;
	if (yych != 'e') goto yy56;
yy854:
	YYDEBUG(854, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy848;
	if (yych == 'r') goto yy848;
	goto yy56;
yy855:
	YYDEBUG(855, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy856;
	if (yych != 't') goto yy56;
yy856:
	YYDEBUG(856, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'O') goto yy857;
	if (yych != 'o') goto yy758;
yy857:
	YYDEBUG(857, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy858;
	if (yych != 'b') goto yy56;
yy858:
	YYDEBUG(858, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy859;
	if (yych != 'e') goto yy56;
yy859:
	YYDEBUG(859, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy848;
	if (yych == 'r') goto yy848;
	goto yy56;
yy860:
	YYDEBUG(860, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'P') {
		if (yych == 'C') goto yy121;
		if (yych <= 'O') goto yy56;
	} else {
		if (yych <= 'c') {
			if (yych <= 'b') goto yy56;
			goto yy121;
		} else {
			if (yych != 'p') goto yy56;
		}
	}
yy861:
	YYDEBUG(861, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy862;
	if (yych != 't') goto yy758;
yy862:
	YYDEBUG(862, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'E') goto yy863;
	if (yych != 'e') goto yy758;
yy863:
	YYDEBUG(863, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy864;
	if (yych != 'm') goto yy56;
yy864:
	YYDEBUG(864, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy865;
	if (yych != 'b') goto yy56;
yy865:
	YYDEBUG(865, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy866;
	if (yych != 'e') goto yy56;
yy866:
	YYDEBUG(866, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy848;
	if (yych == 'r') goto yy848;
	goto yy56;
yy867:
	YYDEBUG(867, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy871;
	if (yych == 'g') goto yy871;
	goto yy56;
yy868:
	YYDEBUG(868, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy869;
	if (yych != 'r') goto yy56;
yy869:
	YYDEBUG(869, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'I') goto yy870;
	if (yych != 'i') goto yy758;
yy870:
	YYDEBUG(870, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'L') goto yy848;
	if (yych == 'l') goto yy848;
	goto yy56;
yy871:
	YYDEBUG(871, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'U') goto yy872;
	if (yych != 'u') goto yy758;
yy872:
	YYDEBUG(872, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy873;
	if (yych != 's') goto yy56;
yy873:
	YYDEBUG(873, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy848;
	if (yych == 't') goto yy848;
	goto yy56;
yy874:
	YYDEBUG(874, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych == 'R') goto yy875;
		if (yych <= 'X') goto yy56;
		goto yy848;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy56;
		} else {
			if (yych == 'y') goto yy848;
			goto yy56;
		}
	}
yy875:
	YYDEBUG(875, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'C') goto yy876;
	if (yych != 'c') goto yy758;
yy876:
	YYDEBUG(876, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy848;
	if (yych == 'h') goto yy848;
	goto yy56;
yy877:
	YYDEBUG(877, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy878;
	if (yych != 'b') goto yy56;
yy878:
	YYDEBUG(878, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'R') goto yy879;
	if (yych != 'r') goto yy758;
yy879:
	YYDEBUG(879, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'U') goto yy880;
	if (yych != 'u') goto yy56;
yy880:
	YYDEBUG(880, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy881;
	if (yych != 'a') goto yy56;
yy881:
	YYDEBUG(881, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy882;
	if (yych != 'r') goto yy56;
yy882:
	YYDEBUG(882, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy848;
	if (yych == 'y') goto yy848;
	goto yy56;
yy883:
	YYDEBUG(883, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych == 'L') goto yy890;
		if (yych <= 'M') goto yy56;
		goto yy889;
	} else {
		if (yych <= 'l') {
			if (yych <= 'k') goto yy56;
			goto yy890;
		} else {
			if (yych == 'n') goto yy889;
			goto yy56;
		}
	}
yy884:
	YYDEBUG(884, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy885;
	if (yych != 'n') goto yy56;
yy885:
	YYDEBUG(885, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'U') goto yy886;
	if (yych != 'u') goto yy758;
yy886:
	YYDEBUG(886, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy887;
	if (yych != 'a') goto yy56;
yy887:
	YYDEBUG(887, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy888;
	if (yych != 'r') goto yy56;
yy888:
	YYDEBUG(888, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy848;
	if (yych == 'y') goto yy848;
	goto yy56;
yy889:
	YYDEBUG(889, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy848;
	if (yych == 'e') goto yy848;
	goto yy758;
yy890:
	YYDEBUG(890, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy848;
	if (yych == 'y') goto yy848;
	goto yy758;
yy891:
	YYDEBUG(891, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy848;
	goto yy758;
yy892:
	YYDEBUG(892, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != 'I') goto yy758;
	YYDEBUG(893, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy848;
	goto yy758;
yy894:
	YYDEBUG(894, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy848;
	goto yy758;
yy895:
	YYDEBUG(895, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy910;
	if (yych <= '9') goto yy909;
	goto yy56;
yy896:
	YYDEBUG(896, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy908;
	goto yy56;
yy897:
	YYDEBUG(897, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy906;
	if (yych <= '6') goto yy905;
	goto yy56;
yy898:
	YYDEBUG(898, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy877;
	if (yych == 'e') goto yy877;
	goto yy56;
yy899:
	YYDEBUG(899, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy874;
	if (yych == 'a') goto yy874;
	goto yy56;
yy900:
	YYDEBUG(900, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy904;
	if (yych == 'e') goto yy904;
	goto yy56;
yy901:
	YYDEBUG(901, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy842;
	if (yych == 'e') goto yy842;
	goto yy56;
yy902:
	YYDEBUG(902, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = *YYCURSOR;
yy903:
	YYDEBUG(903, *YYCURSOR);
	switch (yych) {
	case '\t':
	case ' ':
	case '-':
	case '.':	goto yy902;
	case 'A':
	case 'a':	goto yy764;
	case 'D':
	case 'd':	goto yy901;
	case 'F':
	case 'f':	goto yy898;
	case 'I':	goto yy757;
	case 'J':
	case 'j':	goto yy761;
	case 'M':
	case 'm':	goto yy899;
	case 'N':
	case 'n':	goto yy767;
	case 'O':
	case 'o':	goto yy766;
	case 'S':
	case 's':	goto yy900;
	case 'V':	goto yy759;
	case 'X':	goto yy760;
	default:	goto yy56;
	}
yy904:
	YYDEBUG(904, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'P') goto yy861;
	if (yych == 'p') goto yy861;
	goto yy56;
yy905:
	YYDEBUG(905, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '6') goto yy907;
	goto yy56;
yy906:
	YYDEBUG(906, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
yy907:
	YYDEBUG(907, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy786;
yy908:
	YYDEBUG(908, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy907;
	goto yy56;
yy909:
	YYDEBUG(909, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy907;
	goto yy56;
yy910:
	YYDEBUG(910, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '0') goto yy56;
	if (yych <= '9') goto yy907;
	goto yy56;
yy911:
	YYDEBUG(911, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') goto yy56;
	if (yych <= '/') goto yy914;
	if (yych <= '9') goto yy922;
	goto yy56;
yy912:
	YYDEBUG(912, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') goto yy56;
	if (yych <= '/') goto yy914;
	if (yych <= '2') goto yy922;
	goto yy56;
yy913:
	YYDEBUG(913, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '/') goto yy56;
yy914:
	YYDEBUG(914, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '2') goto yy915;
	if (yych <= '3') goto yy916;
	if (yych <= '9') goto yy917;
	goto yy56;
yy915:
	YYDEBUG(915, *YYCURSOR);
	yyaccept = 20;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy419;
		if (yych <= '9') goto yy917;
		if (yych <= 'm') goto yy419;
		goto yy919;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy419;
			goto yy920;
		} else {
			if (yych <= 's') goto yy918;
			if (yych <= 't') goto yy921;
			goto yy419;
		}
	}
yy916:
	YYDEBUG(916, *YYCURSOR);
	yyaccept = 20;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy419;
		if (yych <= '1') goto yy917;
		if (yych <= 'm') goto yy419;
		goto yy919;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy419;
			goto yy920;
		} else {
			if (yych <= 's') goto yy918;
			if (yych <= 't') goto yy921;
			goto yy419;
		}
	}
yy917:
	YYDEBUG(917, *YYCURSOR);
	yyaccept = 20;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'q') {
		if (yych == 'n') goto yy919;
		goto yy419;
	} else {
		if (yych <= 'r') goto yy920;
		if (yych <= 's') goto yy918;
		if (yych <= 't') goto yy921;
		goto yy419;
	}
yy918:
	YYDEBUG(918, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 't') goto yy418;
	goto yy56;
yy919:
	YYDEBUG(919, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy418;
	goto yy56;
yy920:
	YYDEBUG(920, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy418;
	goto yy56;
yy921:
	YYDEBUG(921, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'h') goto yy418;
	goto yy56;
yy922:
	YYDEBUG(922, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '/') goto yy56;
	YYDEBUG(923, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '2') {
		if (yych <= '/') goto yy56;
		if (yych >= '1') goto yy925;
	} else {
		if (yych <= '3') goto yy926;
		if (yych <= '9') goto yy917;
		goto yy56;
	}
	YYDEBUG(924, *YYCURSOR);
	yyaccept = 20;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy419;
		if (yych <= '9') goto yy927;
		if (yych <= 'm') goto yy419;
		goto yy919;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy419;
			goto yy920;
		} else {
			if (yych <= 's') goto yy918;
			if (yych <= 't') goto yy921;
			goto yy419;
		}
	}
yy925:
	YYDEBUG(925, *YYCURSOR);
	yyaccept = 20;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy419;
		if (yych <= '9') goto yy927;
		if (yych <= 'm') goto yy419;
		goto yy919;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy419;
			goto yy920;
		} else {
			if (yych <= 's') goto yy918;
			if (yych <= 't') goto yy921;
			goto yy419;
		}
	}
yy926:
	YYDEBUG(926, *YYCURSOR);
	yyaccept = 20;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy419;
		if (yych <= '1') goto yy927;
		if (yych <= 'm') goto yy419;
		goto yy919;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy419;
			goto yy920;
		} else {
			if (yych <= 's') goto yy918;
			if (yych <= 't') goto yy921;
			goto yy419;
		}
	}
yy927:
	YYDEBUG(927, *YYCURSOR);
	yyaccept = 20;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych == '/') goto yy418;
		if (yych <= 'm') goto yy419;
		goto yy919;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy419;
			goto yy920;
		} else {
			if (yych <= 's') goto yy918;
			if (yych <= 't') goto yy921;
			goto yy419;
		}
	}
yy928:
	YYDEBUG(928, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'A') goto yy1008;
		if (yych <= 'T') goto yy56;
		goto yy1007;
	} else {
		if (yych <= 'a') {
			if (yych <= '`') goto yy56;
			goto yy1008;
		} else {
			if (yych == 'u') goto yy1007;
			goto yy56;
		}
	}
yy929:
	YYDEBUG(929, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1005;
	if (yych == 'e') goto yy1005;
	goto yy56;
yy930:
	YYDEBUG(930, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1002;
	if (yych == 'a') goto yy1002;
	goto yy56;
yy931:
	YYDEBUG(931, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'P') goto yy999;
		if (yych <= 'T') goto yy56;
		goto yy998;
	} else {
		if (yych <= 'p') {
			if (yych <= 'o') goto yy56;
			goto yy999;
		} else {
			if (yych == 'u') goto yy998;
			goto yy56;
		}
	}
yy932:
	YYDEBUG(932, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy995;
	if (yych == 'e') goto yy995;
	goto yy56;
yy933:
	YYDEBUG(933, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy993;
	if (yych == 'c') goto yy993;
	goto yy56;
yy934:
	YYDEBUG(934, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy991;
	if (yych == 'o') goto yy991;
	goto yy56;
yy935:
	YYDEBUG(935, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy989;
	if (yych == 'e') goto yy989;
	goto yy56;
yy936:
	YYDEBUG(936, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '0') goto yy775;
	if (yych <= '4') goto yy776;
	if (yych <= '5') goto yy777;
	goto yy56;
yy937:
	YYDEBUG(937, *YYCURSOR);
	yyaccept = 21;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '-') goto yy941;
	if (yych <= '/') goto yy938;
	if (yych <= '9') goto yy960;
yy938:
	YYDEBUG(938, *YYCURSOR);
#line 1312 'ext/date/lib/parse_date.re'
	{
		int length = 0;
		DEBUG_OUTPUT('gnudateshorter');
		TIMELIB_INIT;
		TIMELIB_HAVE_DATE();
		s->time->y = timelib_get_nr_ex((char **) &ptr, 4, &length);
		s->time->m = timelib_get_nr((char **) &ptr, 2);
		s->time->d = 1;
		TIMELIB_PROCESS_YEAR(s->time->y, length);
		TIMELIB_DEINIT;
		return TIMELIB_ISO_DATE;
	}
#line 14317 '<stdout>'
yy939:
	YYDEBUG(939, *YYCURSOR);
	yyaccept = 21;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '-') goto yy941;
	if (yych <= '/') goto yy938;
	if (yych <= '2') goto yy960;
	goto yy938;
yy940:
	YYDEBUG(940, *YYCURSOR);
	yyaccept = 21;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych != '-') goto yy938;
yy941:
	YYDEBUG(941, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '2') goto yy942;
	if (yych <= '3') goto yy943;
	if (yych <= '9') goto yy944;
	goto yy56;
yy942:
	YYDEBUG(942, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'm') {
		if (yych <= '9') {
			if (yych <= '/') goto yy621;
			goto yy944;
		} else {
			if (yych == 'T') goto yy949;
			goto yy621;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'n') goto yy946;
			if (yych <= 'q') goto yy621;
			goto yy947;
		} else {
			if (yych <= 's') goto yy945;
			if (yych <= 't') goto yy948;
			goto yy621;
		}
	}
yy943:
	YYDEBUG(943, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'm') {
		if (yych <= '1') {
			if (yych <= '/') goto yy621;
		} else {
			if (yych == 'T') goto yy949;
			goto yy621;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'n') goto yy946;
			if (yych <= 'q') goto yy621;
			goto yy947;
		} else {
			if (yych <= 's') goto yy945;
			if (yych <= 't') goto yy948;
			goto yy621;
		}
	}
yy944:
	YYDEBUG(944, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych == 'T') goto yy949;
		if (yych <= 'm') goto yy621;
		goto yy946;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy947;
		} else {
			if (yych <= 's') goto yy945;
			if (yych <= 't') goto yy948;
			goto yy621;
		}
	}
yy945:
	YYDEBUG(945, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 't') goto yy959;
	goto yy56;
yy946:
	YYDEBUG(946, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy959;
	goto yy56;
yy947:
	YYDEBUG(947, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy959;
	goto yy56;
yy948:
	YYDEBUG(948, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'h') goto yy959;
	goto yy56;
yy949:
	YYDEBUG(949, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy950;
	if (yych <= '2') goto yy951;
	if (yych <= '9') goto yy952;
	goto yy56;
yy950:
	YYDEBUG(950, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy952;
	if (yych <= ':') goto yy953;
	goto yy56;
yy951:
	YYDEBUG(951, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '4') goto yy952;
	if (yych == ':') goto yy953;
	goto yy56;
yy952:
	YYDEBUG(952, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
yy953:
	YYDEBUG(953, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy954;
	if (yych <= '9') goto yy955;
	goto yy56;
yy954:
	YYDEBUG(954, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy955;
	if (yych <= ':') goto yy956;
	goto yy56;
yy955:
	YYDEBUG(955, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
yy956:
	YYDEBUG(956, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy957;
	if (yych <= '6') goto yy958;
	if (yych <= '9') goto yy806;
	goto yy56;
yy957:
	YYDEBUG(957, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy807;
	if (yych <= '9') goto yy806;
	goto yy807;
yy958:
	YYDEBUG(958, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '0') goto yy806;
	goto yy807;
yy959:
	YYDEBUG(959, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'T') goto yy949;
	goto yy621;
yy960:
	YYDEBUG(960, *YYCURSOR);
	yyaccept = 21;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych != '-') goto yy938;
	YYDEBUG(961, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '2') {
		if (yych <= '/') goto yy56;
		if (yych >= '1') goto yy963;
	} else {
		if (yych <= '3') goto yy964;
		if (yych <= '9') goto yy944;
		goto yy56;
	}
	YYDEBUG(962, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'm') {
		if (yych <= '9') {
			if (yych <= '/') goto yy621;
			goto yy965;
		} else {
			if (yych == 'T') goto yy949;
			goto yy621;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'n') goto yy946;
			if (yych <= 'q') goto yy621;
			goto yy947;
		} else {
			if (yych <= 's') goto yy945;
			if (yych <= 't') goto yy948;
			goto yy621;
		}
	}
yy963:
	YYDEBUG(963, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'm') {
		if (yych <= '9') {
			if (yych <= '/') goto yy621;
			goto yy965;
		} else {
			if (yych == 'T') goto yy949;
			goto yy621;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'n') goto yy946;
			if (yych <= 'q') goto yy621;
			goto yy947;
		} else {
			if (yych <= 's') goto yy945;
			if (yych <= 't') goto yy948;
			goto yy621;
		}
	}
yy964:
	YYDEBUG(964, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'm') {
		if (yych <= '1') {
			if (yych <= '/') goto yy621;
		} else {
			if (yych == 'T') goto yy949;
			goto yy621;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'n') goto yy946;
			if (yych <= 'q') goto yy621;
			goto yy947;
		} else {
			if (yych <= 's') goto yy945;
			if (yych <= 't') goto yy948;
			goto yy621;
		}
	}
yy965:
	YYDEBUG(965, *YYCURSOR);
	yyaccept = 20;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych == 'T') goto yy966;
		if (yych <= 'm') goto yy419;
		goto yy946;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy419;
			goto yy947;
		} else {
			if (yych <= 's') goto yy945;
			if (yych <= 't') goto yy948;
			goto yy419;
		}
	}
yy966:
	YYDEBUG(966, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy967;
	if (yych <= '2') goto yy968;
	if (yych <= '9') goto yy952;
	goto yy56;
yy967:
	YYDEBUG(967, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy969;
	if (yych <= ':') goto yy953;
	goto yy56;
yy968:
	YYDEBUG(968, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '4') goto yy969;
	if (yych == ':') goto yy953;
	goto yy56;
yy969:
	YYDEBUG(969, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(970, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy971;
	if (yych <= '9') goto yy955;
	goto yy56;
yy971:
	YYDEBUG(971, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy972;
	if (yych <= ':') goto yy956;
	goto yy56;
yy972:
	YYDEBUG(972, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ':') goto yy56;
	YYDEBUG(973, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy974;
	if (yych <= '6') goto yy975;
	if (yych <= '9') goto yy806;
	goto yy56;
yy974:
	YYDEBUG(974, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy807;
	if (yych <= '9') goto yy976;
	goto yy807;
yy975:
	YYDEBUG(975, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '0') goto yy807;
yy976:
	YYDEBUG(976, *YYCURSOR);
	yyaccept = 22;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych != '.') goto yy807;
	YYDEBUG(977, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
yy978:
	YYDEBUG(978, *YYCURSOR);
	yyaccept = 22;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = *YYCURSOR;
	YYDEBUG(979, *YYCURSOR);
	if (yych <= '-') {
		if (yych == '+') goto yy981;
		if (yych <= ',') goto yy807;
		goto yy981;
	} else {
		if (yych <= '9') {
			if (yych <= '/') goto yy807;
			goto yy978;
		} else {
			if (yych != 'G') goto yy807;
		}
	}
	YYDEBUG(980, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy987;
	goto yy56;
yy981:
	YYDEBUG(981, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy982;
	if (yych <= '2') goto yy983;
	if (yych <= '9') goto yy984;
	goto yy56;
yy982:
	YYDEBUG(982, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy807;
	if (yych <= '9') goto yy984;
	if (yych <= ':') goto yy985;
	goto yy807;
yy983:
	YYDEBUG(983, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '5') {
		if (yych <= '/') goto yy807;
		if (yych >= '5') goto yy986;
	} else {
		if (yych <= '9') goto yy806;
		if (yych <= ':') goto yy985;
		goto yy807;
	}
yy984:
	YYDEBUG(984, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy807;
	if (yych <= '5') goto yy986;
	if (yych <= '9') goto yy806;
	if (yych >= ';') goto yy807;
yy985:
	YYDEBUG(985, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy807;
	if (yych <= '5') goto yy986;
	if (yych <= '9') goto yy806;
	goto yy807;
yy986:
	YYDEBUG(986, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy807;
	if (yych <= '9') goto yy806;
	goto yy807;
yy987:
	YYDEBUG(987, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != 'T') goto yy56;
	YYDEBUG(988, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '+') goto yy981;
	if (yych == '-') goto yy981;
	goto yy56;
yy989:
	YYDEBUG(989, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy990;
	if (yych != 'c') goto yy56;
yy990:
	YYDEBUG(990, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'E') goto yy844;
		if (yych == 'e') goto yy844;
		goto yy758;
	}
yy991:
	YYDEBUG(991, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'V') goto yy992;
	if (yych != 'v') goto yy56;
yy992:
	YYDEBUG(992, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'E') goto yy851;
		if (yych == 'e') goto yy851;
		goto yy758;
	}
yy993:
	YYDEBUG(993, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy994;
	if (yych != 't') goto yy56;
yy994:
	YYDEBUG(994, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'N') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'O') goto yy857;
		if (yych == 'o') goto yy857;
		goto yy758;
	}
yy995:
	YYDEBUG(995, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'P') goto yy996;
	if (yych != 'p') goto yy56;
yy996:
	YYDEBUG(996, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'T') goto yy997;
		if (yych != 't') goto yy758;
	}
yy997:
	YYDEBUG(997, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'E') goto yy863;
		if (yych == 'e') goto yy863;
		goto yy758;
	}
yy998:
	YYDEBUG(998, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy1001;
	if (yych == 'g') goto yy1001;
	goto yy56;
yy999:
	YYDEBUG(999, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy1000;
	if (yych != 'r') goto yy56;
yy1000:
	YYDEBUG(1000, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'H') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'I') goto yy870;
		if (yych == 'i') goto yy870;
		goto yy758;
	}
yy1001:
	YYDEBUG(1001, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'U') goto yy872;
		if (yych == 'u') goto yy872;
		goto yy758;
	}
yy1002:
	YYDEBUG(1002, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych == 'R') goto yy1003;
		if (yych <= 'X') goto yy56;
		goto yy1004;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy56;
		} else {
			if (yych == 'y') goto yy1004;
			goto yy56;
		}
	}
yy1003:
	YYDEBUG(1003, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'B') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'C') goto yy876;
		if (yych == 'c') goto yy876;
		goto yy758;
	}
yy1004:
	YYDEBUG(1004, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '-') goto yy731;
	goto yy758;
yy1005:
	YYDEBUG(1005, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'B') goto yy1006;
	if (yych != 'b') goto yy56;
yy1006:
	YYDEBUG(1006, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'R') goto yy879;
		if (yych == 'r') goto yy879;
		goto yy758;
	}
yy1007:
	YYDEBUG(1007, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych == 'L') goto yy1011;
		if (yych <= 'M') goto yy56;
		goto yy1010;
	} else {
		if (yych <= 'l') {
			if (yych <= 'k') goto yy56;
			goto yy1011;
		} else {
			if (yych == 'n') goto yy1010;
			goto yy56;
		}
	}
yy1008:
	YYDEBUG(1008, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy1009;
	if (yych != 'n') goto yy56;
yy1009:
	YYDEBUG(1009, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'U') goto yy886;
		if (yych == 'u') goto yy886;
		goto yy758;
	}
yy1010:
	YYDEBUG(1010, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'E') goto yy848;
		if (yych == 'e') goto yy848;
		goto yy758;
	}
yy1011:
	YYDEBUG(1011, *YYCURSOR);
	yyaccept = 19;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych == '-') goto yy731;
		goto yy758;
	} else {
		if (yych <= 'Y') goto yy848;
		if (yych == 'y') goto yy848;
		goto yy758;
	}
yy1012:
	YYDEBUG(1012, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy542;
			goto yy695;
		} else {
			if (yych <= ',') goto yy542;
			if (yych <= '-') goto yy696;
			goto yy695;
		}
	} else {
		if (yych <= 'U') {
			if (yych <= '/') goto yy694;
			if (yych <= 'T') goto yy542;
			goto yy79;
		} else {
			if (yych == 'u') goto yy79;
			goto yy542;
		}
	}
yy1013:
	YYDEBUG(1013, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'P') {
		if (yych == 'C') goto yy121;
		if (yych <= 'O') goto yy56;
		goto yy550;
	} else {
		if (yych <= 'c') {
			if (yych <= 'b') goto yy56;
			goto yy121;
		} else {
			if (yych == 'p') goto yy550;
			goto yy56;
		}
	}
yy1014:
	YYDEBUG(1014, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= ',') {
			if (yych == '\t') goto yy1016;
			goto yy1018;
		} else {
			if (yych <= '-') goto yy1015;
			if (yych <= '.') goto yy695;
			if (yych <= '/') goto yy694;
			goto yy705;
		}
	} else {
		if (yych <= 'q') {
			if (yych == 'n') goto yy434;
			goto yy1018;
		} else {
			if (yych <= 'r') goto yy435;
			if (yych <= 's') goto yy429;
			if (yych <= 't') goto yy432;
			goto yy1018;
		}
	}
yy1015:
	YYDEBUG(1015, *YYCURSOR);
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':	goto yy1019;
	case '1':	goto yy1020;
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy582;
	case 'A':
	case 'a':	goto yy586;
	case 'D':
	case 'd':	goto yy590;
	case 'F':
	case 'f':	goto yy584;
	case 'J':
	case 'j':	goto yy583;
	case 'M':
	case 'm':	goto yy585;
	case 'N':
	case 'n':	goto yy589;
	case 'O':
	case 'o':	goto yy588;
	case 'S':
	case 's':	goto yy587;
	default:	goto yy542;
	}
yy1016:
	YYDEBUG(1016, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy1018;
	if (yych <= '0') goto yy700;
	if (yych <= '1') goto yy701;
	if (yych <= '9') goto yy702;
	goto yy1018;
yy1017:
	YYDEBUG(1017, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 13) YYFILL(13);
	yych = *YYCURSOR;
yy1018:
	YYDEBUG(1018, *YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'G') {
			if (yych <= '.') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy1017;
					goto yy56;
				} else {
					if (yych <= ' ') goto yy1017;
					if (yych <= ',') goto yy56;
					goto yy541;
				}
			} else {
				if (yych <= 'C') {
					if (yych == 'A') goto yy538;
					goto yy56;
				} else {
					if (yych <= 'D') goto yy430;
					if (yych == 'F') goto yy431;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'N') {
				if (yych <= 'J') {
					if (yych <= 'H') goto yy65;
					if (yych <= 'I') goto yy439;
					goto yy443;
				} else {
					if (yych <= 'L') goto yy56;
					if (yych <= 'M') goto yy427;
					goto yy446;
				}
			} else {
				if (yych <= 'S') {
					if (yych <= 'O') goto yy445;
					if (yych <= 'R') goto yy56;
					goto yy428;
				} else {
					if (yych <= 'T') goto yy70;
					if (yych <= 'U') goto yy63;
					if (yych <= 'V') goto yy441;
					goto yy69;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych <= '`') {
					if (yych <= 'X') goto yy442;
					if (yych <= 'Y') goto yy68;
					goto yy56;
				} else {
					if (yych <= 'a') goto yy538;
					if (yych <= 'c') goto yy56;
					goto yy430;
				}
			} else {
				if (yych <= 'g') {
					if (yych == 'f') goto yy431;
					goto yy56;
				} else {
					if (yych <= 'h') goto yy65;
					if (yych == 'j') goto yy443;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'o') {
					if (yych <= 'm') goto yy427;
					if (yych <= 'n') goto yy446;
					goto yy445;
				} else {
					if (yych <= 'r') goto yy56;
					if (yych <= 's') goto yy428;
					if (yych <= 't') goto yy70;
					goto yy63;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy69;
					goto yy56;
				} else {
					if (yych <= 'y') goto yy68;
					if (yych == 0xC2) goto yy62;
					goto yy56;
				}
			}
		}
	}
yy1019:
	YYDEBUG(1019, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') {
		if (yych <= ',') goto yy56;
		if (yych <= '-') goto yy619;
		goto yy566;
	} else {
		if (yych <= '/') goto yy56;
		if (yych <= '9') goto yy1021;
		goto yy56;
	}
yy1020:
	YYDEBUG(1020, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '.') {
		if (yych <= ',') goto yy56;
		if (yych <= '-') goto yy619;
		goto yy566;
	} else {
		if (yych <= '/') goto yy56;
		if (yych >= '3') goto yy56;
	}
yy1021:
	YYDEBUG(1021, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= ',') goto yy56;
	if (yych <= '-') goto yy1022;
	if (yych <= '.') goto yy566;
	goto yy56;
yy1022:
	YYDEBUG(1022, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '2') {
		if (yych <= '/') goto yy56;
		if (yych >= '1') goto yy1024;
	} else {
		if (yych <= '3') goto yy1025;
		if (yych <= '9') goto yy623;
		goto yy56;
	}
	YYDEBUG(1023, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '9') goto yy1026;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy1024:
	YYDEBUG(1024, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy621;
		if (yych <= '9') goto yy1026;
		if (yych <= 'm') goto yy621;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy1025:
	YYDEBUG(1025, *YYCURSOR);
	yyaccept = 12;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '1') {
			if (yych <= '/') goto yy621;
		} else {
			if (yych <= '9') goto yy568;
			if (yych <= 'm') goto yy621;
			goto yy625;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy621;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy621;
		}
	}
yy1026:
	YYDEBUG(1026, *YYCURSOR);
	yyaccept = 14;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'n') {
		if (yych <= '/') goto yy728;
		if (yych <= '9') goto yy569;
		if (yych <= 'm') goto yy728;
		goto yy625;
	} else {
		if (yych <= 'r') {
			if (yych <= 'q') goto yy728;
			goto yy626;
		} else {
			if (yych <= 's') goto yy624;
			if (yych <= 't') goto yy627;
			goto yy728;
		}
	}
yy1027:
	YYDEBUG(1027, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= '-') {
			if (yych == '\t') goto yy1016;
			if (yych <= ',') goto yy1018;
			goto yy1015;
		} else {
			if (yych <= '.') goto yy1028;
			if (yych <= '/') goto yy694;
			if (yych <= '5') goto yy1030;
			goto yy705;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= ':') goto yy1029;
			if (yych == 'n') goto yy434;
			goto yy1018;
		} else {
			if (yych <= 'r') goto yy435;
			if (yych <= 's') goto yy429;
			if (yych <= 't') goto yy432;
			goto yy1018;
		}
	}
yy1028:
	YYDEBUG(1028, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '1') {
		if (yych <= '/') goto yy542;
		if (yych <= '0') goto yy1052;
		goto yy1053;
	} else {
		if (yych <= '5') goto yy1054;
		if (yych <= '9') goto yy1055;
		goto yy542;
	}
yy1029:
	YYDEBUG(1029, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy1047;
	if (yych <= '9') goto yy1048;
	goto yy56;
yy1030:
	YYDEBUG(1030, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '-') goto yy749;
	if (yych <= '/') goto yy60;
	if (yych >= ':') goto yy60;
	YYDEBUG(1031, *YYCURSOR);
	yyaccept = 23;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'L') {
		if (yych <= '3') {
			if (yych <= '-') {
				if (yych <= 0x1F) {
					if (yych == '\t') goto yy755;
				} else {
					if (yych <= ' ') goto yy755;
					if (yych >= '-') goto yy752;
				}
			} else {
				if (yych <= '0') {
					if (yych <= '.') goto yy756;
					if (yych <= '/') goto yy753;
					goto yy1033;
				} else {
					if (yych <= '1') goto yy1034;
					if (yych <= '2') goto yy1035;
					goto yy1036;
				}
			}
		} else {
			if (yych <= 'A') {
				if (yych <= '9') {
					if (yych <= '5') goto yy1037;
					if (yych <= '6') goto yy1038;
					goto yy54;
				} else {
					if (yych <= ':') goto yy771;
					if (yych >= 'A') goto yy755;
				}
			} else {
				if (yych <= 'E') {
					if (yych == 'D') goto yy755;
				} else {
					if (yych == 'G') goto yy1032;
					if (yych <= 'J') goto yy755;
				}
			}
		}
	} else {
		if (yych <= 'h') {
			if (yych <= '`') {
				if (yych <= 'V') {
					if (yych <= 'O') goto yy755;
					if (yych >= 'S') goto yy755;
				} else {
					if (yych <= 'W') goto yy774;
					if (yych <= 'Y') goto yy755;
				}
			} else {
				if (yych <= 'd') {
					if (yych <= 'a') goto yy755;
					if (yych >= 'd') goto yy755;
				} else {
					if (yych == 'f') goto yy755;
					if (yych >= 'h') goto yy755;
				}
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'l') {
					if (yych == 'j') goto yy755;
				} else {
					if (yych <= 'o') goto yy755;
					if (yych >= 's') goto yy755;
				}
			} else {
				if (yych <= 'x') {
					if (yych == 'w') goto yy755;
				} else {
					if (yych <= 'y') goto yy755;
					if (yych == 0xC2) goto yy755;
				}
			}
		}
	}
yy1032:
	YYDEBUG(1032, *YYCURSOR);
#line 1204 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('gnunocolon');
		TIMELIB_INIT;
		switch (s->time->have_time) {
			case 0:
				s->time->h = timelib_get_nr((char **) &ptr, 2);
				s->time->i = timelib_get_nr((char **) &ptr, 2);
				s->time->s = 0;
				break;
			case 1:
				s->time->y = timelib_get_nr((char **) &ptr, 4);
				break;
			default:
				TIMELIB_DEINIT;
				add_error(s, 'Double time specification');
				return TIMELIB_ERROR;
		}
		s->time->have_time++;
		TIMELIB_DEINIT;
		return TIMELIB_GNU_NOCOLON;
	}
#line 15432 '<stdout>'
yy1033:
	YYDEBUG(1033, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '0') goto yy1045;
	if (yych <= '9') goto yy1046;
	goto yy60;
yy1034:
	YYDEBUG(1034, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '2') goto yy1044;
	if (yych <= '9') goto yy1043;
	goto yy60;
yy1035:
	YYDEBUG(1035, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '9') goto yy1043;
	goto yy60;
yy1036:
	YYDEBUG(1036, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '5') goto yy1041;
	if (yych <= '6') goto yy1042;
	if (yych <= '9') goto yy1039;
	goto yy60;
yy1037:
	YYDEBUG(1037, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '9') goto yy1039;
	goto yy60;
yy1038:
	YYDEBUG(1038, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy60;
	if (yych <= '0') goto yy1039;
	if (yych <= '9') goto yy54;
	goto yy60;
yy1039:
	YYDEBUG(1039, *YYCURSOR);
	yyaccept = 24;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 2) {
		goto yy54;
	}
	if (yych <= 'X') {
		if (yych <= 'F') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych >= ' ') goto yy60;
			} else {
				if (yych == 'D') goto yy60;
				if (yych >= 'F') goto yy60;
			}
		} else {
			if (yych <= 'M') {
				if (yych == 'H') goto yy60;
				if (yych >= 'M') goto yy60;
			} else {
				if (yych <= 'U') {
					if (yych >= 'S') goto yy60;
				} else {
					if (yych == 'W') goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'e') {
				if (yych <= 'Y') goto yy60;
				if (yych == 'd') goto yy60;
			} else {
				if (yych <= 'g') {
					if (yych <= 'f') goto yy60;
				} else {
					if (yych <= 'h') goto yy60;
					if (yych >= 'm') goto yy60;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') goto yy1040;
				if (yych != 'v') goto yy60;
			} else {
				if (yych <= 'y') {
					if (yych >= 'y') goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
				}
			}
		}
	}
yy1040:
	YYDEBUG(1040, *YYCURSOR);
#line 1250 'ext/date/lib/parse_date.re'
	{
		int tz_not_found;
		DEBUG_OUTPUT('iso8601nocolon');
		TIMELIB_INIT;
		TIMELIB_HAVE_TIME();
		s->time->h = timelib_get_nr((char **) &ptr, 2);
		s->time->i = timelib_get_nr((char **) &ptr, 2);
		s->time->s = timelib_get_nr((char **) &ptr, 2);

		if (*ptr != '\0') {
			s->time->z = timelib_parse_zone((char **) &ptr, &s->time->dst, s->time, &tz_not_found, s->tzdb, tz_get_wrapper);
			if (tz_not_found) {
				add_error(s, 'The timezone could not be found in the database');
			}
		}
		TIMELIB_DEINIT;
		return TIMELIB_ISO_NOCOLON;
	}
#line 15549 '<stdout>'
yy1041:
	YYDEBUG(1041, *YYCURSOR);
	yyaccept = 24;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy1040;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy1040;
					goto yy785;
				} else {
					if (yych == 'D') goto yy60;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy1040;
				if (yych <= 'H') goto yy60;
				goto yy1040;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'V') goto yy1040;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy1040;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy1040;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'v') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy1040;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy1040;
				}
			}
		}
	}
yy1042:
	YYDEBUG(1042, *YYCURSOR);
	yyaccept = 24;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'D') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy1040;
				goto yy60;
			} else {
				if (yych <= '6') {
					if (yych <= '/') goto yy1040;
					goto yy785;
				} else {
					if (yych <= '9') goto yy54;
					if (yych <= 'C') goto yy1040;
					goto yy60;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych <= 'F') {
					if (yych <= 'E') goto yy1040;
					goto yy60;
				} else {
					if (yych == 'H') goto yy60;
					goto yy1040;
				}
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'V') goto yy1040;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy1040;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy1040;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'v') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy1040;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy1040;
				}
			}
		}
	}
yy1043:
	YYDEBUG(1043, *YYCURSOR);
	yyaccept = 24;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= 'E') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy60;
				if (yych <= 0x1F) goto yy1040;
				goto yy60;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto yy1040;
					goto yy785;
				} else {
					if (yych == 'D') goto yy60;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'L') {
				if (yych == 'G') goto yy1040;
				if (yych <= 'H') goto yy60;
				goto yy1040;
			} else {
				if (yych <= 'R') {
					if (yych <= 'M') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'V') goto yy1040;
					goto yy60;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych == 'Y') goto yy60;
				if (yych <= 'c') goto yy1040;
				goto yy60;
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy1040;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'v') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy1040;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy1040;
				}
			}
		}
	}
yy1044:
	YYDEBUG(1044, *YYCURSOR);
	yyaccept = 24;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'V') {
		if (yych <= 'C') {
			if (yych <= '/') {
				if (yych <= '\t') {
					if (yych <= 0x08) goto yy1040;
					goto yy60;
				} else {
					if (yych == ' ') goto yy60;
					goto yy1040;
				}
			} else {
				if (yych <= '2') {
					if (yych <= '0') goto yy809;
					goto yy810;
				} else {
					if (yych <= '3') goto yy811;
					if (yych <= '9') goto yy785;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'G') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'M') {
					if (yych <= 'L') goto yy1040;
					goto yy60;
				} else {
					if (yych <= 'R') goto yy1040;
					if (yych <= 'U') goto yy60;
					goto yy1040;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych <= 'X') {
					if (yych <= 'W') goto yy60;
					goto yy1040;
				} else {
					if (yych <= 'Y') goto yy60;
					if (yych <= 'c') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy1040;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'v') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy1040;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy1040;
				}
			}
		}
	}
yy1045:
	YYDEBUG(1045, *YYCURSOR);
	yyaccept = 24;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'V') {
		if (yych <= 'C') {
			if (yych <= '/') {
				if (yych <= '\t') {
					if (yych <= 0x08) goto yy1040;
					goto yy60;
				} else {
					if (yych == ' ') goto yy60;
					goto yy1040;
				}
			} else {
				if (yych <= '2') {
					if (yych <= '0') goto yy841;
					goto yy810;
				} else {
					if (yych <= '3') goto yy811;
					if (yych <= '9') goto yy785;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'G') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'M') {
					if (yych <= 'L') goto yy1040;
					goto yy60;
				} else {
					if (yych <= 'R') goto yy1040;
					if (yych <= 'U') goto yy60;
					goto yy1040;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych <= 'X') {
					if (yych <= 'W') goto yy60;
					goto yy1040;
				} else {
					if (yych <= 'Y') goto yy60;
					if (yych <= 'c') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy1040;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'v') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy1040;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy1040;
				}
			}
		}
	}
yy1046:
	YYDEBUG(1046, *YYCURSOR);
	yyaccept = 24;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'V') {
		if (yych <= 'C') {
			if (yych <= '/') {
				if (yych <= '\t') {
					if (yych <= 0x08) goto yy1040;
					goto yy60;
				} else {
					if (yych == ' ') goto yy60;
					goto yy1040;
				}
			} else {
				if (yych <= '2') {
					if (yych <= '0') goto yy809;
					goto yy810;
				} else {
					if (yych <= '3') goto yy811;
					if (yych <= '9') goto yy785;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'H') {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'G') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'M') {
					if (yych <= 'L') goto yy1040;
					goto yy60;
				} else {
					if (yych <= 'R') goto yy1040;
					if (yych <= 'U') goto yy60;
					goto yy1040;
				}
			}
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'd') {
				if (yych <= 'X') {
					if (yych <= 'W') goto yy60;
					goto yy1040;
				} else {
					if (yych <= 'Y') goto yy60;
					if (yych <= 'c') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy1040;
					goto yy60;
				} else {
					if (yych == 'h') goto yy60;
					goto yy1040;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 'r') {
					if (yych <= 'm') goto yy60;
					goto yy1040;
				} else {
					if (yych == 'v') goto yy1040;
					goto yy60;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy1040;
					goto yy60;
				} else {
					if (yych == 0xC2) goto yy60;
					goto yy1040;
				}
			}
		}
	}
yy1047:
	YYDEBUG(1047, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy1049;
		goto yy455;
	} else {
		if (yych <= '9') goto yy1048;
		if (yych <= ':') goto yy1049;
		goto yy455;
	}
yy1048:
	YYDEBUG(1048, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy1049;
	if (yych != ':') goto yy455;
yy1049:
	YYDEBUG(1049, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy1050;
	if (yych <= '6') goto yy1051;
	if (yych <= '9') goto yy460;
	goto yy56;
yy1050:
	YYDEBUG(1050, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych <= '/') goto yy455;
	if (yych <= '9') goto yy460;
	goto yy455;
yy1051:
	YYDEBUG(1051, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych == '0') goto yy460;
	goto yy455;
yy1052:
	YYDEBUG(1052, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ',') goto yy455;
		if (yych <= '-') goto yy566;
		goto yy1056;
	} else {
		if (yych <= '/') goto yy455;
		if (yych <= '9') goto yy1055;
		if (yych <= ':') goto yy1049;
		goto yy455;
	}
yy1053:
	YYDEBUG(1053, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') goto yy455;
		if (yych <= '-') goto yy566;
		if (yych <= '.') goto yy1056;
		goto yy455;
	} else {
		if (yych <= '2') goto yy1055;
		if (yych <= '9') goto yy1048;
		if (yych <= ':') goto yy1049;
		goto yy455;
	}
yy1054:
	YYDEBUG(1054, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ',') goto yy455;
		if (yych <= '-') goto yy566;
		goto yy1056;
	} else {
		if (yych <= '/') goto yy455;
		if (yych <= '9') goto yy1048;
		if (yych <= ':') goto yy1049;
		goto yy455;
	}
yy1055:
	YYDEBUG(1055, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ',') goto yy455;
		if (yych <= '-') goto yy566;
	} else {
		if (yych == ':') goto yy1049;
		goto yy455;
	}
yy1056:
	YYDEBUG(1056, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '5') goto yy1057;
	if (yych <= '6') goto yy1058;
	if (yych <= '9') goto yy574;
	goto yy56;
yy1057:
	YYDEBUG(1057, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych <= '/') goto yy455;
	if (yych <= '9') goto yy1059;
	goto yy455;
yy1058:
	YYDEBUG(1058, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych == '.') goto yy461;
		goto yy455;
	} else {
		if (yych <= '0') goto yy1059;
		if (yych <= '9') goto yy575;
		goto yy455;
	}
yy1059:
	YYDEBUG(1059, *YYCURSOR);
	yyaccept = 10;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy461;
	if (yych <= '/') goto yy455;
	if (yych <= '9') goto yy569;
	goto yy455;
yy1060:
	YYDEBUG(1060, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= '-') {
			if (yych == '\t') goto yy424;
			if (yych <= ',') goto yy426;
			goto yy1015;
		} else {
			if (yych <= '.') goto yy438;
			if (yych <= '/') goto yy436;
			if (yych <= '5') goto yy1030;
			goto yy705;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= ':') goto yy447;
			if (yych == 'n') goto yy434;
			goto yy426;
		} else {
			if (yych <= 'r') goto yy435;
			if (yych <= 's') goto yy429;
			if (yych <= 't') goto yy432;
			goto yy426;
		}
	}
yy1061:
	YYDEBUG(1061, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '9') {
		if (yych <= '-') {
			if (yych == '\t') goto yy1016;
			if (yych <= ',') goto yy1018;
			goto yy1015;
		} else {
			if (yych <= '.') goto yy1028;
			if (yych <= '/') goto yy436;
			if (yych <= '5') goto yy1030;
			goto yy705;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= ':') goto yy1029;
			if (yych == 'n') goto yy434;
			goto yy1018;
		} else {
			if (yych <= 'r') goto yy435;
			if (yych <= 's') goto yy429;
			if (yych <= 't') goto yy432;
			goto yy1018;
		}
	}
yy1062:
	YYDEBUG(1062, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy166;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'e') goto yy1063;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1063:
	YYDEBUG(1063, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'V') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'U') goto yy167;
		}
	} else {
		if (yych <= 'u') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'v') goto yy1064;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1064:
	YYDEBUG(1064, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'I') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'H') goto yy168;
		}
	} else {
		if (yych <= 'h') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'i') goto yy1065;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1065:
	YYDEBUG(1065, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'N') goto yy169;
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'o') goto yy1066;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1066:
	YYDEBUG(1066, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'U') goto yy1067;
		if (yych != 'u') goto yy3;
	}
yy1067:
	YYDEBUG(1067, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1068;
	if (yych != 's') goto yy56;
yy1068:
	YYDEBUG(1068, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '\t') goto yy1069;
	if (yych != ' ') goto yy56;
yy1069:
	YYDEBUG(1069, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 12) YYFILL(12);
	yych = *YYCURSOR;
yy1070:
	YYDEBUG(1070, *YYCURSOR);
	if (yych <= 'X') {
		if (yych <= 'G') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy1069;
				if (yych <= 0x1F) goto yy56;
				goto yy1069;
			} else {
				if (yych <= 'D') {
					if (yych <= 'C') goto yy56;
					goto yy1076;
				} else {
					if (yych == 'F') goto yy1077;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'S') {
				if (yych <= 'L') {
					if (yych <= 'H') goto yy1075;
					goto yy56;
				} else {
					if (yych <= 'M') goto yy1071;
					if (yych <= 'R') goto yy56;
					goto yy1074;
				}
			} else {
				if (yych <= 'U') {
					if (yych <= 'T') goto yy1080;
					goto yy1073;
				} else {
					if (yych == 'W') goto yy1079;
					goto yy56;
				}
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'f') {
				if (yych <= 'c') {
					if (yych <= 'Y') goto yy1078;
					goto yy56;
				} else {
					if (yych <= 'd') goto yy1076;
					if (yych <= 'e') goto yy56;
					goto yy1077;
				}
			} else {
				if (yych <= 'h') {
					if (yych <= 'g') goto yy56;
					goto yy1075;
				} else {
					if (yych != 'm') goto yy56;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 't') {
					if (yych <= 's') goto yy1074;
					goto yy1080;
				} else {
					if (yych <= 'u') goto yy1073;
					if (yych <= 'v') goto yy56;
					goto yy1079;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy56;
					goto yy1078;
				} else {
					if (yych == 0xC2) goto yy1072;
					goto yy56;
				}
			}
		}
	}
yy1071:
	YYDEBUG(1071, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= 'N') {
			if (yych == 'I') goto yy1155;
			goto yy56;
		} else {
			if (yych <= 'O') goto yy1154;
			if (yych <= 'R') goto yy56;
			goto yy1156;
		}
	} else {
		if (yych <= 'n') {
			if (yych == 'i') goto yy1155;
			goto yy56;
		} else {
			if (yych <= 'o') goto yy1154;
			if (yych == 's') goto yy1156;
			goto yy56;
		}
	}
yy1072:
	YYDEBUG(1072, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 0xB5) goto yy1151;
	goto yy56;
yy1073:
	YYDEBUG(1073, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1149;
	if (yych == 's') goto yy1149;
	goto yy56;
yy1074:
	YYDEBUG(1074, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= 'D') {
			if (yych == 'A') goto yy1136;
			goto yy56;
		} else {
			if (yych <= 'E') goto yy1137;
			if (yych <= 'T') goto yy56;
			goto yy1135;
		}
	} else {
		if (yych <= 'd') {
			if (yych == 'a') goto yy1136;
			goto yy56;
		} else {
			if (yych <= 'e') goto yy1137;
			if (yych == 'u') goto yy1135;
			goto yy56;
		}
	}
yy1075:
	YYDEBUG(1075, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy1133;
	if (yych == 'o') goto yy1133;
	goto yy56;
yy1076:
	YYDEBUG(1076, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1132;
	if (yych == 'a') goto yy1132;
	goto yy56;
yy1077:
	YYDEBUG(1077, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych == 'O') goto yy1117;
		if (yych <= 'Q') goto yy56;
		goto yy1116;
	} else {
		if (yych <= 'o') {
			if (yych <= 'n') goto yy56;
			goto yy1117;
		} else {
			if (yych == 'r') goto yy1116;
			goto yy56;
		}
	}
yy1078:
	YYDEBUG(1078, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1113;
	if (yych == 'e') goto yy1113;
	goto yy56;
yy1079:
	YYDEBUG(1079, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1099;
	if (yych == 'e') goto yy1099;
	goto yy56;
yy1080:
	YYDEBUG(1080, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'H') goto yy1081;
		if (yych <= 'T') goto yy56;
		goto yy1082;
	} else {
		if (yych <= 'h') {
			if (yych <= 'g') goto yy56;
		} else {
			if (yych == 'u') goto yy1082;
			goto yy56;
		}
	}
yy1081:
	YYDEBUG(1081, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'U') goto yy1094;
	if (yych == 'u') goto yy1094;
	goto yy56;
yy1082:
	YYDEBUG(1082, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1083;
	if (yych != 'e') goto yy56;
yy1083:
	YYDEBUG(1083, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy1085;
		if (yych >= ' ') goto yy1085;
	} else {
		if (yych <= 'S') {
			if (yych >= 'S') goto yy1087;
		} else {
			if (yych == 's') goto yy1087;
		}
	}
yy1084:
	YYDEBUG(1084, *YYCURSOR);
#line 1646 'ext/date/lib/parse_date.re'
	{
		timelib_sll i;
		int         behavior = 0;
		DEBUG_OUTPUT('relativetext');
		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();

		while(*ptr) {
			i = timelib_get_relative_text((char **) &ptr, &behavior);
			timelib_eat_spaces((char **) &ptr);
			timelib_set_relative((char **) &ptr, i, behavior, s);
		}
		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 16541 '<stdout>'
yy1085:
	YYDEBUG(1085, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	YYDEBUG(1086, *YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy1085;
		if (yych <= 0x1F) goto yy56;
		goto yy1085;
	} else {
		if (yych <= 'O') {
			if (yych <= 'N') goto yy56;
			goto yy1091;
		} else {
			if (yych == 'o') goto yy1091;
			goto yy56;
		}
	}
yy1087:
	YYDEBUG(1087, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1088;
	if (yych != 'd') goto yy56;
yy1088:
	YYDEBUG(1088, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1089;
	if (yych != 'a') goto yy56;
yy1089:
	YYDEBUG(1089, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1090;
	if (yych != 'y') goto yy56;
yy1090:
	YYDEBUG(1090, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '\t') goto yy1085;
	if (yych == ' ') goto yy1085;
	goto yy1084;
yy1091:
	YYDEBUG(1091, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'F') goto yy1092;
	if (yych != 'f') goto yy56;
yy1092:
	YYDEBUG(1092, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(1093, *YYCURSOR);
#line 1119 'ext/date/lib/parse_date.re'
	{
		timelib_sll i;
		int         behavior = 0;
		DEBUG_OUTPUT('weekdayof');
		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();
		TIMELIB_HAVE_SPECIAL_RELATIVE();

		i = timelib_get_relative_text((char **) &ptr, &behavior);
		timelib_eat_spaces((char **) &ptr);
		if (i > 0) { /* first, second... etc */
			s->time->relative.special.type = TIMELIB_SPECIAL_DAY_OF_WEEK_IN_MONTH;
			timelib_set_relative((char **) &ptr, i, 1, s);
		} else { /* last */
			s->time->relative.special.type = TIMELIB_SPECIAL_LAST_DAY_OF_WEEK_IN_MONTH;
			timelib_set_relative((char **) &ptr, i, behavior, s);
		}
		TIMELIB_DEINIT;
		return TIMELIB_WEEK_DAY_OF_MONTH;
	}
#line 16613 '<stdout>'
yy1094:
	YYDEBUG(1094, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy1085;
		if (yych <= 0x1F) goto yy1084;
		goto yy1085;
	} else {
		if (yych <= 'R') {
			if (yych <= 'Q') goto yy1084;
		} else {
			if (yych != 'r') goto yy1084;
		}
	}
	YYDEBUG(1095, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1096;
	if (yych != 's') goto yy56;
yy1096:
	YYDEBUG(1096, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1097;
	if (yych != 'd') goto yy56;
yy1097:
	YYDEBUG(1097, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1098;
	if (yych != 'a') goto yy56;
yy1098:
	YYDEBUG(1098, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1090;
	if (yych == 'y') goto yy1090;
	goto yy56;
yy1099:
	YYDEBUG(1099, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= 'C') goto yy56;
		if (yych <= 'D') goto yy1101;
	} else {
		if (yych <= 'c') goto yy56;
		if (yych <= 'd') goto yy1101;
		if (yych >= 'f') goto yy56;
	}
	YYDEBUG(1100, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'K') goto yy1107;
	if (yych == 'k') goto yy1107;
	goto yy56;
yy1101:
	YYDEBUG(1101, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy1085;
		if (yych <= 0x1F) goto yy1084;
		goto yy1085;
	} else {
		if (yych <= 'N') {
			if (yych <= 'M') goto yy1084;
		} else {
			if (yych != 'n') goto yy1084;
		}
	}
	YYDEBUG(1102, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1103;
	if (yych != 'e') goto yy56;
yy1103:
	YYDEBUG(1103, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1104;
	if (yych != 's') goto yy56;
yy1104:
	YYDEBUG(1104, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1105;
	if (yych != 'd') goto yy56;
yy1105:
	YYDEBUG(1105, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1106;
	if (yych != 'a') goto yy56;
yy1106:
	YYDEBUG(1106, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1090;
	if (yych == 'y') goto yy1090;
	goto yy56;
yy1107:
	YYDEBUG(1107, *YYCURSOR);
	yyaccept = 26;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych == 'D') goto yy1110;
		if (yych >= 'S') goto yy1109;
	} else {
		if (yych <= 'd') {
			if (yych >= 'd') goto yy1110;
		} else {
			if (yych == 's') goto yy1109;
		}
	}
yy1108:
	YYDEBUG(1108, *YYCURSOR);
#line 1622 'ext/date/lib/parse_date.re'
	{
		timelib_sll i;
		int         behavior = 0;
		DEBUG_OUTPUT('relativetextweek');
		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();

		while(*ptr) {
			i = timelib_get_relative_text((char **) &ptr, &behavior);
			timelib_eat_spaces((char **) &ptr);
			timelib_set_relative((char **) &ptr, i, behavior, s);
			s->time->relative.weekday_behavior = 2;

			/* to handle the format weekday + last/this/next week */
			if (s->time->relative.have_weekday_relative == 0) {
				TIMELIB_HAVE_WEEKDAY_RELATIVE();
				s->time->relative.weekday = 1;
			}
		}
		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 16744 '<stdout>'
yy1109:
	YYDEBUG(1109, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy1084;
yy1110:
	YYDEBUG(1110, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1111;
	if (yych != 'a') goto yy56;
yy1111:
	YYDEBUG(1111, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1112;
	if (yych != 'y') goto yy56;
yy1112:
	YYDEBUG(1112, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1109;
	if (yych == 's') goto yy1109;
	goto yy1084;
yy1113:
	YYDEBUG(1113, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1114;
	if (yych != 'a') goto yy56;
yy1114:
	YYDEBUG(1114, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy1115;
	if (yych != 'r') goto yy56;
yy1115:
	YYDEBUG(1115, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1109;
	if (yych == 's') goto yy1109;
	goto yy1084;
yy1116:
	YYDEBUG(1116, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy1129;
	if (yych == 'i') goto yy1129;
	goto yy56;
yy1117:
	YYDEBUG(1117, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy1118;
	if (yych != 'r') goto yy56;
yy1118:
	YYDEBUG(1118, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy1119;
	if (yych != 't') goto yy56;
yy1119:
	YYDEBUG(1119, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych == 'H') goto yy1121;
		if (yych <= 'M') goto yy56;
	} else {
		if (yych <= 'h') {
			if (yych <= 'g') goto yy56;
			goto yy1121;
		} else {
			if (yych != 'n') goto yy56;
		}
	}
	YYDEBUG(1120, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy1126;
	if (yych == 'i') goto yy1126;
	goto yy56;
yy1121:
	YYDEBUG(1121, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy1122;
	if (yych != 'n') goto yy56;
yy1122:
	YYDEBUG(1122, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy1123;
	if (yych != 'i') goto yy56;
yy1123:
	YYDEBUG(1123, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy1124;
	if (yych != 'g') goto yy56;
yy1124:
	YYDEBUG(1124, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy1125;
	if (yych != 'h') goto yy56;
yy1125:
	YYDEBUG(1125, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy1115;
	if (yych == 't') goto yy1115;
	goto yy56;
yy1126:
	YYDEBUG(1126, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'G') goto yy1127;
	if (yych != 'g') goto yy56;
yy1127:
	YYDEBUG(1127, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy1128;
	if (yych != 'h') goto yy56;
yy1128:
	YYDEBUG(1128, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy1115;
	if (yych == 't') goto yy1115;
	goto yy56;
yy1129:
	YYDEBUG(1129, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy1085;
		if (yych <= 0x1F) goto yy1084;
		goto yy1085;
	} else {
		if (yych <= 'D') {
			if (yych <= 'C') goto yy1084;
		} else {
			if (yych != 'd') goto yy1084;
		}
	}
	YYDEBUG(1130, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1131;
	if (yych != 'a') goto yy56;
yy1131:
	YYDEBUG(1131, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1090;
	if (yych == 'y') goto yy1090;
	goto yy56;
yy1132:
	YYDEBUG(1132, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1115;
	if (yych == 'y') goto yy1115;
	goto yy56;
yy1133:
	YYDEBUG(1133, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'U') goto yy1134;
	if (yych != 'u') goto yy56;
yy1134:
	YYDEBUG(1134, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy1115;
	if (yych == 'r') goto yy1115;
	goto yy56;
yy1135:
	YYDEBUG(1135, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy1146;
	if (yych == 'n') goto yy1146;
	goto yy56;
yy1136:
	YYDEBUG(1136, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy1141;
	if (yych == 't') goto yy1141;
	goto yy56;
yy1137:
	YYDEBUG(1137, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy1138;
	if (yych != 'c') goto yy56;
yy1138:
	YYDEBUG(1138, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych == 'O') goto yy1139;
		if (yych <= 'R') goto yy1084;
		goto yy1109;
	} else {
		if (yych <= 'o') {
			if (yych <= 'n') goto yy1084;
		} else {
			if (yych == 's') goto yy1109;
			goto yy1084;
		}
	}
yy1139:
	YYDEBUG(1139, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy1140;
	if (yych != 'n') goto yy56;
yy1140:
	YYDEBUG(1140, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1115;
	if (yych == 'd') goto yy1115;
	goto yy56;
yy1141:
	YYDEBUG(1141, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy1085;
		if (yych <= 0x1F) goto yy1084;
		goto yy1085;
	} else {
		if (yych <= 'U') {
			if (yych <= 'T') goto yy1084;
		} else {
			if (yych != 'u') goto yy1084;
		}
	}
	YYDEBUG(1142, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy1143;
	if (yych != 'r') goto yy56;
yy1143:
	YYDEBUG(1143, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1144;
	if (yych != 'd') goto yy56;
yy1144:
	YYDEBUG(1144, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1145;
	if (yych != 'a') goto yy56;
yy1145:
	YYDEBUG(1145, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1090;
	if (yych == 'y') goto yy1090;
	goto yy56;
yy1146:
	YYDEBUG(1146, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy1085;
		if (yych <= 0x1F) goto yy1084;
		goto yy1085;
	} else {
		if (yych <= 'D') {
			if (yych <= 'C') goto yy1084;
		} else {
			if (yych != 'd') goto yy1084;
		}
	}
	YYDEBUG(1147, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1148;
	if (yych != 'a') goto yy56;
yy1148:
	YYDEBUG(1148, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1090;
	if (yych == 'y') goto yy1090;
	goto yy56;
yy1149:
	YYDEBUG(1149, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1150;
	if (yych != 'e') goto yy56;
yy1150:
	YYDEBUG(1150, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy1115;
	if (yych == 'c') goto yy1115;
	goto yy56;
yy1151:
	YYDEBUG(1151, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1152;
	if (yych != 's') goto yy56;
yy1152:
	YYDEBUG(1152, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'E') goto yy1153;
	if (yych != 'e') goto yy1084;
yy1153:
	YYDEBUG(1153, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy1115;
	if (yych == 'c') goto yy1115;
	goto yy56;
yy1154:
	YYDEBUG(1154, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy1177;
	if (yych == 'n') goto yy1177;
	goto yy56;
yy1155:
	YYDEBUG(1155, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= 'K') {
			if (yych == 'C') goto yy1159;
			goto yy56;
		} else {
			if (yych <= 'L') goto yy1158;
			if (yych <= 'M') goto yy56;
			goto yy1160;
		}
	} else {
		if (yych <= 'k') {
			if (yych == 'c') goto yy1159;
			goto yy56;
		} else {
			if (yych <= 'l') goto yy1158;
			if (yych == 'n') goto yy1160;
			goto yy56;
		}
	}
yy1156:
	YYDEBUG(1156, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'E') goto yy1157;
	if (yych != 'e') goto yy1084;
yy1157:
	YYDEBUG(1157, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy1115;
	if (yych == 'c') goto yy1115;
	goto yy56;
yy1158:
	YYDEBUG(1158, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'L') goto yy1170;
	if (yych == 'l') goto yy1170;
	goto yy56;
yy1159:
	YYDEBUG(1159, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy1163;
	if (yych == 'r') goto yy1163;
	goto yy56;
yy1160:
	YYDEBUG(1160, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'U') {
		if (yych == 'S') goto yy1109;
		if (yych <= 'T') goto yy1084;
	} else {
		if (yych <= 's') {
			if (yych <= 'r') goto yy1084;
			goto yy1109;
		} else {
			if (yych != 'u') goto yy1084;
		}
	}
	YYDEBUG(1161, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy1162;
	if (yych != 't') goto yy56;
yy1162:
	YYDEBUG(1162, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1115;
	if (yych == 'e') goto yy1115;
	goto yy56;
yy1163:
	YYDEBUG(1163, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy1164;
	if (yych != 'o') goto yy56;
yy1164:
	YYDEBUG(1164, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1165;
	if (yych != 's') goto yy56;
yy1165:
	YYDEBUG(1165, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1166;
	if (yych != 'e') goto yy56;
yy1166:
	YYDEBUG(1166, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy1167;
	if (yych != 'c') goto yy56;
yy1167:
	YYDEBUG(1167, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy1168;
	if (yych != 'o') goto yy56;
yy1168:
	YYDEBUG(1168, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy1169;
	if (yych != 'n') goto yy56;
yy1169:
	YYDEBUG(1169, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1115;
	if (yych == 'd') goto yy1115;
	goto yy56;
yy1170:
	YYDEBUG(1170, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'I') goto yy1171;
	if (yych != 'i') goto yy56;
yy1171:
	YYDEBUG(1171, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1172;
	if (yych != 's') goto yy56;
yy1172:
	YYDEBUG(1172, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1173;
	if (yych != 'e') goto yy56;
yy1173:
	YYDEBUG(1173, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'C') goto yy1174;
	if (yych != 'c') goto yy56;
yy1174:
	YYDEBUG(1174, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy1175;
	if (yych != 'o') goto yy56;
yy1175:
	YYDEBUG(1175, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'N') goto yy1176;
	if (yych != 'n') goto yy56;
yy1176:
	YYDEBUG(1176, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1115;
	if (yych == 'd') goto yy1115;
	goto yy56;
yy1177:
	YYDEBUG(1177, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy1085;
			goto yy1084;
		} else {
			if (yych <= ' ') goto yy1085;
			if (yych <= 'C') goto yy1084;
		}
	} else {
		if (yych <= 'c') {
			if (yych == 'T') goto yy1179;
			goto yy1084;
		} else {
			if (yych <= 'd') goto yy1178;
			if (yych == 't') goto yy1179;
			goto yy1084;
		}
	}
yy1178:
	YYDEBUG(1178, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1180;
	if (yych == 'a') goto yy1180;
	goto yy56;
yy1179:
	YYDEBUG(1179, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy1115;
	if (yych == 'h') goto yy1115;
	goto yy56;
yy1180:
	YYDEBUG(1180, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1090;
	if (yych == 'y') goto yy1090;
	goto yy56;
yy1181:
	YYDEBUG(1181, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy1063;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'e') goto yy1182;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1182:
	YYDEBUG(1182, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'U') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'V') goto yy1064;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'u') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'v') goto yy1183;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1183:
	YYDEBUG(1183, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'H') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'I') goto yy1065;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'h') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'i') goto yy1184;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1184:
	YYDEBUG(1184, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'N') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'O') goto yy1066;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'n') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'o') goto yy1185;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1185:
	YYDEBUG(1185, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'U') goto yy1067;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'u') goto yy1186;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1186:
	YYDEBUG(1186, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'S') goto yy1068;
	if (yych != 's') goto yy179;
	YYDEBUG(1187, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy56;
			goto yy1069;
		} else {
			if (yych == ' ') goto yy1069;
			goto yy56;
		}
	} else {
		if (yych <= '/') {
			if (yych == '.') goto yy56;
			goto yy172;
		} else {
			if (yych == '_') goto yy172;
			goto yy56;
		}
	}
yy1188:
	YYDEBUG(1188, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'G') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'F') goto yy166;
			goto yy1202;
		}
	} else {
		if (yych <= 'f') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'g') goto yy1202;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1189:
	YYDEBUG(1189, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy166;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'e') goto yy1190;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1190:
	YYDEBUG(1190, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'V') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'U') goto yy167;
		}
	} else {
		if (yych <= 'u') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'v') goto yy1191;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1191:
	YYDEBUG(1191, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy168;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'e') goto yy1192;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1192:
	YYDEBUG(1192, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy169;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'n') goto yy1193;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1193:
	YYDEBUG(1193, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'T') goto yy1194;
		if (yych != 't') goto yy3;
	}
yy1194:
	YYDEBUG(1194, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy1195;
	if (yych != 'h') goto yy56;
yy1195:
	YYDEBUG(1195, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '\t') goto yy1196;
	if (yych != ' ') goto yy56;
yy1196:
	YYDEBUG(1196, *YYCURSOR);
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 12) YYFILL(12);
	yych = *YYCURSOR;
yy1197:
	YYDEBUG(1197, *YYCURSOR);
	if (yych <= 'X') {
		if (yych <= 'G') {
			if (yych <= ' ') {
				if (yych == '\t') goto yy1196;
				if (yych <= 0x1F) goto yy56;
				goto yy1196;
			} else {
				if (yych <= 'D') {
					if (yych <= 'C') goto yy56;
					goto yy1076;
				} else {
					if (yych == 'F') goto yy1077;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'S') {
				if (yych <= 'L') {
					if (yych <= 'H') goto yy1075;
					goto yy56;
				} else {
					if (yych <= 'M') goto yy1071;
					if (yych <= 'R') goto yy56;
					goto yy1074;
				}
			} else {
				if (yych <= 'U') {
					if (yych <= 'T') goto yy1080;
					goto yy1073;
				} else {
					if (yych != 'W') goto yy56;
				}
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'f') {
				if (yych <= 'c') {
					if (yych <= 'Y') goto yy1078;
					goto yy56;
				} else {
					if (yych <= 'd') goto yy1076;
					if (yych <= 'e') goto yy56;
					goto yy1077;
				}
			} else {
				if (yych <= 'h') {
					if (yych <= 'g') goto yy56;
					goto yy1075;
				} else {
					if (yych == 'm') goto yy1071;
					goto yy56;
				}
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 't') {
					if (yych <= 's') goto yy1074;
					goto yy1080;
				} else {
					if (yych <= 'u') goto yy1073;
					if (yych <= 'v') goto yy56;
				}
			} else {
				if (yych <= 'y') {
					if (yych <= 'x') goto yy56;
					goto yy1078;
				} else {
					if (yych == 0xC2) goto yy1072;
					goto yy56;
				}
			}
		}
	}
	YYDEBUG(1198, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1199;
	if (yych != 'e') goto yy56;
yy1199:
	YYDEBUG(1199, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= 'C') goto yy56;
		if (yych <= 'D') goto yy1101;
	} else {
		if (yych <= 'c') goto yy56;
		if (yych <= 'd') goto yy1101;
		if (yych >= 'f') goto yy56;
	}
	YYDEBUG(1200, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'K') goto yy1201;
	if (yych != 'k') goto yy56;
yy1201:
	YYDEBUG(1201, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych == 'D') goto yy1110;
		if (yych <= 'R') goto yy56;
		goto yy1109;
	} else {
		if (yych <= 'd') {
			if (yych <= 'c') goto yy56;
			goto yy1110;
		} else {
			if (yych == 's') goto yy1109;
			goto yy56;
		}
	}
yy1202:
	YYDEBUG(1202, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'G') goto yy167;
		}
	} else {
		if (yych <= 'g') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'h') goto yy1203;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1203:
	YYDEBUG(1203, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy168;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 't') goto yy1204;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1204:
	YYDEBUG(1204, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy1196;
			goto yy3;
		} else {
			if (yych <= ' ') goto yy1196;
			if (yych == ')') goto yy164;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych == 'H') goto yy1205;
			if (yych <= 'Z') goto yy169;
			goto yy3;
		} else {
			if (yych == 'h') goto yy1205;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1205:
	YYDEBUG(1205, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy1196;
		goto yy3;
	} else {
		if (yych <= ' ') goto yy1196;
		if (yych == ')') goto yy164;
		goto yy3;
	}
yy1206:
	YYDEBUG(1206, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'F') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'G') goto yy1202;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'f') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'g') goto yy1214;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1207:
	YYDEBUG(1207, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy1190;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'e') goto yy1208;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1208:
	YYDEBUG(1208, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'U') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'V') goto yy1191;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'u') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'v') goto yy1209;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1209:
	YYDEBUG(1209, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy1192;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'e') goto yy1210;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1210:
	YYDEBUG(1210, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1193;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'n') goto yy1211;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1211:
	YYDEBUG(1211, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'T') goto yy1194;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 't') goto yy1212;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1212:
	YYDEBUG(1212, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'H') goto yy1195;
	if (yych != 'h') goto yy179;
yy1213:
	YYDEBUG(1213, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= ',') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy56;
			goto yy1196;
		} else {
			if (yych == ' ') goto yy1196;
			goto yy56;
		}
	} else {
		if (yych <= '/') {
			if (yych == '.') goto yy56;
			goto yy172;
		} else {
			if (yych == '_') goto yy172;
			goto yy56;
		}
	}
yy1214:
	YYDEBUG(1214, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'H') goto yy1203;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'g') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'h') goto yy1215;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1215:
	YYDEBUG(1215, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1204;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 't') goto yy1216;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1216:
	YYDEBUG(1216, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy3;
				goto yy1196;
			} else {
				if (yych == ' ') goto yy1196;
				goto yy3;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy3;
			} else {
				if (yych == '.') goto yy3;
				goto yy172;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'G') {
				if (yych <= '@') goto yy3;
				goto yy169;
			} else {
				if (yych <= 'H') goto yy1205;
				if (yych <= 'Z') goto yy169;
				goto yy3;
			}
		} else {
			if (yych <= 'g') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'h') goto yy1217;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1217:
	YYDEBUG(1217, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= ')') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy1196;
			goto yy3;
		} else {
			if (yych <= ' ') goto yy1196;
			if (yych <= '(') goto yy3;
			goto yy164;
		}
	} else {
		if (yych <= '.') {
			if (yych == '-') goto yy172;
			goto yy3;
		} else {
			if (yych <= '/') goto yy172;
			if (yych == '_') goto yy172;
			goto yy3;
		}
	}
yy1218:
	YYDEBUG(1218, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'V') {
		if (yych <= 'B') {
			if (yych == ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'O') {
				if (yych <= 'C') goto yy1234;
				goto yy166;
			} else {
				if (yych <= 'P') goto yy1236;
				if (yych <= 'U') goto yy166;
				goto yy1235;
			}
		}
	} else {
		if (yych <= 'o') {
			if (yych <= '`') {
				if (yych <= 'Z') goto yy166;
				goto yy3;
			} else {
				if (yych == 'c') goto yy1234;
				goto yy166;
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'p') goto yy1236;
				goto yy166;
			} else {
				if (yych <= 'v') goto yy1235;
				if (yych <= 'z') goto yy166;
				goto yy3;
			}
		}
	}
yy1219:
	YYDEBUG(1219, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy166;
			goto yy1229;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 't') goto yy1229;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1220:
	YYDEBUG(1220, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'X') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'W') goto yy166;
			goto yy1226;
		}
	} else {
		if (yych <= 'w') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'x') goto yy1226;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1221:
	YYDEBUG(1221, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy166;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'n') goto yy1222;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1222:
	YYDEBUG(1222, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy191;
			goto yy164;
		} else {
			if (yych <= '@') goto yy191;
			if (yych <= 'C') goto yy167;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy191;
			goto yy167;
		} else {
			if (yych <= 'd') goto yy1223;
			if (yych <= 'z') goto yy167;
			goto yy191;
		}
	}
yy1223:
	YYDEBUG(1223, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy168;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1224;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1224:
	YYDEBUG(1224, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'X') goto yy169;
		}
	} else {
		if (yych <= 'x') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'y') goto yy1225;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1225:
	YYDEBUG(1225, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == ')') goto yy164;
	goto yy191;
yy1226:
	YYDEBUG(1226, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy167;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 't') goto yy1227;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1227:
	YYDEBUG(1227, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'G') goto yy168;
		}
	} else {
		if (yych <= 'g') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'h') goto yy1228;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1228:
	YYDEBUG(1228, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '(') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy3;
			goto yy1196;
		} else {
			if (yych == ' ') goto yy1196;
			goto yy3;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy169;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1229:
	YYDEBUG(1229, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= ')') {
			if (yych <= '(') goto yy191;
			goto yy164;
		} else {
			if (yych <= '@') goto yy191;
			if (yych <= 'T') goto yy167;
		}
	} else {
		if (yych <= 't') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy191;
			goto yy167;
		} else {
			if (yych <= 'u') goto yy1230;
			if (yych <= 'z') goto yy167;
			goto yy191;
		}
	}
yy1230:
	YYDEBUG(1230, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy168;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'r') goto yy1231;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1231:
	YYDEBUG(1231, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'C') goto yy169;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'd') goto yy1232;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1232:
	YYDEBUG(1232, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'A') goto yy1233;
		if (yych != 'a') goto yy3;
	}
yy1233:
	YYDEBUG(1233, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy197;
	if (yych == 'y') goto yy197;
	goto yy56;
yy1234:
	YYDEBUG(1234, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'N') goto yy167;
			goto yy1245;
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'o') goto yy1245;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1235:
	YYDEBUG(1235, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy167;
			goto yy1242;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'e') goto yy1242;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1236:
	YYDEBUG(1236, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'T') goto yy167;
			}
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 't') goto yy1237;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy1237:
	YYDEBUG(1237, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'E') goto yy168;
			}
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy218;
				goto yy168;
			} else {
				if (yych <= 'e') goto yy1238;
				if (yych <= 'z') goto yy168;
				goto yy218;
			}
		}
	}
yy1238:
	YYDEBUG(1238, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'M') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'L') goto yy169;
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'm') goto yy1239;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1239:
	YYDEBUG(1239, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'B') goto yy1240;
		if (yych != 'b') goto yy3;
	}
yy1240:
	YYDEBUG(1240, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1241;
	if (yych != 'e') goto yy56;
yy1241:
	YYDEBUG(1241, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy229;
	if (yych == 'r') goto yy229;
	goto yy56;
yy1242:
	YYDEBUG(1242, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy168;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'n') goto yy1243;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1243:
	YYDEBUG(1243, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy169;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 't') goto yy1244;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1244:
	YYDEBUG(1244, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'H') goto yy1195;
		if (yych == 'h') goto yy1195;
		goto yy3;
	}
yy1245:
	YYDEBUG(1245, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy168;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'n') goto yy1246;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1246:
	YYDEBUG(1246, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'C') goto yy169;
			goto yy1205;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'd') goto yy1205;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1247:
	YYDEBUG(1247, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'U') {
		if (yych <= '/') {
			if (yych <= ',') {
				if (yych == ')') goto yy164;
				goto yy3;
			} else {
				if (yych == '.') goto yy3;
				goto yy172;
			}
		} else {
			if (yych <= 'C') {
				if (yych <= '@') goto yy3;
				if (yych <= 'B') goto yy166;
				goto yy1234;
			} else {
				if (yych == 'P') goto yy1236;
				goto yy166;
			}
		}
	} else {
		if (yych <= 'b') {
			if (yych <= '^') {
				if (yych <= 'V') goto yy1235;
				if (yych <= 'Z') goto yy166;
				goto yy3;
			} else {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy3;
				goto yy171;
			}
		} else {
			if (yych <= 'p') {
				if (yych <= 'c') goto yy1263;
				if (yych <= 'o') goto yy171;
				goto yy1265;
			} else {
				if (yych == 'v') goto yy1264;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1248:
	YYDEBUG(1248, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1229;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 't') goto yy1258;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1249:
	YYDEBUG(1249, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'X') goto yy1226;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'w') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'x') goto yy1255;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1250:
	YYDEBUG(1250, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1222;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'n') goto yy1251;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1251:
	YYDEBUG(1251, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy191;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy191;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1223;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy191;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy191;
				goto yy175;
			} else {
				if (yych <= 'd') goto yy1252;
				if (yych <= 'z') goto yy175;
				goto yy191;
			}
		}
	}
yy1252:
	YYDEBUG(1252, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy1224;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1253;
			if (yych <= 'z') goto yy176;
			goto yy3;
		}
	}
yy1253:
	YYDEBUG(1253, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Y') goto yy1225;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'x') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'y') goto yy1254;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1254:
	YYDEBUG(1254, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= '-') {
		if (yych == ')') goto yy164;
		if (yych <= ',') goto yy191;
		goto yy172;
	} else {
		if (yych <= '/') {
			if (yych <= '.') goto yy191;
			goto yy172;
		} else {
			if (yych == '_') goto yy172;
			goto yy191;
		}
	}
yy1255:
	YYDEBUG(1255, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1227;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 't') goto yy1256;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1256:
	YYDEBUG(1256, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'H') goto yy1228;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'g') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'h') goto yy1257;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1257:
	YYDEBUG(1257, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '-') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy1196;
			if (yych <= 0x1F) goto yy3;
			goto yy1196;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		}
	} else {
		if (yych <= 'Z') {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy3;
				goto yy172;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1258:
	YYDEBUG(1258, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy191;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy191;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'U') goto yy1230;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy191;
			goto yy172;
		} else {
			if (yych <= 't') {
				if (yych <= '`') goto yy191;
				goto yy175;
			} else {
				if (yych <= 'u') goto yy1259;
				if (yych <= 'z') goto yy175;
				goto yy191;
			}
		}
	}
yy1259:
	YYDEBUG(1259, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'R') goto yy1231;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'r') goto yy1260;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1260:
	YYDEBUG(1260, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1232;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'd') goto yy1261;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1261:
	YYDEBUG(1261, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy1233;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1262;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1262:
	YYDEBUG(1262, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy197;
	if (yych == 'y') goto yy210;
	goto yy179;
yy1263:
	YYDEBUG(1263, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'N') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'O') goto yy1245;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'n') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'o') goto yy1274;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1264:
	YYDEBUG(1264, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy1242;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'e') goto yy1271;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1265:
	YYDEBUG(1265, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'S') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'T') goto yy1237;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 's') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 't') goto yy1266;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy1266:
	YYDEBUG(1266, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'D') {
				if (yych <= '@') goto yy218;
				goto yy168;
			} else {
				if (yych <= 'E') goto yy1238;
				if (yych <= 'Z') goto yy168;
				goto yy218;
			}
		} else {
			if (yych <= 'd') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy176;
			} else {
				if (yych <= 'e') goto yy1267;
				if (yych <= 'z') goto yy176;
				goto yy218;
			}
		}
	}
yy1267:
	YYDEBUG(1267, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'L') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'M') goto yy1239;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'l') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'm') goto yy1268;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1268:
	YYDEBUG(1268, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'A') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'B') goto yy1240;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'b') goto yy1269;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1269:
	YYDEBUG(1269, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'E') goto yy1241;
	if (yych != 'e') goto yy179;
	YYDEBUG(1270, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy229;
	if (yych == 'r') goto yy341;
	goto yy179;
yy1271:
	YYDEBUG(1271, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1243;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'n') goto yy1272;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1272:
	YYDEBUG(1272, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1244;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 't') goto yy1273;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1273:
	YYDEBUG(1273, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'H') goto yy1195;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'h') goto yy1213;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1274:
	YYDEBUG(1274, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1246;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'n') goto yy1275;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1275:
	YYDEBUG(1275, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1205;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'd') goto yy1217;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1276:
	YYDEBUG(1276, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'C') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'B') goto yy166;
		}
	} else {
		if (yych <= 'b') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'c') goto yy1277;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1277:
	YYDEBUG(1277, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'K') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'J') goto yy167;
		}
	} else {
		if (yych <= 'j') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'k') goto yy1278;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1278:
	YYDEBUG(1278, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ')') {
		if (yych == ' ') goto yy1279;
		if (yych <= '(') goto yy3;
		goto yy164;
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') goto yy3;
			goto yy168;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1279:
	YYDEBUG(1279, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy1280;
	if (yych != 'o') goto yy56;
yy1280:
	YYDEBUG(1280, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'F') goto yy1281;
	if (yych != 'f') goto yy56;
yy1281:
	YYDEBUG(1281, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ' ') goto yy56;
	YYDEBUG(1282, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy1283;
	if (yych <= '2') goto yy1285;
	if (yych <= '9') goto yy1286;
	goto yy56;
yy1283:
	YYDEBUG(1283, *YYCURSOR);
	yyaccept = 27;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy1287;
	if (yych <= '9') goto yy1286;
	goto yy1287;
yy1284:
	YYDEBUG(1284, *YYCURSOR);
#line 1096 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('backof | frontof');
		TIMELIB_INIT;
		TIMELIB_UNHAVE_TIME();
		TIMELIB_HAVE_TIME();

		if (*ptr == 'b') {
			s->time->h = timelib_get_nr((char **) &ptr, 2);
			s->time->i = 15;
		} else {
			s->time->h = timelib_get_nr((char **) &ptr, 2) - 1;
			s->time->i = 45;
		}
		if (*ptr != '\0' ) {
			timelib_eat_spaces((char **) &ptr);
			s->time->h += timelib_meridian((char **) &ptr, s->time->h);
		}

		TIMELIB_DEINIT;
		return TIMELIB_LF_DAY_OF_MONTH;
	}
#line 19601 '<stdout>'
yy1285:
	YYDEBUG(1285, *YYCURSOR);
	yyaccept = 27;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy1287;
	if (yych >= '5') goto yy1287;
yy1286:
	YYDEBUG(1286, *YYCURSOR);
	yyaccept = 27;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
yy1287:
	YYDEBUG(1287, *YYCURSOR);
	if (yych <= 'A') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy1286;
			goto yy1284;
		} else {
			if (yych <= ' ') goto yy1286;
			if (yych <= '@') goto yy1284;
		}
	} else {
		if (yych <= '`') {
			if (yych != 'P') goto yy1284;
		} else {
			if (yych <= 'a') goto yy1288;
			if (yych != 'p') goto yy1284;
		}
	}
yy1288:
	YYDEBUG(1288, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych != '.') goto yy56;
	} else {
		if (yych <= 'M') goto yy1290;
		if (yych == 'm') goto yy1290;
		goto yy56;
	}
	YYDEBUG(1289, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy1290;
	if (yych != 'm') goto yy56;
yy1290:
	YYDEBUG(1290, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych <= 0x00) goto yy1292;
		if (yych == '\t') goto yy1292;
		goto yy56;
	} else {
		if (yych <= ' ') goto yy1292;
		if (yych != '.') goto yy56;
	}
	YYDEBUG(1291, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '\t') {
		if (yych <= 0x00) goto yy1292;
		if (yych <= 0x08) goto yy56;
	} else {
		if (yych != ' ') goto yy56;
	}
yy1292:
	YYDEBUG(1292, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy1284;
yy1293:
	YYDEBUG(1293, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'B') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'C') goto yy1277;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'b') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'c') goto yy1294;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1294:
	YYDEBUG(1294, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'J') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'K') goto yy1278;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'j') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'k') goto yy1295;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1295:
	YYDEBUG(1295, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= '(') {
			if (yych == ' ') goto yy1279;
			goto yy3;
		} else {
			if (yych <= ')') goto yy164;
			if (yych == '-') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '/') goto yy172;
			if (yych <= '@') goto yy3;
			if (yych <= 'Z') goto yy168;
			goto yy3;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy176;
			goto yy3;
		}
	}
yy1296:
	YYDEBUG(1296, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'R') goto yy166;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 's') goto yy1297;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1297:
	YYDEBUG(1297, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy167;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 't') goto yy1298;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1298:
	YYDEBUG(1298, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '(') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy3;
			goto yy1069;
		} else {
			if (yych != ' ') goto yy3;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy168;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1299:
	YYDEBUG(1299, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1300;
	if (yych != 'd') goto yy1070;
yy1300:
	YYDEBUG(1300, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1301;
	if (yych != 'a') goto yy56;
yy1301:
	YYDEBUG(1301, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1302;
	if (yych != 'y') goto yy56;
yy1302:
	YYDEBUG(1302, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych != ' ') goto yy1084;
	} else {
		if (yych <= 'S') goto yy1109;
		if (yych == 's') goto yy1109;
		goto yy1084;
	}
	YYDEBUG(1303, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy1304;
	if (yych != 'o') goto yy56;
yy1304:
	YYDEBUG(1304, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'F') goto yy1305;
	if (yych != 'f') goto yy56;
yy1305:
	YYDEBUG(1305, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(1306, *YYCURSOR);
#line 1079 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('firstdayof | lastdayof');
		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();

		/* skip 'last day of' or 'first day of' */
		if (*ptr == 'l' || *ptr == 'L') {
			s->time->relative.first_last_day_of = TIMELIB_SPECIAL_LAST_DAY_OF_MONTH;
		} else {
			s->time->relative.first_last_day_of = TIMELIB_SPECIAL_FIRST_DAY_OF_MONTH;
		}

		TIMELIB_DEINIT;
		return TIMELIB_LF_DAY_OF_MONTH;
	}
#line 19878 '<stdout>'
yy1307:
	YYDEBUG(1307, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'S') goto yy1297;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'r') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 's') goto yy1308;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1308:
	YYDEBUG(1308, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1298;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 't') goto yy1309;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1309:
	YYDEBUG(1309, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '-') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy1069;
			if (yych <= 0x1F) goto yy3;
			goto yy1299;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		}
	} else {
		if (yych <= 'Z') {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy3;
				goto yy172;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1310:
	YYDEBUG(1310, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'B') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'A') goto yy166;
			goto yy1346;
		}
	} else {
		if (yych <= 'a') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'b') goto yy1346;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1311:
	YYDEBUG(1311, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == 'F') goto yy1336;
			if (yych <= 'Q') goto yy166;
			goto yy1335;
		}
	} else {
		if (yych <= 'f') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			if (yych <= 'e') goto yy166;
			goto yy1336;
		} else {
			if (yych == 'r') goto yy1335;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1312:
	YYDEBUG(1312, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'T') goto yy166;
			goto yy1332;
		}
	} else {
		if (yych <= 't') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'u') goto yy1332;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1313:
	YYDEBUG(1313, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == 'I') goto yy1315;
			if (yych <= 'N') goto yy166;
		}
	} else {
		if (yych <= 'i') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			if (yych <= 'h') goto yy166;
			goto yy1315;
		} else {
			if (yych == 'o') goto yy1314;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1314:
	YYDEBUG(1314, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy167;
			goto yy1318;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'n') goto yy1318;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1315:
	YYDEBUG(1315, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy191;
			goto yy164;
		} else {
			if (yych <= '@') goto yy191;
			if (yych <= 'C') goto yy167;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy191;
			goto yy167;
		} else {
			if (yych <= 'd') goto yy1316;
			if (yych <= 'z') goto yy167;
			goto yy191;
		}
	}
yy1316:
	YYDEBUG(1316, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy168;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1317;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1317:
	YYDEBUG(1317, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'X') goto yy169;
			goto yy1225;
		}
	} else {
		if (yych <= 'x') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'y') goto yy1225;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1318:
	YYDEBUG(1318, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy168;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 't') goto yy1319;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1319:
	YYDEBUG(1319, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= ')') {
		if (yych == ' ') goto yy1320;
		if (yych <= '(') goto yy3;
		goto yy164;
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') goto yy3;
			goto yy169;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1320:
	YYDEBUG(1320, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy1321;
	if (yych != 'o') goto yy56;
yy1321:
	YYDEBUG(1321, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'F') goto yy1322;
	if (yych != 'f') goto yy56;
yy1322:
	YYDEBUG(1322, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != ' ') goto yy56;
	YYDEBUG(1323, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '1') goto yy1324;
	if (yych <= '2') goto yy1325;
	if (yych <= '9') goto yy1326;
	goto yy56;
yy1324:
	YYDEBUG(1324, *YYCURSOR);
	yyaccept = 27;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy1327;
	if (yych <= '9') goto yy1326;
	goto yy1327;
yy1325:
	YYDEBUG(1325, *YYCURSOR);
	yyaccept = 27;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy1327;
	if (yych >= '5') goto yy1327;
yy1326:
	YYDEBUG(1326, *YYCURSOR);
	yyaccept = 27;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
yy1327:
	YYDEBUG(1327, *YYCURSOR);
	if (yych <= 'A') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy1326;
			goto yy1284;
		} else {
			if (yych <= ' ') goto yy1326;
			if (yych <= '@') goto yy1284;
		}
	} else {
		if (yych <= '`') {
			if (yych != 'P') goto yy1284;
		} else {
			if (yych <= 'a') goto yy1328;
			if (yych != 'p') goto yy1284;
		}
	}
yy1328:
	YYDEBUG(1328, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych != '.') goto yy56;
	} else {
		if (yych <= 'M') goto yy1330;
		if (yych == 'm') goto yy1330;
		goto yy56;
	}
	YYDEBUG(1329, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'M') goto yy1330;
	if (yych != 'm') goto yy56;
yy1330:
	YYDEBUG(1330, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych <= 0x00) goto yy1292;
		if (yych == '\t') goto yy1292;
		goto yy56;
	} else {
		if (yych <= ' ') goto yy1292;
		if (yych != '.') goto yy56;
	}
	YYDEBUG(1331, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '\t') {
		if (yych <= 0x00) goto yy1292;
		if (yych <= 0x08) goto yy56;
		goto yy1292;
	} else {
		if (yych == ' ') goto yy1292;
		goto yy56;
	}
yy1332:
	YYDEBUG(1332, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy167;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'r') goto yy1333;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1333:
	YYDEBUG(1333, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy168;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 't') goto yy1334;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1334:
	YYDEBUG(1334, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'G') goto yy169;
			goto yy1205;
		}
	} else {
		if (yych <= 'g') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'h') goto yy1205;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1335:
	YYDEBUG(1335, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'R') goto yy167;
			goto yy1338;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 's') goto yy1338;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1336:
	YYDEBUG(1336, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy167;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 't') goto yy1337;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1337:
	YYDEBUG(1337, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'G') goto yy168;
			goto yy1228;
		}
	} else {
		if (yych <= 'g') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'h') goto yy1228;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1338:
	YYDEBUG(1338, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy168;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 't') goto yy1339;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1339:
	YYDEBUG(1339, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '(') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy3;
			goto yy1196;
		} else {
			if (yych != ' ') goto yy3;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy169;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1340:
	YYDEBUG(1340, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'D') goto yy1341;
	if (yych != 'd') goto yy1197;
yy1341:
	YYDEBUG(1341, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1342;
	if (yych != 'a') goto yy56;
yy1342:
	YYDEBUG(1342, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1343;
	if (yych != 'y') goto yy56;
yy1343:
	YYDEBUG(1343, *YYCURSOR);
	yyaccept = 25;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych != ' ') goto yy1084;
	} else {
		if (yych <= 'S') goto yy1109;
		if (yych == 's') goto yy1109;
		goto yy1084;
	}
	YYDEBUG(1344, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'O') goto yy1345;
	if (yych != 'o') goto yy56;
yy1345:
	YYDEBUG(1345, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'F') goto yy1305;
	if (yych == 'f') goto yy1305;
	goto yy56;
yy1346:
	YYDEBUG(1346, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'R') goto yy167;
			}
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'r') goto yy1347;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy1347:
	YYDEBUG(1347, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'T') goto yy168;
		}
	} else {
		if (yych <= 't') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'u') goto yy1348;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1348:
	YYDEBUG(1348, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy169;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1349;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1349:
	YYDEBUG(1349, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'R') goto yy1350;
		if (yych != 'r') goto yy3;
	}
yy1350:
	YYDEBUG(1350, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy229;
	if (yych == 'y') goto yy229;
	goto yy56;
yy1351:
	YYDEBUG(1351, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'A') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'B') goto yy1346;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'b') goto yy1369;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1352:
	YYDEBUG(1352, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '.') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych == '-') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= '@') {
				if (yych <= '/') goto yy172;
				goto yy3;
			} else {
				if (yych == 'F') goto yy1336;
				goto yy166;
			}
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') {
				if (yych <= 'R') goto yy1335;
				goto yy166;
			} else {
				if (yych == '_') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 'q') {
				if (yych == 'f') goto yy1365;
				goto yy171;
			} else {
				if (yych <= 'r') goto yy1364;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1353:
	YYDEBUG(1353, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'U') goto yy1332;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 't') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'u') goto yy1361;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1354:
	YYDEBUG(1354, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'N') {
		if (yych <= '.') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych == '-') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= '@') {
				if (yych <= '/') goto yy172;
				goto yy3;
			} else {
				if (yych == 'I') goto yy1315;
				goto yy166;
			}
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') {
				if (yych <= 'O') goto yy1314;
				goto yy166;
			} else {
				if (yych == '_') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 'n') {
				if (yych == 'i') goto yy1356;
				goto yy171;
			} else {
				if (yych <= 'o') goto yy1355;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1355:
	YYDEBUG(1355, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1318;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'n') goto yy1359;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1356:
	YYDEBUG(1356, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy191;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy191;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1316;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy191;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy191;
				goto yy175;
			} else {
				if (yych <= 'd') goto yy1357;
				if (yych <= 'z') goto yy175;
				goto yy191;
			}
		}
	}
yy1357:
	YYDEBUG(1357, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy1317;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1358;
			if (yych <= 'z') goto yy176;
			goto yy3;
		}
	}
yy1358:
	YYDEBUG(1358, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Y') goto yy1225;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'x') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'y') goto yy1254;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1359:
	YYDEBUG(1359, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1319;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 't') goto yy1360;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1360:
	YYDEBUG(1360, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= '(') {
			if (yych == ' ') goto yy1320;
			goto yy3;
		} else {
			if (yych <= ')') goto yy164;
			if (yych == '-') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '/') goto yy172;
			if (yych <= '@') goto yy3;
			if (yych <= 'Z') goto yy169;
			goto yy3;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy177;
			goto yy3;
		}
	}
yy1361:
	YYDEBUG(1361, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'R') goto yy1333;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'r') goto yy1362;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1362:
	YYDEBUG(1362, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1334;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 't') goto yy1363;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1363:
	YYDEBUG(1363, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'H') goto yy1205;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'g') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'h') goto yy1217;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1364:
	YYDEBUG(1364, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'S') goto yy1338;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'r') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 's') goto yy1367;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1365:
	YYDEBUG(1365, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1337;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 't') goto yy1366;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1366:
	YYDEBUG(1366, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'H') goto yy1228;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'g') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'h') goto yy1257;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1367:
	YYDEBUG(1367, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1339;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 't') goto yy1368;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1368:
	YYDEBUG(1368, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '-') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy1196;
			if (yych <= 0x1F) goto yy3;
			goto yy1340;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		}
	} else {
		if (yych <= 'Z') {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy3;
				goto yy172;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1369:
	YYDEBUG(1369, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'Q') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'R') goto yy1347;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 'q') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'r') goto yy1370;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy1370:
	YYDEBUG(1370, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'U') goto yy1348;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 't') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'u') goto yy1371;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1371:
	YYDEBUG(1371, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy1349;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1372;
			if (yych <= 'z') goto yy177;
			goto yy3;
		}
	}
yy1372:
	YYDEBUG(1372, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'R') goto yy1350;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'r') goto yy1373;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1373:
	YYDEBUG(1373, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy229;
	if (yych == 'y') goto yy341;
	goto yy179;
yy1374:
	YYDEBUG(1374, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
yy1375:
	YYDEBUG(1375, *YYCURSOR);
	yyaccept = 28;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
	yych = *YYCURSOR;
	YYDEBUG(1376, *YYCURSOR);
	if (yych == '.') goto yy1378;
	if (yych <= '/') goto yy1377;
	if (yych <= '9') goto yy1375;
yy1377:
	YYDEBUG(1377, *YYCURSOR);
#line 1025 'ext/date/lib/parse_date.re'
	{
		timelib_ull i;

		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();
		TIMELIB_UNHAVE_DATE();
		TIMELIB_UNHAVE_TIME();
		TIMELIB_HAVE_TZ();

		i = timelib_get_unsigned_nr((char **) &ptr, 24);
		s->time->y = 1970;
		s->time->m = 1;
		s->time->d = 1;
		s->time->h = s->time->i = s->time->s = 0;
		s->time->f = 0.0;
		s->time->relative.s += i;
		s->time->is_localtime = 1;
		s->time->zone_type = TIMELIB_ZONETYPE_OFFSET;
		s->time->z = 0;
		s->time->dst = 0;

		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 21336 '<stdout>'
yy1378:
	YYDEBUG(1378, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(1379, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(1380, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(1381, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(1382, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(1383, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(1384, *YYCURSOR);
	++YYCURSOR;
	YYDEBUG(1385, *YYCURSOR);
#line 1051 'ext/date/lib/parse_date.re'
	{
		timelib_ull i, ms;

		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();
		TIMELIB_UNHAVE_DATE();
		TIMELIB_UNHAVE_TIME();
		TIMELIB_HAVE_TZ();

		i = timelib_get_unsigned_nr((char **) &ptr, 24);
		ms = timelib_get_unsigned_nr((char **) &ptr, 24);
		s->time->y = 1970;
		s->time->m = 1;
		s->time->d = 1;
		s->time->h = s->time->i = s->time->s = 0;
		s->time->f = 0.0;
		s->time->relative.s += i;
		s->time->relative.f = ((double) ms) / 1000000.0;
		s->time->is_localtime = 1;
		s->time->zone_type = TIMELIB_ZONETYPE_OFFSET;
		s->time->z = 0;
		s->time->dst = 0;

		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 21392 '<stdout>'
yy1386:
	YYDEBUG(1386, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy166;
			goto yy1427;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'n') goto yy1427;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1387:
	YYDEBUG(1387, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'U') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == 'I') goto yy1419;
			if (yych <= 'T') goto yy166;
			goto yy1420;
		}
	} else {
		if (yych <= 'i') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			if (yych <= 'h') goto yy166;
			goto yy1419;
		} else {
			if (yych == 'u') goto yy1420;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1388:
	YYDEBUG(1388, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'M') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == 'D') goto yy1408;
			if (yych <= 'L') goto yy166;
			goto yy1409;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			if (yych <= 'c') goto yy166;
			goto yy1408;
		} else {
			if (yych == 'm') goto yy1409;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1389:
	YYDEBUG(1389, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy166;
			goto yy1404;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'e') goto yy1404;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1390:
	YYDEBUG(1390, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy166;
			goto yy1400;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'e') goto yy1400;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1391:
	YYDEBUG(1391, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') {
		if (yych == '.') goto yy1029;
		goto yy56;
	} else {
		if (yych <= '9') goto yy1394;
		if (yych <= ':') goto yy1029;
		goto yy56;
	}
yy1392:
	YYDEBUG(1392, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') {
		if (yych == '.') goto yy1029;
		goto yy56;
	} else {
		if (yych <= '4') goto yy1394;
		if (yych == ':') goto yy1029;
		goto yy56;
	}
yy1393:
	YYDEBUG(1393, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == '.') goto yy1029;
	if (yych == ':') goto yy1029;
	goto yy56;
yy1394:
	YYDEBUG(1394, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') {
		if (yych == '.') goto yy1029;
		goto yy56;
	} else {
		if (yych <= '5') goto yy1395;
		if (yych == ':') goto yy1029;
		goto yy56;
	}
yy1395:
	YYDEBUG(1395, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych >= ':') goto yy56;
	YYDEBUG(1396, *YYCURSOR);
	yyaccept = 23;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy1032;
	if (yych <= '5') goto yy1397;
	if (yych <= '6') goto yy1398;
	goto yy1032;
yy1397:
	YYDEBUG(1397, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy56;
	if (yych <= '9') goto yy1399;
	goto yy56;
yy1398:
	YYDEBUG(1398, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych != '0') goto yy56;
yy1399:
	YYDEBUG(1399, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy1040;
yy1400:
	YYDEBUG(1400, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'L') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'K') goto yy167;
		}
	} else {
		if (yych <= 'k') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'l') goto yy1401;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1401:
	YYDEBUG(1401, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'F') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'E') goto yy168;
		}
	} else {
		if (yych <= 'e') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'f') goto yy1402;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1402:
	YYDEBUG(1402, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy169;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 't') goto yy1403;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1403:
	YYDEBUG(1403, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'H') goto yy1195;
		if (yych == 'h') goto yy1195;
		goto yy3;
	}
yy1404:
	YYDEBUG(1404, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= ')') {
			if (yych <= '(') goto yy191;
			goto yy164;
		} else {
			if (yych <= '@') goto yy191;
			if (yych <= 'R') goto yy167;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy191;
			goto yy167;
		} else {
			if (yych <= 's') goto yy1405;
			if (yych <= 'z') goto yy167;
			goto yy191;
		}
	}
yy1405:
	YYDEBUG(1405, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'C') goto yy168;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'd') goto yy1406;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1406:
	YYDEBUG(1406, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy169;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1407;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1407:
	YYDEBUG(1407, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'X') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'Y') goto yy197;
		if (yych == 'y') goto yy197;
		goto yy3;
	}
yy1408:
	YYDEBUG(1408, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
		goto yy1416;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy167;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1416;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1409:
	YYDEBUG(1409, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'O') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'N') goto yy167;
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'o') goto yy1410;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1410:
	YYDEBUG(1410, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy168;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'r') goto yy1411;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1411:
	YYDEBUG(1411, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy169;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'r') goto yy1412;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1412:
	YYDEBUG(1412, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'N') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'O') goto yy1413;
		if (yych != 'o') goto yy3;
	}
yy1413:
	YYDEBUG(1413, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'W') goto yy1414;
	if (yych != 'w') goto yy56;
yy1414:
	YYDEBUG(1414, *YYCURSOR);
	++YYCURSOR;
yy1415:
	YYDEBUG(1415, *YYCURSOR);
#line 1013 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('tomorrow');
		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();
		TIMELIB_UNHAVE_TIME();

		s->time->relative.d = 1;
		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 21839 '<stdout>'
yy1416:
	YYDEBUG(1416, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'X') goto yy168;
		}
	} else {
		if (yych <= 'x') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'y') goto yy1417;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1417:
	YYDEBUG(1417, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '@') {
		if (yych == ')') goto yy164;
	} else {
		if (yych <= 'Z') goto yy169;
		if (yych <= '`') goto yy1418;
		if (yych <= 'z') goto yy169;
	}
yy1418:
	YYDEBUG(1418, *YYCURSOR);
#line 1003 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('midnight | today');
		TIMELIB_INIT;
		TIMELIB_UNHAVE_TIME();

		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 21883 '<stdout>'
yy1419:
	YYDEBUG(1419, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych <= 'Q') goto yy167;
			if (yych <= 'R') goto yy1425;
			goto yy1426;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'r') goto yy1425;
			if (yych <= 's') goto yy1426;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1420:
	YYDEBUG(1420, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy191;
			goto yy164;
		} else {
			if (yych <= '@') goto yy191;
			if (yych <= 'Q') goto yy167;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy191;
			goto yy167;
		} else {
			if (yych <= 'r') goto yy1421;
			if (yych <= 'z') goto yy167;
			goto yy191;
		}
	}
yy1421:
	YYDEBUG(1421, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'R') goto yy168;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 's') goto yy1422;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1422:
	YYDEBUG(1422, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'C') goto yy169;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'd') goto yy1423;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1423:
	YYDEBUG(1423, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'A') goto yy1424;
		if (yych != 'a') goto yy3;
	}
yy1424:
	YYDEBUG(1424, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy197;
	if (yych == 'y') goto yy197;
	goto yy56;
yy1425:
	YYDEBUG(1425, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'C') goto yy168;
			goto yy1228;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'd') goto yy1228;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1426:
	YYDEBUG(1426, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '(') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy3;
			goto yy1069;
		} else {
			if (yych == ' ') goto yy1069;
			goto yy3;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy168;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1427:
	YYDEBUG(1427, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy167;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 't') goto yy1428;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1428:
	YYDEBUG(1428, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'G') goto yy168;
			goto yy1228;
		}
	} else {
		if (yych <= 'g') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'h') goto yy1228;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1429:
	YYDEBUG(1429, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1427;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'n') goto yy1459;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1430:
	YYDEBUG(1430, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'T') {
		if (yych <= '.') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych == '-') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= '@') {
				if (yych <= '/') goto yy172;
				goto yy3;
			} else {
				if (yych == 'I') goto yy1419;
				goto yy166;
			}
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') {
				if (yych <= 'U') goto yy1420;
				goto yy166;
			} else {
				if (yych == '_') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 't') {
				if (yych == 'i') goto yy1451;
				goto yy171;
			} else {
				if (yych <= 'u') goto yy1452;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1431:
	YYDEBUG(1431, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'L') {
		if (yych <= '.') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych == '-') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= '@') {
				if (yych <= '/') goto yy172;
				goto yy3;
			} else {
				if (yych == 'D') goto yy1408;
				goto yy166;
			}
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') {
				if (yych <= 'M') goto yy1409;
				goto yy166;
			} else {
				if (yych == '_') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 'l') {
				if (yych == 'd') goto yy1442;
				goto yy171;
			} else {
				if (yych <= 'm') goto yy1443;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1432:
	YYDEBUG(1432, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy1404;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'e') goto yy1438;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1433:
	YYDEBUG(1433, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy1400;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'e') goto yy1434;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1434:
	YYDEBUG(1434, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'K') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'L') goto yy1401;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'k') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'l') goto yy1435;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1435:
	YYDEBUG(1435, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'E') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'F') goto yy1402;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'e') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'f') goto yy1436;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1436:
	YYDEBUG(1436, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1403;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 't') goto yy1437;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1437:
	YYDEBUG(1437, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'H') goto yy1195;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'h') goto yy1213;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1438:
	YYDEBUG(1438, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy191;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy191;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'S') goto yy1405;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy191;
			goto yy172;
		} else {
			if (yych <= 'r') {
				if (yych <= '`') goto yy191;
				goto yy175;
			} else {
				if (yych <= 's') goto yy1439;
				if (yych <= 'z') goto yy175;
				goto yy191;
			}
		}
	}
yy1439:
	YYDEBUG(1439, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1406;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'd') goto yy1440;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1440:
	YYDEBUG(1440, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy1407;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1441;
			if (yych <= 'z') goto yy177;
			goto yy3;
		}
	}
yy1441:
	YYDEBUG(1441, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Y') goto yy197;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'y') goto yy210;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1442:
	YYDEBUG(1442, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy1416;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1449;
			if (yych <= 'z') goto yy175;
			goto yy3;
		}
	}
yy1443:
	YYDEBUG(1443, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'N') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'O') goto yy1410;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'n') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'o') goto yy1444;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1444:
	YYDEBUG(1444, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'R') goto yy1411;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'r') goto yy1445;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1445:
	YYDEBUG(1445, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'R') goto yy1412;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'r') goto yy1446;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1446:
	YYDEBUG(1446, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'N') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'O') goto yy1413;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'o') goto yy1447;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1447:
	YYDEBUG(1447, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'W') goto yy1414;
	if (yych != 'w') goto yy179;
	YYDEBUG(1448, *YYCURSOR);
	yyaccept = 29;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= '.') {
		if (yych == '-') goto yy172;
		goto yy1415;
	} else {
		if (yych <= '/') goto yy172;
		if (yych == '_') goto yy172;
		goto yy1415;
	}
yy1449:
	YYDEBUG(1449, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Y') goto yy1417;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'x') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'y') goto yy1450;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1450:
	YYDEBUG(1450, *YYCURSOR);
	yyaccept = 30;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy1418;
		} else {
			if (yych == '.') goto yy1418;
			goto yy172;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy1418;
			if (yych <= 'Z') goto yy169;
			goto yy1418;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy1418;
			if (yych <= 'z') goto yy177;
			goto yy1418;
		}
	}
yy1451:
	YYDEBUG(1451, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych <= '/') {
				if (yych <= '.') goto yy3;
				goto yy172;
			} else {
				if (yych <= '@') goto yy3;
				if (yych <= 'Q') goto yy167;
				goto yy1425;
			}
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') {
				if (yych <= 'S') goto yy1426;
				goto yy167;
			} else {
				if (yych == '_') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 'r') {
				if (yych <= 'q') goto yy175;
				goto yy1457;
			} else {
				if (yych <= 's') goto yy1458;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1452:
	YYDEBUG(1452, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy191;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy191;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'R') goto yy1421;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy191;
			goto yy172;
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy191;
				goto yy175;
			} else {
				if (yych <= 'r') goto yy1453;
				if (yych <= 'z') goto yy175;
				goto yy191;
			}
		}
	}
yy1453:
	YYDEBUG(1453, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'S') goto yy1422;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'r') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 's') goto yy1454;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1454:
	YYDEBUG(1454, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1423;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'd') goto yy1455;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1455:
	YYDEBUG(1455, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy1424;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1456;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1456:
	YYDEBUG(1456, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy197;
	if (yych == 'y') goto yy210;
	goto yy179;
yy1457:
	YYDEBUG(1457, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1228;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'd') goto yy1257;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1458:
	YYDEBUG(1458, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '-') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy1069;
			if (yych <= 0x1F) goto yy3;
			goto yy1069;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		}
	} else {
		if (yych <= 'Z') {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy3;
				goto yy172;
			} else {
				if (yych <= '`') goto yy3;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1459:
	YYDEBUG(1459, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1428;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 't') goto yy1460;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1460:
	YYDEBUG(1460, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'H') goto yy1228;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'g') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'h') goto yy1257;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1461:
	YYDEBUG(1461, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych <= '@') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == 'R') goto yy1473;
			if (yych <= 'X') goto yy166;
			goto yy1474;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			if (yych <= 'q') goto yy166;
			goto yy1473;
		} else {
			if (yych == 'y') goto yy1474;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1462:
	YYDEBUG(1462, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'C') goto yy166;
			goto yy1467;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'd') goto yy1467;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1463:
	YYDEBUG(1463, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy166;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'n') goto yy1464;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1464:
	YYDEBUG(1464, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'D') {
		if (yych <= ')') {
			if (yych <= '(') goto yy191;
			goto yy164;
		} else {
			if (yych <= '@') goto yy191;
			if (yych <= 'C') goto yy167;
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy191;
			goto yy167;
		} else {
			if (yych <= 'd') goto yy1465;
			if (yych <= 'z') goto yy167;
			goto yy191;
		}
	}
yy1465:
	YYDEBUG(1465, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'A') {
		if (yych == ')') goto yy164;
		if (yych <= '@') goto yy3;
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') goto yy168;
			goto yy3;
		} else {
			if (yych <= 'a') goto yy1466;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1466:
	YYDEBUG(1466, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'Y') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'X') goto yy169;
			goto yy1225;
		}
	} else {
		if (yych <= 'x') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'y') goto yy1225;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1467:
	YYDEBUG(1467, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy167;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'n') goto yy1468;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1468:
	YYDEBUG(1468, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'I') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'H') goto yy168;
		}
	} else {
		if (yych <= 'h') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'i') goto yy1469;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1469:
	YYDEBUG(1469, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'G') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'F') goto yy169;
		}
	} else {
		if (yych <= 'f') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'g') goto yy1470;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1470:
	YYDEBUG(1470, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'H') goto yy1471;
		if (yych != 'h') goto yy3;
	}
yy1471:
	YYDEBUG(1471, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy1472;
	if (yych != 't') goto yy56;
yy1472:
	YYDEBUG(1472, *YYCURSOR);
	yych = *++YYCURSOR;
	goto yy1418;
yy1473:
	YYDEBUG(1473, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych == 'C') goto yy1475;
				goto yy167;
			}
		} else {
			if (yych <= 'b') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'c') goto yy1475;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy1474:
	YYDEBUG(1474, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '-') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy218;
			goto yy220;
		} else {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy218;
			goto yy221;
		}
	} else {
		if (yych <= '@') {
			if (yych == '/') goto yy218;
			if (yych <= '9') goto yy220;
			goto yy218;
		} else {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy218;
			if (yych <= 'z') goto yy167;
			goto yy218;
		}
	}
yy1475:
	YYDEBUG(1475, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'G') goto yy168;
			goto yy360;
		}
	} else {
		if (yych <= 'g') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'h') goto yy360;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1476:
	YYDEBUG(1476, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych <= '.') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych == '-') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= '@') {
				if (yych <= '/') goto yy172;
				goto yy3;
			} else {
				if (yych == 'R') goto yy1473;
				goto yy166;
			}
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'Z') {
				if (yych <= 'Y') goto yy1474;
				goto yy166;
			} else {
				if (yych == '_') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 'x') {
				if (yych == 'r') goto yy1488;
				goto yy171;
			} else {
				if (yych <= 'y') goto yy1489;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1477:
	YYDEBUG(1477, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1467;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'd') goto yy1482;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1478:
	YYDEBUG(1478, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1464;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'n') goto yy1479;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1479:
	YYDEBUG(1479, *YYCURSOR);
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy191;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy191;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'D') goto yy1465;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy191;
			goto yy172;
		} else {
			if (yych <= 'c') {
				if (yych <= '`') goto yy191;
				goto yy175;
			} else {
				if (yych <= 'd') goto yy1480;
				if (yych <= 'z') goto yy175;
				goto yy191;
			}
		}
	}
yy1480:
	YYDEBUG(1480, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'A') goto yy1466;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= '`') goto yy3;
			if (yych <= 'a') goto yy1481;
			if (yych <= 'z') goto yy176;
			goto yy3;
		}
	}
yy1481:
	YYDEBUG(1481, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'X') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Y') goto yy1225;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'x') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'y') goto yy1254;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1482:
	YYDEBUG(1482, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1468;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'n') goto yy1483;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1483:
	YYDEBUG(1483, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'H') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'I') goto yy1469;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'h') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'i') goto yy1484;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1484:
	YYDEBUG(1484, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'F') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'G') goto yy1470;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'f') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'g') goto yy1485;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1485:
	YYDEBUG(1485, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'H') goto yy1471;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'h') goto yy1486;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1486:
	YYDEBUG(1486, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'T') goto yy1472;
	if (yych != 't') goto yy179;
	YYDEBUG(1487, *YYCURSOR);
	yyaccept = 30;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= '.') {
		if (yych == '-') goto yy172;
		goto yy1418;
	} else {
		if (yych <= '/') goto yy172;
		if (yych == '_') goto yy172;
		goto yy1418;
	}
yy1488:
	YYDEBUG(1488, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'B') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'C') goto yy1475;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 'b') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'c') goto yy1490;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy1489:
	YYDEBUG(1489, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '.') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy220;
			if (yych <= 0x1F) goto yy218;
			goto yy220;
		} else {
			if (yych <= ')') {
				if (yych <= '(') goto yy218;
				goto yy164;
			} else {
				if (yych <= ',') goto yy218;
				if (yych <= '-') goto yy336;
				goto yy220;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '/') goto yy172;
			if (yych <= '9') goto yy220;
			if (yych <= '@') goto yy218;
			goto yy167;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy218;
				goto yy172;
			} else {
				if (yych <= '`') goto yy218;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy1490:
	YYDEBUG(1490, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'H') goto yy360;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'g') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'h') goto yy371;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1491:
	YYDEBUG(1491, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'W') {
		if (yych <= 'N') {
			if (yych == ')') goto yy164;
			if (yych <= '@') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'O') goto yy1499;
			if (yych <= 'U') goto yy166;
			if (yych <= 'V') goto yy1500;
			goto yy1497;
		}
	} else {
		if (yych <= 'o') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			if (yych <= 'n') goto yy166;
			goto yy1499;
		} else {
			if (yych <= 'v') {
				if (yych <= 'u') goto yy166;
				goto yy1500;
			} else {
				if (yych <= 'w') goto yy1497;
				if (yych <= 'z') goto yy166;
				goto yy3;
			}
		}
	}
yy1492:
	YYDEBUG(1492, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'X') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'W') goto yy166;
			goto yy1496;
		}
	} else {
		if (yych <= 'w') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'x') goto yy1496;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1493:
	YYDEBUG(1493, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy166;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 'n') goto yy1494;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1494:
	YYDEBUG(1494, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy167;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 't') goto yy1495;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1495:
	YYDEBUG(1495, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'H') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'G') goto yy168;
			goto yy1228;
		}
	} else {
		if (yych <= 'g') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'h') goto yy1228;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1496:
	YYDEBUG(1496, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy167;
			goto yy1426;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 't') goto yy1426;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1497:
	YYDEBUG(1497, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '@') {
		if (yych == ')') goto yy164;
	} else {
		if (yych <= 'Z') goto yy167;
		if (yych <= '`') goto yy1498;
		if (yych <= 'z') goto yy167;
	}
yy1498:
	YYDEBUG(1498, *YYCURSOR);
#line 982 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('now');
		TIMELIB_INIT;

		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 23903 '<stdout>'
yy1499:
	YYDEBUG(1499, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'N') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'M') goto yy167;
			goto yy1505;
		}
	} else {
		if (yych <= 'm') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 'n') goto yy1505;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1500:
	YYDEBUG(1500, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= ',') {
				if (yych <= ')') goto yy164;
				goto yy218;
			} else {
				if (yych <= '-') goto yy221;
				if (yych <= '.') goto yy220;
				goto yy218;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '@') {
				if (yych <= '9') goto yy220;
				goto yy218;
			} else {
				if (yych != 'E') goto yy167;
			}
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'e') goto yy1501;
				if (yych <= 'z') goto yy167;
				goto yy218;
			}
		}
	}
yy1501:
	YYDEBUG(1501, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'M') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'L') goto yy168;
		}
	} else {
		if (yych <= 'l') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'm') goto yy1502;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1502:
	YYDEBUG(1502, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'B') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'A') goto yy169;
		}
	} else {
		if (yych <= 'a') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'b') goto yy1503;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1503:
	YYDEBUG(1503, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'E') goto yy1504;
		if (yych != 'e') goto yy3;
	}
yy1504:
	YYDEBUG(1504, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy229;
	if (yych == 'r') goto yy229;
	goto yy56;
yy1505:
	YYDEBUG(1505, *YYCURSOR);
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '@') {
		if (yych == ')') goto yy164;
	} else {
		if (yych <= 'Z') goto yy168;
		if (yych <= '`') goto yy1506;
		if (yych <= 'z') goto yy168;
	}
yy1506:
	YYDEBUG(1506, *YYCURSOR);
#line 991 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('noon');
		TIMELIB_INIT;
		TIMELIB_UNHAVE_TIME();
		TIMELIB_HAVE_TIME();
		s->time->h = 12;

		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 24053 '<stdout>'
yy1507:
	YYDEBUG(1507, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'V') {
		if (yych <= '.') {
			if (yych <= ')') {
				if (yych <= '(') goto yy3;
				goto yy164;
			} else {
				if (yych == '-') goto yy172;
				goto yy3;
			}
		} else {
			if (yych <= 'N') {
				if (yych <= '/') goto yy172;
				if (yych <= '@') goto yy3;
				goto yy166;
			} else {
				if (yych <= 'O') goto yy1499;
				if (yych <= 'U') goto yy166;
				goto yy1500;
			}
		}
	} else {
		if (yych <= 'n') {
			if (yych <= '^') {
				if (yych <= 'W') goto yy1497;
				if (yych <= 'Z') goto yy166;
				goto yy3;
			} else {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy3;
				goto yy171;
			}
		} else {
			if (yych <= 'v') {
				if (yych <= 'o') goto yy1514;
				if (yych <= 'u') goto yy171;
				goto yy1515;
			} else {
				if (yych <= 'w') goto yy1513;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1508:
	YYDEBUG(1508, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'W') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'X') goto yy1496;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'w') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'x') goto yy1512;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1509:
	YYDEBUG(1509, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1494;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 'n') goto yy1510;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1510:
	YYDEBUG(1510, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1495;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 't') goto yy1511;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1511:
	YYDEBUG(1511, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'G') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'H') goto yy1228;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'g') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'h') goto yy1257;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1512:
	YYDEBUG(1512, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1426;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 't') goto yy1458;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1513:
	YYDEBUG(1513, *YYCURSOR);
	yyaccept = 31;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy1498;
		} else {
			if (yych == '.') goto yy1498;
			goto yy172;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy1498;
			if (yych <= 'Z') goto yy167;
			goto yy1498;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy1498;
			if (yych <= 'z') goto yy175;
			goto yy1498;
		}
	}
yy1514:
	YYDEBUG(1514, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'M') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'N') goto yy1505;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'm') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 'n') goto yy1520;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1515:
	YYDEBUG(1515, *YYCURSOR);
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '9') {
		if (yych <= '(') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy218;
				goto yy220;
			} else {
				if (yych == ' ') goto yy220;
				goto yy218;
			}
		} else {
			if (yych <= '-') {
				if (yych <= ')') goto yy164;
				if (yych <= ',') goto yy218;
				goto yy336;
			} else {
				if (yych == '/') goto yy172;
				goto yy220;
			}
		}
	} else {
		if (yych <= '^') {
			if (yych <= 'D') {
				if (yych <= '@') goto yy218;
				goto yy167;
			} else {
				if (yych <= 'E') goto yy1501;
				if (yych <= 'Z') goto yy167;
				goto yy218;
			}
		} else {
			if (yych <= 'd') {
				if (yych <= '_') goto yy172;
				if (yych <= '`') goto yy218;
				goto yy175;
			} else {
				if (yych <= 'e') goto yy1516;
				if (yych <= 'z') goto yy175;
				goto yy218;
			}
		}
	}
yy1516:
	YYDEBUG(1516, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'L') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'M') goto yy1502;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'l') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'm') goto yy1517;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1517:
	YYDEBUG(1517, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'A') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'B') goto yy1503;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'a') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'b') goto yy1518;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1518:
	YYDEBUG(1518, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'E') goto yy1504;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'e') goto yy1519;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1519:
	YYDEBUG(1519, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'R') goto yy229;
	if (yych == 'r') goto yy341;
	goto yy179;
yy1520:
	YYDEBUG(1520, *YYCURSOR);
	yyaccept = 32;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '/') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy1506;
		} else {
			if (yych == '.') goto yy1506;
			goto yy172;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy1506;
			if (yych <= 'Z') goto yy168;
			goto yy1506;
		} else {
			if (yych <= '_') goto yy172;
			if (yych <= '`') goto yy1506;
			if (yych <= 'z') goto yy176;
			goto yy1506;
		}
	}
yy1521:
	YYDEBUG(1521, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'S') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'R') goto yy166;
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'Z') goto yy166;
			if (yych <= '`') goto yy3;
			goto yy166;
		} else {
			if (yych <= 's') goto yy1522;
			if (yych <= 'z') goto yy166;
			goto yy3;
		}
	}
yy1522:
	YYDEBUG(1522, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'T') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'S') goto yy167;
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'Z') goto yy167;
			if (yych <= '`') goto yy3;
			goto yy167;
		} else {
			if (yych <= 't') goto yy1523;
			if (yych <= 'z') goto yy167;
			goto yy3;
		}
	}
yy1523:
	YYDEBUG(1523, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'E') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'D') goto yy168;
		}
	} else {
		if (yych <= 'd') {
			if (yych <= 'Z') goto yy168;
			if (yych <= '`') goto yy3;
			goto yy168;
		} else {
			if (yych <= 'e') goto yy1524;
			if (yych <= 'z') goto yy168;
			goto yy3;
		}
	}
yy1524:
	YYDEBUG(1524, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych <= 'R') {
		if (yych <= ')') {
			if (yych <= '(') goto yy3;
			goto yy164;
		} else {
			if (yych <= '@') goto yy3;
			if (yych <= 'Q') goto yy169;
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'Z') goto yy169;
			if (yych <= '`') goto yy3;
			goto yy169;
		} else {
			if (yych <= 'r') goto yy1525;
			if (yych <= 'z') goto yy169;
			goto yy3;
		}
	}
yy1525:
	YYDEBUG(1525, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych == ')') goto yy164;
		goto yy3;
	} else {
		if (yych <= 'D') goto yy1526;
		if (yych != 'd') goto yy3;
	}
yy1526:
	YYDEBUG(1526, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1527;
	if (yych != 'a') goto yy56;
yy1527:
	YYDEBUG(1527, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1528;
	if (yych != 'y') goto yy56;
yy1528:
	YYDEBUG(1528, *YYCURSOR);
	++YYCURSOR;
yy1529:
	YYDEBUG(1529, *YYCURSOR);
#line 970 'ext/date/lib/parse_date.re'
	{
		DEBUG_OUTPUT('yesterday');
		TIMELIB_INIT;
		TIMELIB_HAVE_RELATIVE();
		TIMELIB_UNHAVE_TIME();

		s->time->relative.d = -1;
		TIMELIB_DEINIT;
		return TIMELIB_RELATIVE;
	}
#line 24597 '<stdout>'
yy1530:
	YYDEBUG(1530, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'R') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy166;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'S') goto yy1522;
			if (yych <= 'Z') goto yy166;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'r') {
				if (yych <= '`') goto yy3;
				goto yy171;
			} else {
				if (yych <= 's') goto yy1531;
				if (yych <= 'z') goto yy171;
				goto yy3;
			}
		}
	}
yy1531:
	YYDEBUG(1531, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'S') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy167;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'T') goto yy1523;
			if (yych <= 'Z') goto yy167;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 's') {
				if (yych <= '`') goto yy3;
				goto yy175;
			} else {
				if (yych <= 't') goto yy1532;
				if (yych <= 'z') goto yy175;
				goto yy3;
			}
		}
	}
yy1532:
	YYDEBUG(1532, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'D') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy168;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'E') goto yy1524;
			if (yych <= 'Z') goto yy168;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'd') {
				if (yych <= '`') goto yy3;
				goto yy176;
			} else {
				if (yych <= 'e') goto yy1533;
				if (yych <= 'z') goto yy176;
				goto yy3;
			}
		}
	}
yy1533:
	YYDEBUG(1533, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Q') {
		if (yych <= '-') {
			if (yych == ')') goto yy164;
			if (yych <= ',') goto yy3;
			goto yy172;
		} else {
			if (yych == '/') goto yy172;
			if (yych <= '@') goto yy3;
			goto yy169;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'R') goto yy1525;
			if (yych <= 'Z') goto yy169;
			if (yych <= '^') goto yy3;
			goto yy172;
		} else {
			if (yych <= 'q') {
				if (yych <= '`') goto yy3;
				goto yy177;
			} else {
				if (yych <= 'r') goto yy1534;
				if (yych <= 'z') goto yy177;
				goto yy3;
			}
		}
	}
yy1534:
	YYDEBUG(1534, *YYCURSOR);
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'C') {
		if (yych <= ',') {
			if (yych == ')') goto yy164;
			goto yy3;
		} else {
			if (yych == '.') goto yy3;
			if (yych <= '/') goto yy172;
			goto yy3;
		}
	} else {
		if (yych <= '`') {
			if (yych <= 'D') goto yy1526;
			if (yych == '_') goto yy172;
			goto yy3;
		} else {
			if (yych == 'd') goto yy1535;
			if (yych <= 'z') goto yy178;
			goto yy3;
		}
	}
yy1535:
	YYDEBUG(1535, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'A') goto yy1527;
	if (yych != 'a') goto yy179;
	YYDEBUG(1536, *YYCURSOR);
	yych = *++YYCURSOR;
	if (yych == 'Y') goto yy1528;
	if (yych != 'y') goto yy179;
	YYDEBUG(1537, *YYCURSOR);
	yyaccept = 33;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 16) {
		goto yy178;
	}
	if (yych <= '.') {
		if (yych == '-') goto yy172;
		goto yy1529;
	} else {
		if (yych <= '/') goto yy172;
		if (yych == '_') goto yy172;
		goto yy1529;
	}
}
#line 1772 'ext/date/lib/parse_date.re'

}
",1,8058
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"#define TIMELIB_TIME24_WITH_ZONE 278
#define TIMELIB_ISO_WEEK       279
#define TIMELIB_LF_DAY_OF_MONTH 280
",0,8059
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"
static timelib_long timelib_lookup_month(char **ptr)
{
",0,8060
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"static timelib_sll timelib_meridian_with_check(char **ptr, timelib_sll h)
{
	timelib_sll retval = 0;

	while (**ptr && !strchr('AaPp', **ptr)) {
		++*ptr;
	}
	if(!**ptr) {
		return TIMELIB_UNSET;
	}
	if (**ptr == 'a' || **ptr == 'A') {
		if (h == 12) {
			retval = -12;
		}
	} else if (h != 12) {
		retval = 12;
	}
	++*ptr;
	if (**ptr == '.') {
		++*ptr;
		if (**ptr != 'm' && **ptr != 'M') {
			return TIMELIB_UNSET;
		}
		++*ptr;
		if (**ptr != '.' ) {
			return TIMELIB_UNSET;
		}
		++*ptr;
	} else if (**ptr == 'm' || **ptr == 'M') {
		++*ptr;
	} else {
		return TIMELIB_UNSET;
	}
	return retval;
}
",0,8061
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"				if (yych <= 'D') {
					if (yych <= 'A') goto yy1018;
					if (yych <= 'C') goto yy12;
",0,8062
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"const timelib_tz_lookup_table *timelib_timezone_abbreviations_list(void)
{
	return timelib_timezone_lookup;
}
",0,8063
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"#elif !defined(HAVE_STRTOLL)
",0,8064
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"static void timelib_skip_day_suffix(char **ptr)
{
	if (isspace(**ptr)) {
		return;
	}
	if (!strncasecmp(*ptr, 'nd', 2) || !strncasecmp(*ptr, 'rd', 2) ||!strncasecmp(*ptr, 'st', 2) || !strncasecmp(*ptr, 'th', 2)) {
		*ptr += 2;
	}
}
",0,8065
php/php-src,5c0455bf2c8cd3c25401407f158e820aa3b239e1,"#ifdef DEBUG_PARSER
#define DEBUG_OUTPUT(s) printf('%s\n', s);
#define YYDEBUG(s,c) { if (s != -1) { printf('state: %d ', s); printf('[%c]\n', c); } }
",0,8066
collectd/collectd,d16c24542b2f96a194d43a73c2e5778822b9cb47,"static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
  struct snmp_pdu *req;
  struct snmp_pdu *res = NULL;
  struct variable_list *vb;

  const data_set_t *ds;

  size_t oid_list_len = data->values_len + 1;
  /* Holds the last OID returned by the device. We use this in the GETNEXT
   * request to proceed. */
  oid_t oid_list[oid_list_len];
  /* Set to false when an OID has left its subtree so we don't re-request it
   * again. */
  _Bool oid_list_todo[oid_list_len];

  int status;
  size_t i;

  /* `value_list_head' and `value_list_tail' implement a linked list for each
   * value. `instance_list_head' and `instance_list_tail' implement a linked
   * list of
   * instance names. This is used to jump gaps in the table. */
  csnmp_list_instances_t *instance_list_head;
  csnmp_list_instances_t *instance_list_tail;
  csnmp_table_values_t **value_list_head;
  csnmp_table_values_t **value_list_tail;

  DEBUG('snmp plugin: csnmp_read_table (host = %s, data = %s)', host->name,
        data->name);

  if (host->sess_handle == NULL) {
    DEBUG('snmp plugin: csnmp_read_table: host->sess_handle == NULL');
    return (-1);
  }

  ds = plugin_get_ds(data->type);
  if (!ds) {
    ERROR('snmp plugin: DataSet `%s' not defined.', data->type);
    return (-1);
  }

  if (ds->ds_num != data->values_len) {
    ERROR('snmp plugin: DataSet `%s' requires %zu values, but config talks '
          'about %zu',
          data->type, ds->ds_num, data->values_len);
    return (-1);
  }
  assert(data->values_len > 0);

  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */
  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));
  if (data->instance.oid.oid_len > 0)
    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));
  else /* no InstanceFrom option specified. */
    oid_list_len--;

  for (i = 0; i < oid_list_len; i++)
    oid_list_todo[i] = 1;

  /* We're going to construct n linked lists, one for each 'value'.
   * value_list_head will contain pointers to the heads of these linked lists,
   * value_list_tail will contain pointers to the tail of the lists. */
  value_list_head = calloc(data->values_len, sizeof(*value_list_head));
  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));
  if ((value_list_head == NULL) || (value_list_tail == NULL)) {
    ERROR('snmp plugin: csnmp_read_table: calloc failed.');
    sfree(value_list_head);
    sfree(value_list_tail);
    return (-1);
  }

  instance_list_head = NULL;
  instance_list_tail = NULL;

  status = 0;
  while (status == 0) {
    int oid_list_todo_num;

    req = snmp_pdu_create(SNMP_MSG_GETNEXT);
    if (req == NULL) {
      ERROR('snmp plugin: snmp_pdu_create failed.');
      status = -1;
      break;
    }

    oid_list_todo_num = 0;
    for (i = 0; i < oid_list_len; i++) {
      /* Do not rerequest already finished OIDs */
      if (!oid_list_todo[i])
        continue;
      oid_list_todo_num++;
      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);
    }

    if (oid_list_todo_num == 0) {
      /* The request is still empty - so we are finished */
      DEBUG('snmp plugin: all variables have left their subtree');
      status = 0;
      break;
    }

    res = NULL;
    status = snmp_sess_synch_response(host->sess_handle, req, &res);
    if ((status != STAT_SUCCESS) || (res == NULL)) {
      char *errstr = NULL;

      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);

      c_complain(LOG_ERR, &host->complaint,
                 'snmp plugin: host %s: snmp_sess_synch_response failed: %s',
                 host->name, (errstr == NULL) ? 'Unknown problem' : errstr);

      if (res != NULL)
        snmp_free_pdu(res);
      res = NULL;

      /* snmp_synch_response already freed our PDU */
      req = NULL;
      sfree(errstr);
      csnmp_host_close_session(host);

      status = -1;
      break;
    }

    status = 0;
    assert(res != NULL);
    c_release(LOG_INFO, &host->complaint,
              'snmp plugin: host %s: snmp_sess_synch_response successful.',
              host->name);

    vb = res->variables;
    if (vb == NULL) {
      status = -1;
      break;
    }

    for (vb = res->variables, i = 0; (vb != NULL);
         vb = vb->next_variable, i++) {
      /* Calculate value index from todo list */
      while ((i < oid_list_len) && !oid_list_todo[i])
        i++;

      /* An instance is configured and the res variable we process is the
       * instance value (last index) */
      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {
        if ((vb->type == SNMP_ENDOFMIBVIEW) ||
            (snmp_oid_ncompare(
                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,
                 vb->name_length, data->instance.oid.oid_len) != 0)) {
          DEBUG('snmp plugin: host = %s; data = %s; Instance left its subtree.',
                host->name, data->name);
          oid_list_todo[i] = 0;
          continue;
        }

        /* Allocate a new `csnmp_list_instances_t', insert the instance name and
         * add it to the list */
        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,
                                    res, host, data) != 0) {
          ERROR('snmp plugin: host %s: csnmp_instance_list_add failed.',
                host->name);
          status = -1;
          break;
        }
      } else /* The variable we are processing is a normal value */
      {
        csnmp_table_values_t *vt;
        oid_t vb_name;
        oid_t suffix;
        int ret;

        csnmp_oid_init(&vb_name, vb->name, vb->name_length);

        /* Calculate the current suffix. This is later used to check that the
         * suffix is increasing. This also checks if we left the subtree */
        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);
        if (ret != 0) {
          DEBUG('snmp plugin: host = %s; data = %s; i = %zu; '
                'Value probably left its subtree.',
                host->name, data->name, i);
          oid_list_todo[i] = 0;
          continue;
        }

        /* Make sure the OIDs returned by the agent are increasing. Otherwise
         * our
         * table matching algorithm will get confused. */
        if ((value_list_tail[i] != NULL) &&
            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {
          DEBUG('snmp plugin: host = %s; data = %s; i = %zu; '
                'Suffix is not increasing.',
                host->name, data->name, i);
          oid_list_todo[i] = 0;
          continue;
        }

        vt = calloc(1, sizeof(*vt));
        if (vt == NULL) {
          ERROR('snmp plugin: calloc failed.');
          status = -1;
          break;
        }

        vt->value =
            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,
                                      data->shift, host->name, data->name);
        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));
        vt->next = NULL;

        if (value_list_tail[i] == NULL)
          value_list_head[i] = vt;
        else
          value_list_tail[i]->next = vt;
        value_list_tail[i] = vt;
      }

      /* Copy OID to oid_list[i] */
      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);
      oid_list[i].oid_len = vb->name_length;

    } /* for (vb = res->variables ...) */

    if (res != NULL)
      snmp_free_pdu(res);
    res = NULL;
  } /* while (status == 0) */

  if (res != NULL)
    snmp_free_pdu(res);
  res = NULL;

  if (req != NULL)
    snmp_free_pdu(req);
  req = NULL;

  if (status == 0)
    csnmp_dispatch_table(host, data, instance_list_head, value_list_head);

  /* Free all allocated variables here */
  while (instance_list_head != NULL) {
    csnmp_list_instances_t *next = instance_list_head->next;
    sfree(instance_list_head);
    instance_list_head = next;
  }

  for (i = 0; i < data->values_len; i++) {
    while (value_list_head[i] != NULL) {
      csnmp_table_values_t *next = value_list_head[i]->next;
      sfree(value_list_head[i]);
      value_list_head[i] = next;
    }
  }

  sfree(value_list_head);
  sfree(value_list_tail);

  return (0);
} /* int csnmp_read_table */
",1,8067
collectd/collectd,d16c24542b2f96a194d43a73c2e5778822b9cb47,"static int csnmp_strvbcopy_hexstring(char *dst, /* {{{ */
                                     const struct variable_list *vb,
                                     size_t dst_size) {
  char *buffer_ptr;
  size_t buffer_free;

  dst[0] = 0;

  buffer_ptr = dst;
  buffer_free = dst_size;

  for (size_t i = 0; i < vb->val_len; i++) {
    int status;

    status = snprintf(buffer_ptr, buffer_free, (i == 0) ? '%02x' : ':%02x',
                      (unsigned int)vb->val.bitstring[i]);
    assert(status >= 0);

    if (((size_t)status) >= buffer_free) /* truncated */
    {
      dst[dst_size - 1] = 0;
      return ENOMEM;
    } else /* if (status < buffer_free) */
    {
      buffer_ptr += (size_t)status;
      buffer_free -= (size_t)status;
    }
  }

  return 0;
} /* }}} int csnmp_strvbcopy_hexstring */
",0,8068
GNOME/libxml2,e26630548e7d138d2c560844c43820b6767251e3,"static const xmlChar *
xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;

#ifdef DEBUG
    nbParseNameComplex++;
#endif

    /*
     * Handler for more complex cases
     */
    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);
    c = CUR_CHAR(l);
    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
        /*
	 * Use the new checks of production [4] [4a] amd [5] of the
	 * Update 5 of XML-1.0
	 */
	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	    (!(((c >= 'a') && (c <= 'z')) ||
	       ((c >= 'A') && (c <= 'Z')) ||
	       (c == '_') || (c == ':') ||
	       ((c >= 0xC0) && (c <= 0xD6)) ||
	       ((c >= 0xD8) && (c <= 0xF6)) ||
	       ((c >= 0xF8) && (c <= 0x2FF)) ||
	       ((c >= 0x370) && (c <= 0x37D)) ||
	       ((c >= 0x37F) && (c <= 0x1FFF)) ||
	       ((c >= 0x200C) && (c <= 0x200D)) ||
	       ((c >= 0x2070) && (c <= 0x218F)) ||
	       ((c >= 0x2C00) && (c <= 0x2FEF)) ||
	       ((c >= 0x3001) && (c <= 0xD7FF)) ||
	       ((c >= 0xF900) && (c <= 0xFDCF)) ||
	       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
	       ((c >= 0x10000) && (c <= 0xEFFFF))))) {
	    return(NULL);
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
	       (((c >= 'a') && (c <= 'z')) ||
	        ((c >= 'A') && (c <= 'Z')) ||
	        ((c >= '0') && (c <= '9')) || /* !start */
	        (c == '_') || (c == ':') ||
	        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
	        ((c >= 0xC0) && (c <= 0xD6)) ||
	        ((c >= 0xD8) && (c <= 0xF6)) ||
	        ((c >= 0xF8) && (c <= 0x2FF)) ||
	        ((c >= 0x300) && (c <= 0x36F)) || /* !start */
	        ((c >= 0x370) && (c <= 0x37D)) ||
	        ((c >= 0x37F) && (c <= 0x1FFF)) ||
	        ((c >= 0x200C) && (c <= 0x200D)) ||
	        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
	        ((c >= 0x2070) && (c <= 0x218F)) ||
	        ((c >= 0x2C00) && (c <= 0x2FEF)) ||
	        ((c >= 0x3001) && (c <= 0xD7FF)) ||
	        ((c >= 0xF900) && (c <= 0xFDCF)) ||
	        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
	        ((c >= 0x10000) && (c <= 0xEFFFF))
		)) {
	    if (count++ > XML_PARSER_CHUNK_SIZE) {
		count = 0;
		GROW;
                if (ctxt->instate == XML_PARSER_EOF)
                    return(NULL);
	    }
	    len += l;
	    NEXTL(l);
	    c = CUR_CHAR(l);
	}
    } else {
	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	    (!IS_LETTER(c) && (c != '_') &&
	     (c != ':'))) {
	    return(NULL);
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);

	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
		(c == '.') || (c == '-') ||
		(c == '_') || (c == ':') ||
		(IS_COMBINING(c)) ||
		(IS_EXTENDER(c)))) {
	    if (count++ > XML_PARSER_CHUNK_SIZE) {
		count = 0;
		GROW;
                if (ctxt->instate == XML_PARSER_EOF)
                    return(NULL);
	    }
	    len += l;
	    NEXTL(l);
	    c = CUR_CHAR(l);
	    if (c == 0) {
		count = 0;
		GROW;
                if (ctxt->instate == XML_PARSER_EOF)
                    return(NULL);
		c = CUR_CHAR(l);
	    }
	}
    }
    if ((len > XML_MAX_NAME_LENGTH) &&
        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, 'Name');
        return(NULL);
    }
    if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}
",1,8069
GNOME/libxml2,e26630548e7d138d2c560844c43820b6767251e3,"static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL)
{
    if (ctxt->options & XML_PARSE_NSCLEAN) {
        int i;
	for (i = ctxt->nsNr - 2;i >= 0;i -= 2) {
	    if (ctxt->nsTab[i] == prefix) {
		/* in scope */
	        if (ctxt->nsTab[i + 1] == URL)
		    return(-2);
		/* out of scope keep it */
		break;
	    }
	}
    }
    if ((ctxt->nsMax == 0) || (ctxt->nsTab == NULL)) {
	ctxt->nsMax = 10;
	ctxt->nsNr = 0;
	ctxt->nsTab = (const xmlChar **)
	              xmlMalloc(ctxt->nsMax * sizeof(xmlChar *));
	if (ctxt->nsTab == NULL) {
	    xmlErrMemory(ctxt, NULL);
	    ctxt->nsMax = 0;
            return (-1);
	}
    } else if (ctxt->nsNr >= ctxt->nsMax) {
        const xmlChar ** tmp;
        ctxt->nsMax *= 2;
        tmp = (const xmlChar **) xmlRealloc((char *) ctxt->nsTab,
				    ctxt->nsMax * sizeof(ctxt->nsTab[0]));
        if (tmp == NULL) {
            xmlErrMemory(ctxt, NULL);
	    ctxt->nsMax /= 2;
            return (-1);
        }
	ctxt->nsTab = tmp;
    }
    ctxt->nsTab[ctxt->nsNr++] = prefix;
    ctxt->nsTab[ctxt->nsNr++] = URL;
    return (ctxt->nsNr);
}
",0,8070
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"struct key *request_key_and_link(struct key_type *type,
				 const char *description,
				 const void *callout_info,
				 size_t callout_len,
				 void *aux,
				 struct key *dest_keyring,
				 unsigned long flags)
{
	struct keyring_search_context ctx = {
		.index_key.type		= type,
		.index_key.description	= description,
		.cred			= current_cred(),
		.match_data.cmp		= type->match,
		.match_data.raw_data	= description,
		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
	};
	struct key *key;
	key_ref_t key_ref;
	int ret;

	kenter('%s,%s,%p,%zu,%p,%p,%lx',
	       ctx.index_key.type->name, ctx.index_key.description,
	       callout_info, callout_len, aux, dest_keyring, flags);

	if (type->match_preparse) {
		ret = type->match_preparse(&ctx.match_data);
		if (ret < 0) {
			key = ERR_PTR(ret);
			goto error;
		}
	}

	/* search all the process keyrings for a key */
	key_ref = search_process_keyrings(&ctx);

	if (!IS_ERR(key_ref)) {
		key = key_ref_to_ptr(key_ref);
		if (dest_keyring) {
			construct_get_dest_keyring(&dest_keyring);
			ret = key_link(dest_keyring, key);
			key_put(dest_keyring);
			if (ret < 0) {
				key_put(key);
				key = ERR_PTR(ret);
				goto error_free;
			}
		}
	} else if (PTR_ERR(key_ref) != -EAGAIN) {
		key = ERR_CAST(key_ref);
	} else  {
		/* the search failed, but the keyrings were searchable, so we
		 * should consult userspace if we can */
		key = ERR_PTR(-ENOKEY);
		if (!callout_info)
			goto error_free;

		key = construct_key_and_link(&ctx, callout_info, callout_len,
					     aux, dest_keyring, flags);
	}

error_free:
	if (type->match_free)
		type->match_free(&ctx.match_data);
error:
	kleave(' = %p', key);
	return key;
}
",1,8071
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"struct key *key_get_instantiation_authkey(key_serial_t target_id)
{
	char description[16];
	struct keyring_search_context ctx = {
		.index_key.type		= &key_type_request_key_auth,
		.index_key.description	= description,
		.cred			= current_cred(),
		.match_data.cmp		= user_match,
		.match_data.raw_data	= description,
		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
	};
	struct key *authkey;
	key_ref_t authkey_ref;

	sprintf(description, '%x', target_id);

	authkey_ref = search_process_keyrings(&ctx);

	if (IS_ERR(authkey_ref)) {
		authkey = ERR_CAST(authkey_ref);
		if (authkey == ERR_PTR(-EAGAIN))
			authkey = ERR_PTR(-ENOKEY);
		goto error;
	}

	authkey = key_ref_to_ptr(authkey_ref);
	if (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {
		key_put(authkey);
		authkey = ERR_PTR(-EKEYREVOKED);
	}

error:
	return authkey;
}
",1,8072
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81," * The domain name may be a simple name or an absolute domain name (which
 * should end with a period).  The domain name is case-independent.
 */
static int
",1,8073
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static int
dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
{
	int slen, dlen, ret = 0;
	const char *src = key->description, *dsp = match_data->raw_data;

	kenter('%s,%s', src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave(' = %d', ret);
	return ret;
}
",1,8074
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"key_ref_t keyring_search(key_ref_t keyring,
			 struct key_type *type,
			 const char *description)
{
	struct keyring_search_context ctx = {
		.index_key.type		= type,
		.index_key.description	= description,
		.cred			= current_cred(),
		.match_data.cmp		= type->match,
		.match_data.raw_data	= description,
		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
	};
	key_ref_t key;
	int ret;

	if (!ctx.match_data.cmp)
		return ERR_PTR(-ENOKEY);

	if (type->match_preparse) {
		ret = type->match_preparse(&ctx.match_data);
		if (ret < 0)
			return ERR_PTR(ret);
	}

	key = keyring_search_aux(keyring, &ctx);

	if (type->match_free)
		type->match_free(&ctx.match_data);
	return key;
}
",1,8075
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
{
	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, 'id', 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
",1,8076
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static int asymmetric_key_match_preparse(struct key_match_data *match_data)
{
	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
	return 0;
}
",1,8077
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"key_ref_t key_create_or_update(key_ref_t keyring_ref,
			       const char *type,
			       const char *description,
			       const void *payload,
			       size_t plen,
			       key_perm_t perm,
			       unsigned long flags)
{
	struct keyring_index_key index_key = {
		.description	= description,
	};
	struct key_preparsed_payload prep;
	struct assoc_array_edit *edit;
	const struct cred *cred = current_cred();
	struct key *keyring, *key = NULL;
	key_ref_t key_ref;
	int ret;

	/* look up the key type to see if it's one of the registered kernel
	 * types */
	index_key.type = key_type_lookup(type);
	if (IS_ERR(index_key.type)) {
		key_ref = ERR_PTR(-ENODEV);
		goto error;
	}

	key_ref = ERR_PTR(-EINVAL);
	if (!index_key.type->match || !index_key.type->instantiate ||
	    (!index_key.description && !index_key.type->preparse))
		goto error_put_type;

	keyring = key_ref_to_ptr(keyring_ref);

	key_check(keyring);

	key_ref = ERR_PTR(-ENOTDIR);
	if (keyring->type != &key_type_keyring)
		goto error_put_type;

	memset(&prep, 0, sizeof(prep));
	prep.data = payload;
	prep.datalen = plen;
	prep.quotalen = index_key.type->def_datalen;
	prep.trusted = flags & KEY_ALLOC_TRUSTED;
	prep.expiry = TIME_T_MAX;
	if (index_key.type->preparse) {
		ret = index_key.type->preparse(&prep);
		if (ret < 0) {
			key_ref = ERR_PTR(ret);
			goto error_free_prep;
		}
		if (!index_key.description)
			index_key.description = prep.description;
		key_ref = ERR_PTR(-EINVAL);
		if (!index_key.description)
			goto error_free_prep;
	}
	index_key.desc_len = strlen(index_key.description);

	key_ref = ERR_PTR(-EPERM);
	if (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))
		goto error_free_prep;
	flags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;

	ret = __key_link_begin(keyring, &index_key, &edit);
	if (ret < 0) {
		key_ref = ERR_PTR(ret);
		goto error_free_prep;
	}

	/* if we're going to allocate a new key, we're going to have
	 * to modify the keyring */
	ret = key_permission(keyring_ref, KEY_NEED_WRITE);
	if (ret < 0) {
		key_ref = ERR_PTR(ret);
		goto error_link_end;
	}

	/* if it's possible to update this type of key, search for an existing
	 * key of the same type and description in the destination keyring and
	 * update that instead if possible
	 */
	if (index_key.type->update) {
		key_ref = find_key_to_update(keyring_ref, &index_key);
		if (key_ref)
			goto found_matching_key;
	}

	/* if the client doesn't provide, decide on the permissions we want */
	if (perm == KEY_PERM_UNDEF) {
		perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;
		perm |= KEY_USR_VIEW;

		if (index_key.type->read)
			perm |= KEY_POS_READ;

		if (index_key.type == &key_type_keyring ||
		    index_key.type->update)
			perm |= KEY_POS_WRITE;
	}

	/* allocate a new key */
	key = key_alloc(index_key.type, index_key.description,
			cred->fsuid, cred->fsgid, cred, perm, flags);
	if (IS_ERR(key)) {
		key_ref = ERR_CAST(key);
		goto error_link_end;
	}

	/* instantiate it and link it into the target keyring */
	ret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);
	if (ret < 0) {
		key_put(key);
		key_ref = ERR_PTR(ret);
		goto error_link_end;
	}

	key_ref = make_key_ref(key, is_key_possessed(keyring_ref));

error_link_end:
	__key_link_end(keyring, &index_key, edit);
error_free_prep:
	if (index_key.type->preparse)
		index_key.type->free_preparse(&prep);
error_put_type:
	key_type_put(index_key.type);
error:
	return key_ref;

 found_matching_key:
	/* we found a matching key, so we're going to try to update it
	 * - we can drop the locks first as we have the key pinned
	 */
	__key_link_end(keyring, &index_key, edit);

	key_ref = __key_update(key_ref, &prep);
	goto error_free_prep;
}
",1,8078
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static void rxrpc_free_token_list(struct rxrpc_key_token *token)
{
	struct rxrpc_key_token *next;

	for (; token; token = next) {
		next = token->next;
		switch (token->security_index) {
		case RXRPC_SECURITY_RXKAD:
			kfree(token->kad);
			break;
		case RXRPC_SECURITY_RXK5:
			if (token->k5)
				rxrpc_rxk5_free(token->k5);
			break;
		default:
			printk(KERN_ERR 'Unknown token type %x on rxrpc key\n',
			       token->security_index);
			BUG();
		}

		kfree(token);
	}
}
",0,8079
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static int encrypted_key_decrypt(struct encrypted_key_payload *epayload,
				 const char *format, const char *hex_encoded_iv)
{
	struct key *mkey;
	u8 derived_key[HASH_SIZE];
	u8 *master_key;
	u8 *hmac;
	const char *hex_encoded_data;
	unsigned int encrypted_datalen;
	size_t master_keylen;
	size_t asciilen;
	int ret;

	encrypted_datalen = roundup(epayload->decrypted_datalen, blksize);
	asciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;
	if (strlen(hex_encoded_iv) != asciilen)
		return -EINVAL;

	hex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;
	ret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);
	if (ret < 0)
		return -EINVAL;
	ret = hex2bin(epayload->encrypted_data, hex_encoded_data,
		      encrypted_datalen);
	if (ret < 0)
		return -EINVAL;

	hmac = epayload->format + epayload->datablob_len;
	ret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),
		      HASH_SIZE);
	if (ret < 0)
		return -EINVAL;

	mkey = request_master_key(epayload, &master_key, &master_keylen);
	if (IS_ERR(mkey))
		return PTR_ERR(mkey);

	ret = datablob_hmac_verify(epayload, format, master_key, master_keylen);
	if (ret < 0) {
		pr_err('encrypted_key: bad hmac (%d)\n', ret);
		goto out;
	}

	ret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);
	if (ret < 0)
		goto out;

	ret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);
	if (ret < 0)
		pr_err('encrypted_key: failed to decrypt key (%d)\n', ret);
out:
	up_read(&mkey->sem);
	key_put(mkey);
	return ret;
}
",0,8080
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static void asymmetric_key_match_free(struct key_match_data *match_data)
{
}
",0,8081
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"void unregister_asymmetric_key_parser(struct asymmetric_key_parser *parser)
{
	down_write(&asymmetric_key_parsers_sem);
	list_del(&parser->link);
	up_write(&asymmetric_key_parsers_sem);

	pr_notice('Asymmetric key parser '%s' unregistered\n', parser->name);
}
",0,8082
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static void encrypted_destroy(struct key *key)
{
	struct encrypted_key_payload *epayload = key->payload.data;

	if (!epayload)
		return;

	memset(epayload->decrypted_data, 0, epayload->decrypted_datalen);
	kfree(key->payload.data);
}
",0,8083
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static int request_key_auth_preparse(struct key_preparsed_payload *);
",0,8084
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"static int TSS_authhmac(unsigned char *digest, const unsigned char *key,
			unsigned int keylen, unsigned char *h1,
			unsigned char *h2, unsigned char h3, ...)
{
	unsigned char paramdigest[SHA1_DIGEST_SIZE];
	struct sdesc *sdesc;
	unsigned int dlen;
	unsigned char *data;
	unsigned char c;
	int ret;
	va_list argp;

	sdesc = init_sdesc(hashalg);
	if (IS_ERR(sdesc)) {
		pr_info('trusted_key: can't alloc %s\n', hash_alg);
		return PTR_ERR(sdesc);
	}

	c = h3;
	ret = crypto_shash_init(&sdesc->shash);
	if (ret < 0)
		goto out;
	va_start(argp, h3);
	for (;;) {
		dlen = va_arg(argp, unsigned int);
		if (dlen == 0)
			break;
		data = va_arg(argp, unsigned char *);
		if (!data) {
			ret = -EINVAL;
			break;
		}
		ret = crypto_shash_update(&sdesc->shash, data, dlen);
		if (ret < 0)
			break;
	}
	va_end(argp);
	if (!ret)
		ret = crypto_shash_final(&sdesc->shash, paramdigest);
	if (!ret)
		ret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,
				  paramdigest, TPM_NONCE_SIZE, h1,
				  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);
out:
	kfree(sdesc);
	return ret;
}
",0,8085
torvalds/linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"void user_revoke(struct key *key)
{
	struct user_key_payload *upayload = key->payload.data;

	/* clear the quota */
	key_payload_reserve(key, 0);

	if (upayload) {
		rcu_assign_keypointer(key, NULL);
		kfree_rcu(upayload, rcu);
	}
}
",0,8086
openssl/openssl,efbe126e3ebb9123ac9d058aa2bb044261342aaa,"static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_DH
    DH *dh_clnt = NULL;
    const BIGNUM *pub_key;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        return 0;
    }
    ckey = ssl_generate_pkey(skey);
    dh_clnt = EVP_PKEY_get0_DH(ckey);

    if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        EVP_PKEY_free(ckey);
        return 0;
    }

    /* send off the data */
    DH_get0_key(dh_clnt, &pub_key, NULL);
    *len = BN_num_bytes(pub_key);
    s2n(*len, *p);
    BN_bn2bin(pub_key, *p);
    *len += 2;
    EVP_PKEY_free(ckey);

    return 1;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
",1,8087
openssl/openssl,efbe126e3ebb9123ac9d058aa2bb044261342aaa,"static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_EC
    unsigned char *encodedPoint = NULL;
    int encoded_pt_len = 0;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    ckey = ssl_generate_pkey(skey);

    if (ssl_derive(s, ckey, skey) == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);
        goto err;
    }

    /* Generate encoding of client key */
    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);

    if (encoded_pt_len == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);
        goto err;
    }

    EVP_PKEY_free(ckey);
    ckey = NULL;

    *len = encoded_pt_len;

    /* length of encoded point */
    **p = *len;
    *p += 1;
    /* copy the point */
    memcpy(*p, encodedPoint, *len);
    /* increment len to account for length field */
    *len += 1;

    OPENSSL_free(encodedPoint);

    return 1;
 err:
    EVP_PKEY_free(ckey);
    return 0;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
",1,8088
openssl/openssl,efbe126e3ebb9123ac9d058aa2bb044261342aaa,"static int tls_process_ske_ecdhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey, int *al)
{
#ifndef OPENSSL_NO_EC
    PACKET encoded_pt;
    const unsigned char *ecparams;
    int curve_nid;
    unsigned int curve_flags;
    EVP_PKEY_CTX *pctx = NULL;

    /*
     * Extract elliptic curve parameters and the server's ephemeral ECDH
     * public key. For now we only support named (not generic) curves and
     * ECParameters in this case is just three bytes.
     */
    if (!PACKET_get_bytes(pkt, &ecparams, 3)) {
        *al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_LENGTH_TOO_SHORT);
        return 0;
    }
    /*
     * Check curve is one of our preferences, if not server has sent an
     * invalid curve. ECParameters is 3 bytes.
     */
    if (!tls1_check_curve(s, ecparams, 3)) {
        *al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_WRONG_CURVE);
        return 0;
    }

    curve_nid = tls1_ec_curve_id2nid(*(ecparams + 2), &curve_flags);

    if (curve_nid == 0) {
        *al = SSL_AD_INTERNAL_ERROR;
        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE,
               SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
        return 0;
    }

    if ((curve_flags & TLS_CURVE_TYPE) == TLS_CURVE_CUSTOM) {
        EVP_PKEY *key = EVP_PKEY_new();

        if (key == NULL || !EVP_PKEY_set_type(key, curve_nid)) {
            *al = SSL_AD_INTERNAL_ERROR;
            SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_EVP_LIB);
            EVP_PKEY_free(key);
            return 0;
        }
        s->s3->peer_tmp = key;
    } else {
        /* Set up EVP_PKEY with named curve as parameters */
        pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);
        if (pctx == NULL
            || EVP_PKEY_paramgen_init(pctx) <= 0
            || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, curve_nid) <= 0
            || EVP_PKEY_paramgen(pctx, &s->s3->peer_tmp) <= 0) {
            *al = SSL_AD_INTERNAL_ERROR;
            SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_EVP_LIB);
            EVP_PKEY_CTX_free(pctx);
            return 0;
        }
        EVP_PKEY_CTX_free(pctx);
        pctx = NULL;
    }

    if (!PACKET_get_length_prefixed_1(pkt, &encoded_pt)) {
        *al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_LENGTH_MISMATCH);
        return 0;
    }

    if (!EVP_PKEY_set1_tls_encodedpoint(s->s3->peer_tmp,
                                        PACKET_data(&encoded_pt),
                                        PACKET_remaining(&encoded_pt))) {
        *al = SSL_AD_DECODE_ERROR;
        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_BAD_ECPOINT);
        return 0;
    }

    /*
     * The ECC/TLS specification does not mention the use of DSA to sign
     * ECParameters in the server key exchange message. We do support RSA
     * and ECDSA.
     */
    if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aECDSA)
        *pkey = X509_get0_pubkey(s->session->peer);
    else if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aRSA)
        *pkey = X509_get0_pubkey(s->session->peer);
    /* else anonymous ECDH, so no certificate or pkey. */

    return 1;
#else
    SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
",0,8089
openssl/openssl,efbe126e3ebb9123ac9d058aa2bb044261342aaa,"WORK_STATE tls_prepare_client_certificate(SSL *s, WORK_STATE wst)
{
    X509 *x509 = NULL;
    EVP_PKEY *pkey = NULL;
    int i;

    if (wst == WORK_MORE_A) {
        /* Let cert callback update client certificates if required */
        if (s->cert->cert_cb) {
            i = s->cert->cert_cb(s, s->cert->cert_cb_arg);
            if (i < 0) {
                s->rwstate = SSL_X509_LOOKUP;
                return WORK_MORE_A;
            }
            if (i == 0) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
                ossl_statem_set_error(s);
                return 0;
            }
            s->rwstate = SSL_NOTHING;
        }
        if (ssl3_check_client_certificate(s))
            return WORK_FINISHED_CONTINUE;

        /* Fall through to WORK_MORE_B */
        wst = WORK_MORE_B;
    }

    /* We need to get a client cert */
    if (wst == WORK_MORE_B) {
        /*
         * If we get an error, we need to ssl->rwstate=SSL_X509_LOOKUP;
         * return(-1); We then get retied later
         */
        i = ssl_do_client_cert_cb(s, &x509, &pkey);
        if (i < 0) {
            s->rwstate = SSL_X509_LOOKUP;
            return WORK_MORE_B;
        }
        s->rwstate = SSL_NOTHING;
        if ((i == 1) && (pkey != NULL) && (x509 != NULL)) {
            if (!SSL_use_certificate(s, x509) || !SSL_use_PrivateKey(s, pkey))
                i = 0;
        } else if (i == 1) {
            i = 0;
            SSLerr(SSL_F_TLS_PREPARE_CLIENT_CERTIFICATE,
                   SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
        }

        X509_free(x509);
        EVP_PKEY_free(pkey);
        if (i && !ssl3_check_client_certificate(s))
            i = 0;
        if (i == 0) {
            if (s->version == SSL3_VERSION) {
                s->s3->tmp.cert_req = 0;
                ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_CERTIFICATE);
                return WORK_FINISHED_CONTINUE;
            } else {
                s->s3->tmp.cert_req = 2;
                if (!ssl3_digest_cached_records(s, 0)) {
                    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
                    ossl_statem_set_error(s);
                    return 0;
                }
            }
        }

        return WORK_FINISHED_CONTINUE;
    }

    /* Shouldn't ever get here */
    return WORK_ERROR;
}
",0,8090
VirusTotal/yara,83c42e3c26bc2c7e5b83fe970d055c3e70db70e0,"int
yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, 'Starting parse\n'));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_('memory exhausted'),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, 'Stack size increased to %lu\n',
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, 'Entering state %d\n', yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, 'Reading a token: '));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, 'Now at end of input.\n'));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ('Next token is', yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ('Shifting', yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 'grammar.y' /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 'grammar.c' /* yacc.c:1646  */
    break;

  case 9:
#line 242 'grammar.y' /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 'grammar.c' /* yacc.c:1646  */
    break;

  case 10:
#line 251 'grammar.y' /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 'grammar.c' /* yacc.c:1646  */
    break;

  case 11:
#line 259 'grammar.y' /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 'grammar.c' /* yacc.c:1646  */
    break;

  case 12:
#line 274 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 'grammar.c' /* yacc.c:1646  */
    break;

  case 13:
#line 278 'grammar.y' /* yacc.c:1646  */
    {
        // Each rule have a list of meta-data info, consisting in a
        // sequence of YR_META structures. The last YR_META structure does
        // not represent a real meta-data, it's just a end-of-list marker
        // identified by a specific type (META_TYPE_NULL). Here we
        // write the end-of-list marker.

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 'grammar.c' /* yacc.c:1646  */
    break;

  case 14:
#line 305 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 'grammar.c' /* yacc.c:1646  */
    break;

  case 15:
#line 309 'grammar.y' /* yacc.c:1646  */
    {
        // Each rule have a list of strings, consisting in a sequence
        // of YR_STRING structures. The last YR_STRING structure does not
        // represent a real string, it's just a end-of-list marker
        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        // write the end-of-list marker.

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 'grammar.c' /* yacc.c:1646  */
    break;

  case 17:
#line 340 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 'grammar.c' /* yacc.c:1646  */
    break;

  case 18:
#line 341 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 'grammar.c' /* yacc.c:1646  */
    break;

  case 19:
#line 346 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 'grammar.c' /* yacc.c:1646  */
    break;

  case 20:
#line 347 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 'grammar.c' /* yacc.c:1646  */
    break;

  case 21:
#line 353 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 'grammar.c' /* yacc.c:1646  */
    break;

  case 22:
#line 357 'grammar.y' /* yacc.c:1646  */
    {
        // Tags list is represented in the arena as a sequence
        // of null-terminated strings, the sequence ends with an
        // additional null character. Here we write the ending null
        //character. Example: tag1\0tag2\0tag3\0\0

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, '', NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 'grammar.c' /* yacc.c:1646  */
    break;

  case 23:
#line 375 'grammar.y' /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 'grammar.c' /* yacc.c:1646  */
    break;

  case 24:
#line 388 'grammar.y' /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 'grammar.c' /* yacc.c:1646  */
    break;

  case 25:
#line 424 'grammar.y' /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 'grammar.c' /* yacc.c:1646  */
    break;

  case 26:
#line 425 'grammar.y' /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 'grammar.c' /* yacc.c:1646  */
    break;

  case 27:
#line 431 'grammar.y' /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 'grammar.c' /* yacc.c:1646  */
    break;

  case 28:
#line 447 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 'grammar.c' /* yacc.c:1646  */
    break;

  case 29:
#line 460 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 'grammar.c' /* yacc.c:1646  */
    break;

  case 30:
#line 473 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 'grammar.c' /* yacc.c:1646  */
    break;

  case 31:
#line 486 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 'grammar.c' /* yacc.c:1646  */
    break;

  case 32:
#line 502 'grammar.y' /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 'grammar.c' /* yacc.c:1646  */
    break;

  case 33:
#line 503 'grammar.y' /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 'grammar.c' /* yacc.c:1646  */
    break;

  case 34:
#line 509 'grammar.y' /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 'grammar.c' /* yacc.c:1646  */
    break;

  case 35:
#line 513 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 'grammar.c' /* yacc.c:1646  */
    break;

  case 36:
#line 524 'grammar.y' /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 'grammar.c' /* yacc.c:1646  */
    break;

  case 37:
#line 528 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 'grammar.c' /* yacc.c:1646  */
    break;

  case 38:
#line 540 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 'grammar.c' /* yacc.c:1646  */
    break;

  case 39:
#line 553 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 'grammar.c' /* yacc.c:1646  */
    break;

  case 40:
#line 554 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 'grammar.c' /* yacc.c:1646  */
    break;

  case 41:
#line 559 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 'grammar.c' /* yacc.c:1646  */
    break;

  case 42:
#line 560 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 'grammar.c' /* yacc.c:1646  */
    break;

  case 43:
#line 561 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 'grammar.c' /* yacc.c:1646  */
    break;

  case 44:
#line 562 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 'grammar.c' /* yacc.c:1646  */
    break;

  case 45:
#line 568 'grammar.y' /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {
          // Search for identifier within the global namespace, where the
          // externals variables reside.

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            // If not found, search within the current namespace.
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  PTR_TO_INT64(id),
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  PTR_TO_INT64(rule),
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 'grammar.c' /* yacc.c:1646  */
    break;

  case 46:
#line 653 'grammar.y' /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  PTR_TO_INT64(ident),
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 'grammar.c' /* yacc.c:1646  */
    break;

  case 47:
#line 699 'grammar.y' /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, 'array indexes must be of integer type');
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, 'dictionary keys must be of string type');
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 'grammar.c' /* yacc.c:1646  */
    break;

  case 48:
#line 757 'grammar.y' /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                PTR_TO_INT64(args_fmt),
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 'grammar.c' /* yacc.c:1646  */
    break;

  case 49:
#line 801 'grammar.y' /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(''); }
#line 2334 'grammar.c' /* yacc.c:1646  */
    break;

  case 50:
#line 802 'grammar.y' /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 'grammar.c' /* yacc.c:1646  */
    break;

  case 51:
#line 807 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), 'i', MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), 'f', MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), 'b', MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), 's', MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), 'r', MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 'grammar.c' /* yacc.c:1646  */
    break;

  case 52:
#line 832 'grammar.y' /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), 'i', MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), 'f', MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), 'b', MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), 's', MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), 'r', MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 'grammar.c' /* yacc.c:1646  */
    break;

  case 53:
#line 868 'grammar.y' /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              PTR_TO_INT64(re->root_node->forward_code),
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 'grammar.c' /* yacc.c:1646  */
    break;

  case 54:
#line 914 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              'Using literal string \'%s\' in a boolean operation.',
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 'grammar.c' /* yacc.c:1646  */
    break;

  case 55:
#line 936 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 'grammar.c' /* yacc.c:1646  */
    break;

  case 56:
#line 945 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 'grammar.c' /* yacc.c:1646  */
    break;

  case 57:
#line 954 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, 'matches');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, 'matches');

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 'grammar.c' /* yacc.c:1646  */
    break;

  case 58:
#line 969 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, 'contains');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, 'contains');

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 'grammar.c' /* yacc.c:1646  */
    break;

  case 59:
#line 981 'grammar.y' /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 'grammar.c' /* yacc.c:1646  */
    break;

  case 60:
#line 995 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, 'at');

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 'grammar.c' /* yacc.c:1646  */
    break;

  case 61:
#line 1008 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 'grammar.c' /* yacc.c:1646  */
    break;

  case 62:
#line 1019 'grammar.y' /* yacc.c:1646  */
    {
        compiler->loop_depth--;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
      }
#line 2594 'grammar.c' /* yacc.c:1646  */
    break;

  case 63:
#line 1024 'grammar.y' /* yacc.c:1646  */
    {
        int var_index;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Push end-of-list marker
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2628 'grammar.c' /* yacc.c:1646  */
    break;

  case 64:
#line 1054 'grammar.y' /* yacc.c:1646  */
    {
        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        uint8_t* addr;

        // Clear counter for number of expressions evaluating
        // to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        // Clear iterations counter
        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          // Pop the first integer
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          // Pop higher bound of set range
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          // Pop lower bound of set range
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
        compiler->loop_depth++;
      }
#line 2667 'grammar.c' /* yacc.c:1646  */
    break;

  case 65:
#line 1089 'grammar.y' /* yacc.c:1646  */
    {
        int mem_offset;

        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;

        // The value at the top of the stack is the result of
        // evaluating the boolean expression, so it could be
        // 0, 1 or UNDEFINED. Add this value to a counter
        // keeping the number of expressions evaluating to true.
        // If the value is UNDEFINED instruction OP_ADD_M
        // does nothing.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        // Increment iterations counter
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              PTR_TO_INT64(
                  compiler->loop_address[compiler->loop_depth]),
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          // Increment lower bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          // Push lower bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          // Push higher bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          // Compare higher bound with lower bound, do loop again
          // if lower bound is still lower or equal than higher bound
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              PTR_TO_INT64(
                compiler->loop_address[compiler->loop_depth]),
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at the top of the stack. Check if the quantifier
        // is undefined (meaning 'all') and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2752 'grammar.c' /* yacc.c:1646  */
    break;

  case 66:
#line 1170 'grammar.y' /* yacc.c:1646  */
    {
        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        // Pop the first string.
        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
        compiler->loop_depth++;
      }
#line 2786 'grammar.c' /* yacc.c:1646  */
    break;

  case 67:
#line 1200 'grammar.y' /* yacc.c:1646  */
    {
        int mem_offset;

        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;

        // Increment counter by the value returned by the
        // boolean expression (0 or 1). If the boolean expression
        // returned UNDEFINED the OP_ADD_M won't do anything.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        // Increment iterations counter.
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        // If next string is not undefined, go back to the
        // begining of the loop.
        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            PTR_TO_INT64(
                compiler->loop_address[compiler->loop_depth]),
            NULL,
            NULL);

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at top of the stack. Check if the quantifier is
        // undefined (meaning 'all') and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;

      }
#line 2840 'grammar.c' /* yacc.c:1646  */
    break;

  case 68:
#line 1250 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit(yyscanner, OP_OF, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2850 'grammar.c' /* yacc.c:1646  */
    break;

  case 69:
#line 1256 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit(yyscanner, OP_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2860 'grammar.c' /* yacc.c:1646  */
    break;

  case 70:
#line 1262 'grammar.y' /* yacc.c:1646  */
    {
        YR_FIXUP* fixup;
        int64_t* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // create a fixup entry for the jump and push it in the stack
        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
        fixup->next = compiler->fixup_stack_head;
        compiler->fixup_stack_head = fixup;
      }
#line 2890 'grammar.c' /* yacc.c:1646  */
    break;

  case 71:
#line 1288 'grammar.y' /* yacc.c:1646  */
    {
        YR_FIXUP* fixup;
        uint8_t* and_addr;

        // Ensure that we have at least two consecutive bytes in the arena's
        // current page, one for the AND opcode and one for opcode following the
        // AND. This is necessary because we need to compute the address for the
        // opcode following the AND, and we don't want the AND in one page and
        // the following opcode in another page.

        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Now we know the jump destination, which is the address of the
        // instruction following the AND. Let's fixup the jump address.

        fixup = compiler->fixup_stack_head;

        // We know that the AND opcode and the following one are within the same
        // page, so we can compute the address for the opcode following the AND
        // by simply adding one to its address.

        *(fixup->address) = PTR_TO_INT64(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2930 'grammar.c' /* yacc.c:1646  */
    break;

  case 72:
#line 1324 'grammar.y' /* yacc.c:1646  */
    {
        YR_FIXUP* fixup;
        int64_t* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
        fixup->next = compiler->fixup_stack_head;
        compiler->fixup_stack_head = fixup;
      }
#line 2959 'grammar.c' /* yacc.c:1646  */
    break;

  case 73:
#line 1349 'grammar.y' /* yacc.c:1646  */
    {
        YR_FIXUP* fixup;
        uint8_t* or_addr;

        // Ensure that we have at least two consecutive bytes in the arena's
        // current page, one for the OR opcode and one for opcode following the
        // OR. This is necessary because we need to compute the address for the
        // opcode following the OR, and we don't want the OR in one page and
        // the following opcode in another page.

        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Now we know the jump destination, which is the address of the
        // instruction following the OP_OR. Let's fixup the jump address.

        fixup = compiler->fixup_stack_head;

        // We know that the OR opcode and the following one are within the same
        // page, so we can compute the address for the opcode following the OR
        // by simply adding one to its address.

        *(fixup->address) = PTR_TO_INT64(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2999 'grammar.c' /* yacc.c:1646  */
    break;

  case 74:
#line 1385 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '<', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3012 'grammar.c' /* yacc.c:1646  */
    break;

  case 75:
#line 1394 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '>', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3025 'grammar.c' /* yacc.c:1646  */
    break;

  case 76:
#line 1403 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '<=', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3038 'grammar.c' /* yacc.c:1646  */
    break;

  case 77:
#line 1412 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '>=', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3051 'grammar.c' /* yacc.c:1646  */
    break;

  case 78:
#line 1421 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '==', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3064 'grammar.c' /* yacc.c:1646  */
    break;

  case 79:
#line 1430 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '!=', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 3077 'grammar.c' /* yacc.c:1646  */
    break;

  case 80:
#line 1439 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.expression) = (yyvsp[0].expression);
      }
#line 3085 'grammar.c' /* yacc.c:1646  */
    break;

  case 81:
#line 1443 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.expression) = (yyvsp[-1].expression);
      }
#line 3093 'grammar.c' /* yacc.c:1646  */
    break;

  case 82:
#line 1450 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3099 'grammar.c' /* yacc.c:1646  */
    break;

  case 83:
#line 1451 'grammar.y' /* yacc.c:1646  */
    { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3105 'grammar.c' /* yacc.c:1646  */
    break;

  case 84:
#line 1457 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, 'wrong type for range's lower bound');
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, 'wrong type for range's upper bound');
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3127 'grammar.c' /* yacc.c:1646  */
    break;

  case 85:
#line 1479 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, 'wrong type for enumeration item');
          compiler->last_result = ERROR_WRONG_TYPE;

        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3143 'grammar.c' /* yacc.c:1646  */
    break;

  case 86:
#line 1491 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, 'wrong type for enumeration item');
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3158 'grammar.c' /* yacc.c:1646  */
    break;

  case 87:
#line 1506 'grammar.y' /* yacc.c:1646  */
    {
        // Push end-of-list marker
        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
      }
#line 3167 'grammar.c' /* yacc.c:1646  */
    break;

  case 89:
#line 1512 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        yr_parser_emit_pushes_for_strings(yyscanner, '$*');

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3178 'grammar.c' /* yacc.c:1646  */
    break;

  case 92:
#line 1529 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3189 'grammar.c' /* yacc.c:1646  */
    break;

  case 93:
#line 1536 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3200 'grammar.c' /* yacc.c:1646  */
    break;

  case 95:
#line 1548 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
      }
#line 3208 'grammar.c' /* yacc.c:1646  */
    break;

  case 96:
#line 1552 'grammar.y' /* yacc.c:1646  */
    {
        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
      }
#line 3216 'grammar.c' /* yacc.c:1646  */
    break;

  case 97:
#line 1560 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.expression) = (yyvsp[-1].expression);
      }
#line 3224 'grammar.c' /* yacc.c:1646  */
    break;

  case 98:
#line 1564 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit(
            yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3238 'grammar.c' /* yacc.c:1646  */
    break;

  case 99:
#line 1574 'grammar.y' /* yacc.c:1646  */
    {
        yywarning(yyscanner,
            'Using deprecated \'entrypoint\' keyword. Use the \'entry_point\' '
            'function from PE module instead.');

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3256 'grammar.c' /* yacc.c:1646  */
    break;

  case 100:
#line 1588 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, 'intXXXX or uintXXXX');

        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        // in the proper OP_INTXX opcode.

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3276 'grammar.c' /* yacc.c:1646  */
    break;

  case 101:
#line 1604 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = (yyvsp[0].integer);
      }
#line 3290 'grammar.c' /* yacc.c:1646  */
    break;

  case 102:
#line 1614 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg_double(
            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
      }
#line 3303 'grammar.c' /* yacc.c:1646  */
    break;

  case 103:
#line 1623 'grammar.y' /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string;

        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              PTR_TO_INT64(sized_string),
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_STRING;
        (yyval.expression).value.sized_string = sized_string;
      }
#line 3332 'grammar.c' /* yacc.c:1646  */
    break;

  case 104:
#line 1648 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3348 'grammar.c' /* yacc.c:1646  */
    break;

  case 105:
#line 1660 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3364 'grammar.c' /* yacc.c:1646  */
    break;

  case 106:
#line 1672 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3384 'grammar.c' /* yacc.c:1646  */
    break;

  case 107:
#line 1688 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3400 'grammar.c' /* yacc.c:1646  */
    break;

  case 108:
#line 1700 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = UNDEFINED;
      }
#line 3420 'grammar.c' /* yacc.c:1646  */
    break;

  case 109:
#line 1716 'grammar.y' /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  'wrong usage of identifier \'%s\'',
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3469 'grammar.c' /* yacc.c:1646  */
    break;

  case 110:
#line 1761 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, '-');

        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 3492 'grammar.c' /* yacc.c:1646  */
    break;

  case 111:
#line 1780 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '+', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
      }
#line 3514 'grammar.c' /* yacc.c:1646  */
    break;

  case 112:
#line 1798 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '-', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
      }
#line 3536 'grammar.c' /* yacc.c:1646  */
    break;

  case 113:
#line 1816 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '*', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
      }
#line 3558 'grammar.c' /* yacc.c:1646  */
    break;

  case 114:
#line 1834 'grammar.y' /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_operation(
            yyscanner, '\\', (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
      }
#line 3588 'grammar.c' /* yacc.c:1646  */
    break;

  case 115:
#line 1860 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '%');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '%');

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
      }
#line 3610 'grammar.c' /* yacc.c:1646  */
    break;

  case 116:
#line 1878 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '^');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '^');

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3624 'grammar.c' /* yacc.c:1646  */
    break;

  case 117:
#line 1888 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '^');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '^');

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3638 'grammar.c' /* yacc.c:1646  */
    break;

  case 118:
#line 1898 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '|');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '|');

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3652 'grammar.c' /* yacc.c:1646  */
    break;

  case 119:
#line 1908 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '~');

        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
            UNDEFINED : ~((yyvsp[0].expression).value.integer);
      }
#line 3666 'grammar.c' /* yacc.c:1646  */
    break;

  case 120:
#line 1918 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '<<');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '<<');

        yr_parser_emit(yyscanner, OP_SHL, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3680 'grammar.c' /* yacc.c:1646  */
    break;

  case 121:
#line 1928 'grammar.y' /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, '>>');
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, '>>');

        yr_parser_emit(yyscanner, OP_SHR, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
      }
#line 3694 'grammar.c' /* yacc.c:1646  */
    break;

  case 122:
#line 1938 'grammar.y' /* yacc.c:1646  */
    {
        (yyval.expression) = (yyvsp[0].expression);
      }
#line 3702 'grammar.c' /* yacc.c:1646  */
    break;


#line 3706 'grammar.c' /* yacc.c:1646  */
      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ('-> $$ =', yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_('syntax error'));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_('syntax error');
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct ('Error: discarding',
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct ('Error: popping',
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ('Shifting', yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_('memory exhausted'));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ('Cleanup: discarding lookahead',
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ('Cleanup: popping',
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  return yyresult;
}
",1,8091
VirusTotal/yara,83c42e3c26bc2c7e5b83fe970d055c3e70db70e0,"static YYSIZE_T
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == ''')
    {
      YYSIZE_T yyn = 0;
      char const *yyp = yystr;

      for (;;)
        switch (*++yyp)
          {
          case '\'':
          case ',':
            goto do_not_strip_quotes;

          case '\\':
            if (*++yyp != '\\')
              goto do_not_strip_quotes;
            /* Fall through.  */
          default:
            if (yyres)
              yyres[yyn] = *yyp;
            yyn++;
            break;

          case ''':
            if (yyres)
              yyres[yyn] = '\0';
            return yyn;
          }
    do_not_strip_quotes: ;
    }

  if (! yyres)
    return yystrlen (yystr);

  return yystpcpy (yyres, yystr) - yyres;
}
",0,8092
torvalds/linux,dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
	struct socket *sock;
	int err = 0;

	if (!asoc)
		return -EINVAL;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
",1,8093
torvalds/linux,dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,"static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
				size_t msg_len)
{
	struct sock *sk = asoc->base.sk;
	int err = 0;
	long current_timeo = *timeo_p;
	DEFINE_WAIT(wait);

	pr_debug('%s: asoc:%p, timeo:%ld, msg_len:%zu\n', __func__, asoc,
		 *timeo_p, msg_len);

	/* Increment the association's refcnt.  */
	sctp_association_hold(asoc);

	/* Wait on the association specific sndbuf space. */
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (!*timeo_p)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
		    asoc->base.dead)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;

		/* Let another process have a go.  Since we are going
		 * to sleep anyway.
		 */
		release_sock(sk);
		current_timeo = schedule_timeout(current_timeo);
		if (sk != asoc->base.sk)
			goto do_error;
		lock_sock(sk);

		*timeo_p = current_timeo;
	}

out:
	finish_wait(&asoc->wait, &wait);

	/* Release the association's refcnt.  */
	sctp_association_put(asoc);

	return err;

do_error:
	err = -EPIPE;
	goto out;

do_interrupted:
	err = sock_intr_errno(*timeo_p);
	goto out;

do_nonblock:
	err = -EAGAIN;
	goto out;
}
",1,8094
torvalds/linux,dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,"static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,
					unsigned int optlen)
{
	int val;
	struct sctp_sock *sp = sctp_sk(sk);

	if (optlen < sizeof(int))
		return -EINVAL;
	if (get_user(val, (int __user *)optval))
		return -EFAULT;
	if (!sctp_is_ep_boundall(sk) && val)
		return -EINVAL;
	if ((val && sp->do_auto_asconf) || (!val && !sp->do_auto_asconf))
		return 0;

	spin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);
	if (val == 0 && sp->do_auto_asconf) {
		list_del(&sp->auto_asconf_list);
		sp->do_auto_asconf = 0;
	} else if (val && !sp->do_auto_asconf) {
		list_add_tail(&sp->auto_asconf_list,
		    &sock_net(sk)->sctp.auto_asconf_splist);
		sp->do_auto_asconf = 1;
	}
	spin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);
	return 0;
}
",0,8095
torvalds/linux,dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,"static int sctp_send_asconf_add_ip(struct sock		*sk,
				   struct sockaddr	*addrs,
				   int 			addrcnt)
{
	struct net *net = sock_net(sk);
	struct sctp_sock		*sp;
	struct sctp_endpoint		*ep;
	struct sctp_association		*asoc;
	struct sctp_bind_addr		*bp;
	struct sctp_chunk		*chunk;
	struct sctp_sockaddr_entry	*laddr;
	union sctp_addr			*addr;
	union sctp_addr			saveaddr;
	void				*addr_buf;
	struct sctp_af			*af;
	struct list_head		*p;
	int 				i;
	int 				retval = 0;

	if (!net->sctp.addip_enable)
		return retval;

	sp = sctp_sk(sk);
	ep = sp->ep;

	pr_debug('%s: sk:%p, addrs:%p, addrcnt:%d\n',
		 __func__, sk, addrs, addrcnt);

	list_for_each_entry(asoc, &ep->asocs, asocs) {
		if (!asoc->peer.asconf_capable)
			continue;

		if (asoc->peer.addip_disabled_mask & SCTP_PARAM_ADD_IP)
			continue;

		if (!sctp_state(asoc, ESTABLISHED))
			continue;

		/* Check if any address in the packed array of addresses is
		 * in the bind address list of the association. If so,
		 * do not send the asconf chunk to its peer, but continue with
		 * other associations.
		 */
		addr_buf = addrs;
		for (i = 0; i < addrcnt; i++) {
			addr = addr_buf;
			af = sctp_get_af_specific(addr->v4.sin_family);
			if (!af) {
				retval = -EINVAL;
				goto out;
			}

			if (sctp_assoc_lookup_laddr(asoc, addr))
				break;

			addr_buf += af->sockaddr_len;
		}
		if (i < addrcnt)
			continue;

		/* Use the first valid address in bind addr list of
		 * association as Address Parameter of ASCONF CHUNK.
		 */
		bp = &asoc->base.bind_addr;
		p = bp->address_list.next;
		laddr = list_entry(p, struct sctp_sockaddr_entry, list);
		chunk = sctp_make_asconf_update_ip(asoc, &laddr->a, addrs,
						   addrcnt, SCTP_PARAM_ADD_IP);
		if (!chunk) {
			retval = -ENOMEM;
			goto out;
		}

		/* Add the new addresses to the bind address list with
		 * use_as_src set to 0.
		 */
		addr_buf = addrs;
		for (i = 0; i < addrcnt; i++) {
			addr = addr_buf;
			af = sctp_get_af_specific(addr->v4.sin_family);
			memcpy(&saveaddr, addr, af->sockaddr_len);
			retval = sctp_add_bind_addr(bp, &saveaddr,
						    sizeof(saveaddr),
						    SCTP_ADDR_NEW, GFP_ATOMIC);
			addr_buf += af->sockaddr_len;
		}
		if (asoc->src_out_of_asoc_ok) {
			struct sctp_transport *trans;

			list_for_each_entry(trans,
			    &asoc->peer.transport_addr_list, transports) {
				/* Clear the source and route cache */
				sctp_transport_dst_release(trans);
				trans->cwnd = min(4*asoc->pathmtu, max_t(__u32,
				    2*asoc->pathmtu, 4380));
				trans->ssthresh = asoc->peer.i.a_rwnd;
				trans->rto = asoc->rto_initial;
				sctp_max_rto(asoc, trans);
				trans->rtt = trans->srtt = trans->rttvar = 0;
				sctp_transport_route(trans, NULL,
				    sctp_sk(asoc->base.sk));
			}
		}
		retval = sctp_send_asconf(asoc, chunk);
	}

out:
	return retval;
}
",0,8096
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"jp2_box_t *jp2_box_create(int type)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		return 0;
	}
	memset(box, 0, sizeof(jp2_box_t));
	box->type = type;
	box->len = 0;
	if (!(boxinfo = jp2_boxinfolookup(type))) {
		return 0;
	}
	box->info = boxinfo;
	box->ops = &boxinfo->ops;
	return box;
}
",1,8097
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}

	// Mark the box data as never having been constructed
	// so that we will not errantly attempt to destroy it later.
	box->ops = &jp2_boxinfo_unk.ops;

	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
	box->info = boxinfo;
	box->len = len;
	JAS_DBGLOG(10, (
	  'preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n',
	  ''', boxinfo->name, ''', box->type, box->len
	  ));
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf('warning: cannot handle large 64-bit box length\n');
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			jas_eprintf('cannot copy box data\n');
			goto error;
		}
		jas_stream_rewind(tmpstream);

		// From here onwards, the box data will need to be destroyed.
		// So, initialize the box operations.
		box->ops = &boxinfo->ops;

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf('cannot parse box data\n');
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
",1,8098
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_bpcc_t *bpcc = &box->data.bpcc;
	unsigned int i;
	bpcc->numcmpts = box->datalen;
	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
		return -1;
	}
	for (i = 0; i < bpcc->numcmpts; ++i) {
		if (jp2_getuint8(in, &bpcc->bpcs[i])) {
			return -1;
		}
	}
	return 0;
}
",1,8099
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_cdef_t *cdef = &box->data.cdef;
	jp2_cdefchan_t *chan;
	unsigned int channo;
	if (jp2_getuint16(in, &cdef->numchans)) {
		return -1;
	}
	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
		return -1;
	}
	for (channo = 0; channo < cdef->numchans; ++channo) {
		chan = &cdef->ents[channo];
		if (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||
		  jp2_getuint16(in, &chan->assoc)) {
			return -1;
		}
	}
	return 0;
}
",1,8100
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
{
	jas_stream_t *tmpstream;
	bool extlen;
	bool dataflag;

	tmpstream = 0;

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (box->ops->putdata) {
			if ((*box->ops->putdata)(box, tmpstream)) {
				goto error;
			}
		}
		box->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);
		jas_stream_rewind(tmpstream);
	}
	extlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;
	if (jp2_putuint32(out, extlen ? 1 : box->len)) {
		goto error;
	}
	if (jp2_putuint32(out, box->type)) {
		goto error;
	}
	if (extlen) {
		if (jp2_putuint64(out, box->len)) {
			goto error;
		}
	}

	if (dataflag) {
		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
			goto error;
		}
		jas_stream_close(tmpstream);
	}

	return 0;

error:

	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return -1;
}
",1,8101
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_cmap_t *cmap = &box->data.cmap;
	jp2_cmapent_t *ent;
	unsigned int i;

	cmap->numchans = (box->datalen) / 4;
	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
		return -1;
	}
	for (i = 0; i < cmap->numchans; ++i) {
		ent = &cmap->ents[i];
		if (jp2_getuint16(in, &ent->cmptno) ||
		  jp2_getuint8(in, &ent->map) ||
		  jp2_getuint8(in, &ent->pcol)) {
			return -1;
		}
	}
	
	return 0;
}
",1,8102
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_pclr_t *pclr = &box->data.pclr;
	int lutsize;
	unsigned int i;
	unsigned int j;
	int_fast32_t x;

	pclr->lutdata = 0;

	if (jp2_getuint16(in, &pclr->numlutents) ||
	  jp2_getuint8(in, &pclr->numchans)) {
		return -1;
	}
	lutsize = pclr->numlutents * pclr->numchans;
	if (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {
		return -1;
	}
	if (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {
		return -1;
	}
	for (i = 0; i < pclr->numchans; ++i) {
		if (jp2_getuint8(in, &pclr->bpc[i])) {
			return -1;
		}
	}
	for (i = 0; i < pclr->numlutents; ++i) {
		for (j = 0; j < pclr->numchans; ++j) {
			if (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,
			  (pclr->bpc[j] & 0x7f) + 1, &x)) {
				return -1;
			}
			pclr->lutdata[i * pclr->numchans + j] = x;
		}
	}
	return 0;
}
",1,8103
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
{
#if 0
	jp2_pclr_t *pclr = &box->data.pclr;
#endif
/* Eliminate warning about unused variable. */
box = 0;
out = 0;
	return -1;
}
",1,8104
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)
{
	int n;
	int c;
	char *bufptr;

	JAS_DBGLOG(100, ('jas_stream_read(%p, %p, %d)\n', stream, buf, cnt));

	if (cnt < 0) {
		jas_deprecated('negative count for jas_stream_read');
	}

	bufptr = buf;

	n = 0;
	while (n < cnt) {
		if ((c = jas_stream_getc(stream)) == EOF) {
			return n;
		}
		*bufptr++ = c;
		++n;
	}

	return n;
}
",1,8105
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)
{
	int n;
	const char *bufptr;

	JAS_DBGLOG(100, ('jas_stream_write(%p, %p, %d)\n', stream, buf, cnt));

	if (cnt < 0) {
		jas_deprecated('negative count for jas_stream_write');
	}

	bufptr = buf;

	n = 0;
	while (n < cnt) {
		if (jas_stream_putc(stream, *bufptr) == EOF) {
			return n;
		}
		++bufptr;
		++n;
	}

	return n;
}
",1,8106
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)
{
	int c;
	char *bufptr;
	assert(bufsize > 0);

	JAS_DBGLOG(100, ('jas_stream_gets(%p, %p, %d)\n', stream, buf, bufsize));

	bufptr = buf;
	while (bufsize > 1) {
		if ((c = jas_stream_getc(stream)) == EOF) {
			break;
		}
		*bufptr++ = c;
		--bufsize;
		if (c == '\n') {
			break;
		}
	}
	*bufptr = '\0';
	return buf;
}
",1,8107
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jas_stream_gobble(jas_stream_t *stream, int n)
{
	int m;

	JAS_DBGLOG(100, ('jas_stream_gobble(%p, %d)\n', stream, n));

	if (n < 0) {
		jas_deprecated('negative count for jas_stream_gobble');
	}
	m = n;
	for (m = n; m > 0; --m) {
		if (jas_stream_getc(stream) == EOF) {
			return n - m;
		}
	}
	return n;
}
",1,8108
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jas_stream_pad(jas_stream_t *stream, int n, int c)
{
	int m;

	JAS_DBGLOG(100, ('jas_stream_pad(%p, %d, %d)\n', stream, n, c));

	if (n < 0) {
		jas_deprecated('negative count for jas_stream_pad');
	}
	m = n;
	for (m = n; m > 0; --m) {
		if (jas_stream_putc(stream, c) == EOF)
			return n - m;
	}
	return n;
}
",1,8109
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,
  int bufsize)
{
	/* If this function is being called, the buffer should not have been
	  initialized yet. */
	assert(!stream->bufbase_);

	if (bufmode != JAS_STREAM_UNBUF) {
		/* The full- or line-buffered mode is being employed. */
		if (!buf) {
			/* The caller has not specified a buffer to employ, so allocate
			  one. */
			if ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +
			  JAS_STREAM_MAXPUTBACK))) {
				stream->bufmode_ |= JAS_STREAM_FREEBUF;
				stream->bufsize_ = JAS_STREAM_BUFSIZE;
			} else {
				/* The buffer allocation has failed.  Resort to unbuffered
				  operation. */
				stream->bufbase_ = stream->tinybuf_;
				stream->bufsize_ = 1;
			}
		} else {
			/* The caller has specified a buffer to employ. */
			/* The buffer must be large enough to accommodate maximum
			  putback. */
			assert(bufsize > JAS_STREAM_MAXPUTBACK);
			stream->bufbase_ = JAS_CAST(jas_uchar *, buf);
			stream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;
		}
	} else {
		/* The unbuffered mode is being employed. */
		/* A buffer should not have been supplied by the caller. */
		assert(!buf);
		/* Use a trivial one-character buffer. */
		stream->bufbase_ = stream->tinybuf_;
		stream->bufsize_ = 1;
	}
	stream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];
	stream->ptr_ = stream->bufstart_;
	stream->cnt_ = 0;
	stream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;
}
",1,8110
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)
{
	int all;
	int c;
	int m;

	all = (n < 0) ? 1 : 0;

	m = n;
	while (all || m > 0) {
		if ((c = jas_stream_getc_macro(in)) == EOF) {
			/* The next character of input could not be read. */
			/* Return with an error if an I/O error occured
			  (not including EOF) or if an explicit copy count
			  was specified. */
			return (!all || jas_stream_error(in)) ? (-1) : 0;
		}
		if (jas_stream_putc_macro(out, c) == EOF) {
			return -1;
		}
		--m;
	}
	return 0;
}
",1,8111
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)
{
	int old;

	old = stream->rwcnt_;
	stream->rwcnt_ = rwcnt;
	return old;
}
",1,8112
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)
{
	unsigned char buf[16];
	int i;
	int j;
	int m;
	int c;
	int display;
	int cnt;

	cnt = n - (n % 16);
	display = 1;

	for (i = 0; i < n; i += 16) {
		if (n > 16 && i > 0) {
			display = (i >= cnt) ? 1 : 0;
		}
		if (display) {
			fprintf(fp, '%08x:', i);
		}
		m = JAS_MIN(n - i, 16);
		for (j = 0; j < m; ++j) {
			if ((c = jas_stream_getc(stream)) == EOF) {
				abort();
				return -1;
			}
			buf[j] = c;
		}
		if (display) {
			for (j = 0; j < m; ++j) {
				fprintf(fp, ' %02x', buf[j]);
			}
			fputc(' ', fp);
			for (; j < 16; ++j) {
				fprintf(fp, '   ');
			}
			for (j = 0; j < m; ++j) {
				if (isprint(buf[j])) {
					fputc(buf[j], fp);
				} else {
					fputc(' ', fp);
				}
			}
			fprintf(fp, '\n');
		}


	}
	return 0;
}
",1,8113
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)
{
	ssize_t n;
	assert(cnt >= 0);
	assert(buf);

	JAS_DBGLOG(100, ('mem_read(%p, %p, %d)\n', obj, buf, cnt));
	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
	n = m->len_ - m->pos_;
	cnt = JAS_MIN(n, cnt);
	memcpy(buf, &m->buf_[m->pos_], cnt);
	m->pos_ += cnt;
	return cnt;
}
",1,8114
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)
{
	size_t n;
	int ret;
	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
	size_t newbufsize;
	size_t newpos;

	assert(buf);
	assert(cnt >= 0);

	JAS_DBGLOG(100, ('mem_write(%p, %p, %d)\n', obj, buf, cnt));
	newpos = m->pos_ + cnt;
	if (newpos > m->bufsize_ && m->growable_) {
		newbufsize = m->bufsize_;
		while (newbufsize < newpos) {
			//newbufsize <<= 1;
			if (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {
				JAS_DBGLOG(100, ('new buffer size would cause overflow\n'));
				return -1;
			}
		}
		JAS_DBGLOG(100, ('mem_write resizing from %d to %zu\n', m->bufsize_,
		  newbufsize));
		assert(newbufsize > 0);
		if (mem_resize(m, newbufsize)) {
			return -1;
		}
	}
	if (m->pos_ > m->len_) {
		/* The current position is beyond the end of the file, so
		  pad the file to the current position with zeros. */
		n = JAS_MIN(m->pos_, m->bufsize_) - m->len_;
		if (n > 0) {
			memset(&m->buf_[m->len_], 0, n);
			m->len_ += n;
		}
		if (m->pos_ != m->len_) {
			/* The buffer is not big enough. */
			return 0;
		}
	}
	n = m->bufsize_ - m->pos_;
	ret = JAS_MIN(n, cnt);
	if (ret > 0) {
		memcpy(&m->buf_[m->pos_], buf, ret);
		m->pos_ += ret;
	}
	if (m->pos_ > m->len_) {
		m->len_ = m->pos_;
	}
	assert(ret == cnt);
	return ret;
}
",1,8115
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)
{
	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
	size_t newpos;

	JAS_DBGLOG(100, ('mem_seek(%p, %ld, %d)\n', obj, offset, origin));
	switch (origin) {
	case SEEK_SET:
		newpos = offset;
		break;
	case SEEK_END:
		newpos = m->len_ - offset;
		break;
	case SEEK_CUR:
		newpos = m->pos_ + offset;
		break;
	default:
		abort();
		break;
	}
	if (newpos < 0) {
		return -1;
	}
	m->pos_ = newpos;

	return m->pos_;
}
",1,8116
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)
{
	jas_stream_fileobj_t *fileobj;
	JAS_DBGLOG(100, ('file_read(%p, %p, %d)\n', obj, buf, cnt));
	fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);
	return read(fileobj->fd, buf, cnt);
}
",1,8117
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)
{
	jas_stream_fileobj_t *fileobj;
	JAS_DBGLOG(100, ('file_write(%p, %p, %d)\n', obj, buf, cnt));
	fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);
	return write(fileobj->fd, buf, cnt);
}
",1,8118
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static long file_seek(jas_stream_obj_t *obj, long offset, int origin)
{
	jas_stream_fileobj_t *fileobj;
	JAS_DBGLOG(100, ('file_seek(%p, %ld, %d)\n', obj, offset, origin));
	fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);
	return lseek(fileobj->fd, offset, origin);
}
",1,8119
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)
{
	FILE *fp;
	size_t n;
	int result;
	JAS_DBGLOG(100, ('sfile_read(%p, %p, %d)\n', obj, buf, cnt));
	fp = JAS_CAST(FILE *, obj);
	n = fread(buf, 1, cnt, fp);
	if (n != cnt) {
		result = (!ferror(fp) && feof(fp)) ? 0 : -1;
	}
	result = JAS_CAST(int, n);
	return result;
}
",1,8120
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)
{
	FILE *fp;
	size_t n;
	JAS_DBGLOG(100, ('sfile_write(%p, %p, %d)\n', obj, buf, cnt));
	fp = JAS_CAST(FILE *, obj);
	n = fwrite(buf, 1, cnt, fp);
	return (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;
}
",1,8121
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)
{
	FILE *fp;
	JAS_DBGLOG(100, ('sfile_seek(%p, %ld, %d)\n', obj, offset, origin));
	fp = JAS_CAST(FILE *, obj);
	return fseek(fp, offset, origin);
}
",1,8122
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out)
{
	jp2_cdef_t *cdef = &box->data.cdef;
	unsigned int i;
	jp2_cdefchan_t *ent;

	if (jp2_putuint16(out, cdef->numchans)) {
		return -1;
	}

	for (i = 0; i < cdef->numchans; ++i) {
		ent = &cdef->ents[i];
		if (jp2_putuint16(out, ent->channo) ||
		  jp2_putuint16(out, ent->type) ||
		  jp2_putuint16(out, ent->assoc)) {
			return -1;
		}
	}
	return 0;
}
",0,8123
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out)
{
	jp2_colr_t *colr = &box->data.colr;
	if (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) ||
	  jp2_putuint8(out, colr->approx)) {
		return -1;
	}
	switch (colr->method) {
	case JP2_COLR_ENUM:
		if (jp2_putuint32(out, colr->csid)) {
			return -1;
		}
		break;
	case JP2_COLR_ICC:
		if (jas_stream_write(out, colr->iccp,
		  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen))
			return -1;
		break;
	}
	return 0;
}
",0,8124
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"long jas_stream_tell(jas_stream_t *stream)
{
	int adjust;
	int offset;

	JAS_DBGLOG(100, ('jas_stream_tell(%p)\n', stream));

	if (stream->bufmode_ & JAS_STREAM_RDBUF) {
		adjust = -stream->cnt_;
	} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {
		adjust = stream->ptr_ - stream->bufstart_;
	} else {
		adjust = 0;
	}

	if ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {
		return -1;
	}

	return offset + adjust;
}
",0,8125
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jas_stream_rewind(jas_stream_t *stream)
{
	JAS_DBGLOG(100, ('jas_stream_rewind(%p)\n', stream));
	return jas_stream_seek(stream, 0, SEEK_SET);
}
",0,8126
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d," * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH
 * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,
",0,8127
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_colr_t *colr = &box->data.colr;
	colr->csid = 0;
	colr->iccp = 0;
	colr->iccplen = 0;

	if (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||
	  jp2_getuint8(in, &colr->approx)) {
		return -1;
	}
	switch (colr->method) {
	case JP2_COLR_ENUM:
		if (jp2_getuint32(in, &colr->csid)) {
			return -1;
		}
		break;
	case JP2_COLR_ICC:
		colr->iccplen = box->datalen - 3;
		if (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {
			return -1;
		}
		if (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {
			return -1;
		}
		break;
	}
	return 0;
}
",0,8128
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_jp_t *jp = &box->data.jp;
	if (jp2_getuint32(in, &jp->magic)) {
		return -1;
	}
	return 0;
}
",0,8129
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static jas_stream_t *jas_stream_create()
{
	jas_stream_t *stream;

	if (!(stream = jas_malloc(sizeof(jas_stream_t)))) {
		return 0;
	}
	stream->openmode_ = 0;
	stream->bufmode_ = 0;
	stream->flags_ = 0;
	stream->bufbase_ = 0;
	stream->bufstart_ = 0;
	stream->bufsize_ = 0;
	stream->ptr_ = 0;
	stream->cnt_ = 0;
	stream->ops_ = 0;
	stream->obj_ = 0;
	stream->rwcnt_ = 0;
	stream->rwlimit_ = -1;

	return stream;
}
",0,8132
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_putuint16(jas_stream_t *out, uint_fast16_t val)
{
	if (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||
	  jas_stream_putc(out, val & 0xff) == EOF) {
		return -1;
	}
	return 0;
}
",0,8134
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d," * written permission.
 * 
 * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
 * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
 * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
",0,8135
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"jas_stream_t *jas_stream_fopen(const char *filename, const char *mode)
{
	jas_stream_t *stream;
	jas_stream_fileobj_t *obj;
	int openflags;

	JAS_DBGLOG(100, ('jas_stream_fopen(\'%s\', \'%s\')\n', filename, mode));

	/* Allocate a stream object. */
	if (!(stream = jas_stream_create())) {
		return 0;
	}

	/* Parse the mode string. */
	stream->openmode_ = jas_strtoopenmode(mode);

	/* Determine the correct flags to use for opening the file. */
	if ((stream->openmode_ & JAS_STREAM_READ) &&
	  (stream->openmode_ & JAS_STREAM_WRITE)) {
		openflags = O_RDWR;
	} else if (stream->openmode_ & JAS_STREAM_READ) {
		openflags = O_RDONLY;
	} else if (stream->openmode_ & JAS_STREAM_WRITE) {
		openflags = O_WRONLY;
	} else {
		openflags = 0;
	}
	if (stream->openmode_ & JAS_STREAM_APPEND) {
		openflags |= O_APPEND;
	}
	if (stream->openmode_ & JAS_STREAM_BINARY) {
		openflags |= O_BINARY;
	}
	if (stream->openmode_ & JAS_STREAM_CREATE) {
		openflags |= O_CREAT | O_TRUNC;
	}

	/* Allocate space for the underlying file stream object. */
	if (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {
		jas_stream_destroy(stream);
		return 0;
	}
	obj->fd = -1;
	obj->flags = 0;
	obj->pathname[0] = '\0';
	stream->obj_ = (void *) obj;

	/* Select the operations for a file stream object. */
	stream->ops_ = &jas_stream_fileops;

	/* Open the underlying file. */
	if ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {
		// Free the underlying file object, since it will not otherwise
		// be freed.
		jas_free(obj);
		jas_stream_destroy(stream);
		return 0;
	}

	/* By default, use full buffering for this type of stream. */
	jas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);

	return stream;
}
",0,8137
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d," * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
",0,8139
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"long jas_stream_seek(jas_stream_t *stream, long offset, int origin)
{
	long newpos;

	JAS_DBGLOG(100, ('jas_stream_seek(%p, %ld, %d)\n', stream, offset,
	  origin));

	/* The buffer cannot be in use for both reading and writing. */
	assert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &
	  JAS_STREAM_WRBUF)));

	/* Reset the EOF indicator (since we may not be at the EOF anymore). */
	stream->flags_ &= ~JAS_STREAM_EOF;

	if (stream->bufmode_ & JAS_STREAM_RDBUF) {
		if (origin == SEEK_CUR) {
			offset -= stream->cnt_;
		}
	} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {
		if (jas_stream_flush(stream)) {
			return -1;
		}
	}
	stream->cnt_ = 0;
	stream->ptr_ = stream->bufstart_;
	stream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);

	if ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))
	  < 0) {
		return -1;
	}

	return newpos;
}
",0,8140
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val)
{
	int c;
	int i;
	uint_fast32_t v;
	int m;

	m = (n + 7) / 8;

	v = 0;
	for (i = 0; i < m; ++i) {
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;
		}
		v = (v << 8) | c;
	}
	v &= ONES(n);
	if (s) {
		int sb;
		sb = v & (1 << (8 * m - 1));
		*val = ((~v) + 1) & ONES(8 * m);
		if (sb) {
			*val = -*val;
		}
	} else {
		*val = v;
	}

	return 0;
}
",0,8142
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"long jas_stream_length(jas_stream_t *stream)
{
	long oldpos;
	long pos;
	if ((oldpos = jas_stream_tell(stream)) < 0) {
		return -1;
	}
	if (jas_stream_seek(stream, 0, SEEK_END) < 0) {
		return -1;
	}
	if ((pos = jas_stream_tell(stream)) < 0) {
		return -1;
	}
	if (jas_stream_seek(stream, oldpos, SEEK_SET) < 0) {
		return -1;
	}
	return pos;
}
",0,8143
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val)
{
	uint_fast32_t v;
	int c;
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;
	}
	v = c;
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;
	}
	v = (v << 8) | c;
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;
	}
	v = (v << 8) | c;
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;
	}
	v = (v << 8) | c;
	if (val) {
		*val = v;
	}
	return 0;
}
",0,8145
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"int jas_stream_getc_func(jas_stream_t *stream)
{
	assert(stream->ptr_ - stream->bufbase_ <= stream->bufsize_ +
	  JAS_STREAM_MAXPUTBACK);
	return jas_stream_getc_macro(stream);
}
",0,8146
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out)
{
	jp2_jp_t *jp = &box->data.jp;
	if (jp2_putuint32(out, jp->magic)) {
		return -1;
	}
	return 0;
}
",0,8147
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_ftyp_t *ftyp = &box->data.ftyp;
	unsigned int i;
	if (jp2_getuint32(in, &ftyp->majver) || jp2_getuint32(in, &ftyp->minver)) {
		return -1;
	}
	ftyp->numcompatcodes = (box->datalen - 8) / 4;
	if (ftyp->numcompatcodes > JP2_FTYP_MAXCOMPATCODES) {
		return -1;
	}
	for (i = 0; i < ftyp->numcompatcodes; ++i) {
		if (jp2_getuint32(in, &ftyp->compatcodes[i])) {
			return -1;
		}
	}
	return 0;
}
",0,8148
mdadams/jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"static void jp2_bpcc_destroy(jp2_box_t *box)
{
	jp2_bpcc_t *bpcc = &box->data.bpcc;
	if (bpcc->bpcs) {
		jas_free(bpcc->bpcs);
		bpcc->bpcs = 0;
	}
}
",0,8149
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {
	ut32 i = 0;
	while (buf + i < max && buf[i] != eoc) {
		// TODO: calc the expresion with the bytcode (ESIL?)
		i += 1;
	}
	if (buf[i] != eoc) {
		return 0;
	}
	if (offset) {
		*offset += i + 1;
	}
	return i + 1;
}
",1,8151
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {

	RList *ret = NULL;
	RBinWasmDataEntry *ptr = NULL;

	if (!(ret = r_list_newf ((RListFree)free))) {
		return NULL;
	}

	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	ut32 len =  sec->payload_len;
	ut32 count = sec->count;
	ut32 i = 0, r = 0;
	size_t n = 0;

	while (i < len && r < count) {

		if (!(ptr = R_NEW0 (RBinWasmDataEntry))) {
			return ret;
		}

		if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {
			free (ptr);
			return ret;
		}

		if (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {
			free (ptr);
			return ret;
		}

		ptr->offset.len = n;

		if (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {	
			free (ptr);
			return ret;
		}

		ptr->data = sec->payload_data + i;

		r_list_append (ret, ptr);

		r += 1;

	}

	return ret;
}
",1,8152
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static RBinWasmStartEntry *r_bin_wasm_get_start (RBinWasmObj *bin, RBinWasmSection *sec) {

	RBinWasmStartEntry *ptr;	

	if (!(ptr = R_NEW0 (RBinWasmStartEntry))) {
		return NULL;
	}

	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	ut32 len =  sec->payload_len;
	ut32 i = 0;

	if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {
		free (ptr);
		return NULL;
	}

	return ptr;

}
",1,8153
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static RList *r_bin_wasm_get_memory_entries (RBinWasmObj *bin, RBinWasmSection *sec) {

	RList *ret = NULL;
	RBinWasmMemoryEntry *ptr = NULL;

	if (!(ret = r_list_newf ((RListFree)free))) {
		return NULL;
	}

	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	ut32 len =  sec->payload_len;
	ut32 count = sec->count;
	ut32 i = 0, r = 0;

	while (i < len && r < count) {

		if (!(ptr = R_NEW0 (RBinWasmMemoryEntry))) {
			return ret;
		}

		if (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {
			free (ptr);
			return ret;
		}

		r_list_append (ret, ptr);

		r += 1;

	}

	return ret;
}
",1,8154
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static RList *r_bin_wasm_get_table_entries (RBinWasmObj *bin, RBinWasmSection *sec) {

	RList *ret = NULL;
	RBinWasmTableEntry *ptr = NULL;

	if (!(ret = r_list_newf ((RListFree)free))) {
		return NULL;
	}

	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	ut32 len =  sec->payload_len;
	ut32 count = sec->count;
	ut32 i = 0, r = 0;

	while (i < len && r < count) {

		if (!(ptr = R_NEW0 (RBinWasmTableEntry))) {
			return ret;
		}

		if (!(consume_u8 (buf + i, buf + len, &ptr->element_type, &i))) {
			free (ptr);
			return ret;
		}

		if (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {
			free (ptr);
			return ret;
		}

		r_list_append (ret, ptr);

		r += 1;

	}

	return ret;
}
",1,8155
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {
	RList *ret = NULL;
	RBinWasmGlobalEntry *ptr = NULL;
	int buflen = bin->buf->length;
	if (sec->payload_data + 32 > buflen) {
		return NULL;
	}

	if (!(ret = r_list_newf ((RListFree)free))) {
		return NULL;
	}

	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	ut32 len =  sec->payload_len;
	ut32 count = sec->count;
	ut32 i = 0, r = 0;

	while (i < len && len < buflen && r < count) {
		if (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {
			return ret;
		}

		if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {
			goto beach;
		}
		if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {
			goto beach;
		}
		if (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {
			goto beach;
		}
		r_list_append (ret, ptr);
		r++;
	}
	return ret;
beach:
	free (ptr);
	return ret;
}
",1,8156
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {

	RList *ret = NULL;
	RBinWasmElementEntry *ptr = NULL;

	if (!(ret = r_list_newf ((RListFree)free))) {
		return NULL;
	}

	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	ut32 len =  sec->payload_len;
	ut32 count = sec->count;
	ut32 i = 0, r = 0;

	while (i < len && r < count) {

		if (!(ptr = R_NEW0 (RBinWasmElementEntry))) {
			return ret;
		}

		if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {
			free (ptr);
			return ret;
		}

		if (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {
			free (ptr);
			return ret;
		}

		if (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {
			free (ptr);
			return ret;
		}

		ut32 j = 0;
		while (i < len && j < ptr->num_elem	) {
			// TODO: allocate space and fill entry
			ut32 e;
			if (!(consume_u32 (buf + i, buf + len, &e, &i))) {
				free (ptr);
				return ret;
			}
		}

		r_list_append (ret, ptr);

		r += 1;

	}

	return ret;
}
",1,8157
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"RList *r_bin_wasm_get_types (RBinWasmObj *bin) {
	RBinWasmSection *type = NULL;
	RList *types = NULL;

	if (!bin || !bin->g_sections) {
		return NULL;
	}

	if (bin->g_types) {
		return bin->g_types;
	}

	if (!(types = r_bin_wasm_get_sections_by_id (bin->g_sections,
						R_BIN_WASM_SECTION_TYPE))) {
		return r_list_new();
	}

	// support for multiple export sections against spec
	if (!(type = (RBinWasmSection*) r_list_first (types))) {
		return r_list_new();
	}

	bin->g_types = r_bin_wasm_get_type_entries (bin, type);

	return bin->g_types;
}
",0,8158
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static RList *r_bin_wasm_get_sections_by_id (RList *sections, ut8 id) {
	RBinWasmSection *sec = NULL;
	RList *ret = NULL;	
	RListIter *iter = NULL;

	// memory leak
	if (!(ret = r_list_new ())) {
		return NULL;
	}
	r_list_foreach (sections, iter, sec) {
		if (sec->id == id) {
			r_list_append(ret, sec);
		}
	}
	return ret;
}
",0,8159
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"RList *r_bin_wasm_get_memories (RBinWasmObj *bin) {
	RBinWasmSection *memory;
	RList *memories;

	if (!bin || !bin->g_sections) {
		return NULL;
	}

	if (bin->g_memories) {
		return bin->g_memories;
	}

	if (!(memories = r_bin_wasm_get_sections_by_id (bin->g_sections,
						R_BIN_WASM_SECTION_MEMORY))) {
		return r_list_new();
	}

	// support for multiple export sections against spec
	if (!(memory = (RBinWasmSection*) r_list_first (memories))) {
		return r_list_new();
	}

	bin->g_memories = r_bin_wasm_get_memory_entries (bin, memory);

	return bin->g_memories;
}
",0,8160
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static size_t consume_s8 (ut8 *buf, ut8 *max, st8 *out, ut32 *offset) {
	size_t n;
	ut32 tmp;
	if (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) {
		return 0;
	}
	*out = (st8)(tmp & 0x7f);
	return 1;	
}
",0,8161
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"static RList *r_bin_wasm_get_type_entries (RBinWasmObj *bin, RBinWasmSection *sec) {

	RList *ret = NULL;
	RBinWasmTypeEntry *ptr = NULL;

	if (!(ret = r_list_newf ((RListFree)free))) {
		return NULL;
	}

	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	ut32 len =  sec->payload_len;
	ut32 count = sec->count;
	ut32 i = 0, r = 0;

	while (i < len && r < count) {
		if (!(ptr = R_NEW0 (RBinWasmTypeEntry))) {
			return ret;
		}

		if (!(consume_u8 (buf + i, buf + len, &ptr->form, &i))) {
			free (ptr);
			return ret;
		}

		if (!(consume_u32 (buf + i, buf + len, &ptr->param_count, &i))) {
			free (ptr);
			return ret;
		}

		if (!(i + ptr->param_count < len)) {
			free (ptr);
			return ret;
		}

		int j;
		for (j = 0; j < ptr->param_count; j++) {
			if (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->param_types[j], &i))) {
				free (ptr);
				return ret;
			}
		}

		if (!(consume_s8 (buf + i, buf + len, &ptr->return_count, &i))) {
			free (ptr);
			return ret;
		}

		if (ptr->return_count > 1) {
			free(ptr);
			return ret;
		}

		if (ptr->return_count == 1) {
			if (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->return_type, &i))) {
				free(ptr);
				return ret;
			}
		}

		ptr->to_str = r_bin_wasm_type_entry_to_string (ptr);

		r_list_append (ret, ptr);

		r += 1;

	}

	return ret;

}
",0,8162
radare/radare2,d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,"RList *r_bin_wasm_get_globals (RBinWasmObj *bin) {
	RBinWasmSection *global = NULL;
	RList *globals = NULL;

	if (!bin || !bin->g_sections) {
		return NULL;
	}

	if (bin->g_globals) {
		return bin->g_globals;
	}

	if (!(globals = r_bin_wasm_get_sections_by_id (bin->g_sections,
						R_BIN_WASM_SECTION_GLOBAL))) {
		return r_list_new();
	}

	// support for multiple export sections against spec
	if (!(global = (RBinWasmSection*) r_list_first (globals))) {
		return r_list_new();
	}

	bin->g_globals = r_bin_wasm_get_global_entries (bin, global);

	return bin->g_globals;
}
",0,8163
torvalds/linux,67b0503db9c29b04eadfeede6bebbfe5ddad94ef,"int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)
{
	struct hexline *hx;
	u8 reset;
	int ret,pos=0;

	hx = kmalloc(sizeof(*hx), GFP_KERNEL);
	if (!hx)
		return -ENOMEM;

	/* stop the CPU */
	reset = 1;
	if ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)
		err('could not stop the USB controller CPU.');

	while ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {
		deb_fw('writing to address 0x%04x (buffer: 0x%02x %02x)\n', hx->addr, hx->len, hx->chk);
		ret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);

		if (ret != hx->len) {
			err('error while transferring firmware (transferred size: %d, block size: %d)',
				ret, hx->len);
			ret = -EINVAL;
			break;
		}
	}
	if (ret < 0) {
		err('firmware download failed at %d with %d',pos,ret);
		kfree(hx);
		return ret;
	}

	if (ret == 0) {
		/* restart the CPU */
		reset = 0;
		if (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {
			err('could not restart the USB controller CPU.');
			ret = -EINVAL;
		}
	} else
		ret = -EIO;

	kfree(hx);

	return ret;
}
",1,8165
torvalds/linux,67b0503db9c29b04eadfeede6bebbfe5ddad94ef,"int dvb_usb_download_firmware(struct usb_device *udev, struct dvb_usb_device_properties *props)
{
	int ret;
	const struct firmware *fw = NULL;

	if ((ret = request_firmware(&fw, props->firmware, &udev->dev)) != 0) {
		err('did not find the firmware file. (%s) Please see linux/Documentation/dvb/ for more details on firmware-problems. (%d)',
			props->firmware,ret);
		return ret;
	}

	info('downloading firmware from file '%s'',props->firmware);

	switch (props->usb_ctrl) {
		case CYPRESS_AN2135:
		case CYPRESS_AN2235:
		case CYPRESS_FX2:
			ret = usb_cypress_load_firmware(udev, fw, props->usb_ctrl);
			break;
		case DEVICE_SPECIFIC:
			if (props->download_firmware)
				ret = props->download_firmware(udev,fw);
			else {
				err('BUG: driver didn't specified a download_firmware-callback, although it claims to have a DEVICE_SPECIFIC one.');
				ret = -EINVAL;
			}
			break;
		default:
			ret = -EINVAL;
			break;
	}

	release_firmware(fw);
	return ret;
}
",0,8166
ImageMagick/ImageMagick,e82f14da961e607f1b6ffa525644535686070228,"static Image *ReadEPTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  EPTInfo
    ept_info;

  Image
    *image;

  ImageInfo
    *read_info;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  ssize_t
    count;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  ept_info.magick=ReadBlobLSBLong(image);
  if (ept_info.magick != 0xc6d3d0c5ul)
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  ept_info.postscript_offset=(MagickOffsetType) ReadBlobLSBLong(image);
  ept_info.postscript_length=ReadBlobLSBLong(image);
  (void) ReadBlobLSBLong(image);
  (void) ReadBlobLSBLong(image);
  ept_info.tiff_offset=(MagickOffsetType) ReadBlobLSBLong(image);
  ept_info.tiff_length=ReadBlobLSBLong(image);
  (void) ReadBlobLSBShort(image);
  ept_info.postscript=(unsigned char *) AcquireQuantumMemory(
    ept_info.postscript_length+1,sizeof(*ept_info.postscript));
  if (ept_info.postscript == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
  (void) ResetMagickMemory(ept_info.postscript,0,(ept_info.postscript_length+1)*
    sizeof(*ept_info.postscript));
  ept_info.tiff=(unsigned char *) AcquireQuantumMemory(ept_info.tiff_length+1,
    sizeof(*ept_info.tiff));
  if (ept_info.tiff == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
  (void) ResetMagickMemory(ept_info.tiff,0,(ept_info.tiff_length+1)*
    sizeof(*ept_info.tiff));
  offset=SeekBlob(image,ept_info.tiff_offset,SEEK_SET);
  if ((ept_info.tiff_length != 0) && (offset < 30))
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  count=ReadBlob(image,ept_info.tiff_length,ept_info.tiff);
  if (count != (ssize_t) (ept_info.tiff_length))
    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,
      'InsufficientImageDataInFile','`%s'',image->filename);
  offset=SeekBlob(image,ept_info.postscript_offset,SEEK_SET);
  if ((ept_info.postscript_length != 0) && (offset < 30))
    ThrowReaderException(CorruptImageError,'ImproperImageHeader');
  count=ReadBlob(image,ept_info.postscript_length,ept_info.postscript);
  if (count != (ssize_t) (ept_info.postscript_length))
    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,
      'InsufficientImageDataInFile','`%s'',image->filename);
  (void) CloseBlob(image);
  image=DestroyImage(image);
  read_info=CloneImageInfo(image_info);
  (void) CopyMagickString(read_info->magick,'EPS',MagickPathExtent);
  image=BlobToImage(read_info,ept_info.postscript,ept_info.postscript_length,
    exception);
  if (image == (Image *) NULL)
    {
      (void) CopyMagickString(read_info->magick,'TIFF',MagickPathExtent);
      image=BlobToImage(read_info,ept_info.tiff,ept_info.tiff_length,exception);
    }
  read_info=DestroyImageInfo(read_info);
  if (image != (Image *) NULL)
    {
      (void) CopyMagickString(image->filename,image_info->filename,
        MagickPathExtent);
      (void) CopyMagickString(image->magick,'EPT',MagickPathExtent);
    }
  ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);
  ept_info.postscript=(unsigned char *) RelinquishMagickMemory(
    ept_info.postscript);
  return(image);
}
",1,8167
ImageMagick/ImageMagick,e82f14da961e607f1b6ffa525644535686070228,"static MagickBooleanType IsEPT(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,'\305\320\323\306',4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}
",0,8168
ImageMagick/ImageMagick,7fd419441bc7103398e313558171d342c6315f44,"static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    cache_filename[MagickPathExtent],
    id[MagickPathExtent],
    keyword[MagickPathExtent],
    *options;

  const unsigned char
    *p;

  GeometryInfo
    geometry_info;

  Image
    *image;

  int
    c;

  LinkedListInfo
    *profiles;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  MagickStatusType
    flags;

  register ssize_t
    i;

  size_t
    depth,
    length;

  ssize_t
    count;

  StringInfo
    *profile;

  unsigned int
    signature;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent);
  AppendImageFormat('cache',cache_filename);
  c=ReadBlobByte(image);
  if (c == EOF)
    {
      image=DestroyImage(image);
      return((Image *) NULL);
    }
  *id='\0';
  (void) ResetMagickMemory(keyword,0,sizeof(keyword));
  offset=0;
  do
  {
    /*
      Decode image header;  header terminates one character beyond a ':'.
    */
    profiles=(LinkedListInfo *) NULL;
    length=MagickPathExtent;
    options=AcquireString((char *) NULL);
    signature=GetMagickSignature((const StringInfo *) NULL);
    image->depth=8;
    image->compression=NoCompression;
    while ((isgraph(c) != MagickFalse) && (c != (int) ':'))
    {
      register char
        *p;

      if (c == (int) '{')
        {
          char
            *comment;

          /*
            Read comment-- any text between { }.
          */
          length=MagickPathExtent;
          comment=AcquireString((char *) NULL);
          for (p=comment; comment != (char *) NULL; p++)
          {
            c=ReadBlobByte(image);
            if (c == (int) '\\')
              c=ReadBlobByte(image);
            else
              if ((c == EOF) || (c == (int) '}'))
                break;
            if ((size_t) (p-comment+1) >= length)
              {
                *p='\0';
                length<<=1;
                comment=(char *) ResizeQuantumMemory(comment,length+
                  MagickPathExtent,sizeof(*comment));
                if (comment == (char *) NULL)
                  break;
                p=comment+strlen(comment);
              }
            *p=(char) c;
          }
          if (comment == (char *) NULL)
            ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
          *p='\0';
          (void) SetImageProperty(image,'comment',comment,exception);
          comment=DestroyString(comment);
          c=ReadBlobByte(image);
        }
      else
        if (isalnum(c) != MagickFalse)
          {
            /*
              Get the keyword.
            */
            length=MagickPathExtent;
            p=keyword;
            do
            {
              if (c == (int) '=')
                break;
              if ((size_t) (p-keyword) < (MagickPathExtent-1))
                *p++=(char) c;
              c=ReadBlobByte(image);
            } while (c != EOF);
            *p='\0';
            p=options;
            while (isspace((int) ((unsigned char) c)) != 0)
              c=ReadBlobByte(image);
            if (c == (int) '=')
              {
                /*
                  Get the keyword value.
                */
                c=ReadBlobByte(image);
                while ((c != (int) '}') && (c != EOF))
                {
                  if ((size_t) (p-options+1) >= length)
                    {
                      *p='\0';
                      length<<=1;
                      options=(char *) ResizeQuantumMemory(options,length+
                        MagickPathExtent,sizeof(*options));
                      if (options == (char *) NULL)
                        break;
                      p=options+strlen(options);
                    }
                  *p++=(char) c;
                  c=ReadBlobByte(image);
                  if (c == '\\')
                    {
                      c=ReadBlobByte(image);
                      if (c == (int) '}')
                        {
                          *p++=(char) c;
                          c=ReadBlobByte(image);
                        }
                    }
                  if (*options != '{')
                    if (isspace((int) ((unsigned char) c)) != 0)
                      break;
                }
                if (options == (char *) NULL)
                  ThrowReaderException(ResourceLimitError,
                    'MemoryAllocationFailed');
              }
            *p='\0';
            if (*options == '{')
              (void) CopyMagickString(options,options+1,strlen(options));
            /*
              Assign a value to the specified keyword.
            */
            switch (*keyword)
            {
              case 'a':
              case 'A':
              {
                if (LocaleCompare(keyword,'alpha-trait') == 0)
                  {
                    ssize_t
                      alpha_trait;

                    alpha_trait=ParseCommandOption(MagickPixelTraitOptions,
                      MagickFalse,options);
                    if (alpha_trait < 0)
                      break;
                    image->alpha_trait=(PixelTrait) alpha_trait;
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'b':
              case 'B':
              {
                if (LocaleCompare(keyword,'background-color') == 0)
                  {
                    (void) QueryColorCompliance(options,AllCompliance,
                      &image->background_color,exception);
                    break;
                  }
                if (LocaleCompare(keyword,'blue-primary') == 0)
                  {
                    flags=ParseGeometry(options,&geometry_info);
                    image->chromaticity.blue_primary.x=geometry_info.rho;
                    image->chromaticity.blue_primary.y=geometry_info.sigma;
                    if ((flags & SigmaValue) == 0)
                      image->chromaticity.blue_primary.y=
                        image->chromaticity.blue_primary.x;
                    break;
                  }
                if (LocaleCompare(keyword,'border-color') == 0)
                  {
                    (void) QueryColorCompliance(options,AllCompliance,
                      &image->border_color,exception);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'c':
              case 'C':
              {
                if (LocaleCompare(keyword,'class') == 0)
                  {
                    ssize_t
                      storage_class;

                    storage_class=ParseCommandOption(MagickClassOptions,
                      MagickFalse,options);
                    if (storage_class < 0)
                      break;
                    image->storage_class=(ClassType) storage_class;
                    break;
                  }
                if (LocaleCompare(keyword,'colors') == 0)
                  {
                    image->colors=StringToUnsignedLong(options);
                    break;
                  }
                if (LocaleCompare(keyword,'colorspace') == 0)
                  {
                    ssize_t
                      colorspace;

                    colorspace=ParseCommandOption(MagickColorspaceOptions,
                      MagickFalse,options);
                    if (colorspace < 0)
                      break;
                    image->colorspace=(ColorspaceType) colorspace;
                    break;
                  }
                if (LocaleCompare(keyword,'compression') == 0)
                  {
                    ssize_t
                      compression;

                    compression=ParseCommandOption(MagickCompressOptions,
                      MagickFalse,options);
                    if (compression < 0)
                      break;
                    image->compression=(CompressionType) compression;
                    break;
                  }
                if (LocaleCompare(keyword,'columns') == 0)
                  {
                    image->columns=StringToUnsignedLong(options);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'd':
              case 'D':
              {
                if (LocaleCompare(keyword,'delay') == 0)
                  {
                    image->delay=StringToUnsignedLong(options);
                    break;
                  }
                if (LocaleCompare(keyword,'depth') == 0)
                  {
                    image->depth=StringToUnsignedLong(options);
                    break;
                  }
                if (LocaleCompare(keyword,'dispose') == 0)
                  {
                    ssize_t
                      dispose;

                    dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,
                      options);
                    if (dispose < 0)
                      break;
                    image->dispose=(DisposeType) dispose;
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'e':
              case 'E':
              {
                if (LocaleCompare(keyword,'endian') == 0)
                  {
                    ssize_t
                      endian;

                    endian=ParseCommandOption(MagickEndianOptions,MagickFalse,
                      options);
                    if (endian < 0)
                      break;
                    image->endian=(EndianType) endian;
                    break;
                  }
                if (LocaleCompare(keyword,'error') == 0)
                  {
                    image->error.mean_error_per_pixel=StringToDouble(options,
                      (char **) NULL);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'g':
              case 'G':
              {
                if (LocaleCompare(keyword,'gamma') == 0)
                  {
                    image->gamma=StringToDouble(options,(char **) NULL);
                    break;
                  }
                if (LocaleCompare(keyword,'green-primary') == 0)
                  {
                    flags=ParseGeometry(options,&geometry_info);
                    image->chromaticity.green_primary.x=geometry_info.rho;
                    image->chromaticity.green_primary.y=geometry_info.sigma;
                    if ((flags & SigmaValue) == 0)
                      image->chromaticity.green_primary.y=
                        image->chromaticity.green_primary.x;
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'i':
              case 'I':
              {
                if (LocaleCompare(keyword,'id') == 0)
                  {
                    (void) CopyMagickString(id,options,MagickPathExtent);
                    break;
                  }
                if (LocaleCompare(keyword,'iterations') == 0)
                  {
                    image->iterations=StringToUnsignedLong(options);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'm':
              case 'M':
              {
                if (LocaleCompare(keyword,'magick-signature') == 0)
                  {
                    signature=(unsigned int) StringToUnsignedLong(options);
                    break;
                  }
                if (LocaleCompare(keyword,'mattecolor') == 0)
                  {
                    (void) QueryColorCompliance(options,AllCompliance,
                      &image->matte_color,exception);
                    break;
                  }
                if (LocaleCompare(keyword,'maximum-error') == 0)
                  {
                    image->error.normalized_maximum_error=StringToDouble(
                      options,(char **) NULL);
                    break;
                  }
                if (LocaleCompare(keyword,'mean-error') == 0)
                  {
                    image->error.normalized_mean_error=StringToDouble(options,
                      (char **) NULL);
                    break;
                  }
                if (LocaleCompare(keyword,'montage') == 0)
                  {
                    (void) CloneString(&image->montage,options);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'n':
              case 'N':
              {
                if (LocaleCompare(keyword,'number-channels') == 0)
                  {
                    image->number_channels=StringToUnsignedLong(options);
                    break;
                  }
                if (LocaleCompare(keyword,'number-meta-channels') == 0)
                  {
                    image->number_meta_channels=StringToUnsignedLong(options);
                    break;
                  }
                break;
              }
              case 'o':
              case 'O':
              {
                if (LocaleCompare(keyword,'orientation') == 0)
                  {
                    ssize_t
                      orientation;

                    orientation=ParseCommandOption(MagickOrientationOptions,
                      MagickFalse,options);
                    if (orientation < 0)
                      break;
                    image->orientation=(OrientationType) orientation;
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'p':
              case 'P':
              {
                if (LocaleCompare(keyword,'page') == 0)
                  {
                    char
                      *geometry;

                    geometry=GetPageGeometry(options);
                    (void) ParseAbsoluteGeometry(geometry,&image->page);
                    geometry=DestroyString(geometry);
                    break;
                  }
                if (LocaleCompare(keyword,'pixel-intensity') == 0)
                  {
                    ssize_t
                      intensity;

                    intensity=ParseCommandOption(MagickPixelIntensityOptions,
                      MagickFalse,options);
                    if (intensity < 0)
                      break;
                    image->intensity=(PixelIntensityMethod) intensity;
                    break;
                  }
                if ((LocaleNCompare(keyword,'profile:',8) == 0) ||
                    (LocaleNCompare(keyword,'profile-',8) == 0))
                  {
                    if (profiles == (LinkedListInfo *) NULL)
                      profiles=NewLinkedList(0);
                    (void) AppendValueToLinkedList(profiles,
                      AcquireString(keyword+8));
                    profile=BlobToStringInfo((const void *) NULL,(size_t)
                      StringToLong(options));
                    if (profile == (StringInfo *) NULL)
                      ThrowReaderException(ResourceLimitError,
                        'MemoryAllocationFailed');
                    (void) SetImageProfile(image,keyword+8,profile,exception);
                    profile=DestroyStringInfo(profile);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'q':
              case 'Q':
              {
                if (LocaleCompare(keyword,'quality') == 0)
                  {
                    image->quality=StringToUnsignedLong(options);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'r':
              case 'R':
              {
                if (LocaleCompare(keyword,'red-primary') == 0)
                  {
                    flags=ParseGeometry(options,&geometry_info);
                    image->chromaticity.red_primary.x=geometry_info.rho;
                    if ((flags & SigmaValue) != 0)
                      image->chromaticity.red_primary.y=geometry_info.sigma;
                    break;
                  }
                if (LocaleCompare(keyword,'rendering-intent') == 0)
                  {
                    ssize_t
                      rendering_intent;

                    rendering_intent=ParseCommandOption(MagickIntentOptions,
                      MagickFalse,options);
                    if (rendering_intent < 0)
                      break;
                    image->rendering_intent=(RenderingIntent) rendering_intent;
                    break;
                  }
                if (LocaleCompare(keyword,'resolution') == 0)
                  {
                    flags=ParseGeometry(options,&geometry_info);
                    image->resolution.x=geometry_info.rho;
                    image->resolution.y=geometry_info.sigma;
                    if ((flags & SigmaValue) == 0)
                      image->resolution.y=image->resolution.x;
                    break;
                  }
                if (LocaleCompare(keyword,'rows') == 0)
                  {
                    image->rows=StringToUnsignedLong(options);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 's':
              case 'S':
              {
                if (LocaleCompare(keyword,'scene') == 0)
                  {
                    image->scene=StringToUnsignedLong(options);
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 't':
              case 'T':
              {
                if (LocaleCompare(keyword,'ticks-per-second') == 0)
                  {
                    image->ticks_per_second=(ssize_t) StringToLong(options);
                    break;
                  }
                if (LocaleCompare(keyword,'tile-offset') == 0)
                  {
                    char
                      *geometry;

                    geometry=GetPageGeometry(options);
                    (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);
                    geometry=DestroyString(geometry);
                  }
                if (LocaleCompare(keyword,'type') == 0)
                  {
                    ssize_t
                      type;

                    type=ParseCommandOption(MagickTypeOptions,MagickFalse,
                      options);
                    if (type < 0)
                      break;
                    image->type=(ImageType) type;
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'u':
              case 'U':
              {
                if (LocaleCompare(keyword,'units') == 0)
                  {
                    ssize_t
                      units;

                    units=ParseCommandOption(MagickResolutionOptions,
                      MagickFalse,options);
                    if (units < 0)
                      break;
                    image->units=(ResolutionType) units;
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              case 'w':
              case 'W':
              {
                if (LocaleCompare(keyword,'white-point') == 0)
                  {
                    flags=ParseGeometry(options,&geometry_info);
                    image->chromaticity.white_point.x=geometry_info.rho;
                    image->chromaticity.white_point.y=geometry_info.sigma;
                    if ((flags & SigmaValue) == 0)
                      image->chromaticity.white_point.y=
                        image->chromaticity.white_point.x;
                    break;
                  }
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
              default:
              {
                (void) SetImageProperty(image,keyword,options,exception);
                break;
              }
            }
          }
        else
          c=ReadBlobByte(image);
      while (isspace((int) ((unsigned char) c)) != 0)
        c=ReadBlobByte(image);
    }
    options=DestroyString(options);
    (void) ReadBlobByte(image);
    /*
      Verify that required image information is defined.
    */
    if ((LocaleCompare(id,'MagickCache') != 0) ||
        (image->storage_class == UndefinedClass) ||
        (image->compression == UndefinedCompression) || (image->columns == 0) ||
        (image->rows == 0))
      ThrowReaderException(CorruptImageError,'ImproperImageHeader');
    if (signature != GetMagickSignature((const StringInfo *) NULL))
      ThrowReaderException(CacheError,'IncompatibleAPI');
    if (image->montage != (char *) NULL)
      {
        register char
          *p;

        /*
          Image directory.
        */
        length=MagickPathExtent;
        image->directory=AcquireString((char *) NULL);
        p=image->directory;
        do
        {
          *p='\0';
          if ((strlen(image->directory)+MagickPathExtent) >= length)
            {
              /*
                Allocate more memory for the image directory.
              */
              length<<=1;
              image->directory=(char *) ResizeQuantumMemory(image->directory,
                length+MagickPathExtent,sizeof(*image->directory));
              if (image->directory == (char *) NULL)
                ThrowReaderException(CorruptImageError,'UnableToReadImageData');
              p=image->directory+strlen(image->directory);
            }
          c=ReadBlobByte(image);
          *p++=(char) c;
        } while (c != (int) '\0');
      }
    if (profiles != (LinkedListInfo *) NULL)
      {
        const char
          *name;

        const StringInfo
          *profile;

        register unsigned char
          *p;

        /*
          Read image profiles.
        */
        ResetLinkedListIterator(profiles);
        name=(const char *) GetNextValueInLinkedList(profiles);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          if (profile != (StringInfo *) NULL)
            {
              p=GetStringInfoDatum(profile);
              count=ReadBlob(image,GetStringInfoLength(profile),p);
            }
          name=(const char *) GetNextValueInLinkedList(profiles);
        }
        profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);
      }
    depth=GetImageQuantumDepth(image,MagickFalse);
    if (image->storage_class == PseudoClass)
      {
        /*
          Create image colormap.
        */
        image->colormap=(PixelInfo *) AcquireQuantumMemory(image->colors+1,
          sizeof(*image->colormap));
        if (image->colormap == (PixelInfo *) NULL)
          ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
        if (image->colors != 0)
          {
            size_t
              packet_size;

            unsigned char
              *colormap;

            /*
              Read image colormap from file.
            */
            packet_size=(size_t) (3UL*depth/8UL);
            colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
              packet_size*sizeof(*colormap));
            if (colormap == (unsigned char *) NULL)
              ThrowReaderException(ResourceLimitError,'MemoryAllocationFailed');
            count=ReadBlob(image,packet_size*image->colors,colormap);
            if (count != (ssize_t) (packet_size*image->colors))
              {
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
                ThrowReaderException(CorruptImageError,
                  'InsufficientImageDataInFile');
              }
            p=colormap;
            switch (depth)
            {
              default:
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
                ThrowReaderException(CorruptImageError,
                  'ImageDepthNotSupported');
              case 8:
              {
                unsigned char
                  pixel;

                for (i=0; i < (ssize_t) image->colors; i++)
                {
                  p=PushCharPixel(p,&pixel);
                  image->colormap[i].red=ScaleCharToQuantum(pixel);
                  p=PushCharPixel(p,&pixel);
                  image->colormap[i].green=ScaleCharToQuantum(pixel);
                  p=PushCharPixel(p,&pixel);
                  image->colormap[i].blue=ScaleCharToQuantum(pixel);
                }
                break;
              }
              case 16:
              {
                unsigned short
                  pixel;

                for (i=0; i < (ssize_t) image->colors; i++)
                {
                  p=PushShortPixel(MSBEndian,p,&pixel);
                  image->colormap[i].red=ScaleShortToQuantum(pixel);
                  p=PushShortPixel(MSBEndian,p,&pixel);
                  image->colormap[i].green=ScaleShortToQuantum(pixel);
                  p=PushShortPixel(MSBEndian,p,&pixel);
                  image->colormap[i].blue=ScaleShortToQuantum(pixel);
                }
                break;
              }
              case 32:
              {
                unsigned int
                  pixel;

                for (i=0; i < (ssize_t) image->colors; i++)
                {
                  p=PushLongPixel(MSBEndian,p,&pixel);
                  image->colormap[i].red=ScaleLongToQuantum(pixel);
                  p=PushLongPixel(MSBEndian,p,&pixel);
                  image->colormap[i].green=ScaleLongToQuantum(pixel);
                  p=PushLongPixel(MSBEndian,p,&pixel);
                  image->colormap[i].blue=ScaleLongToQuantum(pixel);
                }
                break;
              }
            }
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
          }
      }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,'UnexpectedEndOfFile',
          image->filename);
        break;
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||
        (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))
      ThrowReaderException(ImageError,'WidthOrHeightExceedsLimit');
    /*
      Attach persistent pixel cache.
    */
    status=PersistPixelCache(image,cache_filename,MagickTrue,&offset,exception);
    if (status == MagickFalse)
      ThrowReaderException(CacheError,'UnableToPersistPixelCache');
    /*
      Proceed to next image.
    */
    do
    {
      c=ReadBlobByte(image);
    } while ((isgraph(c) == MagickFalse) && (c != EOF));
    if (c != EOF)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (c != EOF);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",1,8169
ImageMagick/ImageMagick,7fd419441bc7103398e313558171d342c6315f44,"static MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)
{
  if (length < 14)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick,'id=MagickCache',14) == 0)
    return(MagickTrue);
  return(MagickFalse);
}
",0,8170
mruby/mruby,5c114c91d4ff31859fcd84cf8bf349b737b90d99,"static void
mark_context_stack(mrb_state *mrb, struct mrb_context *c)
{
  size_t i;
  size_t e;

  if (c->stack == NULL) return;
  e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
    mrb_value v = c->stbase[i];

    if (!mrb_immediate_p(v)) {
      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
        c->stbase[i] = mrb_nil_value();
      }
      else {
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
    }
  }
}
",1,8171
mruby/mruby,5c114c91d4ff31859fcd84cf8bf349b737b90d99,"static mrb_value
gc_interval_ratio_get(mrb_state *mrb, mrb_value obj)
{
  return mrb_fixnum_value(mrb->gc.interval_ratio);
}
",0,8172
torvalds/linux,07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,"int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
				struct drm_file *file_priv)
{
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct vmw_user_surface *user_srf;
	struct vmw_surface *srf;
	struct vmw_resource *res;
	struct vmw_resource *tmp;
	union drm_vmw_gb_surface_create_arg *arg =
	    (union drm_vmw_gb_surface_create_arg *)data;
	struct drm_vmw_gb_surface_create_req *req = &arg->req;
	struct drm_vmw_gb_surface_create_rep *rep = &arg->rep;
	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
	int ret;
	uint32_t size;
	uint32_t backup_handle;

	if (req->multisample_count != 0)
		return -EINVAL;

	if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)
		return -EINVAL;

	if (unlikely(vmw_user_surface_size == 0))
		vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +
			128;

	size = vmw_user_surface_size + 128;

	/* Define a surface based on the parameters. */
	ret = vmw_surface_gb_priv_define(dev,
			size,
			req->svga3d_flags,
			req->format,
			req->drm_surface_flags & drm_vmw_surface_flag_scanout,
			req->mip_levels,
			req->multisample_count,
			req->array_size,
			req->base_size,
			&srf);
	if (unlikely(ret != 0))
		return ret;

	user_srf = container_of(srf, struct vmw_user_surface, srf);
	if (drm_is_primary_client(file_priv))
		user_srf->master = drm_master_get(file_priv->master);

	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
	if (unlikely(ret != 0))
		return ret;

	res = &user_srf->srf.res;


	if (req->buffer_handle != SVGA3D_INVALID_ID) {
		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
					     &res->backup,
					     &user_srf->backup_base);
		if (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <
		    res->backup_size) {
			DRM_ERROR('Surface backup buffer is too small.\n');
			vmw_dmabuf_unreference(&res->backup);
			ret = -EINVAL;
			goto out_unlock;
		}
	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
					    res->backup_size,
					    req->drm_surface_flags &
					    drm_vmw_surface_flag_shareable,
					    &backup_handle,
					    &res->backup,
					    &user_srf->backup_base);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	tmp = vmw_resource_reference(res);
	ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,
				    req->drm_surface_flags &
				    drm_vmw_surface_flag_shareable,
				    VMW_RES_SURFACE,
				    &vmw_user_surface_base_release, NULL);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&tmp);
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	rep->handle      = user_srf->prime.base.hash.key;
	rep->backup_size = res->backup_size;
	if (res->backup) {
		rep->buffer_map_handle =
			drm_vma_node_offset_addr(&res->backup->base.vma_node);
		rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;
		rep->buffer_handle = backup_handle;
	} else {
		rep->buffer_map_handle = 0;
		rep->buffer_size = 0;
		rep->buffer_handle = SVGA3D_INVALID_ID;
	}

	vmw_resource_unreference(&res);

out_unlock:
	ttm_read_unlock(&dev_priv->reservation_sem);
	return ret;
}
",1,8173
torvalds/linux,07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,"static inline uint32_t vmw_surface_dma_size(const struct vmw_surface *srf)
{
	return srf->num_sizes * sizeof(struct vmw_surface_dma);
}
",0,8174
curl/curl,ba1dbd78e5f1ed67c1b8d37ac89d90e5e330b628,"CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)
{
  /* When sending a SMTP payload we must detect CRLF. sequences making sure
     they are sent as CRLF.. instead, as a . on the beginning of a line will
     be deleted by the server when not part of an EOB terminator and a
     genuine CRLF.CRLF which isn't escaped will wrongly be detected as end of
     data by the server
  */
  ssize_t i;
  ssize_t si;
  struct Curl_easy *data = conn->data;
  struct SMTP *smtp = data->req.protop;
  char *scratch = data->state.scratch;
  char *newscratch = NULL;
  char *oldscratch = NULL;
  size_t eob_sent;

  /* Do we need to allocate a scratch buffer? */
  if(!scratch || data->set.crlf) {
    oldscratch = scratch;

    scratch = newscratch = malloc(2 * data->set.buffer_size);
    if(!newscratch) {
      failf(data, 'Failed to alloc scratch buffer!');

      return CURLE_OUT_OF_MEMORY;
    }
  }

  /* Have we already sent part of the EOB? */
  eob_sent = smtp->eob;

  /* This loop can be improved by some kind of Boyer-Moore style of
     approach but that is saved for later... */
  for(i = 0, si = 0; i < nread; i++) {
    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {
      smtp->eob++;

      /* Is the EOB potentially the terminating CRLF? */
      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)
        smtp->trailing_crlf = TRUE;
      else
        smtp->trailing_crlf = FALSE;
    }
    else if(smtp->eob) {
      /* A previous substring matched so output that first */
      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);
      si += smtp->eob - eob_sent;

      /* Then compare the first byte */
      if(SMTP_EOB[0] == data->req.upload_fromhere[i])
        smtp->eob = 1;
      else
        smtp->eob = 0;

      eob_sent = 0;

      /* Reset the trailing CRLF flag as there was more data */
      smtp->trailing_crlf = FALSE;
    }

    /* Do we have a match for CRLF. as per RFC-5321, sect. 4.5.2 */
    if(SMTP_EOB_FIND_LEN == smtp->eob) {
      /* Copy the replacement data to the target buffer */
      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],
             SMTP_EOB_REPL_LEN - eob_sent);
      si += SMTP_EOB_REPL_LEN - eob_sent;
      smtp->eob = 0;
      eob_sent = 0;
    }
    else if(!smtp->eob)
      scratch[si++] = data->req.upload_fromhere[i];
  }

  if(smtp->eob - eob_sent) {
    /* A substring matched before processing ended so output that now */
    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);
    si += smtp->eob - eob_sent;
  }

  /* Only use the new buffer if we replaced something */
  if(si != nread) {
    /* Upload from the new (replaced) buffer instead */
    data->req.upload_fromhere = scratch;

    /* Save the buffer so it can be freed later */
    data->state.scratch = scratch;

    /* Free the old scratch buffer */
    free(oldscratch);

    /* Set the new amount too */
    data->req.upload_present = si;
  }
  else
    free(newscratch);

  return CURLE_OK;
}
",1,8175
curl/curl,ba1dbd78e5f1ed67c1b8d37ac89d90e5e330b628,"static CURLcode smtp_perform_command(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  struct Curl_easy *data = conn->data;
  struct SMTP *smtp = data->req.protop;

  /* Send the command */
  if(smtp->rcpt)
    result = Curl_pp_sendf(&conn->proto.smtpc.pp, '%s %s',
                           smtp->custom && smtp->custom[0] != '\0' ?
                           smtp->custom : 'VRFY',
                           smtp->rcpt->data);
  else
    result = Curl_pp_sendf(&conn->proto.smtpc.pp, '%s',
                           smtp->custom && smtp->custom[0] != '\0' ?
                           smtp->custom : 'HELP');

  if(!result)
    state(conn, SMTP_COMMAND);

  return result;
}
",0,8176
contiki-ng/contiki-ng,196accb9b79d39029a9ee07d1191eedf9d588127,"db_result_t
aql_add_attribute(aql_adt_t *adt, char *name, domain_t domain,
                   unsigned element_size, int processed_only)
{
  aql_attribute_t *attr;

  if(adt->attribute_count == AQL_ATTRIBUTE_LIMIT) {
    return DB_LIMIT_ERROR;
  }

  if(processed_only && get_attribute(adt, name)) {
    /* No need to have multiple instances of attributes that are only 
       used for processing in the PLE. */
    return DB_OK;
  }

  attr = &adt->attributes[adt->attribute_count++];

  if(strlen(name) + 1 > sizeof(attr->name)) {
    return DB_LIMIT_ERROR;
  }

  strcpy(attr->name, name);
  attr->domain = domain;
  attr->element_size = element_size;
  attr->flags = processed_only ? ATTRIBUTE_FLAG_NO_STORE : 0;

  return DB_OK;
}
",1,8177
contiki-ng/contiki-ng,196accb9b79d39029a9ee07d1191eedf9d588127,"static unsigned char *
save_char(unsigned char *ptr, size_t length)
{
  unsigned char *start_ptr;

  if(length + next_free_offset > DB_MAX_CHAR_SIZE_PER_ROW) {
    return NULL;
  }

  start_ptr = char_buf + next_free_offset;
  memcpy(start_ptr, ptr, length);
  next_free_offset += length;

  return start_ptr;
}
",0,8178
contiki-ng/contiki-ng,a73822176ad0a8ce321d0f6460a07721cf6a8d83,"static int
next_string(lexer_t *lexer, const char *s)
{
  char *end;
  size_t length;

  end = strchr(s, '\'');
  if(end == NULL) {
    return -1;
  }

  length = end - s;
  *lexer->token = STRING_VALUE;
  lexer->input = end + 1; /* Skip the closing delimiter. */

  memcpy(lexer->value, s, length);
  (*lexer->value)[length] = '\0';

  return 1;
}
",1,8179
contiki-ng/contiki-ng,a73822176ad0a8ce321d0f6460a07721cf6a8d83,"static int
next_token(lexer_t *lexer, const char *s)
{
  size_t length;

  length = strcspn(s, separators);
  if(length == 0) {
    /* We encountered a separator, so we try to get a token of 
       precisely 1 byte. */
    length = 1;
  }

  *lexer->token = get_token_id(s, length);
  lexer->input = s + length;
  if(*lexer->token != NONE) {
    return 1;
  }

  /* The input did not constitute a valid token,
     so we regard it as an identifier. */

  *lexer->token = IDENTIFIER;

  memcpy(lexer->value, s, length);
  (*lexer->value)[length] = '\0';

  return 1;
}
",1,8180
contiki-ng/contiki-ng,a73822176ad0a8ce321d0f6460a07721cf6a8d83,"  {'IS', IS},
  {'ON', ON},
  {'IN', IN},
",0,8181
contiki-ng/contiki-ng,a73822176ad0a8ce321d0f6460a07721cf6a8d83,"  {';', END},
  {'(', LEFT_PAREN},
",0,8182
libarchive/libarchive,9c84b7426660c09c18cc349f6d70b5f8168b5680,"static int
_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)
{
	struct warc_s *w = a->format->data;
	const char *rab;
	ssize_t nrd;

	if (w->cntoff >= w->cntlen) {
	eof:
		/* it's our lucky day, no work, we can leave early */
		*buf = NULL;
		*bsz = 0U;
		*off = w->cntoff + 4U/*for \r\n\r\n separator*/;
		w->unconsumed = 0U;
		return (ARCHIVE_EOF);
	}

	rab = __archive_read_ahead(a, 1U, &nrd);
	if (nrd < 0) {
		*bsz = 0U;
		/* big catastrophe */
		return (int)nrd;
	} else if (nrd == 0) {
		goto eof;
	} else if ((size_t)nrd > w->cntlen - w->cntoff) {
		/* clamp to content-length */
		nrd = w->cntlen - w->cntoff;
	}
	*off = w->cntoff;
	*bsz = nrd;
	*buf = rab;

	w->cntoff += nrd;
	w->unconsumed = (size_t)nrd;
	return (ARCHIVE_OK);
}
",1,8183
libarchive/libarchive,9c84b7426660c09c18cc349f6d70b5f8168b5680,"static ssize_t
_warc_rdlen(const char *buf, size_t bsz)
{
	static const char _key[] = '\r\nContent-Length:';
	const char *val, *eol;
	char *on = NULL;
	long int len;

	if ((val = xmemmem(buf, bsz, _key, sizeof(_key) - 1U)) == NULL) {
		/* no bother */
		return -1;
	}
	val += sizeof(_key) - 1U;
	if ((eol = _warc_find_eol(val, buf + bsz - val)) == NULL) {
		/* no end of line */
		return -1;
	}

	/* skip leading whitespace */
	while (val < eol && (*val == ' ' || *val == '\t'))
		val++;
	/* there must be at least one digit */
	if (!isdigit((unsigned char)*val))
		return -1;
	len = strtol(val, &on, 10);
	if (on != eol) {
		/* line must end here */
		return -1;
	}

	return (size_t)len;
}
",0,8184
radare/radare2,1f37c04f2a762500222dda2459e6a04646feeedf,"static void process_constructors (RBinFile *bf, RList *ret, int bits) {
	RList *secs = sections (bf);
	RListIter *iter;
	RBinSection *sec;
	int i, type;
	r_list_foreach (secs, iter, sec) {
		type = -1;
		if (!strcmp (sec->name, '.fini_array')) {
			type = R_BIN_ENTRY_TYPE_FINI;
		} else if (!strcmp (sec->name, '.init_array')) {
			type = R_BIN_ENTRY_TYPE_INIT;
		} else if (!strcmp (sec->name, '.preinit_array')) {
			type = R_BIN_ENTRY_TYPE_PREINIT;
		}
		if (type != -1) {
			ut8 *buf = calloc (sec->size, 1);
			if (!buf) {
				continue;
			}
			(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);
			if (bits == 32) {
				for (i = 0; i < sec->size; i += 4) {
					ut32 addr32 = r_read_le32 (buf + i);
					if (addr32) {
						RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);
						r_list_append (ret, ba);
					}
				}
			} else {
				for (i = 0; i < sec->size; i += 8) {
					ut64 addr64 = r_read_le64 (buf + i);
					if (addr64) {
						RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);
						r_list_append (ret, ba);
					}
				}
			}
			free (buf);
		}
	}
	r_list_free (secs);
}
",1,8185
radare/radare2,1f37c04f2a762500222dda2459e6a04646feeedf,"static char *build_hash_string(int mode, const char *chksum, ut8 *data, ut32 datalen) {
	char *chkstr = NULL, *aux, *ret = NULL;
	const char *ptr = chksum;
	char tmp[128];
	int i;
	do {
		for (i = 0; *ptr && *ptr != ',' && i < sizeof (tmp) -1; i++) {
			tmp[i] = *ptr++;
		}
		tmp[i] = '\0';
		r_str_trim_head_tail (tmp);
		chkstr = r_hash_to_string (NULL, tmp, data, datalen);
		if (!chkstr) {
			if (*ptr && *ptr == ',') {
				ptr++;
			}
			continue;
		}
		if (IS_MODE_SIMPLE (mode)) {
			aux = r_str_newf ('%s ', chkstr);
		} else if (IS_MODE_JSON (mode)) {
			aux = r_str_newf ('\'%s\':\'%s\',', tmp, chkstr);
		} else {
			aux = r_str_newf ('%s=%s ', tmp, chkstr);
		}
		ret = r_str_append (ret, aux);
		free (chkstr);
		free (aux);
		if (*ptr && *ptr == ',') ptr++;
	} while (*ptr);

	return ret;
}
",0,8186
torvalds/linux,f7068114d45ec55996b9040e98111afa56e010fe,"   clear after one error */

int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)
{
	struct scsi_device *SDev;
	struct scsi_sense_hdr sshdr;
	int result, err = 0, retries = 0;

",1,8187
torvalds/linux,f7068114d45ec55996b9040e98111afa56e010fe,"		goto out;
	}

	result = scsi_execute(SDev, cgc->cmd, cgc->data_direction,
			      cgc->buffer, cgc->buflen,
			      (unsigned char *)cgc->sense, &sshdr,
			      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);

",1,8188
torvalds/linux,f7068114d45ec55996b9040e98111afa56e010fe,"int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)
{
	struct scsi_device *SDev;
	struct scsi_sense_hdr sshdr;
	int result, err = 0, retries = 0;

	SDev = cd->device;

      retry:
	if (!scsi_block_when_processing_errors(SDev)) {
		err = -ENODEV;
		goto out;
	}

	result = scsi_execute(SDev, cgc->cmd, cgc->data_direction,
			      cgc->buffer, cgc->buflen,
			      (unsigned char *)cgc->sense, &sshdr,
			      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);

	/* Minimal error checking.  Ignore cases we know about, and report the rest. */
	if (driver_byte(result) != 0) {
		switch (sshdr.sense_key) {
		case UNIT_ATTENTION:
			SDev->changed = 1;
			if (!cgc->quiet)
				sr_printk(KERN_INFO, cd,
					  'disc change detected.\n');
			if (retries++ < 10)
				goto retry;
			err = -ENOMEDIUM;
			break;
		case NOT_READY:	/* This happens if there is no disc in drive */
			if (sshdr.asc == 0x04 &&
			    sshdr.ascq == 0x01) {
				/* sense: Logical unit is in process of becoming ready */
				if (!cgc->quiet)
					sr_printk(KERN_INFO, cd,
						  'CDROM not ready yet.\n');
				if (retries++ < 10) {
					/* sleep 2 sec and try again */
					ssleep(2);
					goto retry;
				} else {
					/* 20 secs are enough? */
					err = -ENOMEDIUM;
					break;
				}
			}
			if (!cgc->quiet)
				sr_printk(KERN_INFO, cd,
					  'CDROM not ready.  Make sure there '
					  'is a disc in the drive.\n');
			err = -ENOMEDIUM;
			break;
		case ILLEGAL_REQUEST:
			err = -EIO;
			if (sshdr.asc == 0x20 &&
			    sshdr.ascq == 0x00)
				/* sense: Invalid command operation code */
				err = -EDRIVE_CANT_DO_THIS;
			break;
		default:
			err = -EIO;
		}
	}

	/* Wake up a process waiting for device */
      out:
	cgc->stat = err;
	return err;
}
",1,8189
torvalds/linux,f7068114d45ec55996b9040e98111afa56e010fe,"static int sr_read_cd(Scsi_CD *cd, unsigned char *dest, int lba, int format, int blksize)
{
	struct packet_command cgc;

#ifdef DEBUG
	sr_printk(KERN_INFO, cd, 'sr_read_cd lba=%d format=%d blksize=%d\n',
		  lba, format, blksize);
#endif

	memset(&cgc, 0, sizeof(struct packet_command));
	cgc.cmd[0] = GPCMD_READ_CD;	/* READ_CD */
	cgc.cmd[1] = ((format & 7) << 2);
	cgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;
	cgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;
	cgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;
	cgc.cmd[5] = (unsigned char) lba & 0xff;
	cgc.cmd[8] = 1;
	switch (blksize) {
	case 2336:
		cgc.cmd[9] = 0x58;
		break;
	case 2340:
		cgc.cmd[9] = 0x78;
		break;
	case 2352:
		cgc.cmd[9] = 0xf8;
		break;
	default:
		cgc.cmd[9] = 0x10;
		break;
	}
	cgc.buffer = dest;
	cgc.buflen = blksize;
	cgc.data_direction = DMA_FROM_DEVICE;
	cgc.timeout = IOCTL_TIMEOUT;
	return sr_do_ioctl(cd, &cgc);
}
",0,8190
torvalds/linux,f7068114d45ec55996b9040e98111afa56e010fe,"#include <linux/module.h>
#include <linux/blkpg.h>
#include <linux/cdrom.h>
#include <linux/delay.h>
#include <linux/slab.h>
",0,8191
torvalds/linux,f7068114d45ec55996b9040e98111afa56e010fe,"	tochdr->cdth_trk1 = buffer[3];

	kfree(buffer);
	return result;
",0,8192
mruby/mruby,778500563a9f7ceba996937dc886bd8cde29b42b,"static mrb_value
fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)
{
  struct mrb_context *c = fiber_check(mrb, self);
  struct mrb_context *old_c = mrb->c;
  mrb_value value;

  fiber_check_cfunc(mrb, c);
  if (resume && c->status == MRB_FIBER_TRANSFERRED) {
    mrb_raise(mrb, E_FIBER_ERROR, 'resuming transferred fiber');
  }
  if (c->status == MRB_FIBER_RUNNING || c->status == MRB_FIBER_RESUMED) {
    mrb_raise(mrb, E_FIBER_ERROR, 'double resume (fib)');
  }
  if (c->status == MRB_FIBER_TERMINATED) {
    mrb_raise(mrb, E_FIBER_ERROR, 'resuming dead fiber');
  }
  mrb->c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;
  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);
  if (c->status == MRB_FIBER_CREATED) {
    mrb_value *b, *e;

    if (len >= c->stend - c->stack) {
      mrb_raise(mrb, E_FIBER_ERROR, 'too many arguments to fiber');
    }
    b = c->stack+1;
    e = b + len;
    while (b<e) {
      *b++ = *a++;
    }
    c->cibase->argc = (int)len;
    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];
  }
  else {
    value = fiber_result(mrb, a, len);
  }
  fiber_switch_context(mrb, c);

  if (vmexec) {
    c->vmexec = TRUE;
    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);
    mrb->c = old_c;
  }
  else {
    MARK_CONTEXT_MODIFY(c);
  }
  return value;
}
",1,8193
mruby/mruby,778500563a9f7ceba996937dc886bd8cde29b42b,"static struct mrb_context*
fiber_check(mrb_state *mrb, mrb_value fib)
{
  struct RFiber *f = fiber_ptr(fib);

  mrb_assert(f->tt == MRB_TT_FIBER);
  if (!f->cxt) {
    mrb_raise(mrb, E_FIBER_ERROR, 'uninitialized Fiber');
  }
  return f->cxt;
}
",0,8194
radareorg/radare2,d37d2b858ac47f2f108034be0bcecadaddfbc8b3,"static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,
		RBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da,
		size_t offset, const ut8 *debug_str, size_t debug_str_len) {
	const ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7);
	ut64 abbr_code;
	size_t i;
	
	if (cu->hdr.length > debug_str_len) {
		//avoid oob read
		return NULL;
	}
	while (buf && buf < buf_end && buf >= obuf) {
		if (cu->length && cu->capacity == cu->length) {
			r_bin_dwarf_expand_cu (cu);
		}
		buf = r_uleb128 (buf, buf_end - buf, &abbr_code);
		if (abbr_code > da->length || !buf) {
			return NULL;
		}

		r_bin_dwarf_init_die (&cu->dies[cu->length]);
		if (!abbr_code) {
			cu->dies[cu->length].abbrev_code = 0;
			cu->length++;
			buf++;
			continue;
		}

		cu->dies[cu->length].abbrev_code = abbr_code;
		cu->dies[cu->length].tag = da->decls[abbr_code - 1].tag;
		abbr_code += offset;

		if (da->capacity < abbr_code) {
			return NULL;
		}

		for (i = 0; i < da->decls[abbr_code - 1].length; i++) {
			if (cu->dies[cu->length].length == cu->dies[cu->length].capacity) {
				r_bin_dwarf_expand_die (&cu->dies[cu->length]);
			}
			if (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) {
				eprintf ('Warning: malformed dwarf attribute capacity doesn't match length\n');
				break;
			}
			memset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));
			buf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,
					&da->decls[abbr_code - 1].specs[i],
					&cu->dies[cu->length].attr_values[i],
					&cu->hdr, debug_str, debug_str_len);
			if (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {
				const char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string;
				sdb_set (s, 'DW_AT_comp_dir', name, 0);
			}
			cu->dies[cu->length].length++;
		}
		cu->length++;
	}
	return buf;
}
",1,8195
radareorg/radare2,d37d2b858ac47f2f108034be0bcecadaddfbc8b3,"R_API int r_bin_dwarf_parse_aranges_raw(const ut8 *obuf, int len, FILE *f) {
	ut32 length, offset;
	ut16 version;
	ut32 debug_info_offset;
	ut8 address_size, segment_size;
	const ut8 *buf = obuf;
	int idx = 0;

	if (!buf || len< 4) {
		return false;
	}

	READ_BUF (length, ut32);
	if (f) {
		printf('parse_aranges\n');
		printf('length 0x%x\n', length);
	}

	if (idx+12>=len)
		return false;

	READ_BUF (version, ut16);
	if (f) {
		printf('Version %d\n', version);
	}

	READ_BUF (debug_info_offset, ut32);
	if (f) {
		fprintf (f, 'Debug info offset %d\n', debug_info_offset);
	}

	READ_BUF (address_size, ut8);
	if (f) {
		fprintf (f, 'address size %d\n', (int)address_size);
	}

	READ_BUF (segment_size, ut8);
	if (f) {
		fprintf (f, 'segment size %d\n', (int)segment_size);
	}

	offset = segment_size + address_size * 2;

	if (offset) {
		ut64 n = (((ut64) (size_t)buf / offset) + 1) * offset - ((ut64)(size_t)buf);
		if (idx+n>=len) {
			return false;
		}
		buf += n;
		idx += n;
	}

	while ((buf - obuf) < len) {
		ut64 adr, length;
		if ((idx+8)>=len) {
			break;
		}
		READ_BUF (adr, ut64);
		READ_BUF (length, ut64);
		if (f) printf('length 0x%'PFMT64x' address 0x%'PFMT64x'\n', length, adr);
	}

	return 0;
}
",0,8196
the-tcpdump-group/tcpdump,aa3e54f594385ce7e1e319b0c84999e51192578b,"u_int
mfr_print(netdissect_options *ndo,
          register const u_char *p, u_int length)
{
    u_int tlen,idx,hdr_len = 0;
    uint16_t sequence_num;
    uint8_t ie_type,ie_len;
    const uint8_t *tptr;


/*
 * FRF.16 Link Integrity Control Frame
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C=1| 0    0    0    0  | EA |
 *    +----+----+----+----+----+----+----+----+
 *    | 0    0    0    0    0    0    0    0  |
 *    +----+----+----+----+----+----+----+----+
 *    |              message type             |
 *    +----+----+----+----+----+----+----+----+
 */

    ND_TCHECK2(*p, 4); /* minimum frame header length */

    if ((p[0] & MFR_BEC_MASK) == MFR_CTRL_FRAME && p[1] == 0) {
        ND_PRINT((ndo, 'FRF.16 Control, Flags [%s], %s, length %u',
               bittok2str(frf_flag_values,'none',(p[0] & MFR_BEC_MASK)),
               tok2str(mfr_ctrl_msg_values,'Unknown Message (0x%02x)',p[2]),
               length));
        tptr = p + 3;
        tlen = length -3;
        hdr_len = 3;

        if (!ndo->ndo_vflag)
            return hdr_len;

        while (tlen>sizeof(struct ie_tlv_header_t)) {
            ND_TCHECK2(*tptr, sizeof(struct ie_tlv_header_t));
            ie_type=tptr[0];
            ie_len=tptr[1];

            ND_PRINT((ndo, '\n\tIE %s (%u), length %u: ',
                   tok2str(mfr_ctrl_ie_values,'Unknown',ie_type),
                   ie_type,
                   ie_len));

            /* infinite loop check */
            if (ie_type == 0 || ie_len <= sizeof(struct ie_tlv_header_t))
                return hdr_len;

            ND_TCHECK2(*tptr, ie_len);
            tptr+=sizeof(struct ie_tlv_header_t);
            /* tlv len includes header */
            ie_len-=sizeof(struct ie_tlv_header_t);
            tlen-=sizeof(struct ie_tlv_header_t);

            switch (ie_type) {

            case MFR_CTRL_IE_MAGIC_NUM:
                ND_PRINT((ndo, '0x%08x', EXTRACT_32BITS(tptr)));
                break;

            case MFR_CTRL_IE_BUNDLE_ID: /* same message format */
            case MFR_CTRL_IE_LINK_ID:
                for (idx = 0; idx < ie_len && idx < MFR_ID_STRING_MAXLEN; idx++) {
                    if (*(tptr+idx) != 0) /* don't print null termination */
                        safeputchar(ndo, *(tptr + idx));
                    else
                        break;
                }
                break;

            case MFR_CTRL_IE_TIMESTAMP:
                if (ie_len == sizeof(struct timeval)) {
                    ts_print(ndo, (const struct timeval *)tptr);
                    break;
                }
                /* fall through and hexdump if no unix timestamp */

                /*
                 * FIXME those are the defined IEs that lack a decoder
                 * you are welcome to contribute code ;-)
                 */

            case MFR_CTRL_IE_VENDOR_EXT:
            case MFR_CTRL_IE_CAUSE:

            default:
                if (ndo->ndo_vflag <= 1)
                    print_unknown_data(ndo, tptr, '\n\t  ', ie_len);
                break;
            }

            /* do we want to see a hexdump of the IE ? */
            if (ndo->ndo_vflag > 1 )
                print_unknown_data(ndo, tptr, '\n\t  ', ie_len);

            tlen-=ie_len;
            tptr+=ie_len;
        }
        return hdr_len;
    }
/*
 * FRF.16 Fragmentation Frame
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C=0|seq. (high 4 bits) | EA  |
 *    +----+----+----+----+----+----+----+----+
 *    |        sequence  (low 8 bits)         |
 *    +----+----+----+----+----+----+----+----+
 *    |        DLCI (6 bits)        | CR | EA  |
 *    +----+----+----+----+----+----+----+----+
 *    |   DLCI (4 bits)   |FECN|BECN| DE | EA |
 *    +----+----+----+----+----+----+----+----+
 */

    sequence_num = (p[0]&0x1e)<<7 | p[1];
    /* whole packet or first fragment ? */
    if ((p[0] & MFR_BEC_MASK) == MFR_FRAG_FRAME ||
        (p[0] & MFR_BEC_MASK) == MFR_B_BIT) {
        ND_PRINT((ndo, 'FRF.16 Frag, seq %u, Flags [%s], ',
               sequence_num,
               bittok2str(frf_flag_values,'none',(p[0] & MFR_BEC_MASK))));
        hdr_len = 2;
        fr_print(ndo, p+hdr_len,length-hdr_len);
        return hdr_len;
    }

    /* must be a middle or the last fragment */
    ND_PRINT((ndo, 'FRF.16 Frag, seq %u, Flags [%s]',
           sequence_num,
           bittok2str(frf_flag_values,'none',(p[0] & MFR_BEC_MASK))));
    print_unknown_data(ndo, p, '\n\t', length);

    return hdr_len;

 trunc:
    ND_PRINT((ndo, '[|mfr]'));
    return length;
}
",1,8197
the-tcpdump-group/tcpdump,aa3e54f594385ce7e1e319b0c84999e51192578b,"void
q933_print(netdissect_options *ndo,
           const u_char *p, u_int length)
{
	u_int olen;
	u_int call_ref_length, i;
	uint8_t call_ref[15];	/* maximum length - length field is 4 bits */
	u_int msgtype;
	u_int iecode;
	u_int ielength;
	u_int codeset = 0;
	u_int is_ansi = 0;
	u_int ie_is_known;
	u_int non_locking_shift;
	u_int unshift_codeset;

	ND_PRINT((ndo, '%s', ndo->ndo_eflag ? '' : 'Q.933'));

	if (length == 0 || !ND_TTEST(*p)) {
		if (!ndo->ndo_eflag)
			ND_PRINT((ndo, ', '));
		ND_PRINT((ndo, 'length %u', length));
		goto trunc;
	}

	/*
	 * Get the length of the call reference value.
	 */
	olen = length; /* preserve the original length for display */
	call_ref_length = (*p) & 0x0f;
	p++;
	length--;

	/*
	 * Get the call reference value.
	 */
	for (i = 0; i < call_ref_length; i++) {
		if (length == 0 || !ND_TTEST(*p)) {
			if (!ndo->ndo_eflag)
				ND_PRINT((ndo, ', '));
			ND_PRINT((ndo, 'length %u', olen));
			goto trunc;
		}
		call_ref[i] = *p;
		p++;
		length--;
	}

	/*
	 * Get the message type.
	 */
	if (length == 0 || !ND_TTEST(*p)) {
		if (!ndo->ndo_eflag)
			ND_PRINT((ndo, ', '));
		ND_PRINT((ndo, 'length %u', olen));
		goto trunc;
	}
	msgtype = *p;
	p++;
	length--;

	/*
	 * Peek ahead to see if we start with a shift.
	 */
	non_locking_shift = 0;
	unshift_codeset = codeset;
	if (length != 0) {
		if (!ND_TTEST(*p)) {
			if (!ndo->ndo_eflag)
				ND_PRINT((ndo, ', '));
			ND_PRINT((ndo, 'length %u', olen));
			goto trunc;
		}
		iecode = *p;
		if (IE_IS_SHIFT(iecode)) {
			/*
			 * It's a shift.  Skip over it.
			 */
			p++;
			length--;

			/*
			 * Get the codeset.
			 */
			codeset = IE_SHIFT_CODESET(iecode);

			/*
			 * If it's a locking shift to codeset 5,
			 * mark this as ANSI.  (XXX - 5 is actually
			 * for national variants in general, not
			 * the US variant in particular, but maybe
			 * this is more American exceptionalism. :-))
			 */
			if (IE_SHIFT_IS_LOCKING(iecode)) {
				/*
				 * It's a locking shift.
				 */
				if (codeset == 5) {
					/*
					 * It's a locking shift to
					 * codeset 5, so this is
					 * T1.617 Annex D.
					 */
					is_ansi = 1;
				}
			} else {
				/*
				 * It's a non-locking shift.
				 * Remember the current codeset, so we
				 * can revert to it after the next IE.
				 */
				non_locking_shift = 1;
				unshift_codeset = 0;
			}
		}
	}

	/* printing out header part */
	if (!ndo->ndo_eflag)
		ND_PRINT((ndo, ', '));
	ND_PRINT((ndo, '%s, codeset %u', is_ansi ? 'ANSI' : 'CCITT', codeset));

	if (call_ref_length != 0) {
		ND_TCHECK(p[0]);
		if (call_ref_length > 1 || p[0] != 0) {
			/*
			 * Not a dummy call reference.
			 */
			ND_PRINT((ndo, ', Call Ref: 0x'));
			for (i = 0; i < call_ref_length; i++)
				ND_PRINT((ndo, '%02x', call_ref[i]));
		}
	}
	if (ndo->ndo_vflag) {
		ND_PRINT((ndo, ', %s (0x%02x), length %u',
		   tok2str(fr_q933_msg_values,
			'unknown message', msgtype),
		   msgtype,
		   olen));
	} else {
		ND_PRINT((ndo, ', %s',
		       tok2str(fr_q933_msg_values,
			       'unknown message 0x%02x', msgtype)));
	}

	/* Loop through the rest of the IEs */
	while (length != 0) {
		/*
		 * What's the state of any non-locking shifts?
		 */
		if (non_locking_shift == 1) {
			/*
			 * There's a non-locking shift in effect for
			 * this IE.  Count it, so we reset the codeset
			 * before the next IE.
			 */
			non_locking_shift = 2;
		} else if (non_locking_shift == 2) {
			/*
			 * Unshift.
			 */
			codeset = unshift_codeset;
			non_locking_shift = 0;
		}

		/*
		 * Get the first octet of the IE.
		 */
		if (!ND_TTEST(*p)) {
			if (!ndo->ndo_vflag) {
				ND_PRINT((ndo, ', length %u', olen));
			}
			goto trunc;
		}
		iecode = *p;
		p++;
		length--;

		/* Single-octet IE? */
		if (IE_IS_SINGLE_OCTET(iecode)) {
			/*
			 * Yes.  Is it a shift?
			 */
			if (IE_IS_SHIFT(iecode)) {
				/*
				 * Yes.  Is it locking?
				 */
				if (IE_SHIFT_IS_LOCKING(iecode)) {
					/*
					 * Yes.
					 */
					non_locking_shift = 0;
				} else {
					/*
					 * No.  Remember the current
					 * codeset, so we can revert
					 * to it after the next IE.
					 */
					non_locking_shift = 1;
					unshift_codeset = codeset;
				}

				/*
				 * Get the codeset.
				 */
				codeset = IE_SHIFT_CODESET(iecode);
			}
		} else {
			/*
			 * No.  Get the IE length.
			 */
			if (length == 0 || !ND_TTEST(*p)) {
				if (!ndo->ndo_vflag) {
					ND_PRINT((ndo, ', length %u', olen));
				}
				goto trunc;
			}
			ielength = *p;
			p++;
			length--;

			/* lets do the full IE parsing only in verbose mode
			 * however some IEs (DLCI Status, Link Verify)
			 * are also interesting in non-verbose mode */
			if (ndo->ndo_vflag) {
				ND_PRINT((ndo, '\n\t%s IE (0x%02x), length %u: ',
				    tok2str(fr_q933_ie_codesets[codeset],
					'unknown', iecode),
				    iecode,
				    ielength));
			}

			/* sanity checks */
			if (iecode == 0 || ielength == 0) {
				return;
			}
			if (length < ielength || !ND_TTEST2(*p, ielength)) {
				if (!ndo->ndo_vflag) {
					ND_PRINT((ndo, ', length %u', olen));
				}
				goto trunc;
			}

			ie_is_known = 0;
			if (fr_q933_print_ie_codeset[codeset] != NULL) {
				ie_is_known = fr_q933_print_ie_codeset[codeset](ndo, iecode, ielength, p);
			}

			if (ie_is_known) {
				/*
				 * Known IE; do we want to see a hexdump
				 * of it?
				 */
				if (ndo->ndo_vflag > 1) {
					/* Yes. */
					print_unknown_data(ndo, p, '\n\t  ', ielength);
				}
			} else {
				/*
				 * Unknown IE; if we're printing verbosely,
				 * print its content in hex.
				 */
				if (ndo->ndo_vflag >= 1) {
					print_unknown_data(ndo, p, '\n\t', ielength);
				}
			}

			length -= ielength;
			p += ielength;
		}
	}
	if (!ndo->ndo_vflag) {
	    ND_PRINT((ndo, ', length %u', olen));
	}
	return;

trunc:
	ND_PRINT((ndo, '[|q.933]'));
}
",0,8198
the-tcpdump-group/tcpdump,9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,"static char *
get_next_file(FILE *VFile, char *ptr)
{
	char *ret;

	ret = fgets(ptr, PATH_MAX, VFile);
	if (!ret)
		return NULL;

	if (ptr[strlen(ptr) - 1] == '\n')
		ptr[strlen(ptr) - 1] = '\0';

	return ret;
}
",1,8199
the-tcpdump-group/tcpdump,9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,"static void
dump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	++packets_captured;

	++infodelay;

	pcap_dump(user, h, sp);
#ifdef HAVE_PCAP_DUMP_FLUSH
	if (Uflag)
		pcap_dump_flush((pcap_dumper_t *)user);
#endif

	--infodelay;
	if (infoprint)
		info(0);
}
",0,8200
xkbcommon/libxkbcommon,842e4351c2c97de6051cab6ce36b4a81e709a0e1,"static enum rules_token
lex(struct scanner *s, union lvalue *val)
{
skip_more_whitespace_and_comments:
    /* Skip spaces. */
    while (is_space(peek(s)))
        if (next(s) == '\n')
            return TOK_END_OF_LINE;

    /* Skip comments. */
    if (chr(s, '#')) {
        skip_to_eol(s);
        goto skip_more_whitespace_and_comments;
    }

    /* See if we're done. */
    if (eof(s)) return TOK_END_OF_FILE;

    /* New token. */
    s->token_line = s->line;
    s->token_column = s->column;
    s->buf_pos = 0;

    /* LHS Keysym. */
    if (chr(s, '<')) {
        while (peek(s) != '>' && !eol(s))
            buf_append(s, next(s));
        if (!chr(s, '>')) {
            scanner_err(s, 'unterminated keysym literal');
            return TOK_ERROR;
        }
        if (!buf_append(s, '\0')) {
            scanner_err(s, 'keysym literal is too long');
            return TOK_ERROR;
        }
        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_LHS_KEYSYM;
    }

    /* Colon. */
    if (chr(s, ':'))
        return TOK_COLON;
    if (chr(s, '!'))
        return TOK_BANG;
    if (chr(s, '~'))
        return TOK_TILDE;

    /* String literal. */
    if (chr(s, '\'')) {
        while (!eof(s) && !eol(s) && peek(s) != '\'') {
            if (chr(s, '\\')) {
                uint8_t o;
                if (chr(s, '\\')) {
                    buf_append(s, '\\');
                }
                else if (chr(s, ''')) {
                    buf_append(s, ''');
                }
                else if (chr(s, 'x') || chr(s, 'X')) {
                    if (hex(s, &o))
                        buf_append(s, (char) o);
                    else
                        scanner_warn(s, 'illegal hexadecimal escape sequence in string literal');
                }
                else if (oct(s, &o)) {
                    buf_append(s, (char) o);
                }
                else {
                    scanner_warn(s, 'unknown escape sequence (%c) in string literal', peek(s));
                    /* Ignore. */
                }
            } else {
                buf_append(s, next(s));
            }
        }
        if (!chr(s, '\'')) {
            scanner_err(s, 'unterminated string literal');
            return TOK_ERROR;
        }
        if (!buf_append(s, '\0')) {
            scanner_err(s, 'string literal is too long');
            return TOK_ERROR;
        }
        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {
            scanner_err(s, 'string literal is not a valid UTF-8 string');
            return TOK_ERROR;
        }
        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_STRING;
    }

    /* Identifier or include. */
    if (is_alpha(peek(s)) || peek(s) == '_') {
        s->buf_pos = 0;
        while (is_alnum(peek(s)) || peek(s) == '_')
            buf_append(s, next(s));
        if (!buf_append(s, '\0')) {
            scanner_err(s, 'identifier is too long');
            return TOK_ERROR;
        }

        if (streq(s->buf, 'include'))
            return TOK_INCLUDE;

        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_IDENT;
    }

    /* Discard rest of line. */
    skip_to_eol(s);

    scanner_err(s, 'unrecognized token');
    return TOK_ERROR;
}
",1,8201
xkbcommon/libxkbcommon,842e4351c2c97de6051cab6ce36b4a81e709a0e1,"static uint32_t
add_node(struct xkb_compose_table *table, xkb_keysym_t keysym)
{
    struct compose_node new = {
        .keysym = keysym,
        .next = 0,
        .is_leaf = true,
    };
    darray_append(table->nodes, new);
    return darray_size(table->nodes) - 1;
}

static void
add_production(struct xkb_compose_table *table, struct scanner *s,
               const struct production *production)
{
    unsigned lhs_pos;
    uint32_t curr;
    struct compose_node *node;

    curr = 0;
    node = &darray_item(table->nodes, curr);

    /*
     * Insert the sequence to the trie, creating new nodes as needed.
     *
     * TODO: This can be sped up a bit by first trying the path that the
     * previous production took, and only then doing the linear search
     * through the trie levels.  This will work because sequences in the
     * Compose files are often clustered by a common prefix; especially
     * in the 1st and 2nd keysyms, which is where the largest variation
     * (thus, longest search) is.
     */
    for (lhs_pos = 0; lhs_pos < production->len; lhs_pos++) {
        while (production->lhs[lhs_pos] != node->keysym) {
            if (node->next == 0) {
                uint32_t next = add_node(table, production->lhs[lhs_pos]);
                /* Refetch since add_node could have realloc()ed. */
                node = &darray_item(table->nodes, curr);
                node->next = next;
            }

            curr = node->next;
            node = &darray_item(table->nodes, curr);
        }

        if (lhs_pos + 1 == production->len)
            break;

        if (node->is_leaf) {
            if (node->u.leaf.utf8 != 0 ||
                node->u.leaf.keysym != XKB_KEY_NoSymbol) {
                scanner_warn(s, 'a sequence already exists which is a prefix of this sequence; overriding');
                node->u.leaf.utf8 = 0;
                node->u.leaf.keysym = XKB_KEY_NoSymbol;
            }

            {
                uint32_t successor = add_node(table, production->lhs[lhs_pos + 1]);
                /* Refetch since add_node could have realloc()ed. */
                node = &darray_item(table->nodes, curr);
                node->is_leaf = false;
                node->u.successor = successor;
            }
        }

        curr = node->u.successor;
        node = &darray_item(table->nodes, curr);
    }

    if (!node->is_leaf) {
        scanner_warn(s, 'this compose sequence is a prefix of another; skipping line');
        return;
    }

    if (node->u.leaf.utf8 != 0 || node->u.leaf.keysym != XKB_KEY_NoSymbol) {
        bool same_string =
            (node->u.leaf.utf8 == 0 && !production->has_string) ||
            (
                node->u.leaf.utf8 != 0 && production->has_string &&
                streq(&darray_item(table->utf8, node->u.leaf.utf8),
                      production->string)
            );
        bool same_keysym =
            (node->u.leaf.keysym == XKB_KEY_NoSymbol && !production->has_keysym) ||
            (
                node->u.leaf.keysym != XKB_KEY_NoSymbol && production->has_keysym &&
                node->u.leaf.keysym == production->keysym
            );
        if (same_string && same_keysym) {
            scanner_warn(s, 'this compose sequence is a duplicate of another; skipping line');
            return;
        }
        scanner_warn(s, 'this compose sequence already exists; overriding');
    }

    if (production->has_string) {
        node->u.leaf.utf8 = darray_size(table->utf8);
        darray_append_items(table->utf8, production->string,
                            strlen(production->string) + 1);
    }
    if (production->has_keysym) {
        node->u.leaf.keysym = production->keysym;
    }
}

/* Should match resolve_modifier(). */
#define ALL_MODS_MASK ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3))

static xkb_mod_index_t
resolve_modifier(const char *name)
{
    static const struct {
        const char *name;
        xkb_mod_index_t mod;
    } mods[] = {
        { 'Shift', 0 },
        { 'Ctrl', 2 },
        { 'Alt', 3 },
        { 'Meta', 3 },
        { 'Lock', 1 },
        { 'Caps', 1 },
    };

    for (unsigned i = 0; i < ARRAY_SIZE(mods); i++)
        if (streq(name, mods[i].name))
            return mods[i].mod;

    return XKB_MOD_INVALID;
}

static bool
parse(struct xkb_compose_table *table, struct scanner *s,
      unsigned include_depth);

static bool
do_include(struct xkb_compose_table *table, struct scanner *s,
           const char *path, unsigned include_depth)
{
    FILE *file;
    bool ok;
    char *string;
    size_t size;
    struct scanner new_s;

    if (include_depth >= MAX_INCLUDE_DEPTH) {
        scanner_err(s, 'maximum include depth (%d) exceeded; maybe there is an include loop?',
                    MAX_INCLUDE_DEPTH);
        return false;
    }

    file = fopen(path, 'r');
    if (!file) {
        scanner_err(s, 'failed to open included Compose file \'%s\': %s',
                    path, strerror(errno));
        return false;
    }

    ok = map_file(file, &string, &size);
    if (!ok) {
        scanner_err(s, 'failed to read included Compose file \'%s\': %s',
                    path, strerror(errno));
        goto err_file;
    }

    scanner_init(&new_s, table->ctx, string, size, path, s->priv);

    ok = parse(table, &new_s, include_depth + 1);
    if (!ok)
        goto err_unmap;

err_unmap:
    unmap_file(string, size);
err_file:
    fclose(file);
    return ok;
}

static bool
parse(struct xkb_compose_table *table, struct scanner *s,
      unsigned include_depth)
{
    enum rules_token tok;
    union lvalue val;
    xkb_keysym_t keysym;
    struct production production;
    enum { MAX_ERRORS = 10 };
    int num_errors = 0;

initial:
    production.len = 0;
    production.has_keysym = false;
    production.has_string = false;
    production.mods = 0;
    production.modmask = 0;

    /* fallthrough */

initial_eol:
    switch (tok = lex(s, &val)) {
    case TOK_END_OF_LINE:
        goto initial_eol;
    case TOK_END_OF_FILE:
        goto finished;
    case TOK_INCLUDE:
        goto include;
    default:
        goto lhs_tok;
    }

include:
    switch (tok = lex_include_string(s, table, &val)) {
    case TOK_INCLUDE_STRING:
        goto include_eol;
    default:
        goto unexpected;
    }

include_eol:
    switch (tok = lex(s, &val)) {
    case TOK_END_OF_LINE:
        if (!do_include(table, s, val.string.str, include_depth))
            goto fail;
        goto initial;
    default:
        goto unexpected;
    }

lhs:
    tok = lex(s, &val);
lhs_tok:
    switch (tok) {
    case TOK_COLON:
        if (production.len <= 0) {
            scanner_warn(s, 'expected at least one keysym on left-hand side; skipping line');
            goto skip;
        }
        goto rhs;
    case TOK_IDENT:
        if (streq(val.string.str, 'None')) {
            production.mods = 0;
            production.modmask = ALL_MODS_MASK;
            goto lhs_keysym;
        }
        goto lhs_mod_list_tok;
    case TOK_TILDE:
        goto lhs_mod_list_tok;
    case TOK_BANG:
        production.modmask = ALL_MODS_MASK;
        goto lhs_mod_list;
    default:
        goto lhs_keysym_tok;
    }

lhs_keysym:
    tok = lex(s, &val);
lhs_keysym_tok:
    switch (tok) {
    case TOK_LHS_KEYSYM:
        keysym = xkb_keysym_from_name(val.string.str, XKB_KEYSYM_NO_FLAGS);
        if (keysym == XKB_KEY_NoSymbol) {
            scanner_err(s, 'unrecognized keysym \'%s\' on left-hand side',
                        val.string.str);
            goto error;
        }
        if (production.len + 1 > MAX_LHS_LEN) {
            scanner_warn(s, 'too many keysyms (%d) on left-hand side; skipping line',
                         MAX_LHS_LEN + 1);
            goto skip;
        }
        production.lhs[production.len++] = keysym;
        production.mods = 0;
        production.modmask = 0;
        goto lhs;
    default:
        goto unexpected;
    }

lhs_mod_list:
    tok = lex(s, &val);
lhs_mod_list_tok: {
        bool tilde = false;
        xkb_mod_index_t mod;

        if (tok != TOK_TILDE && tok != TOK_IDENT)
            goto lhs_keysym_tok;

        if (tok == TOK_TILDE) {
            tilde = true;
            tok = lex(s, &val);
        }

        if (tok != TOK_IDENT)
            goto unexpected;

        mod = resolve_modifier(val.string.str);
        if (mod == XKB_MOD_INVALID) {
            scanner_err(s, 'unrecognized modifier \'%s\'',
                        val.string.str);
            goto error;
        }

        production.modmask |= 1 << mod;
        if (tilde)
            production.mods &= ~(1 << mod);
        else
            production.mods |= 1 << mod;

        goto lhs_mod_list;
    }

rhs:
    switch (tok = lex(s, &val)) {
    case TOK_STRING:
        if (production.has_string) {
            scanner_warn(s, 'right-hand side can have at most one string; skipping line');
            goto skip;
        }
        if (val.string.len <= 0) {
            scanner_warn(s, 'right-hand side string must not be empty; skipping line');
            goto skip;
        }
        if (val.string.len >= sizeof(production.string)) {
            scanner_warn(s, 'right-hand side string is too long; skipping line');
            goto skip;
        }
        strcpy(production.string, val.string.str);
        production.has_string = true;
        goto rhs;
    case TOK_IDENT:
        keysym = xkb_keysym_from_name(val.string.str, XKB_KEYSYM_NO_FLAGS);
        if (keysym == XKB_KEY_NoSymbol) {
            scanner_err(s, 'unrecognized keysym \'%s\' on right-hand side',
                        val.string.str);
            goto error;
        }
        if (production.has_keysym) {
            scanner_warn(s, 'right-hand side can have at most one keysym; skipping line');
            goto skip;
        }
        production.keysym = keysym;
        production.has_keysym = true;
	/* fallthrough */
    case TOK_END_OF_LINE:
        if (!production.has_string && !production.has_keysym) {
            scanner_warn(s, 'right-hand side must have at least one of string or keysym; skipping line');
            goto skip;
        }
        add_production(table, s, &production);
        goto initial;
    default:
        goto unexpected;
    }

unexpected:
    if (tok != TOK_ERROR)
        scanner_err(s, 'unexpected token');
error:
    num_errors++;
    if (num_errors <= MAX_ERRORS)
        goto skip;

    scanner_err(s, 'too many errors');
    goto fail;

fail:
    scanner_err(s, 'failed to parse file');
    return false;

skip:
    while (tok != TOK_END_OF_LINE && tok != TOK_END_OF_FILE)
        tok = lex(s, &val);
    goto initial;

finished:
    return true;
}

bool
parse_string(struct xkb_compose_table *table, const char *string, size_t len,
             const char *file_name)
{
    struct scanner s;
    scanner_init(&s, table->ctx, string, len, file_name, NULL);
    if (!parse(table, &s, 0))
        return false;
    /* Maybe the allocator can use the excess space. */
    darray_shrink(table->nodes);
    darray_shrink(table->utf8);
    return true;
}

bool
parse_file(struct xkb_compose_table *table, FILE *file, const char *file_name)
{
    bool ok;
    char *string;
    size_t size;

    ok = map_file(file, &string, &size);
    if (!ok) {
        log_err(table->ctx, 'Couldn't read Compose file %s: %s\n',
                file_name, strerror(errno));
        return false;
    }

    ok = parse_string(table, string, size, file_name);
    unmap_file(string, size);
    return ok;
}
",0,8202
xkbcommon/libxkbcommon,96df3106d49438e442510c59acad306e94f3db4d,"static bool
AddInterp(CompatInfo *info, SymInterpInfo *new, bool same_file)
{
    SymInterpInfo *old = FindMatchingInterp(info, new);
    if (old) {
        const int verbosity = xkb_context_get_log_verbosity(info->ctx);
        const bool report = (same_file && verbosity > 0) || verbosity > 9;
        enum si_field collide = 0;

        if (new->merge == MERGE_REPLACE) {
            if (report)
                log_warn(info->ctx,
                         'Multiple definitions for \'%s\'; '
                         'Earlier interpretation ignored\n',
                         siText(new, info));
            *old = *new;
            return true;
        }

        if (UseNewInterpField(SI_FIELD_VIRTUAL_MOD, old, new, report,
                              &collide)) {
            old->interp.virtual_mod = new->interp.virtual_mod;
            old->defined |= SI_FIELD_VIRTUAL_MOD;
        }
        if (UseNewInterpField(SI_FIELD_ACTION, old, new, report,
                              &collide)) {
            old->interp.action = new->interp.action;
            old->defined |= SI_FIELD_ACTION;
        }
        if (UseNewInterpField(SI_FIELD_AUTO_REPEAT, old, new, report,
                              &collide)) {
            old->interp.repeat = new->interp.repeat;
            old->defined |= SI_FIELD_AUTO_REPEAT;
        }
        if (UseNewInterpField(SI_FIELD_LEVEL_ONE_ONLY, old, new, report,
                              &collide)) {
            old->interp.level_one_only = new->interp.level_one_only;
            old->defined |= SI_FIELD_LEVEL_ONE_ONLY;
        }

        if (collide) {
            log_warn(info->ctx,
                     'Multiple interpretations of \'%s\'; '
                     'Using %s definition for duplicate fields\n',
                     siText(new, info),
                     (new->merge != MERGE_AUGMENT ? 'last' : 'first'));
        }

        return true;
    }

    darray_append(info->interps, *new);
    return true;
}

/***====================================================================***/

static bool
ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,
                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)
{
    if (expr == NULL) {
        *pred_rtrn = MATCH_ANY_OR_NONE;
        *mods_rtrn = MOD_REAL_MASK_ALL;
        return true;
    }

    *pred_rtrn = MATCH_EXACTLY;
    if (expr->expr.op == EXPR_ACTION_DECL) {
        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {
            log_err(info->ctx,
                    'Illegal modifier predicate \'%s\'; Ignored\n', pred_txt);
            return false;
        }
        expr = expr->action.args;
    }
    else if (expr->expr.op == EXPR_IDENT) {
        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);
        if (pred_txt && istreq(pred_txt, 'any')) {
            *pred_rtrn = MATCH_ANY;
            *mods_rtrn = MOD_REAL_MASK_ALL;
            return true;
        }
    }

    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,
                              mods_rtrn);
}

/***====================================================================***/

static bool
UseNewLEDField(enum led_field field, LedInfo *old, LedInfo *new,
               bool report, enum led_field *collide)
{
    if (!(old->defined & field))
        return true;

    if (new->defined & field) {
        if (report)
            *collide |= field;

        if (new->merge != MERGE_AUGMENT)
            return true;
    }

    return false;
}

static bool
AddLedMap(CompatInfo *info, LedInfo *new, bool same_file)
{
    enum led_field collide;
    const int verbosity = xkb_context_get_log_verbosity(info->ctx);
    const bool report = (same_file && verbosity > 0) || verbosity > 9;

    for (xkb_led_index_t i = 0; i < info->num_leds; i++) {
        LedInfo *old = &info->leds[i];

        if (old->led.name != new->led.name)
            continue;

        if (old->led.mods.mods == new->led.mods.mods &&
            old->led.groups == new->led.groups &&
            old->led.ctrls == new->led.ctrls &&
            old->led.which_mods == new->led.which_mods &&
            old->led.which_groups == new->led.which_groups) {
            old->defined |= new->defined;
            return true;
        }

        if (new->merge == MERGE_REPLACE) {
            if (report)
                log_warn(info->ctx,
                         'Map for indicator %s redefined; '
                         'Earlier definition ignored\n',
                         xkb_atom_text(info->ctx, old->led.name));
            *old = *new;
            return true;
        }

        collide = 0;
        if (UseNewLEDField(LED_FIELD_MODS, old, new, report, &collide)) {
            old->led.which_mods = new->led.which_mods;
            old->led.mods = new->led.mods;
            old->defined |= LED_FIELD_MODS;
        }
        if (UseNewLEDField(LED_FIELD_GROUPS, old, new, report, &collide)) {
            old->led.which_groups = new->led.which_groups;
            old->led.groups = new->led.groups;
            old->defined |= LED_FIELD_GROUPS;
        }
        if (UseNewLEDField(LED_FIELD_CTRLS, old, new, report, &collide)) {
            old->led.ctrls = new->led.ctrls;
            old->defined |= LED_FIELD_CTRLS;
        }

        if (collide) {
            log_warn(info->ctx,
                     'Map for indicator %s redefined; '
                     'Using %s definition for duplicate fields\n',
                     xkb_atom_text(info->ctx, old->led.name),
                     (new->merge == MERGE_AUGMENT ? 'first' : 'last'));
        }

        return true;
    }

    if (info->num_leds >= XKB_MAX_LEDS) {
        log_err(info->ctx,
                'Too many LEDs defined (maximum %d)\n',
                XKB_MAX_LEDS);
        return false;
    }
    info->leds[info->num_leds++] = *new;
    return true;
}

static void
MergeIncludedCompatMaps(CompatInfo *into, CompatInfo *from,
                        enum merge_mode merge)
{
    if (from->errorCount > 0) {
        into->errorCount += from->errorCount;
        return;
    }

    into->mods = from->mods;

    if (into->name == NULL) {
        into->name = from->name;
        from->name = NULL;
    }

    if (darray_empty(into->interps)) {
        into->interps = from->interps;
        darray_init(from->interps);
    }
    else {
        SymInterpInfo *si;
        darray_foreach(si, from->interps) {
            si->merge = (merge == MERGE_DEFAULT ? si->merge : merge);
            if (!AddInterp(into, si, false))
                into->errorCount++;
        }
    }

    if (into->num_leds == 0) {
        memcpy(into->leds, from->leds, sizeof(*from->leds) * from->num_leds);
        into->num_leds = from->num_leds;
        from->num_leds = 0;
    }
    else {
        for (xkb_led_index_t i = 0; i < from->num_leds; i++) {
            LedInfo *ledi = &from->leds[i];
            ledi->merge = (merge == MERGE_DEFAULT ? ledi->merge : merge);
            if (!AddLedMap(into, ledi, false))
                into->errorCount++;
        }
    }
}

static void
HandleCompatMapFile(CompatInfo *info, XkbFile *file, enum merge_mode merge);

static bool
HandleIncludeCompatMap(CompatInfo *info, IncludeStmt *include)
{
    CompatInfo included;

    InitCompatInfo(&included, info->ctx, info->actions, &info->mods);
    included.name = include->stmt;
    include->stmt = NULL;

    for (IncludeStmt *stmt = include; stmt; stmt = stmt->next_incl) {
        CompatInfo next_incl;
        XkbFile *file;

        file = ProcessIncludeFile(info->ctx, stmt, FILE_TYPE_COMPAT);
        if (!file) {
            info->errorCount += 10;
            ClearCompatInfo(&included);
            return false;
        }

        InitCompatInfo(&next_incl, info->ctx, info->actions, &included.mods);
        next_incl.default_interp = info->default_interp;
        next_incl.default_interp.merge = stmt->merge;
        next_incl.default_led = info->default_led;
        next_incl.default_led.merge = stmt->merge;

        HandleCompatMapFile(&next_incl, file, MERGE_OVERRIDE);

        MergeIncludedCompatMaps(&included, &next_incl, stmt->merge);

        ClearCompatInfo(&next_incl);
        FreeXkbFile(file);
    }

    MergeIncludedCompatMaps(info, &included, include->merge);
    ClearCompatInfo(&included);

    return (info->errorCount == 0);
}

static bool
SetInterpField(CompatInfo *info, SymInterpInfo *si, const char *field,
               ExprDef *arrayNdx, ExprDef *value)
{
    xkb_mod_index_t ndx;

    if (istreq(field, 'action')) {
        if (arrayNdx)
            return ReportSINotArray(info, si, field);

        if (!HandleActionDef(info->ctx, info->actions, &info->mods,
                             value, &si->interp.action))
            return false;

        si->defined |= SI_FIELD_ACTION;
    }
    else if (istreq(field, 'virtualmodifier') ||
             istreq(field, 'virtualmod')) {
        if (arrayNdx)
            return ReportSINotArray(info, si, field);

        if (!ExprResolveMod(info->ctx, value, MOD_VIRT, &info->mods, &ndx))
            return ReportSIBadType(info, si, field, 'virtual modifier');

        si->interp.virtual_mod = ndx;
        si->defined |= SI_FIELD_VIRTUAL_MOD;
    }
    else if (istreq(field, 'repeat')) {
        bool set;

        if (arrayNdx)
            return ReportSINotArray(info, si, field);

        if (!ExprResolveBoolean(info->ctx, value, &set))
            return ReportSIBadType(info, si, field, 'boolean');

        si->interp.repeat = set;

        si->defined |= SI_FIELD_AUTO_REPEAT;
    }
    else if (istreq(field, 'locking')) {
        log_dbg(info->ctx,
                'The \'locking\' field in symbol interpretation is unsupported; '
                'Ignored\n');
    }
    else if (istreq(field, 'usemodmap') ||
             istreq(field, 'usemodmapmods')) {
        unsigned int val;

        if (arrayNdx)
            return ReportSINotArray(info, si, field);

        if (!ExprResolveEnum(info->ctx, value, &val, useModMapValueNames))
            return ReportSIBadType(info, si, field, 'level specification');

        si->interp.level_one_only = val;
        si->defined |= SI_FIELD_LEVEL_ONE_ONLY;
    }
    else {
        return ReportBadField(info->ctx, 'symbol interpretation', field,
                              siText(si, info));
    }

    return true;
}

static bool
SetLedMapField(CompatInfo *info, LedInfo *ledi, const char *field,
               ExprDef *arrayNdx, ExprDef *value)
{
    bool ok = true;

    if (istreq(field, 'modifiers') || istreq(field, 'mods')) {
        if (arrayNdx)
            return ReportLedNotArray(info, ledi, field);

        if (!ExprResolveModMask(info->ctx, value, MOD_BOTH,
                                &info->mods, &ledi->led.mods.mods))
            return ReportLedBadType(info, ledi, field, 'modifier mask');

        ledi->defined |= LED_FIELD_MODS;
    }
    else if (istreq(field, 'groups')) {
        unsigned int mask;

        if (arrayNdx)
            return ReportLedNotArray(info, ledi, field);

        if (!ExprResolveMask(info->ctx, value, &mask, groupMaskNames))
            return ReportLedBadType(info, ledi, field, 'group mask');

        ledi->led.groups = mask;
        ledi->defined |= LED_FIELD_GROUPS;
    }
    else if (istreq(field, 'controls') || istreq(field, 'ctrls')) {
        unsigned int mask;

        if (arrayNdx)
            return ReportLedNotArray(info, ledi, field);

        if (!ExprResolveMask(info->ctx, value, &mask, ctrlMaskNames))
            return ReportLedBadType(info, ledi, field, 'controls mask');

        ledi->led.ctrls = mask;
        ledi->defined |= LED_FIELD_CTRLS;
    }
    else if (istreq(field, 'allowexplicit')) {
        log_dbg(info->ctx,
                'The \'allowExplicit\' field in indicator statements is unsupported; '
                'Ignored\n');
    }
    else if (istreq(field, 'whichmodstate') ||
             istreq(field, 'whichmodifierstate')) {
        unsigned int mask;

        if (arrayNdx)
            return ReportLedNotArray(info, ledi, field);

        if (!ExprResolveMask(info->ctx, value, &mask,
                             modComponentMaskNames))
            return ReportLedBadType(info, ledi, field,
                                    'mask of modifier state components');

        ledi->led.which_mods = mask;
    }
    else if (istreq(field, 'whichgroupstate')) {
        unsigned mask;

        if (arrayNdx)
            return ReportLedNotArray(info, ledi, field);

        if (!ExprResolveMask(info->ctx, value, &mask,
                             groupComponentMaskNames))
            return ReportLedBadType(info, ledi, field,
                                    'mask of group state components');

        ledi->led.which_groups = mask;
    }
    else if (istreq(field, 'driveskbd') ||
             istreq(field, 'driveskeyboard') ||
             istreq(field, 'leddriveskbd') ||
             istreq(field, 'leddriveskeyboard') ||
             istreq(field, 'indicatordriveskbd') ||
             istreq(field, 'indicatordriveskeyboard')) {
        log_dbg(info->ctx,
                'The \'%s\' field in indicator statements is unsupported; '
                'Ignored\n', field);
    }
    else if (istreq(field, 'index')) {
        /* Users should see this, it might cause unexpected behavior. */
        log_err(info->ctx,
                'The \'index\' field in indicator statements is unsupported; '
                'Ignored\n');
    }
    else {
        log_err(info->ctx,
                'Unknown field %s in map for %s indicator; '
                'Definition ignored\n',
                field, xkb_atom_text(info->ctx, ledi->led.name));
        ok = false;
    }

    return ok;
}

static bool
HandleGlobalVar(CompatInfo *info, VarDef *stmt)
{
    const char *elem, *field;
    ExprDef *ndx;
    bool ret;

    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx))
        ret = false;
    else if (elem && istreq(elem, 'interpret'))
        ret = SetInterpField(info, &info->default_interp, field, ndx,
                             stmt->value);
    else if (elem && istreq(elem, 'indicator'))
        ret = SetLedMapField(info, &info->default_led, field, ndx,
                             stmt->value);
    else
        ret = SetActionField(info->ctx, info->actions, &info->mods,
                             elem, field, ndx, stmt->value);
    return ret;
}

static bool
HandleInterpBody(CompatInfo *info, VarDef *def, SymInterpInfo *si)
{
    bool ok = true;
    const char *elem, *field;
    ExprDef *arrayNdx;

    for (; def; def = (VarDef *) def->common.next) {
        if (def->name && def->name->expr.op == EXPR_FIELD_REF) {
            log_err(info->ctx,
                    'Cannot set a global default value from within an interpret statement; '
                    'Move statements to the global file scope\n');
            ok = false;
            continue;
        }

        ok = ExprResolveLhs(info->ctx, def->name, &elem, &field, &arrayNdx);
        if (!ok)
            continue;

        ok = SetInterpField(info, si, field, arrayNdx, def->value);
    }

    return ok;
}

static bool
HandleInterpDef(CompatInfo *info, InterpDef *def, enum merge_mode merge)
{
    enum xkb_match_operation pred;
    xkb_mod_mask_t mods;
    SymInterpInfo si;

    if (!ResolveStateAndPredicate(def->match, &pred, &mods, info)) {
        log_err(info->ctx,
                'Couldn't determine matching modifiers; '
                'Symbol interpretation ignored\n');
        return false;
    }

    si = info->default_interp;
    si.merge = merge = (def->merge == MERGE_DEFAULT ? merge : def->merge);
    si.interp.sym = def->sym;
    si.interp.match = pred;
    si.interp.mods = mods;

    if (!HandleInterpBody(info, def->def, &si)) {
        info->errorCount++;
        return false;
    }

    if (!AddInterp(info, &si, true)) {
        info->errorCount++;
        return false;
    }

    return true;
}

static bool
HandleLedMapDef(CompatInfo *info, LedMapDef *def, enum merge_mode merge)
{
    LedInfo ledi;
    VarDef *var;
    bool ok;

    if (def->merge != MERGE_DEFAULT)
        merge = def->merge;

    ledi = info->default_led;
    ledi.merge = merge;
    ledi.led.name = def->name;

    ok = true;
    for (var = def->body; var != NULL; var = (VarDef *) var->common.next) {
        const char *elem, *field;
        ExprDef *arrayNdx;
        if (!ExprResolveLhs(info->ctx, var->name, &elem, &field, &arrayNdx)) {
            ok = false;
            continue;
        }

        if (elem) {
            log_err(info->ctx,
                    'Cannot set defaults for \'%s\' element in indicator map; '
                    'Assignment to %s.%s ignored\n', elem, elem, field);
            ok = false;
        }
        else {
            ok = SetLedMapField(info, &ledi, field, arrayNdx, var->value) && ok;
        }
    }

    if (ok)
        return AddLedMap(info, &ledi, true);

    return false;
}

static void
HandleCompatMapFile(CompatInfo *info, XkbFile *file, enum merge_mode merge)
{
    bool ok;

    merge = (merge == MERGE_DEFAULT ? MERGE_AUGMENT : merge);

    free(info->name);
    info->name = strdup_safe(file->name);

    for (ParseCommon *stmt = file->defs; stmt; stmt = stmt->next) {
        switch (stmt->type) {
        case STMT_INCLUDE:
            ok = HandleIncludeCompatMap(info, (IncludeStmt *) stmt);
            break;
        case STMT_INTERP:
            ok = HandleInterpDef(info, (InterpDef *) stmt, merge);
            break;
        case STMT_GROUP_COMPAT:
            log_dbg(info->ctx,
                    'The \'group\' statement in compat is unsupported; '
                    'Ignored\n');
            ok = true;
            break;
        case STMT_LED_MAP:
            ok = HandleLedMapDef(info, (LedMapDef *) stmt, merge);
            break;
        case STMT_VAR:
            ok = HandleGlobalVar(info, (VarDef *) stmt);
            break;
        case STMT_VMOD:
            ok = HandleVModDef(info->ctx, &info->mods, (VModDef *) stmt, merge);
            break;
        default:
            log_err(info->ctx,
                    'Compat files may not include other types; '
                    'Ignoring %s\n', stmt_type_to_string(stmt->type));
            ok = false;
            break;
        }

        if (!ok)
            info->errorCount++;

        if (info->errorCount > 10) {
            log_err(info->ctx,
                    'Abandoning compatibility map \'%s\'\n', file->name);
            break;
        }
    }
}

/* Temporary struct for CopyInterps. */
struct collect {
    darray(struct xkb_sym_interpret) sym_interprets;
};

static void
CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}

static void
CopyLedMapDefsToKeymap(struct xkb_keymap *keymap, CompatInfo *info)
{
    for (xkb_led_index_t idx = 0; idx < info->num_leds; idx++) {
        LedInfo *ledi = &info->leds[idx];
        xkb_led_index_t i;
        struct xkb_led *led;

        /*
         * Find the LED with the given name, if it was already declared
         * in keycodes.
         */
        xkb_leds_enumerate(i, led, keymap)
            if (led->name == ledi->led.name)
                break;

        /* Not previously declared; create it with next free index. */
        if (i >= keymap->num_leds) {
            log_dbg(keymap->ctx,
                    'Indicator name \'%s\' was not declared in the keycodes section; '
                    'Adding new indicator\n',
                    xkb_atom_text(keymap->ctx, ledi->led.name));

            xkb_leds_enumerate(i, led, keymap)
                if (led->name == XKB_ATOM_NONE)
                    break;

            if (i >= keymap->num_leds) {
                /* Not place to put it; ignore. */
                if (i >= XKB_MAX_LEDS) {
                    log_err(keymap->ctx,
                            'Too many indicators (maximum is %d); '
                            'Indicator name \'%s\' ignored\n',
                            XKB_MAX_LEDS,
                            xkb_atom_text(keymap->ctx, ledi->led.name));
                    continue;
                }

                /* Add a new LED. */
                led = &keymap->leds[keymap->num_leds++];
            }
        }

        *led = ledi->led;
        if (led->groups != 0 && led->which_groups == 0)
            led->which_groups = XKB_STATE_LAYOUT_EFFECTIVE;
        if (led->mods.mods != 0 && led->which_mods == 0)
            led->which_mods = XKB_STATE_MODS_EFFECTIVE;
    }
}

static bool
CopyCompatToKeymap(struct xkb_keymap *keymap, CompatInfo *info)
{
    keymap->compat_section_name = strdup_safe(info->name);
    XkbEscapeMapName(keymap->compat_section_name);

    keymap->mods = info->mods;

    if (!darray_empty(info->interps)) {
        struct collect collect;
        darray_init(collect.sym_interprets);

        /* Most specific to least specific. */
        CopyInterps(info, true, MATCH_EXACTLY, &collect);
        CopyInterps(info, true, MATCH_ALL, &collect);
        CopyInterps(info, true, MATCH_NONE, &collect);
        CopyInterps(info, true, MATCH_ANY, &collect);
        CopyInterps(info, true, MATCH_ANY_OR_NONE, &collect);
        CopyInterps(info, false, MATCH_EXACTLY, &collect);
        CopyInterps(info, false, MATCH_ALL, &collect);
        CopyInterps(info, false, MATCH_NONE, &collect);
        CopyInterps(info, false, MATCH_ANY, &collect);
        CopyInterps(info, false, MATCH_ANY_OR_NONE, &collect);

        darray_steal(collect.sym_interprets,
                     &keymap->sym_interprets, &keymap->num_sym_interprets);
    }

    CopyLedMapDefsToKeymap(keymap, info);

    return true;
}

bool
CompileCompatMap(XkbFile *file, struct xkb_keymap *keymap,
                 enum merge_mode merge)
{
    CompatInfo info;
    ActionsInfo *actions;

    actions = NewActionsInfo();
    if (!actions)
        return false;

    InitCompatInfo(&info, keymap->ctx, actions, &keymap->mods);
    info.default_interp.merge = merge;
    info.default_led.merge = merge;

    HandleCompatMapFile(&info, file, merge);
    if (info.errorCount != 0)
        goto err_info;

    if (!CopyCompatToKeymap(keymap, &info))
        goto err_info;

    ClearCompatInfo(&info);
    FreeActionsInfo(actions);
    return true;

err_info:
    ClearCompatInfo(&info);
    FreeActionsInfo(actions);
    return false;
}
",1,8203
xkbcommon/libxkbcommon,96df3106d49438e442510c59acad306e94f3db4d,"static void
ClearCompatInfo(CompatInfo *info)
{
    free(info->name);
    darray_free(info->interps);
}
",0,8204
mongodb/mongo-c-driver,0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,"static bool
_bson_iter_next_internal (bson_iter_t *iter,    /* INOUT */
                          uint32_t next_keylen, /* IN */
                          const char **key,     /* OUT */
                          uint32_t *bson_type,  /* OUT */
                          bool *unsupported)    /* OUT */
{
   const uint8_t *data;
   uint32_t o;
   unsigned int len;

   BSON_ASSERT (iter);

   *unsupported = false;

   if (!iter->raw) {
      *key = NULL;
      *bson_type = BSON_TYPE_EOD;
      return false;
   }

   data = iter->raw;
   len = iter->len;

   iter->off = iter->next_off;
   iter->type = iter->off;
   iter->key = iter->off + 1;
   iter->d1 = 0;
   iter->d2 = 0;
   iter->d3 = 0;
   iter->d4 = 0;

   if (next_keylen == 0) {
      /* iterate from start to end of NULL-terminated key string */
      for (o = iter->key; o < len; o++) {
         if (!data[o]) {
            iter->d1 = ++o;
            goto fill_data_fields;
         }
      }
   } else {
      o = iter->key + next_keylen + 1;
      iter->d1 = o;
      goto fill_data_fields;
   }

   goto mark_invalid;

fill_data_fields:

   *key = bson_iter_key_unsafe (iter);
   *bson_type = ITER_TYPE (iter);

   switch (*bson_type) {
   case BSON_TYPE_DATE_TIME:
   case BSON_TYPE_DOUBLE:
   case BSON_TYPE_INT64:
   case BSON_TYPE_TIMESTAMP:
      iter->next_off = o + 8;
      break;
   case BSON_TYPE_CODE:
   case BSON_TYPE_SYMBOL:
   case BSON_TYPE_UTF8: {
      uint32_t l;

      if ((o + 4) >= len) {
         iter->err_off = o;
         goto mark_invalid;
      }

      iter->d2 = o + 4;
      memcpy (&l, iter->raw + iter->d1, sizeof (l));
      l = BSON_UINT32_FROM_LE (l);

      if (l > (len - (o + 4))) {
         iter->err_off = o;
         goto mark_invalid;
      }

      iter->next_off = o + 4 + l;

      /*
       * Make sure the string length includes the NUL byte.
       */
      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {
         iter->err_off = o;
         goto mark_invalid;
      }

      /*
       * Make sure the last byte is a NUL byte.
       */
      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\0')) {
         iter->err_off = o + 4 + l - 1;
         goto mark_invalid;
      }
   } break;
   case BSON_TYPE_BINARY: {
      bson_subtype_t subtype;
      uint32_t l;

      if (o >= (len - 4)) {
         iter->err_off = o;
         goto mark_invalid;
      }

      iter->d2 = o + 4;
      iter->d3 = o + 5;

      memcpy (&l, iter->raw + iter->d1, sizeof (l));
      l = BSON_UINT32_FROM_LE (l);

      if (l >= (len - o)) {
         iter->err_off = o;
         goto mark_invalid;
      }

      subtype = *(iter->raw + iter->d2);

      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {
         int32_t binary_len;

         if (l < 4) {
            iter->err_off = o;
            goto mark_invalid;
         }

         /* subtype 2 has a redundant length header in the data */
         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));
         binary_len = BSON_UINT32_FROM_LE (binary_len);
         if (binary_len + 4 != l) {
            iter->err_off = iter->d3;
            goto mark_invalid;
         }
      }

      iter->next_off = o + 5 + l;
   } break;
   case BSON_TYPE_ARRAY:
   case BSON_TYPE_DOCUMENT: {
      uint32_t l;

      if (o >= (len - 4)) {
         iter->err_off = o;
         goto mark_invalid;
      }

      memcpy (&l, iter->raw + iter->d1, sizeof (l));
      l = BSON_UINT32_FROM_LE (l);

      if ((l > len) || (l > (len - o))) {
         iter->err_off = o;
         goto mark_invalid;
      }

      iter->next_off = o + l;
   } break;
   case BSON_TYPE_OID:
      iter->next_off = o + 12;
      break;
   case BSON_TYPE_BOOL: {
      char val;

      if (iter->d1 >= len) {
         iter->err_off = o;
         goto mark_invalid;
      }

      memcpy (&val, iter->raw + iter->d1, 1);
      if (val != 0x00 && val != 0x01) {
         iter->err_off = o;
         goto mark_invalid;
      }

      iter->next_off = o + 1;
   } break;
   case BSON_TYPE_REGEX: {
      bool eor = false;
      bool eoo = false;

      for (; o < len; o++) {
         if (!data[o]) {
            iter->d2 = ++o;
            eor = true;
            break;
         }
      }

      if (!eor) {
         iter->err_off = iter->next_off;
         goto mark_invalid;
      }

      for (; o < len; o++) {
         if (!data[o]) {
            eoo = true;
            break;
         }
      }

      if (!eoo) {
         iter->err_off = iter->next_off;
         goto mark_invalid;
      }

      iter->next_off = o + 1;
   } break;
   case BSON_TYPE_DBPOINTER: {
      uint32_t l;

      if (o >= (len - 4)) {
         iter->err_off = o;
         goto mark_invalid;
      }

      iter->d2 = o + 4;
      memcpy (&l, iter->raw + iter->d1, sizeof (l));
      l = BSON_UINT32_FROM_LE (l);

      /* Check valid string length. l counts '\0' but not 4 bytes for itself. */
      if (l == 0 || l > (len - o - 4)) {
         iter->err_off = o;
         goto mark_invalid;
      }

      if (*(iter->raw + o + l + 3)) {
         /* not null terminated */
         iter->err_off = o + l + 3;
         goto mark_invalid;
      }

      iter->d3 = o + 4 + l;
      iter->next_off = o + 4 + l + 12;
   } break;
   case BSON_TYPE_CODEWSCOPE: {
      uint32_t l;
      uint32_t doclen;

      if ((len < 19) || (o >= (len - 14))) {
         iter->err_off = o;
         goto mark_invalid;
      }

      iter->d2 = o + 4;
      iter->d3 = o + 8;

      memcpy (&l, iter->raw + iter->d1, sizeof (l));
      l = BSON_UINT32_FROM_LE (l);

      if ((l < 14) || (l >= (len - o))) {
         iter->err_off = o;
         goto mark_invalid;
      }

      iter->next_off = o + l;

      if (iter->next_off >= len) {
         iter->err_off = o;
         goto mark_invalid;
      }

      memcpy (&l, iter->raw + iter->d2, sizeof (l));
      l = BSON_UINT32_FROM_LE (l);

      if (l == 0 || l >= (len - o - 4 - 4)) {
         iter->err_off = o;
         goto mark_invalid;
      }

      if ((o + 4 + 4 + l + 4) >= iter->next_off) {
         iter->err_off = o + 4;
         goto mark_invalid;
      }

      iter->d4 = o + 4 + 4 + l;
      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));
      doclen = BSON_UINT32_FROM_LE (doclen);

      if ((o + 4 + 4 + l + doclen) != iter->next_off) {
         iter->err_off = o + 4 + 4 + l;
         goto mark_invalid;
      }
   } break;
   case BSON_TYPE_INT32:
      iter->next_off = o + 4;
      break;
   case BSON_TYPE_DECIMAL128:
      iter->next_off = o + 16;
      break;
   case BSON_TYPE_MAXKEY:
   case BSON_TYPE_MINKEY:
   case BSON_TYPE_NULL:
   case BSON_TYPE_UNDEFINED:
      iter->next_off = o;
      break;
   default:
      *unsupported = true;
   /* FALL THROUGH */
   case BSON_TYPE_EOD:
      iter->err_off = o;
      goto mark_invalid;
   }

   /*
    * Check to see if any of the field locations would overflow the
    * current BSON buffer. If so, set the error location to the offset
    * of where the field starts.
    */
   if (iter->next_off >= len) {
      iter->err_off = o;
      goto mark_invalid;
   }

   iter->err_off = 0;

   return true;

mark_invalid:
   iter->raw = NULL;
   iter->len = 0;
   iter->next_off = 0;

   return false;
}
",1,8205
mongodb/mongo-c-driver,0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,"static void
test_bson_validate (void)
{
   char filename[64];
   size_t offset;
   bson_t *b;
   int i;
   bson_error_t error;

   for (i = 1; i <= 38; i++) {
      bson_snprintf (filename, sizeof filename, 'test%u.bson', i);
      b = get_bson (filename);
      BSON_ASSERT (bson_validate (b, BSON_VALIDATE_NONE, &offset));
      bson_destroy (b);
   }

   b = get_bson ('codewscope.bson');
   BSON_ASSERT (bson_validate (b, BSON_VALIDATE_NONE, &offset));
   bson_destroy (b);

   b = get_bson ('empty_key.bson');
   BSON_ASSERT (bson_validate (b,
                               BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 |
                                  BSON_VALIDATE_DOLLAR_KEYS |
                                  BSON_VALIDATE_DOT_KEYS,
                               &offset));
   bson_destroy (b);

#define VALIDATE_TEST(_filename, _flags, _offset, _flag, _msg)     \
   b = get_bson (_filename);                                       \
   BSON_ASSERT (!bson_validate (b, _flags, &offset));              \
   ASSERT_CMPSIZE_T (offset, ==, (size_t) _offset);                \
   BSON_ASSERT (!bson_validate_with_error (b, _flags, &error));    \
   ASSERT_ERROR_CONTAINS (error, BSON_ERROR_INVALID, _flag, _msg); \
   bson_destroy (b)

   VALIDATE_TEST ('overflow2.bson',
                  BSON_VALIDATE_NONE,
                  9,
                  BSON_VALIDATE_NONE,
                  'corrupt BSON');
   VALIDATE_TEST ('trailingnull.bson',
                  BSON_VALIDATE_NONE,
                  14,
                  BSON_VALIDATE_NONE,
                  'corrupt BSON');
   VALIDATE_TEST ('dollarquery.bson',
                  BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS,
                  4,
                  BSON_VALIDATE_DOLLAR_KEYS,
                  'keys cannot begin with \'$\': \'$query\'');
   VALIDATE_TEST ('dotquery.bson',
                  BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS,
                  4,
                  BSON_VALIDATE_DOT_KEYS,
                  'keys cannot contain \'.\': \'abc.def\'');
   VALIDATE_TEST ('overflow3.bson',
                  BSON_VALIDATE_NONE,
                  9,
                  BSON_VALIDATE_NONE,
                  'corrupt BSON');
   /* same outcome as above, despite different flags */
   VALIDATE_TEST ('overflow3.bson',
                  BSON_VALIDATE_UTF8,
                  9,
                  BSON_VALIDATE_NONE,
                  'corrupt BSON');
   VALIDATE_TEST ('overflow4.bson',
                  BSON_VALIDATE_NONE,
                  9,
                  BSON_VALIDATE_NONE,
                  'corrupt BSON');
   VALIDATE_TEST ('empty_key.bson',
                  BSON_VALIDATE_EMPTY_KEYS,
                  4,
                  BSON_VALIDATE_EMPTY_KEYS,
                  'empty key');
   VALIDATE_TEST (
      'test40.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test41.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test42.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test43.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test44.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test45.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test46.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test47.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test48.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test49.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST ('test50.bson',
                  BSON_VALIDATE_NONE,
                  10,
                  BSON_VALIDATE_NONE,
                  'corrupt code-with-scope');
   VALIDATE_TEST ('test51.bson',
                  BSON_VALIDATE_NONE,
                  10,
                  BSON_VALIDATE_NONE,
                  'corrupt code-with-scope');
   VALIDATE_TEST (
      'test52.bson', BSON_VALIDATE_NONE, 9, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST (
      'test53.bson', BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, 'corrupt BSON');
   VALIDATE_TEST ('test54.bson',
                  BSON_VALIDATE_NONE,
                  12,
                  BSON_VALIDATE_NONE,
                  'corrupt BSON');

   /* DBRef validation */
   b = BCON_NEW ('my_dbref',
                 '{',
                 '$ref',
                 BCON_UTF8 ('collection'),
                 '$id',
                 BCON_INT32 (1),
                 '}');
   BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
   BSON_ASSERT (
      bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
   bson_destroy (b);

   /* needs '$ref' before '$id' */
   b = BCON_NEW ('my_dbref', '{', '$id', BCON_INT32 (1), '}');
   BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
   BSON_ASSERT (
      !bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
   ASSERT_ERROR_CONTAINS (error,
                          BSON_ERROR_INVALID,
                          BSON_VALIDATE_DOLLAR_KEYS,
                          'keys cannot begin with \'$\': \'$id\'');
   bson_destroy (b);

   /* two $refs */
   b = BCON_NEW ('my_dbref',
                 '{',
                 '$ref',
                 BCON_UTF8 ('collection'),
                 '$ref',
                 BCON_UTF8 ('collection'),
                 '}');
   BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
   BSON_ASSERT (
      !bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
   ASSERT_ERROR_CONTAINS (error,
                          BSON_ERROR_INVALID,
                          BSON_VALIDATE_DOLLAR_KEYS,
                          'keys cannot begin with \'$\': \'$ref\'');
   bson_destroy (b);

   /* must not contain invalid key like 'extra' */
   b = BCON_NEW ('my_dbref',
                 '{',
                 '$ref',
                 BCON_UTF8 ('collection'),
                 'extra',
                 BCON_INT32 (2),
                 '$id',
                 BCON_INT32 (1),
                 '}');
   BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
   BSON_ASSERT (
      !bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
   ASSERT_ERROR_CONTAINS (error,
                          BSON_ERROR_INVALID,
                          BSON_VALIDATE_DOLLAR_KEYS,
                          'invalid key within DBRef subdocument: \'extra\'');
   bson_destroy (b);

#undef VALIDATE_TEST
}
",1,8206
mongodb/mongo-c-driver,0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,"const bson_oid_t *
bson_iter_oid (const bson_iter_t *iter) /* IN */
{
   BSON_ASSERT (iter);

   if (ITER_TYPE (iter) == BSON_TYPE_OID) {
      return bson_iter_oid_unsafe (iter);
   }

   return NULL;
}
",0,8207
mongodb/mongo-c-driver,0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,"static void
test_bson_initializer (void)
{
   bson_t b = BSON_INITIALIZER;

   BSON_ASSERT (bson_empty (&b));
   bson_append_bool (&b, 'foo', -1, true);
   BSON_ASSERT (!bson_empty (&b));
   bson_destroy (&b);
}
",0,8208
openvswitch/ovs,9237a63c47bd314b807cda0bd2216264e82edbe8,"static enum ofperr
decode_bundle(bool load, const struct nx_action_bundle *nab,
              const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,
              struct ofpbuf *ofpacts)
{
    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);
    struct ofpact_bundle *bundle;
    uint32_t slave_type;
    size_t slaves_size, i;
    enum ofperr error;

    bundle = ofpact_put_BUNDLE(ofpacts);

    bundle->n_slaves = ntohs(nab->n_slaves);
    bundle->basis = ntohs(nab->basis);
    bundle->fields = ntohs(nab->fields);
    bundle->algorithm = ntohs(nab->algorithm);
    slave_type = ntohl(nab->slave_type);
    slaves_size = ntohs(nab->len) - sizeof *nab;

    error = OFPERR_OFPBAC_BAD_ARGUMENT;
    if (!flow_hash_fields_valid(bundle->fields)) {
        VLOG_WARN_RL(&rl, 'unsupported fields %d', (int) bundle->fields);
    } else if (bundle->n_slaves > BUNDLE_MAX_SLAVES) {
        VLOG_WARN_RL(&rl, 'too many slaves');
    } else if (bundle->algorithm != NX_BD_ALG_HRW
               && bundle->algorithm != NX_BD_ALG_ACTIVE_BACKUP) {
        VLOG_WARN_RL(&rl, 'unsupported algorithm %d', (int) bundle->algorithm);
    } else if (slave_type != mf_nxm_header(MFF_IN_PORT)) {
        VLOG_WARN_RL(&rl, 'unsupported slave type %'PRIu16, slave_type);
    } else {
        error = 0;
    }

    if (!is_all_zeros(nab->zero, sizeof nab->zero)) {
        VLOG_WARN_RL(&rl, 'reserved field is nonzero');
        error = OFPERR_OFPBAC_BAD_ARGUMENT;
    }

    if (load) {
        bundle->dst.ofs = nxm_decode_ofs(nab->ofs_nbits);
        bundle->dst.n_bits = nxm_decode_n_bits(nab->ofs_nbits);
        error = mf_vl_mff_mf_from_nxm_header(ntohl(nab->dst), vl_mff_map,
                                             &bundle->dst.field, tlv_bitmap);
        if (error) {
            return error;
        }

        if (bundle->dst.n_bits < 16) {
            VLOG_WARN_RL(&rl, 'bundle_load action requires at least 16 bit '
                         'destination.');
            error = OFPERR_OFPBAC_BAD_ARGUMENT;
        }
    } else {
        if (nab->ofs_nbits || nab->dst) {
            VLOG_WARN_RL(&rl, 'bundle action has nonzero reserved fields');
            error = OFPERR_OFPBAC_BAD_ARGUMENT;
        }
    }

    if (slaves_size < bundle->n_slaves * sizeof(ovs_be16)) {
        VLOG_WARN_RL(&rl, 'Nicira action %s only has %'PRIuSIZE' bytes '
                     'allocated for slaves.  %'PRIuSIZE' bytes are required '
                     'for %'PRIu16' slaves.',
                     load ? 'bundle_load' : 'bundle', slaves_size,
                     bundle->n_slaves * sizeof(ovs_be16), bundle->n_slaves);
        error = OFPERR_OFPBAC_BAD_LEN;
    }

    for (i = 0; i < bundle->n_slaves; i++) {
        ofp_port_t ofp_port = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i]));
        ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port);
        bundle = ofpacts->header;
    }

    ofpact_finish_BUNDLE(ofpacts, &bundle);
    if (!error) {
        error = bundle_check(bundle, OFPP_MAX, NULL);
    }
    return error;
}
",1,8209
openvswitch/ovs,9237a63c47bd314b807cda0bd2216264e82edbe8,"static void
encode_WRITE_METADATA(const struct ofpact_metadata *metadata,
                      enum ofp_version ofp_version, struct ofpbuf *out)
{
    if (ofp_version == OFP10_VERSION) {
        struct nx_action_write_metadata *nawm;

        nawm = put_NXAST_WRITE_METADATA(out);
        nawm->metadata = metadata->metadata;
        nawm->mask = metadata->mask;
    } else {
        struct ofp11_instruction_write_metadata *oiwm;

        oiwm = instruction_put_OFPIT11_WRITE_METADATA(out);
        oiwm->metadata = metadata->metadata;
        oiwm->metadata_mask = metadata->mask;
    }
}
",0,8210
liblouis/liblouis,5e4089659bb49b3095fa541fa6387b4c40d7396e,"static int
matchCurrentInput(
		const InString *input, int pos, const widechar *passInstructions, int passIC) {
	int k;
	int kk = pos;
	for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)
		if (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])
			return 0;
	return 1;
}
",1,8211
liblouis/liblouis,5e4089659bb49b3095fa541fa6387b4c40d7396e,"	StringBufferPool *pool = malloc(sizeof(StringBufferPool));
	pool->size = MAXPASSBUF;
	pool->buffers = stringBuffers;
",0,8212
git/git,a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, 'submodule', &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    'disallowed submodule name: %s',
				    name);
	free(name);

	return 0;
}
",1,8213
git/git,a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,"void fsck_set_msg_types(struct fsck_options *options, const char *values)
{
	char *buf = xstrdup(values), *to_free = buf;
	int done = 0;

	while (!done) {
		int len = strcspn(buf, ' ,|'), equal;

		done = !buf[len];
		if (!len) {
			buf++;
			continue;
		}
		buf[len] = '\0';

		for (equal = 0;
		     equal < len && buf[equal] != '=' && buf[equal] != ':';
		     equal++)
			buf[equal] = tolower(buf[equal]);
		buf[equal] = '\0';

		if (!strcmp(buf, 'skiplist')) {
			if (equal == len)
				die('skiplist requires a path');
			init_skiplist(options, buf + equal + 1);
			buf += len + 1;
			continue;
		}

		if (equal == len)
			die('Missing '=': '%s'', buf);

		fsck_set_msg_type(options, buf, buf + equal + 1);
		buf += len + 1;
	}
	free(to_free);
}
",0,8214
uriparser/uriparser,864f5d4c127def386dd5cc926ad96934b297f04e,"		TEST_ADD(UriSuite::testQueryDissection_Bug3590761)
		TEST_ADD(UriSuite::testFreeCrash_Bug20080827)
		TEST_ADD(UriSuite::testParseInvalid_Bug16)
",1,8215
uriparser/uriparser,864f5d4c127def386dd5cc926ad96934b297f04e,"		TEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_3)
		TEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_4)
		TEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_1)
		TEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_12)
		TEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_2)
		TEST_ADD(UriSuite::testUriUserInfoHostPort3)
		TEST_ADD(UriSuite::testUriUserInfoHostPort4)
		TEST_ADD(UriSuite::testUriUserInfoHostPort5)
		TEST_ADD(UriSuite::testUriUserInfoHostPort6)
		TEST_ADD(UriSuite::testUriHostRegname)
		TEST_ADD(UriSuite::testUriHostIpFour1)
		TEST_ADD(UriSuite::testUriHostIpFour2)
		TEST_ADD(UriSuite::testUriHostIpSix1)
		TEST_ADD(UriSuite::testUriHostIpSix2)
		TEST_ADD(UriSuite::testUriHostIpFuture)
		TEST_ADD(UriSuite::testUriHostEmpty)
		TEST_ADD(UriSuite::testUriComponents)
		TEST_ADD(UriSuite::testUriComponents_Bug20070701)
		TEST_ADD(UriSuite::testEscaping)
		TEST_ADD(UriSuite::testUnescaping)
		TEST_ADD(UriSuite::testTrailingSlash)
		TEST_ADD(UriSuite::testAddBase)
		TEST_ADD(UriSuite::testToString)
		TEST_ADD(UriSuite::testToString_Bug1950126)
		TEST_ADD(UriSuite::testToStringCharsRequired)
		TEST_ADD(UriSuite::testToStringCharsRequired)
		TEST_ADD(UriSuite::testNormalizeSyntaxMaskRequired)
		TEST_ADD(UriSuite::testNormalizeSyntax)
		TEST_ADD(UriSuite::testNormalizeSyntaxComponents)
		TEST_ADD(UriSuite::testNormalizeCrash_Bug20080224)
		TEST_ADD(UriSuite::testFilenameUriConversion)
		TEST_ADD(UriSuite::testCrash_FreeUriMembers_Bug20080116)
		TEST_ADD(UriSuite::testCrash_Report2418192)
		TEST_ADD(UriSuite::testPervertedQueryString);
		TEST_ADD(UriSuite::testQueryStringEndingInEqualSign_NonBug32);
		TEST_ADD(UriSuite::testCrash_MakeOwner_Bug20080207)
		TEST_ADD(UriSuite::testQueryList)
		TEST_ADD(UriSuite::testQueryListPair)
		TEST_ADD(UriSuite::testQueryDissection_Bug3590761)
		TEST_ADD(UriSuite::testFreeCrash_Bug20080827)
		TEST_ADD(UriSuite::testParseInvalid_Bug16)
		TEST_ADD(UriSuite::testRangeComparison)
",1,8216
uriparser/uriparser,864f5d4c127def386dd5cc926ad96934b297f04e,"		TEST_ADD(UriSuite::testQueryListPair)
		TEST_ADD(UriSuite::testQueryDissection_Bug3590761)
		TEST_ADD(UriSuite::testFreeCrash_Bug20080827)
		TEST_ADD(UriSuite::testParseInvalid_Bug16)
		TEST_ADD(UriSuite::testRangeComparison)
		TEST_ADD(UriSuite::testRangeComparison_RemoveBaseUri_Issue19)
",1,8217
uriparser/uriparser,864f5d4c127def386dd5cc926ad96934b297f04e,"		TEST_ASSERT(testEscapingHelper(L'g\x0d', L'g%0D%0A', SPACE_TO_PLUS, NORMALIZE));
		TEST_ASSERT(testEscapingHelper(L'\x0dg', L'%0D%0Ag', SPACE_TO_PLUS, NORMALIZE));
		TEST_ASSERT(testEscapingHelper(L'\x0d', L'%0D', SPACE_TO_PLUS, KEEP_UNMODIFIED));
		TEST_ASSERT(testEscapingHelper(L'g\x0d', L'g%0D', SPACE_TO_PLUS, KEEP_UNMODIFIED));
		TEST_ASSERT(testEscapingHelper(L'\x0dg', L'%0Dg', SPACE_TO_PLUS, KEEP_UNMODIFIED));
",0,8218
uriparser/uriparser,864f5d4c127def386dd5cc926ad96934b297f04e,"
// Note the closing brackets! TODO
#define URI_TEST_IP_SIX_FAIL(x) TEST_ASSERT(URI_FALSE == uri_TESTING_ONLY_ParseIpSixA(x ']'))
",0,8219
uriparser/uriparser,864f5d4c127def386dd5cc926ad96934b297f04e,"		uriFreeUriMembersA(&uriA);
	}

	void testUriUserInfoHostPort5() {
		// No user info, no port
",0,8220
sass/libsass,3d5dfefa189de3a106ac96c26aa263f8ca9727bb,"    Selector_List_Obj get_arg_sels(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, Context& ctx) {
      Expression_Obj exp = ARG(argname, Expression);
      if (exp->concrete_type() == Expression::NULL_VAL) {
        std::stringstream msg;
        msg << argname << ': null is not a valid selector: it must be a string,\n';
        msg << 'a list of strings, or a list of lists of strings for `' << function_name(sig) << ''';
        error(msg.str(), exp->pstate(), traces);
      }
      if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {
        str->quote_mark(0);
      }
      std::string exp_src = exp->to_string(ctx.c_options);
      return Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
    }
",1,8221
sass/libsass,3d5dfefa189de3a106ac96c26aa263f8ca9727bb,"    Compound_Selector_Obj get_arg_sel(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, Context& ctx) {
      Expression_Obj exp = ARG(argname, Expression);
      if (exp->concrete_type() == Expression::NULL_VAL) {
        std::stringstream msg;
        msg << argname << ': null is not a string for `' << function_name(sig) << ''';
        error(msg.str(), exp->pstate(), traces);
      }
      if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {
        str->quote_mark(0);
      }
      std::string exp_src = exp->to_string(ctx.c_options);
      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
      if (sel_list->length() == 0) return {};
      Complex_Selector_Obj first = sel_list->first();
      if (!first->tail()) return first->head();
      return first->tail()->head();
    }
",1,8222
sass/libsass,3d5dfefa189de3a106ac96c26aa263f8ca9727bb,"    double get_arg_val(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces)
    {
      Number_Ptr val = get_arg<Number>(argname, env, sig, pstate, traces);
      Number tmpnr(val);
      tmpnr.reduce();
      return tmpnr.value();
    }
",0,8223
sass/libsass,3d5dfefa189de3a106ac96c26aa263f8ca9727bb,"    double get_arg_r(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, double lo, double hi)
    {
      Number_Ptr val = get_arg<Number>(argname, env, sig, pstate, traces);
      Number tmpnr(val);
      tmpnr.reduce();
      double v = tmpnr.value();
      if (!(lo <= v && v <= hi)) {
        std::stringstream msg;
        msg << 'argument `' << argname << '` of `' << sig << '` must be between ';
        msg << lo << ' and ' << hi;
        error(msg.str(), pstate, traces);
      }
      return v;
    }
",0,8224
dbry/WavPack,070ef6f138956d9ea9612e69586152339dbefe51,"int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)
{
    uint32_t flags, bps = 0;
    uint32_t chan_mask = config->channel_mask;
    int num_chans = config->num_channels;
    int i;

    wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;

    if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {
#ifdef ENABLE_DSD
        wpc->dsd_multiplier = 1;
        flags = DSD_FLAG;

        for (i = 14; i >= 0; --i)
            if (config->sample_rate % sample_rates [i] == 0) {
                int divisor = config->sample_rate / sample_rates [i];

                if (divisor && (divisor & (divisor - 1)) == 0) {
                    config->sample_rate /= divisor;
                    wpc->dsd_multiplier = divisor;
                    break;
                }
            }

        // most options that don't apply to DSD we can simply ignore for now, but NOT hybrid mode!
        if (config->flags & CONFIG_HYBRID_FLAG) {
            strcpy (wpc->error_message, 'hybrid mode not available for DSD!');
            return FALSE;
        }

        // with DSD, very few PCM options work (or make sense), so only allow those that do
        config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);
        config->float_norm_exp = config->xmode = 0;
#else
        strcpy (wpc->error_message, 'libwavpack not configured for DSD!');
        return FALSE;
#endif
    }
    else
        flags = config->bytes_per_sample - 1;

    wpc->total_samples = total_samples;
    wpc->config.sample_rate = config->sample_rate;
    wpc->config.num_channels = config->num_channels;
    wpc->config.channel_mask = config->channel_mask;
    wpc->config.bits_per_sample = config->bits_per_sample;
    wpc->config.bytes_per_sample = config->bytes_per_sample;
    wpc->config.block_samples = config->block_samples;
    wpc->config.flags = config->flags;
    wpc->config.qmode = config->qmode;

    if (config->flags & CONFIG_VERY_HIGH_FLAG)
        wpc->config.flags |= CONFIG_HIGH_FLAG;

    for (i = 0; i < 15; ++i)
        if (wpc->config.sample_rate == sample_rates [i])
            break;

    flags |= i << SRATE_LSB;

    // all of this stuff only applies to PCM

    if (!(flags & DSD_FLAG)) {
        if (config->float_norm_exp) {
            wpc->config.float_norm_exp = config->float_norm_exp;
            wpc->config.flags |= CONFIG_FLOAT_DATA;
            flags |= FLOAT_DATA;
        }
        else
            flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;

        if (config->flags & CONFIG_HYBRID_FLAG) {
            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;

            if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {
                wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;
                flags |= HYBRID_SHAPE | NEW_SHAPING;
            }
            else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {
                wpc->config.shaping_weight = config->shaping_weight;
                flags |= HYBRID_SHAPE | NEW_SHAPING;
            }

            if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))
                flags |= CROSS_DECORR;

            if (config->flags & CONFIG_BITRATE_KBPS) {
                bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);

                if (bps > (64 << 8))
                    bps = 64 << 8;
            }
            else
                bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);
        }
        else
            flags |= CROSS_DECORR;

        if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))
            flags |= JOINT_STEREO;

        if (config->flags & CONFIG_CREATE_WVC)
            wpc->wvc_flag = TRUE;
    }

    // if a channel-identities string was specified, process that here, otherwise all channels
    // not present in the channel mask are considered 'unassigned'

    if (chan_ids) {
        int lastchan = 0, mask_copy = chan_mask;

        if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!
            strcpy (wpc->error_message, 'chan_ids longer than num channels!');
            return FALSE;
        }

        // skip past channels that are specified in the channel mask (no reason to store those)

        while (*chan_ids)
            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                mask_copy &= ~(1 << (*chan_ids-1));
                lastchan = *chan_ids++;
            }
            else
                break;

        // now scan the string for an actually defined channel (and don't store if there aren't any)

        for (i = 0; chan_ids [i]; i++)
            if (chan_ids [i] != 0xff) {
                wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);
                break;
            }
    }

    // This loop goes through all the channels and creates the Wavpack 'streams' for them to go in.
    // A stream can hold either one or two channels, so we have several rules to determine how many
    // channels will go in each stream.

    for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {
        WavpackStream *wps = malloc (sizeof (WavpackStream));
        unsigned char left_chan_id = 0, right_chan_id = 0;
        int pos, chans = 1;

        // allocate the stream and initialize the pointer to it
        wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));
        wpc->streams [wpc->current_stream] = wps;
        CLEAR (*wps);

        // if there are any bits [still] set in the channel_mask, get the next one or two IDs from there
        if (chan_mask)
            for (pos = 0; pos < 32; ++pos)
                if (chan_mask & (1 << pos)) {
                    if (left_chan_id) {
                        right_chan_id = pos + 1;
                        break;
                    }
                    else {
                        chan_mask &= ~(1 << pos);
                        left_chan_id = pos + 1;
                    }
                }

        // next check for any channels identified in the channel-identities string
        while (!right_chan_id && chan_ids && *chan_ids)
            if (left_chan_id)
                right_chan_id = *chan_ids;
            else
                left_chan_id = *chan_ids++;

        // assume anything we did not get is 'unassigned'
        if (!left_chan_id)
            left_chan_id = right_chan_id = 0xff;
        else if (!right_chan_id)
            right_chan_id = 0xff;

        // if we have 2 channels, this is where we decide if we can combine them into one stream:
        // 1. they are 'unassigned' and we've been told to combine unassigned pairs, or
        // 2. they appear together in the valid 'pairings' list
        if (num_chans >= 2) {
            if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)
                chans = 2;
            else
                for (i = 0; i < NUM_STEREO_PAIRS; ++i)
                    if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||
                        (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {
                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                chan_mask &= ~(1 << (right_chan_id-1));
                            else if (chan_ids && *chan_ids == right_chan_id)
                                chan_ids++;

                            chans = 2;
                            break;
                        }
        }

        num_chans -= chans;

        if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)
            break;

        memcpy (wps->wphdr.ckID, 'wvpk', 4);
        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;
        SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);
        wps->wphdr.version = wpc->stream_version;
        wps->wphdr.flags = flags;
        wps->bits = bps;

        if (!wpc->current_stream)
            wps->wphdr.flags |= INITIAL_BLOCK;

        if (!num_chans)
            wps->wphdr.flags |= FINAL_BLOCK;

        if (chans == 1) {
            wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);
            wps->wphdr.flags |= MONO_FLAG;
        }
    }

    wpc->num_streams = wpc->current_stream;
    wpc->current_stream = 0;

    if (num_chans) {
        strcpy (wpc->error_message, 'too many channels!');
        return FALSE;
    }

    if (config->flags & CONFIG_EXTRA_MODE)
        wpc->config.xmode = config->xmode ? config->xmode : 1;

    return TRUE;
}
",1,8225
dbry/WavPack,070ef6f138956d9ea9612e69586152339dbefe51,"WavpackContext *WavpackOpenFileOutput (WavpackBlockOutput blockout, void *wv_id, void *wvc_id)
{
    WavpackContext *wpc = malloc (sizeof (WavpackContext));

    if (!wpc)
        return NULL;

    CLEAR (*wpc);
    wpc->total_samples = -1;
",0,8226
dbry/WavPack,bba5389dc598a92bdf2b297c3ea34620b6679b5b,"int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)
{
    WavpackHeader *wphdr = (WavpackHeader *) buffer;
    uint32_t checksum_passed = 0, bcount, meta_bc;
    unsigned char *dp, meta_id, c1, c2;

    if (strncmp (wphdr->ckID, 'wvpk', 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))
        return FALSE;

    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;
    dp = (unsigned char *)(wphdr + 1);

    while (bcount >= 2) {
        meta_id = *dp++;
        c1 = *dp++;

        meta_bc = c1 << 1;
        bcount -= 2;

        if (meta_id & ID_LARGE) {
            if (bcount < 2)
                return FALSE;

            c1 = *dp++;
            c2 = *dp++;
            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);
            bcount -= 2;
        }

        if (bcount < meta_bc)
            return FALSE;

        if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {
#ifdef BITSTREAM_SHORTS
            uint16_t *csptr = (uint16_t*) buffer;
#else
            unsigned char *csptr = buffer;
#endif
            int wcount = (int)(dp - 2 - buffer) >> 1;
            uint32_t csum = (uint32_t) -1;

            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)
                return FALSE;

#ifdef BITSTREAM_SHORTS
            while (wcount--)
                csum = (csum * 3) + *csptr++;
#else
            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);

            while (wcount--) {
                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);
                csptr += 2;
            }

            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);
#endif

            if (meta_bc == 4) {
                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))
                    return FALSE;
            }
            else {
                csum ^= csum >> 16;

                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))
                    return FALSE;
            }

            checksum_passed++;
        }

        bcount -= meta_bc;
        dp += meta_bc;
    }

    return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);
}
",1,8227
dbry/WavPack,bba5389dc598a92bdf2b297c3ea34620b6679b5b,"
    wpc->filelen = wpc->reader->get_length (wpc->wv_in);
",0,8228
radare/radare2,f17bfd9f1da05f30f23a4dd05e9d2363e1406948,"static int opmov(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	st64 offset = 0;
	int mod = 0;
	int base = 0;
	int rex = 0;
	ut64 immediate = 0;
	if (op->operands[1].type & OT_CONSTANT) {
		if (!op->operands[1].is_good_flag) {
			return -1;
		}
		if (op->operands[1].immediate == -1) {
			return -1;
		}
		immediate = op->operands[1].immediate * op->operands[1].sign;
		if (op->operands[0].type & OT_GPREG && !(op->operands[0].type & OT_MEMORY)) {
			if (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD))) {
				if (!(op->operands[1].type & OT_CONSTANT) && op->operands[1].extended) {
					data[l++] = 0x49;
				} else {
					data[l++] = 0x48;
				}
			} else if (op->operands[0].extended) {
				data[l++] = 0x41;
			}
			if (op->operands[0].type & OT_WORD) {
				if (a->bits > 16) {
					data[l++] = 0x66;
				}
			}
			if (op->operands[0].type & OT_BYTE) {
				data[l++] = 0xb0 | op->operands[0].reg;
				data[l++] = immediate;
			} else {
				if (a->bits == 64 &&
					((op->operands[0].type & OT_QWORD) |
					(op->operands[1].type & OT_QWORD)) &&
					immediate < UT32_MAX) {
						data[l++] = 0xc7;
				 		data[l++] = 0xc0 | op->operands[0].reg;
				} else {
					data[l++] = 0xb8 | op->operands[0].reg;
				}
				data[l++] = immediate;
				data[l++] = immediate >> 8;
				if (!(op->operands[0].type & OT_WORD)) {
					data[l++] = immediate >> 16;
					data[l++] = immediate >> 24;
				}
				if (a->bits == 64 && immediate > UT32_MAX) {
					data[l++] = immediate >> 32;
					data[l++] = immediate >> 40;
					data[l++] = immediate >> 48;
					data[l++] = immediate >> 56;
				}
			}
		} else if (op->operands[0].type & OT_MEMORY) {
			if (!op->operands[0].explicit_size) {
				if (op->operands[0].type & OT_GPREG) {
					((Opcode *)op)->operands[0].dest_size = op->operands[0].reg_size;
				} else {
					return -1;
				}
			}

			int dest_bits = 8 * ((op->operands[0].dest_size & ALL_SIZE) >> OPSIZE_SHIFT);
			int reg_bits = 8 * ((op->operands[0].reg_size & ALL_SIZE) >> OPSIZE_SHIFT);
			int offset = op->operands[0].offset * op->operands[0].offset_sign;

			//addr_size_override prefix
			bool use_aso = false;
			if (reg_bits < a->bits) {
				use_aso = true;
			}

			//op_size_override prefix
			bool use_oso = false;
			if (dest_bits == 16) {
				use_oso = true;
			}

			bool rip_rel = op->operands[0].regs[0] == X86R_RIP;

			//rex prefix
			int rex = 1 << 6;
			bool use_rex = false;
			if (dest_bits == 64) {			//W field
				use_rex = true;
				rex |= 1 << 3;
			}
			if (op->operands[0].extended) {		//B field
				use_rex = true;
				rex |= 1;
			}

			//opcode selection
			int opcode;
			if (dest_bits == 8) {
				opcode = 0xc6;
			} else {
				opcode = 0xc7;
			}

			//modrm and SIB selection
			int modrm = 0;
			int mod;
			int reg = 0;
			int rm;
			bool use_sib = false;
			int sib;
			//mod
			if (offset == 0) {
				mod = 0;
			} else if (offset < 128 && offset > -129) {
				mod = 1;
			} else {
				mod = 2;
			}

			if (reg_bits == 16) {
				if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {
					rm = B0000;
				} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {
					rm = B0001;
				} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {
					rm = B0010;
				} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {
					rm = B0011;
				} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {
					rm = B0100;
				} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {
					rm = B0101;
				} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {
					rm = B0111;
				} else {
					//TODO allow for displacement only when parser is reworked
					return -1;
				}
				modrm = (mod << 6) | (reg << 3) | rm;
			} else {
				//rm
				if (op->operands[0].extended) {
					rm = op->operands[0].reg;
				} else {
					rm = op->operands[0].regs[0];
				}
				//[epb] alone is illegal, so we need to fake a [ebp+0]
				if (rm == 5 && mod == 0) {
					mod = 1;
				}

				//sib
				int index = op->operands[0].regs[1];
				int scale = getsib(op->operands[0].scale[1]);
				if (index != -1) {
					use_sib = true;
					sib = (scale << 6) | (index << 3) | rm;
				} else if (rm == 4) {
					use_sib = true;
					sib = 0x24;
				}
				if (use_sib) {
					rm = B0100;
				}
				if (rip_rel) {
					modrm = (B0000 << 6) | (reg << 3) | B0101;
					sib = (scale << 6) | (B0100 << 3) | B0101;
				} else {
					modrm = (mod << 6) | (reg << 3) | rm;
				}
			}

			//build the final result
			if (use_aso) {
				data[l++] = 0x67;
			}
			if (use_oso) {
				data[l++] = 0x66;
			}
			if (use_rex) {
				data[l++] = rex;
			}
			data[l++] = opcode;
			data[l++] = modrm;
			if (use_sib) {
				data[l++] = sib;
			}
			//offset
			if (mod == 1) {
				data[l++] = offset;
			} else if (reg_bits == 16 && mod == 2) {
				data[l++] = offset;
				data[l++] = offset >> 8;
			} else if (mod == 2 || rip_rel) {
				data[l++] = offset;
				data[l++] = offset >> 8;
				data[l++] = offset >> 16;
				data[l++] = offset >> 24;
			}
			//immediate
			int byte;
			for (byte = 0; byte < dest_bits && byte < 32; byte += 8) {
				data[l++] = (immediate >> byte);
			}
		}
	} else if (op->operands[1].type & OT_REGALL &&
			 !(op->operands[1].type & OT_MEMORY)) {
		if (op->operands[0].type & OT_CONSTANT) {
			return -1;
		}
		if (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG &&
		    op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {
				return -1;
		}
		// Check reg sizes match
		if (op->operands[0].type & OT_REGTYPE && op->operands[1].type & OT_REGTYPE) {
			if (!((op->operands[0].type & ALL_SIZE) &
			(op->operands[1].type & ALL_SIZE))) {
				return -1;
			}
		}

		if (a->bits == 64) {
			if (op->operands[0].extended) {
				rex = 1;
			}
			if (op->operands[1].extended) {
				rex += 4;
			}
			if (op->operands[1].type & OT_QWORD) {
				if (!(op->operands[0].type & OT_QWORD)) {
					data[l++] = 0x67;
					data[l++] = 0x48;
				}
			}
			if (op->operands[1].type & OT_QWORD &&
				op->operands[0].type & OT_QWORD) {
				data[l++] = 0x48 | rex;
			}
			if (op->operands[1].type & OT_DWORD &&
				op->operands[0].type & OT_DWORD) {
				data[l++] = 0x40 | rex;
			}
		} else if (op->operands[0].extended && op->operands[1].extended) {
			data[l++] = 0x45;
		}
		offset = op->operands[0].offset * op->operands[0].offset_sign;
		if (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {
			data[l++] = 0x8c;
		} else {
			if (op->operands[0].type & OT_WORD) {
				data[l++] = 0x66;
			}
			data[l++] = (op->operands[0].type & OT_BYTE) ? 0x88 : 0x89;
		}

		if (op->operands[0].scale[0] > 1) {
				data[l++] = op->operands[1].reg << 3 | 4;
				data[l++] = getsib (op->operands[0].scale[0]) << 6 |
						    op->operands[0].regs[0] << 3 | 5;

				data[l++] = offset;
				data[l++] = offset >> 8;
				data[l++] = offset >> 16;
				data[l++] = offset >> 24;

				return l;
			}

		if (!(op->operands[0].type & OT_MEMORY)) {
			if (op->operands[0].reg == X86R_UNDEFINED ||
				op->operands[1].reg == X86R_UNDEFINED) {
				return -1;
			}
			mod = 0x3;
			data[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].reg;
		} else if (op->operands[0].regs[0] == X86R_UNDEFINED) {
			data[l++] = op->operands[1].reg << 3 | 0x5;
			data[l++] = offset;
			data[l++] = offset >> 8;
			data[l++] = offset >> 16;
			data[l++] = offset >> 24;
		} else {
			if (op->operands[0].type & OT_MEMORY) {
				if (op->operands[0].regs[1] != X86R_UNDEFINED) {
					data[l++] = op->operands[1].reg << 3 | 0x4;
					data[l++] = op->operands[0].regs[1] << 3 | op->operands[0].regs[0];
					return l;
				}
				if (offset) {
					mod = (offset > 128 || offset < -129) ? 0x2 : 0x1;
				}
				if (op->operands[0].regs[0] == X86R_EBP) {
					mod = 0x2;
				}
				data[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].regs[0];
				if (op->operands[0].regs[0] == X86R_ESP) {
					data[l++] = 0x24;
				}
				if (offset) {
					data[l++] = offset;
				}
				if (mod == 2) {
					// warning C4293: '>>': shift count negative or too big, undefined behavior
					data[l++] = offset >> 8;
					data[l++] = offset >> 16;
					data[l++] = offset >> 24;
				}
			}
		}
	} else if (op->operands[1].type & OT_MEMORY) {
		if (op->operands[0].type & OT_MEMORY) {
			return -1;
		}
		offset = op->operands[1].offset * op->operands[1].offset_sign;
		if (op->operands[0].reg == X86R_EAX && op->operands[1].regs[0] == X86R_UNDEFINED) {
			if (a->bits == 64) {
				data[l++] = 0x48;
			}
			if (op->operands[0].type & OT_BYTE) {
				data[l++] = 0xa0;
			} else {
				data[l++] = 0xa1;
			}
			data[l++] = offset;
			data[l++] = offset >> 8;
			data[l++] = offset >> 16;
			data[l++] = offset >> 24;
			if (a->bits == 64) {
				data[l++] = offset >> 32;
				data[l++] = offset >> 40;
				data[l++] = offset >> 48;
				data[l++] = offset >> 54;
			}
			return l;
		}
		if (op->operands[0].type & OT_BYTE && a->bits == 64 && op->operands[1].regs[0]) {
			if (op->operands[1].regs[0] >= X86R_R8 &&
			    op->operands[0].reg < 4) {
				data[l++] = 0x41;
				data[l++] = 0x8a;
				data[l++] = op->operands[0].reg << 3 | (op->operands[1].regs[0] - 8);
				return l;
			}
			return -1;
		}

		if (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {
			if (op->operands[1].scale[0] == 0) {
				return -1;
			}
			data[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0]];
			data[l++] = 0x8b;
			data[l++] = op->operands[0].reg << 3 | 0x5;
			data[l++] = offset;
			data[l++] = offset >> 8;
			data[l++] = offset >> 16;
			data[l++] = offset >> 24;
			return l;
		}

		if (a->bits == 64) {
			if (op->operands[0].type & OT_QWORD) {
				if (!(op->operands[1].type & OT_QWORD)) {
					if (op->operands[1].regs[0] != -1) {
						data[l++] = 0x67;
					}
					data[l++] = 0x48;
				}
			} else if (op->operands[1].type & OT_DWORD) {
				data[l++] = 0x44;
			} else if (!(op->operands[1].type & OT_QWORD)) {
				data[l++] = 0x67;
			}
			if (op->operands[1].type & OT_QWORD &&
				op->operands[0].type & OT_QWORD) {
				data[l++] = 0x48;
			}
		}

		if (op->operands[0].type & OT_WORD) {
			data[l++] = 0x66;
			data[l++] = op->operands[1].type & OT_BYTE ? 0x8a : 0x8b;
		} else {
			data[l++] = (op->operands[1].type & OT_BYTE ||
				op->operands[0].type & OT_BYTE) ?
				0x8a : 0x8b;
		}

		if (op->operands[1].regs[0] == X86R_UNDEFINED) {
			if (a->bits == 64) {
				data[l++] = op->operands[0].reg << 3 | 0x4;
				data[l++] = 0x25;
			} else {
				data[l++] = op->operands[0].reg << 3 | 0x5;
			}
			data[l++] = offset;
			data[l++] = offset >> 8;
			data[l++] = offset >> 16;
			data[l++] = offset >> 24;
		} else {
			if (op->operands[1].scale[0] > 1) {
				data[l++] = op->operands[0].reg << 3 | 4;

				if (op->operands[1].scale[0] >= 2) {
					base = 5;
				}
				if (base) {
					data[l++] = getsib (op->operands[1].scale[0]) << 6 | op->operands[1].regs[0] << 3 | base;
				} else {
					data[l++] = getsib (op->operands[1].scale[0]) << 3 | op->operands[1].regs[0];
				}
				if (offset || base) {
					data[l++] = offset;
					data[l++] = offset >> 8;
					data[l++] = offset >> 16;
					data[l++] = offset >> 24;
				}
				return l;
			}
			if (op->operands[1].regs[1] != X86R_UNDEFINED) {
				data[l++] = op->operands[0].reg << 3 | 0x4;
				data[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];
				return l;
			}

			if (offset || op->operands[1].regs[0] == X86R_EBP) {
				mod = 0x2;
				if (op->operands[1].offset > 127) {
					mod = 0x4;
				}
			}
			if (a->bits == 64 && offset && op->operands[0].type & OT_QWORD) {
				if (op->operands[1].regs[0] == X86R_RIP) {
					data[l++] = 0x5;
				} else {
					if (op->operands[1].offset > 127) {
						data[l++] = 0x80 | op->operands[0].reg << 3 | op->operands[1].regs[0];
					} else {
						data[l++] = 0x40 | op->operands[1].regs[0];
					}
				}
				if (op->operands[1].offset > 127) {
					mod = 0x1;
				}
			} else {
				if (op->operands[1].regs[0] == X86R_EIP && (op->operands[0].type & OT_DWORD)) {
					data[l++] = 0x0d;
				} else if (op->operands[1].regs[0] == X86R_RIP && (op->operands[0].type & OT_QWORD)) {
					data[l++] = 0x05;
				} else {
					data[l++] = mod << 5 | op->operands[0].reg << 3 | op->operands[1].regs[0];
				}
			}
			if (op->operands[1].regs[0] == X86R_ESP) {
				data[l++] = 0x24;
			}
			if (mod >= 0x2) {
				data[l++] = offset;
				if (op->operands[1].offset > 128 || op->operands[1].regs[0] == X86R_EIP) {
					data[l++] = offset >> 8;
					data[l++] = offset >> 16;
					data[l++] = offset >> 24;
				}
			} else if (a->bits == 64 && (offset || op->operands[1].regs[0] == X86R_RIP)) {
				data[l++] = offset;
				if (op->operands[1].offset > 127 || op->operands[1].regs[0] == X86R_RIP) {
					data[l++] = offset >> 8;
					data[l++] = offset >> 16;
					data[l++] = offset >> 24;
				}
			}
		}
	}
	return l;
}
",1,8229
radare/radare2,f17bfd9f1da05f30f23a4dd05e9d2363e1406948,"static int opfstenv(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			data[l++] = 0x9b;
			data[l++] = 0xd9;
			data[l++] = 0x30 | op->operands[0].regs[0];
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
",0,8230
FFmpeg/FFmpeg,cced03dd667a5df6df8fd40d8de0bff477ee02e8,"int ff_mms_asf_header_parser(MMSContext *mms)
{
    uint8_t *p = mms->asf_header;
    uint8_t *end;
    int flags, stream_id;
    mms->stream_num = 0;

    if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||
        memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {
        av_log(NULL, AV_LOG_ERROR,
               'Corrupt stream (invalid ASF header, size=%d)\n',
               mms->asf_header_size);
        return AVERROR_INVALIDDATA;
    }

    end = mms->asf_header + mms->asf_header_size;

    p += sizeof(ff_asf_guid) + 14;
    while(end - p >= sizeof(ff_asf_guid) + 8) {
        uint64_t chunksize;
        if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {
            chunksize = 50; // see Reference [2] section 5.1
        } else {
            chunksize = AV_RL64(p + sizeof(ff_asf_guid));
        }
        if (!chunksize || chunksize > end - p) {
            av_log(NULL, AV_LOG_ERROR,
                   'Corrupt stream (header chunksize %'PRId64' is invalid)\n',
                   chunksize);
            return AVERROR_INVALIDDATA;
        }
        if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {
            /* read packet size */
            if (end - p > sizeof(ff_asf_guid) * 2 + 68) {
                mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);
                if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {
                    av_log(NULL, AV_LOG_ERROR,
                           'Corrupt stream (too large pkt_len %d)\n',
                           mms->asf_packet_len);
                    return AVERROR_INVALIDDATA;
                }
            }
        } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {
            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
            stream_id = flags & 0x7F;
            //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,
            //we can calculate the packet size by stream_num.
            //Please see function send_stream_selection_request().
            if (mms->stream_num < MMS_MAX_STREAMS &&
                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {
                mms->streams = av_fast_realloc(mms->streams,
                                   &mms->nb_streams_allocated,
                                   (mms->stream_num + 1) * sizeof(MMSStream));
                if (!mms->streams)
                    return AVERROR(ENOMEM);
                mms->streams[mms->stream_num].id = stream_id;
                mms->stream_num++;
            } else {
                av_log(NULL, AV_LOG_ERROR,
                       'Corrupt stream (too many A/V streams)\n');
                return AVERROR_INVALIDDATA;
            }
        } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {
            if (end - p >= 88) {
                int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);
                uint64_t skip_bytes = 88;
                while (stream_count--) {
                    if (end - p < skip_bytes + 4) {
                        av_log(NULL, AV_LOG_ERROR,
                               'Corrupt stream (next stream name length is not in the buffer)\n');
                        return AVERROR_INVALIDDATA;
                    }
                    skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);
                }
                while (ext_len_count--) {
                    if (end - p < skip_bytes + 22) {
                        av_log(NULL, AV_LOG_ERROR,
                               'Corrupt stream (next extension system info length is not in the buffer)\n');
                        return AVERROR_INVALIDDATA;
                    }
                    skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);
                }
                if (end - p < skip_bytes) {
                    av_log(NULL, AV_LOG_ERROR,
                           'Corrupt stream (the last extension system info length is invalid)\n');
                    return AVERROR_INVALIDDATA;
                }
                if (chunksize - skip_bytes > 24)
                    chunksize = skip_bytes;
            }
        } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {
            chunksize = 46; // see references [2] section 3.4. This should be set 46.
        }
        p += chunksize;
    }

    return 0;
}
",1,8231
FFmpeg/FFmpeg,cced03dd667a5df6df8fd40d8de0bff477ee02e8,"int ff_mms_read_header(MMSContext *mms, uint8_t *buf, const int size)
{
    char *pos;
    int size_to_copy;
    int remaining_size = mms->asf_header_size - mms->asf_header_read_size;
    size_to_copy = FFMIN(size, remaining_size);
    pos = mms->asf_header + mms->asf_header_read_size;
    memcpy(buf, pos, size_to_copy);
    if (mms->asf_header_read_size == mms->asf_header_size) {
        av_freep(&mms->asf_header); // which contains asf header
    }
    mms->asf_header_read_size += size_to_copy;
    return size_to_copy;
}
",0,8232
FFmpeg/FFmpeg,bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,"static int mxf_parse_structural_metadata(MXFContext *mxf)
{
    MXFPackage *material_package = NULL;
    int i, j, k, ret;

    av_log(mxf->fc, AV_LOG_TRACE, 'metadata sets count %d\n', mxf->metadata_sets_count);
    /* TODO: handle multiple material packages (OP3x) */
    for (i = 0; i < mxf->packages_count; i++) {
        material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);
        if (material_package) break;
    }
    if (!material_package) {
        av_log(mxf->fc, AV_LOG_ERROR, 'no material package found\n');
        return AVERROR_INVALIDDATA;
    }

    mxf_add_umid_metadata(&mxf->fc->metadata, 'material_package_umid', material_package);
    if (material_package->name && material_package->name[0])
        av_dict_set(&mxf->fc->metadata, 'material_package_name', material_package->name, 0);
    mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);

    for (i = 0; i < material_package->tracks_count; i++) {
        MXFPackage *source_package = NULL;
        MXFTrack *material_track = NULL;
        MXFTrack *source_track = NULL;
        MXFTrack *temp_track = NULL;
        MXFDescriptor *descriptor = NULL;
        MXFStructuralComponent *component = NULL;
        MXFTimecodeComponent *mxf_tc = NULL;
        UID *essence_container_ul = NULL;
        const MXFCodecUL *codec_ul = NULL;
        const MXFCodecUL *container_ul = NULL;
        const MXFCodecUL *pix_fmt_ul = NULL;
        AVStream *st;
        AVTimecode tc;
        int flags;

        if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {
            av_log(mxf->fc, AV_LOG_ERROR, 'could not resolve material track strong ref\n');
            continue;
        }

        if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {
            mxf_tc = (MXFTimecodeComponent*)component;
            flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;
            if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {
                mxf_add_timecode_metadata(&mxf->fc->metadata, 'timecode', &tc);
            }
        }

        if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {
            av_log(mxf->fc, AV_LOG_ERROR, 'could not resolve material track sequence strong ref\n');
            continue;
        }

        for (j = 0; j < material_track->sequence->structural_components_count; j++) {
            component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);
            if (!component)
                continue;

            mxf_tc = (MXFTimecodeComponent*)component;
            flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;
            if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {
                mxf_add_timecode_metadata(&mxf->fc->metadata, 'timecode', &tc);
                break;
            }
        }

        /* TODO: handle multiple source clips, only finds first valid source clip */
        if(material_track->sequence->structural_components_count > 1)
            av_log(mxf->fc, AV_LOG_WARNING, 'material track %d: has %d components\n',
                       material_track->track_id, material_track->sequence->structural_components_count);

        for (j = 0; j < material_track->sequence->structural_components_count; j++) {
            component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);
            if (!component)
                continue;

            source_package = mxf_resolve_source_package(mxf, component->source_package_ul, component->source_package_uid);
            if (!source_package) {
                av_log(mxf->fc, AV_LOG_TRACE, 'material track %d: no corresponding source package found\n', material_track->track_id);
                continue;
            }
            for (k = 0; k < source_package->tracks_count; k++) {
                if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {
                    av_log(mxf->fc, AV_LOG_ERROR, 'could not resolve source track strong ref\n');
                    ret = AVERROR_INVALIDDATA;
                    goto fail_and_free;
                }
                if (temp_track->track_id == component->source_track_id) {
                    source_track = temp_track;
                    break;
                }
            }
            if (!source_track) {
                av_log(mxf->fc, AV_LOG_ERROR, 'material track %d: no corresponding source track found\n', material_track->track_id);
                break;
            }

            for (k = 0; k < mxf->essence_container_data_count; k++) {
                MXFEssenceContainerData *essence_data;

                if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {
                    av_log(mxf, AV_LOG_TRACE, 'could not resolve essence container data strong ref\n');
                    continue;
                }
                if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {
                    source_track->body_sid = essence_data->body_sid;
                    source_track->index_sid = essence_data->index_sid;
                    break;
                }
            }

            if(source_track && component)
                break;
        }
        if (!source_track || !component || !source_package) {
            if((ret = mxf_add_metadata_stream(mxf, material_track)))
                goto fail_and_free;
            continue;
        }

        if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {
            av_log(mxf->fc, AV_LOG_ERROR, 'could not resolve source track sequence strong ref\n');
            ret = AVERROR_INVALIDDATA;
            goto fail_and_free;
        }

        /* 0001GL00.MXF.A1.mxf_opatom.mxf has the same SourcePackageID as 0001GL.MXF.V1.mxf_opatom.mxf
         * This would result in both files appearing to have two streams. Work around this by sanity checking DataDefinition */
        if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {
            av_log(mxf->fc, AV_LOG_ERROR, 'material track %d: DataDefinition mismatch\n', material_track->track_id);
            continue;
        }

        st = avformat_new_stream(mxf->fc, NULL);
        if (!st) {
            av_log(mxf->fc, AV_LOG_ERROR, 'could not allocate stream\n');
            ret = AVERROR(ENOMEM);
            goto fail_and_free;
        }
        st->id = material_track->track_id;
        st->priv_data = source_track;

        source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);
        descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);

        /* A SourceClip from a EssenceGroup may only be a single frame of essence data. The clips duration is then how many
         * frames its suppose to repeat for. Descriptor->duration, if present, contains the real duration of the essence data */
        if (descriptor && descriptor->duration != AV_NOPTS_VALUE)
            source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);
        else
            source_track->original_duration = st->duration = component->duration;

        if (st->duration == -1)
            st->duration = AV_NOPTS_VALUE;
        st->start_time = component->start_position;
        if (material_track->edit_rate.num <= 0 ||
            material_track->edit_rate.den <= 0) {
            av_log(mxf->fc, AV_LOG_WARNING,
                   'Invalid edit rate (%d/%d) found on stream #%d, '
                   'defaulting to 25/1\n',
                   material_track->edit_rate.num,
                   material_track->edit_rate.den, st->index);
            material_track->edit_rate = (AVRational){25, 1};
        }
        avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);

        /* ensure SourceTrack EditRate == MaterialTrack EditRate since only
         * the former is accessible via st->priv_data */
        source_track->edit_rate = material_track->edit_rate;

        PRINT_KEY(mxf->fc, 'data definition   ul', source_track->sequence->data_definition_ul);
        codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);
        st->codecpar->codec_type = codec_ul->id;

        if (!descriptor) {
            av_log(mxf->fc, AV_LOG_INFO, 'source track %d: stream %d, no descriptor found\n', source_track->track_id, st->index);
            continue;
        }
        PRINT_KEY(mxf->fc, 'essence codec     ul', descriptor->essence_codec_ul);
        PRINT_KEY(mxf->fc, 'essence container ul', descriptor->essence_container_ul);
        essence_container_ul = &descriptor->essence_container_ul;
        source_track->wrapping = (mxf->op == OPAtom) ? ClipWrapped : mxf_get_wrapping_kind(essence_container_ul);
        if (source_track->wrapping == UnknownWrapped)
            av_log(mxf->fc, AV_LOG_INFO, 'wrapping of stream %d is unknown\n', st->index);
        /* HACK: replacing the original key with mxf_encrypted_essence_container
         * is not allowed according to s429-6, try to find correct information anyway */
        if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {
            av_log(mxf->fc, AV_LOG_INFO, 'broken encrypted mxf file\n');
            for (k = 0; k < mxf->metadata_sets_count; k++) {
                MXFMetadataSet *metadata = mxf->metadata_sets[k];
                if (metadata->type == CryptoContext) {
                    essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;
                    break;
                }
            }
        }

        /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */
        codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);
        st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;
        if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {
            codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);
            st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;
        }

        av_log(mxf->fc, AV_LOG_VERBOSE, '%s: Universal Label: ',
               avcodec_get_name(st->codecpar->codec_id));
        for (k = 0; k < 16; k++) {
            av_log(mxf->fc, AV_LOG_VERBOSE, '%.2x',
                   descriptor->essence_codec_ul[k]);
            if (!(k+1 & 19) || k == 5)
                av_log(mxf->fc, AV_LOG_VERBOSE, '.');
        }
        av_log(mxf->fc, AV_LOG_VERBOSE, '\n');

        mxf_add_umid_metadata(&st->metadata, 'file_package_umid', source_package);
        if (source_package->name && source_package->name[0])
            av_dict_set(&st->metadata, 'file_package_name', source_package->name, 0);
        if (material_track->name && material_track->name[0])
            av_dict_set(&st->metadata, 'track_name', material_track->name, 0);

        mxf_parse_physical_source_package(mxf, source_track, st);

        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
            source_track->intra_only = mxf_is_intra_only(descriptor);
            container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);
            if (st->codecpar->codec_id == AV_CODEC_ID_NONE)
                st->codecpar->codec_id = container_ul->id;
            st->codecpar->width = descriptor->width;
            st->codecpar->height = descriptor->height; /* Field height, not frame height */
            switch (descriptor->frame_layout) {
                case FullFrame:
                    st->codecpar->field_order = AV_FIELD_PROGRESSIVE;
                    break;
                case OneField:
                    /* Every other line is stored and needs to be duplicated. */
                    av_log(mxf->fc, AV_LOG_INFO, 'OneField frame layout isn't currently supported\n');
                    break; /* The correct thing to do here is fall through, but by breaking we might be
                              able to decode some streams at half the vertical resolution, rather than not al all.
                              It's also for compatibility with the old behavior. */
                case MixedFields:
                    break;
                case SegmentedFrame:
                    st->codecpar->field_order = AV_FIELD_PROGRESSIVE;
                case SeparateFields:
                    av_log(mxf->fc, AV_LOG_DEBUG, 'video_line_map: (%d, %d), field_dominance: %d\n',
                           descriptor->video_line_map[0], descriptor->video_line_map[1],
                           descriptor->field_dominance);
                    if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {
                        /* Detect coded field order from VideoLineMap:
                         *  (even, even) => bottom field coded first
                         *  (even, odd)  => top field coded first
                         *  (odd, even)  => top field coded first
                         *  (odd, odd)   => bottom field coded first
                         */
                        if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {
                            switch (descriptor->field_dominance) {
                                case MXF_FIELD_DOMINANCE_DEFAULT:
                                case MXF_FIELD_DOMINANCE_FF:
                                    st->codecpar->field_order = AV_FIELD_TT;
                                    break;
                                case MXF_FIELD_DOMINANCE_FL:
                                    st->codecpar->field_order = AV_FIELD_TB;
                                    break;
                                default:
                                    avpriv_request_sample(mxf->fc,
                                                          'Field dominance %d support',
                                                          descriptor->field_dominance);
                            }
                        } else {
                            switch (descriptor->field_dominance) {
                                case MXF_FIELD_DOMINANCE_DEFAULT:
                                case MXF_FIELD_DOMINANCE_FF:
                                    st->codecpar->field_order = AV_FIELD_BB;
                                    break;
                                case MXF_FIELD_DOMINANCE_FL:
                                    st->codecpar->field_order = AV_FIELD_BT;
                                    break;
                                default:
                                    avpriv_request_sample(mxf->fc,
                                                          'Field dominance %d support',
                                                          descriptor->field_dominance);
                            }
                        }
                    }
                    /* Turn field height into frame height. */
                    st->codecpar->height *= 2;
                    break;
                default:
                    av_log(mxf->fc, AV_LOG_INFO, 'Unknown frame layout type: %d\n', descriptor->frame_layout);
            }
            if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {
                st->codecpar->format = descriptor->pix_fmt;
                if (st->codecpar->format == AV_PIX_FMT_NONE) {
                    pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,
                                                  &descriptor->essence_codec_ul);
                    st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;
                    if (st->codecpar->format== AV_PIX_FMT_NONE) {
                        st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,
                                                                   &descriptor->essence_codec_ul)->id;
                        if (!st->codecpar->codec_tag) {
                            /* support files created before RP224v10 by defaulting to UYVY422
                               if subsampling is 4:2:2 and component depth is 8-bit */
                            if (descriptor->horiz_subsampling == 2 &&
                                descriptor->vert_subsampling == 1 &&
                                descriptor->component_depth == 8) {
                                st->codecpar->format = AV_PIX_FMT_UYVY422;
                            }
                        }
                    }
                }
            }
            st->need_parsing = AVSTREAM_PARSE_HEADERS;
            if (material_track->sequence->origin) {
                av_dict_set_int(&st->metadata, 'material_track_origin', material_track->sequence->origin, 0);
            }
            if (source_track->sequence->origin) {
                av_dict_set_int(&st->metadata, 'source_track_origin', source_track->sequence->origin, 0);
            }
            if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den)
                st->display_aspect_ratio = descriptor->aspect_ratio;
        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
            container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);
            /* Only overwrite existing codec ID if it is unset or A-law, which is the default according to SMPTE RP 224. */
            if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))
                st->codecpar->codec_id = (enum AVCodecID)container_ul->id;
            st->codecpar->channels = descriptor->channels;
            st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;

            if (descriptor->sample_rate.den > 0) {
                st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;
                avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);
            } else {
                av_log(mxf->fc, AV_LOG_WARNING, 'invalid sample rate (%d/%d) '
                       'found for stream #%d, time base forced to 1/48000\n',
                       descriptor->sample_rate.num, descriptor->sample_rate.den,
                       st->index);
                avpriv_set_pts_info(st, 64, 1, 48000);
            }

            /* if duration is set, rescale it from EditRate to SampleRate */
            if (st->duration != AV_NOPTS_VALUE)
                st->duration = av_rescale_q(st->duration,
                                            av_inv_q(material_track->edit_rate),
                                            st->time_base);

            /* TODO: implement AV_CODEC_ID_RAWAUDIO */
            if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {
                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)
                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;
                else if (descriptor->bits_per_sample == 32)
                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;
            } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {
                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)
                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;
                else if (descriptor->bits_per_sample == 32)
                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;
            } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {
                st->need_parsing = AVSTREAM_PARSE_FULL;
            }
        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {
            enum AVMediaType type;
            container_ul = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul);
            if (st->codecpar->codec_id == AV_CODEC_ID_NONE)
                st->codecpar->codec_id = container_ul->id;
            type = avcodec_get_type(st->codecpar->codec_id);
            if (type == AVMEDIA_TYPE_SUBTITLE)
                st->codecpar->codec_type = type;
            if (container_ul->desc)
                av_dict_set(&st->metadata, 'data_type', container_ul->desc, 0);
        }
        if (descriptor->extradata) {
            if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {
                memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);
            }
        } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {
            int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,
                                               &descriptor->essence_codec_ul)->id;
            if (coded_width)
                st->codecpar->width = coded_width;
            ret = ff_generate_avci_extradata(st);
            if (ret < 0)
                return ret;
        }
        if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && source_track->wrapping != FrameWrapped) {
            /* TODO: decode timestamps */
            st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;
        }
    }

    ret = 0;
fail_and_free:
    return ret;
}
",1,8233
FFmpeg/FFmpeg,bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,"        return AVERROR_INVALIDDATA;
    return size;
}
",0,8234
FFmpeg/FFmpeg,5aba5b89d0b1d73164d3b81764828bb8b20ff32a,"static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
{
    int i, j, v;

    if (get_bits1(gb)) {
        /* intra_quantiser_matrix */
        for (i = 0; i < 64; i++) {
            v = get_bits(gb, 8);
            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];
            s->intra_matrix[j]        = v;
            s->chroma_intra_matrix[j] = v;
        }
    }

    if (get_bits1(gb)) {
        /* non_intra_quantiser_matrix */
        for (i = 0; i < 64; i++) {
            get_bits(gb, 8);
        }
    }

    if (get_bits1(gb)) {
        /* chroma_intra_quantiser_matrix */
        for (i = 0; i < 64; i++) {
            v = get_bits(gb, 8);
            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];
            s->chroma_intra_matrix[j] = v;
        }
    }

    if (get_bits1(gb)) {
        /* chroma_non_intra_quantiser_matrix */
        for (i = 0; i < 64; i++) {
            get_bits(gb, 8);
        }
    }

    next_start_code_studio(gb);
}
",1,8235
FFmpeg/FFmpeg,5aba5b89d0b1d73164d3b81764828bb8b20ff32a,"static int mpeg4_decode_mb(MpegEncContext *s, int16_t block[6][64])
{
    Mpeg4DecContext *ctx = s->avctx->priv_data;
    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;
    int16_t *mot_val;
    static const int8_t quant_tab[4] = { -1, -2, 1, 2 };
    const int xy = s->mb_x + s->mb_y * s->mb_stride;

    av_assert2(s ==  (void*)ctx);
    av_assert2(s->h263_pred);

    if (s->pict_type == AV_PICTURE_TYPE_P ||
        s->pict_type == AV_PICTURE_TYPE_S) {
        do {
            if (get_bits1(&s->gb)) {
                /* skip mb */
                s->mb_intra = 0;
                for (i = 0; i < 6; i++)
                    s->block_last_index[i] = -1;
                s->mv_dir  = MV_DIR_FORWARD;
                s->mv_type = MV_TYPE_16X16;
                if (s->pict_type == AV_PICTURE_TYPE_S &&
                    ctx->vol_sprite_usage == GMC_SPRITE) {
                    s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |
                                                     MB_TYPE_GMC   |
                                                     MB_TYPE_16x16 |
                                                     MB_TYPE_L0;
                    s->mcsel       = 1;
                    s->mv[0][0][0] = get_amv(ctx, 0);
                    s->mv[0][0][1] = get_amv(ctx, 1);
                    s->mb_skipped  = 0;
                } else {
                    s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |
                                                     MB_TYPE_16x16 |
                                                     MB_TYPE_L0;
                    s->mcsel       = 0;
                    s->mv[0][0][0] = 0;
                    s->mv[0][0][1] = 0;
                    s->mb_skipped  = 1;
                }
                goto end;
            }
            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);
            if (cbpc < 0) {
                av_log(s->avctx, AV_LOG_ERROR,
                       'mcbpc damaged at %d %d\n', s->mb_x, s->mb_y);
                return AVERROR_INVALIDDATA;
            }
        } while (cbpc == 20);

        s->bdsp.clear_blocks(s->block[0]);
        dquant      = cbpc & 8;
        s->mb_intra = ((cbpc & 4) != 0);
        if (s->mb_intra)
            goto intra;

        if (s->pict_type == AV_PICTURE_TYPE_S &&
            ctx->vol_sprite_usage == GMC_SPRITE && (cbpc & 16) == 0)
            s->mcsel = get_bits1(&s->gb);
        else
            s->mcsel = 0;
        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1) ^ 0x0F;
        if (cbpy < 0) {
            av_log(s->avctx, AV_LOG_ERROR,
                   'P cbpy damaged at %d %d\n', s->mb_x, s->mb_y);
            return AVERROR_INVALIDDATA;
        }

        cbp = (cbpc & 3) | (cbpy << 2);
        if (dquant)
            ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);
        if ((!s->progressive_sequence) &&
            (cbp || (s->workaround_bugs & FF_BUG_XVID_ILACE)))
            s->interlaced_dct = get_bits1(&s->gb);

        s->mv_dir = MV_DIR_FORWARD;
        if ((cbpc & 16) == 0) {
            if (s->mcsel) {
                s->current_picture.mb_type[xy] = MB_TYPE_GMC   |
                                                 MB_TYPE_16x16 |
                                                 MB_TYPE_L0;
                /* 16x16 global motion prediction */
                s->mv_type     = MV_TYPE_16X16;
                mx             = get_amv(ctx, 0);
                my             = get_amv(ctx, 1);
                s->mv[0][0][0] = mx;
                s->mv[0][0][1] = my;
            } else if ((!s->progressive_sequence) && get_bits1(&s->gb)) {
                s->current_picture.mb_type[xy] = MB_TYPE_16x8 |
                                                 MB_TYPE_L0   |
                                                 MB_TYPE_INTERLACED;
                /* 16x8 field motion prediction */
                s->mv_type = MV_TYPE_FIELD;

                s->field_select[0][0] = get_bits1(&s->gb);
                s->field_select[0][1] = get_bits1(&s->gb);

                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);

                for (i = 0; i < 2; i++) {
                    mx = ff_h263_decode_motion(s, pred_x, s->f_code);
                    if (mx >= 0xffff)
                        return AVERROR_INVALIDDATA;

                    my = ff_h263_decode_motion(s, pred_y / 2, s->f_code);
                    if (my >= 0xffff)
                        return AVERROR_INVALIDDATA;

                    s->mv[0][i][0] = mx;
                    s->mv[0][i][1] = my;
                }
            } else {
                s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;
                /* 16x16 motion prediction */
                s->mv_type = MV_TYPE_16X16;
                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);
                mx = ff_h263_decode_motion(s, pred_x, s->f_code);

                if (mx >= 0xffff)
                    return AVERROR_INVALIDDATA;

                my = ff_h263_decode_motion(s, pred_y, s->f_code);

                if (my >= 0xffff)
                    return AVERROR_INVALIDDATA;
                s->mv[0][0][0] = mx;
                s->mv[0][0][1] = my;
            }
        } else {
            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;
            s->mv_type                     = MV_TYPE_8X8;
            for (i = 0; i < 4; i++) {
                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);
                mx      = ff_h263_decode_motion(s, pred_x, s->f_code);
                if (mx >= 0xffff)
                    return AVERROR_INVALIDDATA;

                my = ff_h263_decode_motion(s, pred_y, s->f_code);
                if (my >= 0xffff)
                    return AVERROR_INVALIDDATA;
                s->mv[0][i][0] = mx;
                s->mv[0][i][1] = my;
                mot_val[0]     = mx;
                mot_val[1]     = my;
            }
        }
    } else if (s->pict_type == AV_PICTURE_TYPE_B) {
        int modb1;   // first bit of modb
        int modb2;   // second bit of modb
        int mb_type;

        s->mb_intra = 0;  // B-frames never contain intra blocks
        s->mcsel    = 0;  //      ...               true gmc blocks

        if (s->mb_x == 0) {
            for (i = 0; i < 2; i++) {
                s->last_mv[i][0][0] =
                s->last_mv[i][0][1] =
                s->last_mv[i][1][0] =
                s->last_mv[i][1][1] = 0;
            }

            ff_thread_await_progress(&s->next_picture_ptr->tf, s->mb_y, 0);
        }

        /* if we skipped it in the future P-frame than skip it now too */
        s->mb_skipped = s->next_picture.mbskip_table[s->mb_y * s->mb_stride + s->mb_x];  // Note, skiptab=0 if last was GMC

        if (s->mb_skipped) {
            /* skip mb */
            for (i = 0; i < 6; i++)
                s->block_last_index[i] = -1;

            s->mv_dir      = MV_DIR_FORWARD;
            s->mv_type     = MV_TYPE_16X16;
            s->mv[0][0][0] =
            s->mv[0][0][1] =
            s->mv[1][0][0] =
            s->mv[1][0][1] = 0;
            s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |
                                             MB_TYPE_16x16 |
                                             MB_TYPE_L0;
            goto end;
        }

        modb1 = get_bits1(&s->gb);
        if (modb1) {
            // like MB_TYPE_B_DIRECT but no vectors coded
            mb_type = MB_TYPE_DIRECT2 | MB_TYPE_SKIP | MB_TYPE_L0L1;
            cbp     = 0;
        } else {
            modb2   = get_bits1(&s->gb);
            mb_type = get_vlc2(&s->gb, mb_type_b_vlc.table, MB_TYPE_B_VLC_BITS, 1);
            if (mb_type < 0) {
                av_log(s->avctx, AV_LOG_ERROR, 'illegal MB_type\n');
                return AVERROR_INVALIDDATA;
            }
            mb_type = mb_type_b_map[mb_type];
            if (modb2) {
                cbp = 0;
            } else {
                s->bdsp.clear_blocks(s->block[0]);
                cbp = get_bits(&s->gb, 6);
            }

            if ((!IS_DIRECT(mb_type)) && cbp) {
                if (get_bits1(&s->gb))
                    ff_set_qscale(s, s->qscale + get_bits1(&s->gb) * 4 - 2);
            }

            if (!s->progressive_sequence) {
                if (cbp)
                    s->interlaced_dct = get_bits1(&s->gb);

                if (!IS_DIRECT(mb_type) && get_bits1(&s->gb)) {
                    mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;
                    mb_type &= ~MB_TYPE_16x16;

                    if (USES_LIST(mb_type, 0)) {
                        s->field_select[0][0] = get_bits1(&s->gb);
                        s->field_select[0][1] = get_bits1(&s->gb);
                    }
                    if (USES_LIST(mb_type, 1)) {
                        s->field_select[1][0] = get_bits1(&s->gb);
                        s->field_select[1][1] = get_bits1(&s->gb);
                    }
                }
            }

            s->mv_dir = 0;
            if ((mb_type & (MB_TYPE_DIRECT2 | MB_TYPE_INTERLACED)) == 0) {
                s->mv_type = MV_TYPE_16X16;

                if (USES_LIST(mb_type, 0)) {
                    s->mv_dir = MV_DIR_FORWARD;

                    mx = ff_h263_decode_motion(s, s->last_mv[0][0][0], s->f_code);
                    my = ff_h263_decode_motion(s, s->last_mv[0][0][1], s->f_code);
                    s->last_mv[0][1][0] =
                    s->last_mv[0][0][0] =
                    s->mv[0][0][0]      = mx;
                    s->last_mv[0][1][1] =
                    s->last_mv[0][0][1] =
                    s->mv[0][0][1]      = my;
                }

                if (USES_LIST(mb_type, 1)) {
                    s->mv_dir |= MV_DIR_BACKWARD;

                    mx = ff_h263_decode_motion(s, s->last_mv[1][0][0], s->b_code);
                    my = ff_h263_decode_motion(s, s->last_mv[1][0][1], s->b_code);
                    s->last_mv[1][1][0] =
                    s->last_mv[1][0][0] =
                    s->mv[1][0][0]      = mx;
                    s->last_mv[1][1][1] =
                    s->last_mv[1][0][1] =
                    s->mv[1][0][1]      = my;
                }
            } else if (!IS_DIRECT(mb_type)) {
                s->mv_type = MV_TYPE_FIELD;

                if (USES_LIST(mb_type, 0)) {
                    s->mv_dir = MV_DIR_FORWARD;

                    for (i = 0; i < 2; i++) {
                        mx = ff_h263_decode_motion(s, s->last_mv[0][i][0], s->f_code);
                        my = ff_h263_decode_motion(s, s->last_mv[0][i][1] / 2, s->f_code);
                        s->last_mv[0][i][0] =
                        s->mv[0][i][0]      = mx;
                        s->last_mv[0][i][1] = (s->mv[0][i][1] = my) * 2;
                    }
                }

                if (USES_LIST(mb_type, 1)) {
                    s->mv_dir |= MV_DIR_BACKWARD;

                    for (i = 0; i < 2; i++) {
                        mx = ff_h263_decode_motion(s, s->last_mv[1][i][0], s->b_code);
                        my = ff_h263_decode_motion(s, s->last_mv[1][i][1] / 2, s->b_code);
                        s->last_mv[1][i][0] =
                        s->mv[1][i][0]      = mx;
                        s->last_mv[1][i][1] = (s->mv[1][i][1] = my) * 2;
                    }
                }
            }
        }

        if (IS_DIRECT(mb_type)) {
            if (IS_SKIP(mb_type)) {
                mx =
                my = 0;
            } else {
                mx = ff_h263_decode_motion(s, 0, 1);
                my = ff_h263_decode_motion(s, 0, 1);
            }

            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;
            mb_type  |= ff_mpeg4_set_direct_mv(s, mx, my);
        }
        s->current_picture.mb_type[xy] = mb_type;
    } else { /* I-Frame */
        do {
            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);
            if (cbpc < 0) {
                av_log(s->avctx, AV_LOG_ERROR,
                       'I cbpc damaged at %d %d\n', s->mb_x, s->mb_y);
                return AVERROR_INVALIDDATA;
            }
        } while (cbpc == 8);

        dquant = cbpc & 4;
        s->mb_intra = 1;

intra:
        s->ac_pred = get_bits1(&s->gb);
        if (s->ac_pred)
            s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;
        else
            s->current_picture.mb_type[xy] = MB_TYPE_INTRA;

        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);
        if (cbpy < 0) {
            av_log(s->avctx, AV_LOG_ERROR,
                   'I cbpy damaged at %d %d\n', s->mb_x, s->mb_y);
            return AVERROR_INVALIDDATA;
        }
        cbp = (cbpc & 3) | (cbpy << 2);

        ctx->use_intra_dc_vlc = s->qscale < ctx->intra_dc_threshold;

        if (dquant)
            ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);

        if (!s->progressive_sequence)
            s->interlaced_dct = get_bits1(&s->gb);

        s->bdsp.clear_blocks(s->block[0]);
        /* decode each block */
        for (i = 0; i < 6; i++) {
            if (mpeg4_decode_block(ctx, block[i], i, cbp & 32, 1, 0) < 0)
                return AVERROR_INVALIDDATA;
            cbp += cbp;
        }
        goto end;
    }

    /* decode each block */
    for (i = 0; i < 6; i++) {
        if (mpeg4_decode_block(ctx, block[i], i, cbp & 32, 0, 0) < 0)
            return AVERROR_INVALIDDATA;
        cbp += cbp;
    }

end:
    /* per-MB end of slice check */
    if (s->codec_id == AV_CODEC_ID_MPEG4) {
        int next = mpeg4_is_resync(ctx);
        if (next) {
            if        (s->mb_x + s->mb_y*s->mb_width + 1 >  next && (s->avctx->err_recognition & AV_EF_AGGRESSIVE)) {
                return AVERROR_INVALIDDATA;
            } else if (s->mb_x + s->mb_y*s->mb_width + 1 >= next)
                return SLICE_END;

            if (s->pict_type == AV_PICTURE_TYPE_B) {
                const int delta= s->mb_x + 1 == s->mb_width ? 2 : 1;
                ff_thread_await_progress(&s->next_picture_ptr->tf,
                                         (s->mb_x + delta >= s->mb_width)
                                         ? FFMIN(s->mb_y + 1, s->mb_height - 1)
                                         : s->mb_y, 0);
                if (s->next_picture.mbskip_table[xy + delta])
                    return SLICE_OK;
            }

            return SLICE_END;
        }
    }

    return SLICE_OK;
}
",0,8236
eclipse/mosquitto,9097577b49b7fdcf45d30975976dd93808ccc0c4,"int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])
{
	int i;
	int port_tmp;

	for(i=1; i<argc; i++){
		if(!strcmp(argv[i], '-c') || !strcmp(argv[i], '--config-file')){
			if(i<argc-1){
				db->config_file = argv[i+1];

				if(config__read(db, config, false)){
					log__printf(NULL, MOSQ_LOG_ERR, 'Error: Unable to open configuration file.');
					return MOSQ_ERR_INVAL;
				}
			}else{
				log__printf(NULL, MOSQ_LOG_ERR, 'Error: -c argument given, but no config file specified.');
				return MOSQ_ERR_INVAL;
			}
			i++;
		}else if(!strcmp(argv[i], '-d') || !strcmp(argv[i], '--daemon')){
			config->daemon = true;
		}else if(!strcmp(argv[i], '-h') || !strcmp(argv[i], '--help')){
			print_usage();
			return MOSQ_ERR_INVAL;
		}else if(!strcmp(argv[i], '-p') || !strcmp(argv[i], '--port')){
			if(i<argc-1){
				port_tmp = atoi(argv[i+1]);
				if(port_tmp<1 || port_tmp>65535){
					log__printf(NULL, MOSQ_LOG_ERR, 'Error: Invalid port specified (%d).', port_tmp);
					return MOSQ_ERR_INVAL;
				}else{
					if(config->default_listener.port){
						log__printf(NULL, MOSQ_LOG_WARNING, 'Warning: Default listener port specified multiple times. Only the latest will be used.');
					}
					config->default_listener.port = port_tmp;
				}
			}else{
				log__printf(NULL, MOSQ_LOG_ERR, 'Error: -p argument given, but no port specified.');
				return MOSQ_ERR_INVAL;
			}
			i++;
		}else if(!strcmp(argv[i], '-v') || !strcmp(argv[i], '--verbose')){
			db->verbose = true;
		}else{
			fprintf(stderr, 'Error: Unknown option '%s'.\n',argv[i]);
			print_usage();
			return MOSQ_ERR_INVAL;
		}
	}

	if(config->listener_count == 0
#ifdef WITH_TLS
			|| config->default_listener.cafile
			|| config->default_listener.capath
			|| config->default_listener.certfile
			|| config->default_listener.keyfile
			|| config->default_listener.ciphers
			|| config->default_listener.psk_hint
			|| config->default_listener.require_certificate
			|| config->default_listener.crlfile
			|| config->default_listener.use_identity_as_username
			|| config->default_listener.use_subject_as_username
#endif
			|| config->default_listener.use_username_as_clientid
			|| config->default_listener.host
			|| config->default_listener.port
			|| config->default_listener.max_connections != -1
			|| config->default_listener.mount_point
			|| config->default_listener.protocol != mp_mqtt
			|| config->default_listener.socket_domain
			|| config->default_listener.security_options.password_file
			|| config->default_listener.security_options.psk_file
			|| config->default_listener.security_options.auth_plugin_config_count
			|| config->default_listener.security_options.allow_anonymous != -1
			){

		config->listener_count++;
		config->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);
		if(!config->listeners){
			log__printf(NULL, MOSQ_LOG_ERR, 'Error: Out of memory.');
			return MOSQ_ERR_NOMEM;
		}
		memset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));
		if(config->default_listener.port){
			config->listeners[config->listener_count-1].port = config->default_listener.port;
		}else{
			config->listeners[config->listener_count-1].port = 1883;
		}
		if(config->default_listener.host){
			config->listeners[config->listener_count-1].host = config->default_listener.host;
		}else{
			config->listeners[config->listener_count-1].host = NULL;
		}
		if(config->default_listener.mount_point){
			config->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;
		}else{
			config->listeners[config->listener_count-1].mount_point = NULL;
		}
		config->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;
		config->listeners[config->listener_count-1].protocol = config->default_listener.protocol;
		config->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;
		config->listeners[config->listener_count-1].client_count = 0;
		config->listeners[config->listener_count-1].socks = NULL;
		config->listeners[config->listener_count-1].sock_count = 0;
		config->listeners[config->listener_count-1].client_count = 0;
		config->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;
#ifdef WITH_TLS
		config->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;
		config->listeners[config->listener_count-1].cafile = config->default_listener.cafile;
		config->listeners[config->listener_count-1].capath = config->default_listener.capath;
		config->listeners[config->listener_count-1].certfile = config->default_listener.certfile;
		config->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;
		config->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;
		config->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;
		config->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;
		config->listeners[config->listener_count-1].ssl_ctx = NULL;
		config->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;
		config->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;
		config->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;
#endif
		config->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;
		config->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;
		config->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;
		config->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;
		config->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;
	}

	/* Default to drop to mosquitto user if we are privileged and no user specified. */
	if(!config->user){
		config->user = 'mosquitto';
	}
	if(db->verbose){
		config->log_type = INT_MAX;
	}
	return config__check(config);
}
",1,8237
eclipse/mosquitto,9097577b49b7fdcf45d30975976dd93808ccc0c4,"#include 'memory_mosq.h'
#include 'tls_mosq.h'
#include 'util_mosq.h'
#include 'mqtt3_protocol.h'

",0,8238
radare/radare2,9b46d38dd3c4de6048a488b655c7319f845af185,"static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {
	size_t pos, nextpos = 0;
	x86newTokenType last_type;
	int size_token = 1;
	bool explicit_size = false;
	int reg_index = 0;
	// Reset type
	op->type = 0;
	// Consume tokens denoting the operand size
	while (size_token) {
		pos = nextpos;
		last_type = getToken (str, &pos, &nextpos);

		// Token may indicate size: then skip
		if (!r_str_ncasecmp (str + pos, 'ptr', 3)) {
			continue;
		} else if (!r_str_ncasecmp (str + pos, 'byte', 4)) {
			op->type |= OT_MEMORY | OT_BYTE;
			op->dest_size = OT_BYTE;
			explicit_size = true;
		} else if (!r_str_ncasecmp (str + pos, 'word', 4)) {
			op->type |= OT_MEMORY | OT_WORD;
			op->dest_size = OT_WORD;
			explicit_size = true;
		} else if (!r_str_ncasecmp (str + pos, 'dword', 5)) {
			op->type |= OT_MEMORY | OT_DWORD;
			op->dest_size = OT_DWORD;
			explicit_size = true;
		} else if (!r_str_ncasecmp (str + pos, 'qword', 5)) {
			op->type |= OT_MEMORY | OT_QWORD;
			op->dest_size = OT_QWORD;
			explicit_size = true;
		} else if (!r_str_ncasecmp (str + pos, 'oword', 5)) {
			op->type |= OT_MEMORY | OT_OWORD;
			op->dest_size = OT_OWORD;
			explicit_size = true;
		} else if (!r_str_ncasecmp (str + pos, 'tbyte', 5)) {
			op->type |= OT_MEMORY | OT_TBYTE;
			op->dest_size = OT_TBYTE;
			explicit_size = true;
		} else { // the current token doesn't denote a size
			size_token = 0;
		}
	}

	// Next token: register, immediate, or '['
	if (str[pos] == '[') {
		// Don't care about size, if none is given.
		if (!op->type) {
			op->type = OT_MEMORY;
		}
		// At the moment, we only accept plain linear combinations:
		// part := address | [factor *] register
		// address := part {+ part}*
		op->offset = op->scale[0] = op->scale[1] = 0;

		ut64 temp = 1;
		Register reg = X86R_UNDEFINED;
		bool first_reg = true;
		while (str[pos] != ']') {
			if (pos > nextpos) {
			//	eprintf ('Error parsing instruction\n');
				break;
			}
			pos = nextpos;
			if (!str[pos]) {
				break;
			}
			last_type = getToken (str, &pos, &nextpos);

			if (last_type == TT_SPECIAL) {
				if (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {
					if (reg != X86R_UNDEFINED) {
						op->regs[reg_index] = reg;
						op->scale[reg_index] = temp;
						++reg_index;
					} else {
						op->offset += temp;
						op->regs[reg_index] = X86R_UNDEFINED;
					}

					temp = 1;
					reg = X86R_UNDEFINED;
				} else if (str[pos] == '*') {
					// go to ], + or - to get scale

					// Something to do here?
					// Seems we are just ignoring '*' or assuming it implicitly.
				}
			}
			else if (last_type == TT_WORD) {
				ut32 reg_type = 0;

				// We can't multiply registers
				if (reg != X86R_UNDEFINED) {
					op->type = 0;	// Make the result invalid
				}

				// Reset nextpos: parseReg wants to parse from the beginning
				nextpos = pos;
				reg = parseReg (a, str, &nextpos, &reg_type);

				if (first_reg) {
					op->extended = false;
					if (reg > 8) {
						op->extended = true;
						op->reg = reg - 9;
					}
					first_reg = false;
				} else if (reg > 8) {
					op->reg = reg - 9;
				}
				if (reg_type & OT_REGTYPE & OT_SEGMENTREG) {
					op->reg = reg;
					op->type = reg_type;
					parse_segment_offset (a, str, &nextpos, op, reg_index);
					return nextpos;
				}

				// Still going to need to know the size if not specified
				if (!explicit_size) {
					op->type |= reg_type;
				}
				op->reg_size = reg_type;
				op->explicit_size = explicit_size;

				// Addressing only via general purpose registers
				if (!(reg_type & OT_GPREG)) {
					op->type = 0;	// Make the result invalid
				}
			}
			else {
				char *p = strchr (str, '+');
				op->offset_sign = 1;
				if (!p) {
					p = strchr (str, '-');
					if (p) {
						op->offset_sign = -1;
					}
				}
				//with SIB notation, we need to consider the right sign
				char * plus = strchr (str, '+');
				char * minus = strchr (str, '-');
				char * closeB = strchr (str, ']');
				if (plus && minus && plus < closeB && minus < closeB) {
					op->offset_sign = -1;
				}
				// If there's a scale, we don't want to parse out the
				// scale with the offset (scale + offset) otherwise the scale
				// will be the sum of the two. This splits the numbers
				char *tmp;
				tmp = malloc (strlen (str + pos) + 1);
				strcpy (tmp, str + pos);
				strtok (tmp, '+-');
				st64 read = getnum (a, tmp);
				free (tmp);
				temp *= read;
			}
		}
	} else if (last_type == TT_WORD) {   // register
		nextpos = pos;
		RFlagItem *flag;

		if (isrepop) {
			op->is_good_flag = false;
			strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);
			op->rep_op[MAX_REPOP_LENGTH - 1] = '\0';
			return nextpos;
		}

		op->reg = parseReg (a, str, &nextpos, &op->type);

		op->extended = false;
		if (op->reg > 8) {
			op->extended = true;
			op->reg -= 9;
		}
		if (op->type & OT_REGTYPE & OT_SEGMENTREG) {
			parse_segment_offset (a, str, &nextpos, op, reg_index);
			return nextpos;
		}
		if (op->reg == X86R_UNDEFINED) {
			op->is_good_flag = false;
			if (a->num && a->num->value == 0) {
				return nextpos;
			}
			op->type = OT_CONSTANT;
			RCore *core = a->num? (RCore *)(a->num->userptr): NULL;
			if (core && (flag = r_flag_get (core->flags, str))) {
				op->is_good_flag = true;
			}

			char *p = strchr (str, '-');
			if (p) {
				op->sign = -1;
				str = ++p;
			}
			op->immediate = getnum (a, str);
		} else if (op->reg < X86R_UNDEFINED) {
			strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);
			op->rep_op[MAX_REPOP_LENGTH - 1] = '\0';
		}
	} else {                             // immediate
		// We don't know the size, so let's just set no size flag.
		op->type = OT_CONSTANT;
		op->sign = 1;
		char *p = strchr (str, '-');
		if (p) {
			op->sign = -1;
			str = ++p;
		}
		op->immediate = getnum (a, str);
	}

	return nextpos;
}
",1,8239
radare/radare2,9b46d38dd3c4de6048a488b655c7319f845af185,"static int optest(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	if (!op->operands[0].type || !op->operands[1].type) {
		eprintf ('Error: Invalid operands\n');
		return -1;
	}
	if (a->bits == 64) {
		if (op->operands[0].type & OT_MEMORY ||
			op->operands[1].type & OT_MEMORY) {
			data[l++] = 0x67;
		}
		if (op->operands[0].type & OT_QWORD &&
			op->operands[1].type & OT_QWORD) {
			if (op->operands[0].extended &&
			    op->operands[1].extended) {
					data[l++] = 0x4d;
				} else {
					data[l++] = 0x48;
				}
		}
	}

	if (op->operands[1].type & OT_CONSTANT) {
		if (op->operands[0].type & OT_BYTE) {
			data[l++] = 0xf6;
			data[l++] = op->operands[0].regs[0];
			data[l++] = op->operands[1].immediate;
			return l;
		}
		data[l++] = 0xf7;
		if (op->operands[0].type & OT_MEMORY) {
			data[l++] = 0x00 | op->operands[0].regs[0];
		} else {
			data[l++] = 0xc0 | op->operands[0].reg;
		}
		data[l++] = op->operands[1].immediate >> 0;
		data[l++] = op->operands[1].immediate >> 8;
		data[l++] = op->operands[1].immediate >> 16;
		data[l++] = op->operands[1].immediate >> 24;
		return l;
	}
	if (op->operands[0].type & OT_BYTE ||
		op->operands[1].type & OT_BYTE) {
		data[l++] = 0x84;
	} else {
		data[l++] = 0x85;
	}
	if (op->operands[0].type & OT_MEMORY) {
		data[l++] = 0x00 | op->operands[1].reg << 3 | op->operands[0].regs[0];
	} else {
		if (op->operands[1].type & OT_MEMORY) {
			data[l++] = 0x00 | op->operands[0].reg << 3 | op->operands[1].regs[0];
		} else {
			data[l++] = 0xc0 | op->operands[1].reg << 3 | op->operands[0].reg;
		}
	}
	return l;
}
",0,8240
torvalds/linux,9824dfae5741275473a23a7ed5756c7b6efacc9d,"		case SIOCADDIPDDPRT:
                        return ipddp_create(&rcp);

                case SIOCFINDIPDDPRT:
			spin_lock_bh(&ipddp_route_lock);
			rp = __ipddp_find_route(&rcp);
			if (rp)
				memcpy(&rcp2, rp, sizeof(rcp2));
",1,8241
torvalds/linux,9824dfae5741275473a23a7ed5756c7b6efacc9d," *
 *	Derived from:
 *	- Almost all code already existed in net/appletalk/ddp.c I just
 *	  moved/reorginized it into a driver file. Original IP-over-DDP code
 *	  was done by Bradford W. Johnson <johns393@maroon.tc.umn.edu>
",0,8242
appneta/tcpreplay,6b830a1640ca20528032c89a4fdd8291a4d2d8b2,"u_char *_our_safe_pcap_next(pcap_t *pcap,  struct pcap_pkthdr *pkthdr,
        const char *funcname, const int line, const char *file)
{
    u_char *pktdata = (u_char *)pcap_next(pcap, pkthdr);

    if (pktdata) {
        if (pkthdr->len > MAXPACKET) {
            fprintf(stderr, 'safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n',
                    file, funcname, line, pkthdr->len, MAXPACKET);
            exit(-1);
        }

        if (pkthdr->len < pkthdr->caplen) {
            fprintf(stderr, 'safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n',
                    file, funcname, line, pkthdr->len, pkthdr->caplen);
            exit(-1);
        }
    }

    return pktdata;
}
",1,8243
appneta/tcpreplay,6b830a1640ca20528032c89a4fdd8291a4d2d8b2,"int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,
        const u_char **pktdata, const char *funcname,
        const int line, const char *file)
{
    int res = pcap_next_ex(pcap, pkthdr, pktdata);

    if (*pktdata && *pkthdr) {
        if ((*pkthdr)->len > MAXPACKET) {
            fprintf(stderr, 'safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n',
                    file, funcname, line, (*pkthdr)->len, MAXPACKET);
            exit(-1);
        }

        if ((*pkthdr)->len < (*pkthdr)->caplen) {
            fprintf(stderr, 'safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n',
                    file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);
            exit(-1);
        }
    }

    return res;
}
",1,8244
appneta/tcpreplay,6b830a1640ca20528032c89a4fdd8291a4d2d8b2,"
void *
_our_safe_malloc(size_t len, const char *funcname, const int line, const char *file)
{
    u_char *ptr;
",0,8245
appneta/tcpreplay,6b830a1640ca20528032c89a4fdd8291a4d2d8b2," * to use it as:
 * ptr = safe_realloc(ptr, size)
 */
void *
_our_safe_realloc(void *ptr, size_t len, const char *funcname, const int line, const char *file)
{

    if ((ptr = realloc(ptr, len)) == NULL) {
        fprintf(stderr, 'ERROR: in %s:%s() line %d: Unable to remalloc() buffer to %zu bytes', file, funcname, line, len);
",0,8246
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
test_window (void)
{
	GSWindow   *window;
	gboolean    lock_active;
	gboolean    user_switch_enabled;
	GdkDisplay *display;
	GdkMonitor *monitor;

	lock_active = TRUE;
	user_switch_enabled = TRUE;
	display = gdk_display_get_default ();
	monitor = gdk_display_get_primary_monitor (display);

	window = gs_window_new (display, monitor, lock_active);

	gs_window_set_user_switch_enabled (window, user_switch_enabled);

	connect_window_signals (window);

	gs_window_show (window);
}
",1,8247
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
apply_background_to_window (GSManager *manager,
                            GSWindow  *window)
{
	cairo_surface_t *surface;
	GdkDisplay      *display;
	GdkScreen       *screen;
	int              width;
	int              height;
	gint             scale;

        mate_bg_load_from_preferences (manager->priv->bg);

	if (manager->priv->bg == NULL)
	{
		gs_debug ('No background available');
		gs_window_set_background_surface (window, NULL);
	}

	display = gs_window_get_display (window);
	screen = gdk_display_get_default_screen (display);
	scale = gdk_window_get_scale_factor (gdk_screen_get_root_window (screen));
	width = WidthOfScreen (gdk_x11_screen_get_xscreen (screen)) / scale;
	height = HeightOfScreen (gdk_x11_screen_get_xscreen (screen)) / scale;
	gs_debug ('Creating background w:%d h:%d', width, height);
	surface = mate_bg_create_surface (manager->priv->bg,
	                                  gs_window_get_gdk_window (window),
	                                  width,
	                                  height,
	                                  FALSE);
	gs_window_set_background_surface (window, surface);
	cairo_surface_destroy (surface);
}
",1,8248
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_manager_create_window_for_monitor (GSManager  *manager,
                                      GdkMonitor *monitor)
{
	GSWindow    *window;
	GdkDisplay  *display;
	GdkRectangle rect;

	display = gdk_monitor_get_display (monitor);
	gdk_monitor_get_geometry (monitor, &rect);

	gs_debug ('Creating a window [%d,%d] (%dx%d)',
	          rect.x, rect.y, rect.width, rect.height);

	window = gs_window_new (display, monitor, manager->priv->lock_active);

	gs_window_set_user_switch_enabled (window, manager->priv->user_switch_enabled);
	gs_window_set_logout_enabled (window, manager->priv->logout_enabled);
	gs_window_set_logout_timeout (window, manager->priv->logout_timeout);
	gs_window_set_logout_command (window, manager->priv->logout_command);
	gs_window_set_keyboard_enabled (window, manager->priv->keyboard_enabled);
	gs_window_set_keyboard_command (window, manager->priv->keyboard_command);
	gs_window_set_status_message (window, manager->priv->status_message);

	connect_window_signals (manager, window);

	manager->priv->windows = g_slist_append (manager->priv->windows, window);

	if (manager->priv->active && !manager->priv->fading)
	{
		gtk_widget_show (GTK_WIDGET (window));
	}
}
",1,8249
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
on_screen_monitors_changed (GdkScreen *screen,
                            GSManager *manager)
{
	GSList     *l;
	GdkDisplay *display;
	int         n_monitors;
	int         n_windows;
	int         i;

	display = gdk_screen_get_display (screen);
	n_monitors = gdk_display_get_n_monitors (display);
	n_windows = g_slist_length (manager->priv->windows);

	gs_debug ('Monitors changed for display %s: num=%d',
	          gdk_display_get_name (display),
	          n_monitors);

	if (n_monitors > n_windows)
	{

		/* Tear down unlock dialog in case we want to move it
		 * to a new monitor
		 */
		l = manager->priv->windows;
		while (l != NULL)
		{
			gs_window_cancel_unlock_request (GS_WINDOW (l->data));
			l = l->next;
		}

		/* add more windows */
		for (i = n_windows; i < n_monitors; i++)
		{
			GdkMonitor *mon = gdk_display_get_monitor (display, i);
			gs_manager_create_window_for_monitor (manager, mon);
		}

		/* And put unlock dialog up where ever it's supposed to be
		 */
		gs_manager_request_unlock (manager);
	}
	else
	{

		gdk_x11_grab_server ();

		/* remove the extra windows */
		l = manager->priv->windows;
		while (l != NULL)
		{
			GdkDisplay *this_display;
			GdkMonitor *this_monitor;
			GSList     *next = l->next;

			this_display = gs_window_get_display (GS_WINDOW (l->data));
			this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));
			if (this_display == display &&
			    !GDK_IS_MONITOR (this_monitor))
			{
				manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));
				g_hash_table_remove (manager->priv->jobs, l->data);
				gs_window_destroy (GS_WINDOW (l->data));
				manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);
			}
			l = next;
		}

		/* make sure there is a lock dialog on a connected monitor,
		 * and that the keyboard is still properly grabbed after all
		 * the windows above got destroyed*/
		if (n_windows > n_monitors)
		{
			gs_manager_request_unlock (manager);
		}

		gdk_display_flush (display);
		gdk_x11_ungrab_server ();
	}
}
",1,8250
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_manager_destroy_windows (GSManager *manager)
{
	GdkDisplay  *display;
	GSList      *l;

	g_return_if_fail (manager != NULL);
	g_return_if_fail (GS_IS_MANAGER (manager));

	if (manager->priv->windows == NULL)
	{
		return;
	}

	display = gdk_display_get_default ();

	g_signal_handlers_disconnect_by_func (gdk_display_get_default_screen (display),
	                                      on_screen_monitors_changed,
	                                      manager);

	for (l = manager->priv->windows; l; l = l->next)
	{
		gs_window_destroy (l->data);
	}
	g_slist_free (manager->priv->windows);
	manager->priv->windows = NULL;
}
",1,8251
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_manager_create_windows (GSManager *manager)
{
	GdkDisplay  *display;

	g_return_if_fail (manager != NULL);
	g_return_if_fail (GS_IS_MANAGER (manager));

	g_assert (manager->priv->windows == NULL);

	display = gdk_display_get_default ();
	g_signal_connect (gdk_display_get_default_screen (display),
	                  'monitors-changed',
	                  G_CALLBACK (on_screen_monitors_changed),
	                  manager);

	gs_manager_create_windows_for_display (manager, display);
}
",1,8252
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
screen_size_changed (GdkScreen *screen,
                     GSWindow  *window)
{
	gs_debug ('Got screen size changed signal');
	gtk_widget_queue_resize (GTK_WIDGET (window));
}
",1,8253
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_window_real_unrealize (GtkWidget *widget)
{
	g_signal_handlers_disconnect_by_func (gtk_window_get_screen (GTK_WINDOW (widget)),
	                                      screen_size_changed,
	                                      widget);

	if (GTK_WIDGET_CLASS (gs_window_parent_class)->unrealize)
	{
		GTK_WIDGET_CLASS (gs_window_parent_class)->unrealize (widget);
	}
}
",1,8254
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_window_real_realize (GtkWidget *widget)
{
	widget_set_best_visual (widget);

	if (GTK_WIDGET_CLASS (gs_window_parent_class)->realize)
	{
		GTK_WIDGET_CLASS (gs_window_parent_class)->realize (widget);
	}

	gs_window_override_user_time (GS_WINDOW (widget));

	gs_window_move_resize_window (GS_WINDOW (widget), TRUE, TRUE);

	g_signal_connect (gtk_window_get_screen (GTK_WINDOW (widget)),
	                  'size_changed',
	                  G_CALLBACK (screen_size_changed),
	                  widget);
}
",1,8255
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"GSWindow *
gs_window_new (GdkDisplay *display,
               GdkMonitor *monitor,
               gboolean   lock_enabled)
{
	GObject   *result;
	GdkScreen *screen = gdk_display_get_default_screen (display);

	result = g_object_new (GS_TYPE_WINDOW,
	                       'type', GTK_WINDOW_POPUP,
	                       'screen', screen,
	                       'monitor', monitor,
	                       'lock-enabled', lock_enabled,
	                       'app-paintable', TRUE,
	                       NULL);

	return GS_WINDOW (result);
}
",1,8256
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_window_override_user_time (GSWindow *window)
{
	guint32 ev_time = gtk_get_current_event_time ();

	if (ev_time == 0)
	{
		gint ev_mask = gtk_widget_get_events (GTK_WIDGET (window));
		if (!(ev_mask & GDK_PROPERTY_CHANGE_MASK))
		{
			gtk_widget_add_events (GTK_WIDGET (window),
			                       GDK_PROPERTY_CHANGE_MASK);
		}

		/*
		 * NOTE: Last resort for D-BUS or other non-interactive
		 *       openings.  Causes roundtrip to server.  Lame.
		 */
		ev_time = gdk_x11_get_server_time (gtk_widget_get_window (GTK_WIDGET (window)));
	}

	gdk_x11_window_set_user_time (gtk_widget_get_window (GTK_WIDGET (window)), ev_time);
}
",0,8257
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_manager_finalize (GObject *object)
{
	GSManager *manager;

	g_return_if_fail (object != NULL);
	g_return_if_fail (GS_IS_MANAGER (object));

	manager = GS_MANAGER (object);

	g_return_if_fail (manager->priv != NULL);

	if (manager->priv->bg != NULL)
	{
		g_object_unref (manager->priv->bg);
	}

	free_themes (manager);
	g_free (manager->priv->logout_command);
	g_free (manager->priv->keyboard_command);
	g_free (manager->priv->status_message);

	remove_unfade_idle (manager);
	remove_timers (manager);

	gs_grab_release (manager->priv->grab, TRUE);

	manager_stop_jobs (manager);

	gs_manager_destroy_windows (manager);

	manager->priv->active = FALSE;
	manager->priv->activate_time = 0;
	manager->priv->lock_enabled = FALSE;

	g_object_unref (manager->priv->fade);
	g_object_unref (manager->priv->grab);
	g_object_unref (manager->priv->theme_manager);

	G_OBJECT_CLASS (gs_manager_parent_class)->finalize (object);
}
",0,8258
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static gboolean
gs_window_real_draw (GtkWidget *widget,
                     cairo_t   *cr)
{
	GSWindow *window = GS_WINDOW (widget);
	cairo_surface_t *bg_surface = window->priv->background_surface;

	cairo_set_operator (cr, CAIRO_OPERATOR_OVER);
	if (bg_surface != NULL)
	{
		cairo_set_source_surface (cr, bg_surface, 0, 0);
	}
	else
	{
		cairo_set_source_rgb (cr, 0, 0, 0);
	}
	cairo_paint (cr);

	return FALSE;
}
",0,8259
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
window_obscured_cb (GSWindow   *window,
                    GParamSpec *pspec,
                    GSManager  *manager)
{
	gboolean obscured;

	obscured = gs_window_is_obscured (window);
	gs_debug ('Handling window obscured: %s', obscured ? 'obscured' : 'unobscured');

	maybe_set_window_throttle (manager, window, obscured);

	if (! obscured)
	{
		gs_manager_request_unlock (manager);
	}
}
",0,8260
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
lock_socket_show (GtkWidget *widget,
                  GSWindow  *window)
{
	gtk_widget_child_focus (window->priv->lock_socket, GTK_DIR_TAB_FORWARD);

	/* send queued events to the dialog */
	forward_key_events (window);
}
",0,8261
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
remove_popup_dialog_idle (GSWindow *window)
{
	if (window->priv->popup_dialog_idle_id != 0)
	{
		g_source_remove (window->priv->popup_dialog_idle_id);
		window->priv->popup_dialog_idle_id = 0;
	}
}
",0,8262
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_window_raise (GSWindow *window)
{
	GdkWindow *win;

	g_return_if_fail (GS_IS_WINDOW (window));

	gs_debug ('Raising screensaver window');

	win = gtk_widget_get_window (GTK_WIDGET (window));

	gdk_window_raise (win);
}
",0,8263
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"GSManager *
gs_manager_new (void)
{
	GObject *manager;

	manager = g_object_new (GS_TYPE_MANAGER, NULL);

	return GS_MANAGER (manager);
}
",0,8264
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"{
	gs_window_request_unlock (window);

",0,8265
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
gs_window_class_init (GSWindowClass *klass)
{
	GObjectClass   *object_class = G_OBJECT_CLASS (klass);
	GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);

	object_class->finalize     = gs_window_finalize;
	object_class->get_property = gs_window_get_property;
	object_class->set_property = gs_window_set_property;

	widget_class->show                = gs_window_real_show;
	widget_class->hide                = gs_window_real_hide;
	widget_class->draw                = gs_window_real_draw;
	widget_class->realize             = gs_window_real_realize;
	widget_class->unrealize           = gs_window_real_unrealize;
	widget_class->key_press_event     = gs_window_real_key_press_event;
	widget_class->motion_notify_event = gs_window_real_motion_notify_event;
	widget_class->button_press_event  = gs_window_real_button_press_event;
	widget_class->scroll_event        = gs_window_real_scroll_event;
	widget_class->get_preferred_width  = gs_window_real_get_preferred_width;
	widget_class->get_preferred_height = gs_window_real_get_preferred_height;
	widget_class->grab_broken_event   = gs_window_real_grab_broken;
	widget_class->visibility_notify_event = gs_window_real_visibility_notify_event;

	g_type_class_add_private (klass, sizeof (GSWindowPrivate));

	signals [ACTIVITY] =
	    g_signal_new ('activity',
	                  G_TYPE_FROM_CLASS (object_class),
	                  G_SIGNAL_RUN_LAST,
	                  G_STRUCT_OFFSET (GSWindowClass, activity),
	                  NULL,
	                  NULL,
	                  gs_marshal_BOOLEAN__VOID,
	                  G_TYPE_BOOLEAN,
	                  0);
	signals [DEACTIVATED] =
	    g_signal_new ('deactivated',
	                  G_TYPE_FROM_CLASS (object_class),
	                  G_SIGNAL_RUN_LAST,
	                  G_STRUCT_OFFSET (GSWindowClass, deactivated),
	                  NULL,
	                  NULL,
	                  g_cclosure_marshal_VOID__VOID,
	                  G_TYPE_NONE,
	                  0);

	g_object_class_install_property (object_class,
	                                 PROP_OBSCURED,
	                                 g_param_spec_boolean ('obscured',
	                                         NULL,
	                                         NULL,
	                                         FALSE,
	                                         G_PARAM_READABLE));
	g_object_class_install_property (object_class,
	                                 PROP_DIALOG_UP,
	                                 g_param_spec_boolean ('dialog-up',
	                                         NULL,
	                                         NULL,
	                                         FALSE,
	                                         G_PARAM_READABLE));
	g_object_class_install_property (object_class,
	                                 PROP_LOCK_ENABLED,
	                                 g_param_spec_boolean ('lock-enabled',
	                                         NULL,
	                                         NULL,
	                                         FALSE,
	                                         G_PARAM_READWRITE));
	g_object_class_install_property (object_class,
	                                 PROP_LOGOUT_ENABLED,
	                                 g_param_spec_boolean ('logout-enabled',
	                                         NULL,
	                                         NULL,
	                                         FALSE,
	                                         G_PARAM_READWRITE));
	g_object_class_install_property (object_class,
	                                 PROP_LOGOUT_TIMEOUT,
	                                 g_param_spec_long ('logout-timeout',
	                                         NULL,
	                                         NULL,
	                                         -1,
	                                         G_MAXLONG,
	                                         0,
	                                         G_PARAM_READWRITE));
	g_object_class_install_property (object_class,
	                                 PROP_LOGOUT_COMMAND,
	                                 g_param_spec_string ('logout-command',
	                                         NULL,
	                                         NULL,
	                                         NULL,
	                                         G_PARAM_READWRITE));
	g_object_class_install_property (object_class,
	                                 PROP_STATUS_MESSAGE,
	                                 g_param_spec_string ('status-message',
	                                         NULL,
	                                         NULL,
	                                         NULL,
	                                         G_PARAM_READWRITE));
	g_object_class_install_property (object_class,
	                                 PROP_KEYBOARD_ENABLED,
	                                 g_param_spec_boolean ('keyboard-enabled',
	                                         NULL,
	                                         NULL,
	                                         FALSE,
	                                         G_PARAM_READWRITE));
	g_object_class_install_property (object_class,
	                                 PROP_KEYBOARD_COMMAND,
	                                 g_param_spec_string ('keyboard-command',
	                                         NULL,
	                                         NULL,
	                                         NULL,
	                                         G_PARAM_READWRITE));

	g_object_class_install_property (object_class,
	                                 PROP_MONITOR,
	                                 g_param_spec_pointer ('monitor',
	                                         'Gdk monitor',
	                                         'The monitor (in terms of Gdk) which the window is on',
	                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
}
",0,8266
mate-desktop/mate-screensaver,8c17c272184f0227e8bd42c2a7d62d5683a466a8,"static void
window_dialog_up_cb (GSWindow  *window,
                     gpointer   data)
{
}
",0,8267
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"                  uint8_t **output_rows, size_t *output_rows_length) {
  try {
    filter(condition, condition_length,
",1,8268
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"  try {
    non_oblivious_sort_merge_join(join_expr, join_expr_length,
                                  input_rows, input_rows_length,
",1,8269
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"  uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,
  uint8_t **output_rows, size_t *output_rows_length) {
  try {
",1,8270
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"                             uint32_t num_partitions,
                             uint8_t *input_rows, size_t input_rows_length,
                             uint8_t **output_rows, size_t *output_rows_length) {
  try {
    find_range_bounds(sort_order, sort_order_length,
                      num_partitions,
                      input_rows, input_rows_length,
                      output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}

void ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,
                              uint32_t num_partitions,
                              uint8_t *input_rows, size_t input_rows_length,
                              uint8_t *boundary_rows, size_t boundary_rows_length,
                              uint8_t **output_partitions, size_t *output_partition_lengths) {
  try {
    partition_for_sort(sort_order, sort_order_length,
                       num_partitions,
                       input_rows, input_rows_length,
                       boundary_rows, boundary_rows_length,
                       output_partitions, output_partition_lengths);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}

void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,
                         uint8_t *input_rows, size_t input_rows_length,
                         uint8_t **output_rows, size_t *output_rows_length) {
  try {
    external_sort(sort_order, sort_order_length,
                  input_rows, input_rows_length,
                  output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}

void ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,
",1,8271
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}

void ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,
                              uint32_t num_partitions,
                              uint8_t *input_rows, size_t input_rows_length,
                              uint8_t *boundary_rows, size_t boundary_rows_length,
                              uint8_t **output_partitions, size_t *output_partition_lengths) {
  try {
    partition_for_sort(sort_order, sort_order_length,
                       num_partitions,
",1,8273
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"                       boundary_rows, boundary_rows_length,
                       output_partitions, output_partition_lengths);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}

void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,
                         uint8_t *input_rows, size_t input_rows_length,
                         uint8_t **output_rows, size_t *output_rows_length) {
  try {
    external_sort(sort_order, sort_order_length,
                  input_rows, input_rows_length,
",1,8274
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_project(uint8_t *condition, size_t condition_length,
                   uint8_t *input_rows, size_t input_rows_length,
                   uint8_t **output_rows, size_t *output_rows_length) {
  try {
    project(condition, condition_length,
            input_rows, input_rows_length,
            output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
",1,8275
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"  try {
    filter(condition, condition_length,
           input_rows, input_rows_length,
           output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}

",1,8276
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"                             uint8_t *input_rows, size_t input_rows_length,
                             uint8_t **output_rows, size_t *output_rows_length) {
  try {
    find_range_bounds(sort_order, sort_order_length,
                      num_partitions,
                      input_rows, input_rows_length,
                      output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
",1,8277
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"
void ecall_project(uint8_t *condition, size_t condition_length,
                   uint8_t *input_rows, size_t input_rows_length,
                   uint8_t **output_rows, size_t *output_rows_length) {
  try {
",1,8278
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"
void ecall_filter(uint8_t *condition, size_t condition_length,
                  uint8_t *input_rows, size_t input_rows_length,
                  uint8_t **output_rows, size_t *output_rows_length) {
  try {
",1,8279
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"                             uint8_t **output_rows, size_t *output_rows_length) {
  try {
    find_range_bounds(sort_order, sort_order_length,
",1,8280
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,
                   uint8_t *ciphertext, uint32_t cipher_length) {
  try {
    // IV (12 bytes) + ciphertext + mac (16 bytes)
    assert(cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE);
    (void)cipher_length;
    (void)plaintext_length;
    encrypt(plaintext, plaintext_length, ciphertext);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8281
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_project(uint8_t *condition, size_t condition_length,
                   uint8_t *input_rows, size_t input_rows_length,
                   uint8_t **output_rows, size_t *output_rows_length) {
  try {
    project(condition, condition_length,
            input_rows, input_rows_length,
            output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8282
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_filter(uint8_t *condition, size_t condition_length,
                  uint8_t *input_rows, size_t input_rows_length,
                  uint8_t **output_rows, size_t *output_rows_length) {
  try {
    filter(condition, condition_length,
           input_rows, input_rows_length,
           output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8283
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_sample(uint8_t *input_rows, size_t input_rows_length,
                  uint8_t **output_rows, size_t *output_rows_length) {
  try {
    sample(input_rows, input_rows_length,
           output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8284
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_find_range_bounds(uint8_t *sort_order, size_t sort_order_length,
                             uint32_t num_partitions,
                             uint8_t *input_rows, size_t input_rows_length,
                             uint8_t **output_rows, size_t *output_rows_length) {
  try {
    find_range_bounds(sort_order, sort_order_length,
                      num_partitions,
                      input_rows, input_rows_length,
                      output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8285
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,
                              uint32_t num_partitions,
                              uint8_t *input_rows, size_t input_rows_length,
                              uint8_t *boundary_rows, size_t boundary_rows_length,
                              uint8_t **output_partitions, size_t *output_partition_lengths) {
  try {
    partition_for_sort(sort_order, sort_order_length,
                       num_partitions,
                       input_rows, input_rows_length,
                       boundary_rows, boundary_rows_length,
                       output_partitions, output_partition_lengths);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8286
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,
                         uint8_t *input_rows, size_t input_rows_length,
                         uint8_t **output_rows, size_t *output_rows_length) {
  try {
    external_sort(sort_order, sort_order_length,
                  input_rows, input_rows_length,
                  output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8287
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,
                                     uint8_t *input_rows, size_t input_rows_length,
                                     uint8_t **output_rows, size_t *output_rows_length) {
  try {
    scan_collect_last_primary(join_expr, join_expr_length,
                              input_rows, input_rows_length,
                              output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8288
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_non_oblivious_sort_merge_join(uint8_t *join_expr, size_t join_expr_length,
                                         uint8_t *input_rows, size_t input_rows_length,
                                         uint8_t *join_row, size_t join_row_length,
                                         uint8_t **output_rows, size_t *output_rows_length) {
  try {
    non_oblivious_sort_merge_join(join_expr, join_expr_length,
                                  input_rows, input_rows_length,
                                  join_row, join_row_length,
                                  output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8289
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_non_oblivious_aggregate_step1(
  uint8_t *agg_op, size_t agg_op_length,
  uint8_t *input_rows, size_t input_rows_length,
  uint8_t **first_row, size_t *first_row_length,
  uint8_t **last_group, size_t *last_group_length,
  uint8_t **last_row, size_t *last_row_length) {
  try {
    non_oblivious_aggregate_step1(
      agg_op, agg_op_length,
      input_rows, input_rows_length,
      first_row, first_row_length,
      last_group, last_group_length,
      last_row, last_row_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8290
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_non_oblivious_aggregate_step2(
  uint8_t *agg_op, size_t agg_op_length,
  uint8_t *input_rows, size_t input_rows_length,
  uint8_t *next_partition_first_row, size_t next_partition_first_row_length,
  uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,
  uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,
  uint8_t **output_rows, size_t *output_rows_length) {
  try {
    non_oblivious_aggregate_step2(
      agg_op, agg_op_length,
      input_rows, input_rows_length,
      next_partition_first_row, next_partition_first_row_length,
      prev_partition_last_group, prev_partition_last_group_length,
      prev_partition_last_row, prev_partition_last_row_length,
      output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}
",1,8291
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"            size *= 2;
    }
}

void exit(int exit_code) {
  ocall_exit(exit_code);
}

void print_bytes(uint8_t *ptr, uint32_t len) {
",1,8292
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"  ocall_exit(exit_code);
}

void print_bytes(uint8_t *ptr, uint32_t len) {
  for (uint32_t i = 0; i < len; i++) {
",1,8293
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void exit(int exit_code) {
  ocall_exit(exit_code);
}
",1,8294
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ocall_malloc(size_t size, uint8_t **ret) {
  *ret = static_cast<uint8_t *>(malloc(size));
}
",1,8295
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"    non_oblivious_aggregate_step2(
      agg_op, agg_op_length,
      input_rows, input_rows_length,
",0,8296
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"    printf(' - ');
  }

  printf('\n');
}
",0,8297
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"                             uint32_t num_partitions,
                             uint8_t *input_rows, size_t input_rows_length,
                             uint8_t **output_rows, size_t *output_rows_length) {
",0,8298
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"  printf('\n');
}

",0,8299
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"    find_range_bounds(sort_order, sort_order_length,
                      num_partitions,
                      input_rows, input_rows_length,
",0,8300
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,
                         uint8_t *input_rows, size_t input_rows_length,
                         uint8_t **output_rows, size_t *output_rows_length) {
",0,8301
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"    ocall_throw(e.what());
  }
}
",0,8303
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"}

/// From http://git.musl-libc.org/cgit/musl/tree/src/time/__secs_to_tm.c?h=v0.9.15
/* 2000-03-01 (mod 400 year, immediately after feb29 */
#define LEAPOCH (946684800LL + 86400*(31+29))
#define DAYS_PER_400Y (365*400 + 97)
#define DAYS_PER_100Y (365*100 + 24)
",0,8305
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"int pow_2(int value);

int secs_to_tm(long long t, struct tm *tm);

#endif // UTIL_H
",0,8308
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_non_oblivious_sort_merge_join(uint8_t *join_expr, size_t join_expr_length,
                                         uint8_t *input_rows, size_t input_rows_length,
                                         uint8_t *join_row, size_t join_row_length,
",0,8309
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"int secs_to_tm(long long t, struct tm *tm) {
  long long days, secs;
  int remdays, remsecs, remyears;
",0,8314
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"        if (n > -1 && n < size)
",0,8316
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"void ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,
                                     uint8_t *input_rows, size_t input_rows_length,
                                     uint8_t **output_rows, size_t *output_rows_length) {
",0,8317
ucbrise/opaque,5ddda15d89f5ac82f4416208c5319ace4aecdc36,"  static const char days_in_month[] = {31,30,31,30,31,31,30,31,30,31,31,29};

  /* Reject time_t values whose year would overflow int */
",0,8318
torvalds/linux,6acb47d1a318e5b3b7115354ebc4ea060c59d3a1,"static struct phy *serdes_simple_xlate(struct device *dev,
				       struct of_phandle_args *args)
{
	struct serdes_ctrl *ctrl = dev_get_drvdata(dev);
	unsigned int port, idx, i;

	if (args->args_count != 2)
		return ERR_PTR(-EINVAL);

	port = args->args[0];
	idx = args->args[1];

	for (i = 0; i <= SERDES_MAX; i++) {
		struct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);

		if (idx != macro->idx)
			continue;

		/* SERDES6G(0) is the only SerDes capable of QSGMII */
		if (idx != SERDES6G(0) && macro->port >= 0)
			return ERR_PTR(-EBUSY);

		macro->port = port;
		return ctrl->phys[i];
	}

	return ERR_PTR(-ENODEV);
}
",1,8319
torvalds/linux,6acb47d1a318e5b3b7115354ebc4ea060c59d3a1,"static int serdes_probe(struct platform_device *pdev)
{
	struct phy_provider *provider;
	struct serdes_ctrl *ctrl;
	unsigned int i;
	int ret;

	ctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);
	if (!ctrl)
		return -ENOMEM;

	ctrl->dev = &pdev->dev;
	ctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);
	if (IS_ERR(ctrl->regs))
		return PTR_ERR(ctrl->regs);

	for (i = 0; i <= SERDES_MAX; i++) {
		ret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);
		if (ret)
			return ret;
	}

	dev_set_drvdata(&pdev->dev, ctrl);

	provider = devm_of_phy_provider_register(ctrl->dev,
						 serdes_simple_xlate);

	return PTR_ERR_OR_ZERO(provider);
}
",1,8320
torvalds/linux,6acb47d1a318e5b3b7115354ebc4ea060c59d3a1,"static int serdes_update_mcb_s1g(struct regmap *regmap, u8 macro)
{
	return __serdes_write_mcb_s1g(regmap, macro,
		HSIO_MCB_S1G_ADDR_CFG_SERDES1G_RD_ONE_SHOT);
}
",0,8321
torvalds/linux,c095508770aebf1b9218e77026e48345d719b17c,"int rds_rdma_extra_size(struct rds_rdma_args *args)
{
	struct rds_iovec vec;
	struct rds_iovec __user *local_vec;
	int tot_pages = 0;
	unsigned int nr_pages;
	unsigned int i;

	local_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;

	/* figure out the number of pages in the vector */
	for (i = 0; i < args->nr_local; i++) {
		if (copy_from_user(&vec, &local_vec[i],
				   sizeof(struct rds_iovec)))
			return -EFAULT;

		nr_pages = rds_pages_in_vec(&vec);
		if (nr_pages == 0)
			return -EINVAL;

		tot_pages += nr_pages;

		/*
		 * nr_pages for one entry is limited to (UINT_MAX>>PAGE_SHIFT)+1,
		 * so tot_pages cannot overflow without first going negative.
		 */
		if (tot_pages < 0)
			return -EINVAL;
	}

	return tot_pages * sizeof(struct scatterlist);
}
",1,8323
torvalds/linux,c095508770aebf1b9218e77026e48345d719b17c,"void rds_rdma_drop_keys(struct rds_sock *rs)
{
	struct rds_mr *mr;
	struct rb_node *node;
	unsigned long flags;

	/* Release any MRs associated with this socket */
	spin_lock_irqsave(&rs->rs_rdma_lock, flags);
	while ((node = rb_first(&rs->rs_rdma_keys))) {
		mr = rb_entry(node, struct rds_mr, r_rb_node);
		if (mr->r_trans == rs->rs_transport)
			mr->r_invalidate = 0;
		rb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);
		RB_CLEAR_NODE(&mr->r_rb_node);
		spin_unlock_irqrestore(&rs->rs_rdma_lock, flags);
		rds_destroy_mr(mr);
		rds_mr_put(mr);
		spin_lock_irqsave(&rs->rs_rdma_lock, flags);
	}
	spin_unlock_irqrestore(&rs->rs_rdma_lock, flags);

	if (rs->rs_transport && rs->rs_transport->flush_mrs)
		rs->rs_transport->flush_mrs();
}
",0,8324
krb5/krb5,e1caf6fb74981da62039846931ebdffed71309d1,"krb5_error_code
krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,
                        char **db_args)
{
    int                         l=0, kerberos_principal_object_type=0;
    unsigned int                ntrees=0, tre=0;
    krb5_error_code             st=0, tempst=0;
    LDAP                        *ld=NULL;
    LDAPMessage                 *result=NULL, *ent=NULL;
    char                        **subtreelist = NULL;
    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;
    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];
    char                        *filtuser=NULL;
    struct berval               **bersecretkey=NULL;
    LDAPMod                     **mods=NULL;
    krb5_boolean                create_standalone=FALSE;
    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;
    char                        *standalone_principal_dn=NULL;
    krb5_tl_data                *tl_data=NULL;
    krb5_key_data               **keys=NULL;
    kdb5_dal_handle             *dal_handle=NULL;
    krb5_ldap_context           *ldap_context=NULL;
    krb5_ldap_server_handle     *ldap_server_handle=NULL;
    osa_princ_ent_rec           princ_ent = {0};
    xargs_t                     xargs = {0};
    char                        *polname = NULL;
    OPERATION optype;
    krb5_boolean                found_entry = FALSE;

    /* Clear the global error string */
    krb5_clear_error_message(context);

    SETUP_CONTEXT();
    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)
        return EINVAL;

    /* get ldap handle */
    GET_HANDLE();

    if (!is_principal_in_realm(ldap_context, entry->princ)) {
        st = EINVAL;
        k5_setmsg(context, st,
                  _('Principal does not belong to the default realm'));
        goto cleanup;
    }

    /* get the principal information to act on */
    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||
        ((st=krb5_ldap_unparse_principal_name(user)) != 0))
        goto cleanup;
    filtuser = ldap_filter_correct(user);
    if (filtuser == NULL) {
        st = ENOMEM;
        goto cleanup;
    }

    /* Identity the type of operation, it can be
     * add principal or modify principal.
     * hack if the entry->mask has KRB_PRINCIPAL flag set
     * then it is a add operation
     */
    if (entry->mask & KADM5_PRINCIPAL)
        optype = ADD_PRINCIPAL;
    else
        optype = MODIFY_PRINCIPAL;

    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||
        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))
        goto cleanup;

    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)
        goto cleanup;

    if (entry->mask & KADM5_LOAD) {
        unsigned int     tree = 0;
        int              numlentries = 0;
        char             *filter = NULL;

        /*  A load operation is special, will do a mix-in (add krbprinc
         *  attrs to a non-krb object entry) if an object exists with a
         *  matching krbprincipalname attribute so try to find existing
         *  object and set principal_dn.  This assumes that the
         *  krbprincipalname attribute is unique (only one object entry has
         *  a particular krbprincipalname attribute).
         */
        if (asprintf(&filter, FILTER'%s))', filtuser) < 0) {
            filter = NULL;
            st = ENOMEM;
            goto cleanup;
        }

        /* get the current subtree list */
        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)
            goto cleanup;

        found_entry = FALSE;
        /* search for entry with matching krbprincipalname attribute */
        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {
            if (principal_dn == NULL) {
                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);
            } else {
                /* just look for entry with principal_dn */
                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);
            }
            if (st == LDAP_SUCCESS) {
                numlentries = ldap_count_entries(ld, result);
                if (numlentries > 1) {
                    free(filter);
                    st = EINVAL;
                    k5_setmsg(context, st,
                              _('operation can not continue, more than one '
                                'entry with principal name \'%s\' found'),
                              user);
                    goto cleanup;
                } else if (numlentries == 1) {
                    found_entry = TRUE;
                    if (principal_dn == NULL) {
                        ent = ldap_first_entry(ld, result);
                        if (ent != NULL) {
                            /* setting principal_dn will cause that entry to be modified further down */
                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {
                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);
                                st = set_ldap_error (context, st, 0);
                                free(filter);
                                goto cleanup;
                            }
                        }
                    }
                }
            } else if (st != LDAP_NO_SUCH_OBJECT) {
                /* could not perform search, return with failure */
                st = set_ldap_error (context, st, 0);
                free(filter);
                goto cleanup;
            }
            ldap_msgfree(result);
            result = NULL;
            /*
             * If it isn't found then assume a standalone princ entry is to
             * be created.
             */
        } /* end for (tree = 0; principal_dn == ... */

        free(filter);

        if (found_entry == FALSE && principal_dn != NULL) {
            /*
             * if principal_dn is null then there is code further down to
             * deal with setting standalone_principal_dn.  Also note that
             * this will set create_standalone true for
             * non-mix-in entries which is okay if loading from a dump.
             */
            create_standalone = TRUE;
            standalone_principal_dn = strdup(principal_dn);
            CHECK_NULL(standalone_principal_dn);
        }
    } /* end if (entry->mask & KADM5_LOAD */

    /* time to generate the DN information with the help of
     * containerdn, principalcontainerreference or
     * realmcontainerdn information
     */
    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */
        /* get the subtree information */
        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen('krbtgt') &&
            strncmp(entry->princ->data[0].data, 'krbtgt', entry->princ->data[0].length) == 0) {
            /* if the principal is a inter-realm principal, always created in the realm container */
            subtree = strdup(ldap_context->lrparams->realmdn);
        } else if (xargs.containerdn) {
            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {
                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {
                    int ost = st;
                    st = EINVAL;
                    k5_wrapmsg(context, ost, st, _(''%s' not found'),
                               xargs.containerdn);
                }
                goto cleanup;
            }
            subtree = strdup(xargs.containerdn);
        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {
            /*
             * Here the subtree should be changed with
             * principalcontainerreference attribute value
             */
            subtree = strdup(ldap_context->lrparams->containerref);
        } else {
            subtree = strdup(ldap_context->lrparams->realmdn);
        }
        CHECK_NULL(subtree);

        if (asprintf(&standalone_principal_dn, 'krbprincipalname=%s,%s',
                     filtuser, subtree) < 0)
            standalone_principal_dn = NULL;
        CHECK_NULL(standalone_principal_dn);
        /*
         * free subtree when you are done using the subtree
         * set the boolean create_standalone to TRUE
         */
        create_standalone = TRUE;
        free(subtree);
        subtree = NULL;
    }

    /*
     * If the DN information is presented by the user, time to
     * validate the input to ensure that the DN falls under
     * any of the subtrees
     */
    if (xargs.dn_from_kbd == TRUE) {
        /* make sure the DN falls in the subtree */
        int              dnlen=0, subtreelen=0;
        char             *dn=NULL;
        krb5_boolean     outofsubtree=TRUE;

        if (xargs.dn != NULL) {
            dn = xargs.dn;
        } else if (xargs.linkdn != NULL) {
            dn = xargs.linkdn;
        } else if (standalone_principal_dn != NULL) {
            /*
             * Even though the standalone_principal_dn is constructed
             * within this function, there is the containerdn input
             * from the user that can become part of the it.
             */
            dn = standalone_principal_dn;
        }

        /* Get the current subtree list if we haven't already done so. */
        if (subtreelist == NULL) {
            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);
            if (st)
                goto cleanup;
        }

        for (tre=0; tre<ntrees; ++tre) {
            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {
                outofsubtree = FALSE;
                break;
            } else {
                dnlen = strlen (dn);
                subtreelen = strlen(subtreelist[tre]);
                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {
                    outofsubtree = FALSE;
                    break;
                }
            }
        }

        if (outofsubtree == TRUE) {
            st = EINVAL;
            k5_setmsg(context, st, _('DN is out of the realm subtree'));
            goto cleanup;
        }

        /*
         * dn value will be set either by dn, linkdn or the standalone_principal_dn
         * In the first 2 cases, the dn should be existing and in the last case we
         * are supposed to create the ldap object. so the below should not be
         * executed for the last case.
         */

        if (standalone_principal_dn == NULL) {
            /*
             * If the ldap object is missing, this results in an error.
             */

            /*
             * Search for krbprincipalname attribute here.
             * This is to find if a kerberos identity is already present
             * on the ldap object, in which case adding a kerberos identity
             * on the ldap object should result in an error.
             */
            char  *attributes[]={'krbticketpolicyreference', 'krbprincipalname', NULL};

            ldap_msgfree(result);
            result = NULL;
            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);
            if (st == LDAP_SUCCESS) {
                ent = ldap_first_entry(ld, result);
                if (ent != NULL) {
                    if ((values=ldap_get_values(ld, ent, 'krbticketpolicyreference')) != NULL) {
                        ldap_value_free(values);
                    }

                    if ((values=ldap_get_values(ld, ent, 'krbprincipalname')) != NULL) {
                        krb_identity_exists = TRUE;
                        ldap_value_free(values);
                    }
                }
            } else {
                st = set_ldap_error(context, st, OP_SEARCH);
                goto cleanup;
            }
        }
    }

    /*
     * If xargs.dn is set then the request is to add a
     * kerberos principal on a ldap object, but if
     * there is one already on the ldap object this
     * should result in an error.
     */

    if (xargs.dn != NULL && krb_identity_exists == TRUE) {
        st = EINVAL;
        snprintf(errbuf, sizeof(errbuf),
                 _('ldap object is already kerberized'));
        k5_setmsg(context, st, '%s', errbuf);
        goto cleanup;
    }

    if (xargs.linkdn != NULL) {
        /*
         * link information can be changed using modprinc.
         * However, link information can be changed only on the
         * standalone kerberos principal objects. A standalone
         * kerberos principal object is of type krbprincipal
         * structural objectclass.
         *
         * NOTE: kerberos principals on an ldap object can't be
         * linked to other ldap objects.
         */
        if (optype == MODIFY_PRINCIPAL &&
            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {
            st = EINVAL;
            snprintf(errbuf, sizeof(errbuf),
                     _('link information can not be set/updated as the '
                       'kerberos principal belongs to an ldap object'));
            k5_setmsg(context, st, '%s', errbuf);
            goto cleanup;
        }
        /*
         * Check the link information. If there is already a link
         * existing then this operation is not allowed.
         */
        {
            char **linkdns=NULL;
            int  j=0;

            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {
                snprintf(errbuf, sizeof(errbuf),
                         _('Failed getting object references'));
                k5_setmsg(context, st, '%s', errbuf);
                goto cleanup;
            }
            if (linkdns != NULL) {
                st = EINVAL;
                snprintf(errbuf, sizeof(errbuf),
                         _('kerberos principal is already linked to a ldap '
                           'object'));
                k5_setmsg(context, st, '%s', errbuf);
                for (j=0; linkdns[j] != NULL; ++j)
                    free (linkdns[j]);
                free (linkdns);
                goto cleanup;
            }
        }

        establish_links = TRUE;
    }

    if (entry->mask & KADM5_LAST_SUCCESS) {
        memset(strval, 0, sizeof(strval));
        if ((strval[0]=getstringtime(entry->last_success)) == NULL)
            goto cleanup;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbLastSuccessfulAuth', LDAP_MOD_REPLACE, strval)) != 0) {
            free (strval[0]);
            goto cleanup;
        }
        free (strval[0]);
    }

    if (entry->mask & KADM5_LAST_FAILED) {
        memset(strval, 0, sizeof(strval));
        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)
            goto cleanup;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbLastFailedAuth', LDAP_MOD_REPLACE, strval)) != 0) {
            free (strval[0]);
            goto cleanup;
        }
        free(strval[0]);
    }

    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {
        krb5_kvno fail_auth_count;

        fail_auth_count = entry->fail_auth_count;
        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)
            fail_auth_count++;

        st = krb5_add_int_mem_ldap_mod(&mods, 'krbLoginFailedCount',
                                       LDAP_MOD_REPLACE,
                                       fail_auth_count);
        if (st != 0)
            goto cleanup;
    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {
        int attr_mask = 0;
        krb5_boolean has_fail_count;

        /* Check if the krbLoginFailedCount attribute exists.  (Through
         * krb5 1.8.1, it wasn't set in new entries.) */
        st = krb5_get_attributes_mask(context, entry, &attr_mask);
        if (st != 0)
            goto cleanup;
        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);

        /*
         * If the client library and server supports RFC 4525,
         * then use it to increment by one the value of the
         * krbLoginFailedCount attribute. Otherwise, assert the
         * (provided) old value by deleting it before adding.
         */
#ifdef LDAP_MOD_INCREMENT
        if (ldap_server_handle->server_info->modify_increment &&
            has_fail_count) {
            st = krb5_add_int_mem_ldap_mod(&mods, 'krbLoginFailedCount',
                                           LDAP_MOD_INCREMENT, 1);
            if (st != 0)
                goto cleanup;
        } else {
#endif /* LDAP_MOD_INCREMENT */
            if (has_fail_count) {
                st = krb5_add_int_mem_ldap_mod(&mods,
                                               'krbLoginFailedCount',
                                               LDAP_MOD_DELETE,
                                               entry->fail_auth_count);
                if (st != 0)
                    goto cleanup;
            }
            st = krb5_add_int_mem_ldap_mod(&mods, 'krbLoginFailedCount',
                                           LDAP_MOD_ADD,
                                           entry->fail_auth_count + 1);
            if (st != 0)
                goto cleanup;
#ifdef LDAP_MOD_INCREMENT
        }
#endif
    } else if (optype == ADD_PRINCIPAL) {
        /* Initialize krbLoginFailedCount in new entries to help avoid a
         * race during the first failed login. */
        st = krb5_add_int_mem_ldap_mod(&mods, 'krbLoginFailedCount',
                                       LDAP_MOD_ADD, 0);
    }

    if (entry->mask & KADM5_MAX_LIFE) {
        if ((st=krb5_add_int_mem_ldap_mod(&mods, 'krbmaxticketlife', LDAP_MOD_REPLACE, entry->max_life)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_MAX_RLIFE) {
        if ((st=krb5_add_int_mem_ldap_mod(&mods, 'krbmaxrenewableage', LDAP_MOD_REPLACE,
                                          entry->max_renewable_life)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_ATTRIBUTES) {
        if ((st=krb5_add_int_mem_ldap_mod(&mods, 'krbticketflags', LDAP_MOD_REPLACE,
                                          entry->attributes)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_PRINCIPAL) {
        memset(strval, 0, sizeof(strval));
        strval[0] = user;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbprincipalname', LDAP_MOD_REPLACE, strval)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {
        memset(strval, 0, sizeof(strval));
        if ((strval[0]=getstringtime(entry->expiration)) == NULL)
            goto cleanup;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbprincipalexpiration', LDAP_MOD_REPLACE, strval)) != 0) {
            free (strval[0]);
            goto cleanup;
        }
        free (strval[0]);
    }

    if (entry->mask & KADM5_PW_EXPIRATION) {
        memset(strval, 0, sizeof(strval));
        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)
            goto cleanup;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbpasswordexpiration',
                                          LDAP_MOD_REPLACE,
                                          strval)) != 0) {
            free (strval[0]);
            goto cleanup;
        }
        free (strval[0]);
    }

    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {
        memset(&princ_ent, 0, sizeof(princ_ent));
        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {
            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {
                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {
                    goto cleanup;
                }
                break;
            }
        }
    }

    if (entry->mask & KADM5_POLICY) {
        if (princ_ent.aux_attributes & KADM5_POLICY) {
            memset(strval, 0, sizeof(strval));
            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)
                goto cleanup;
            strval[0] = polname;
            if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbpwdpolicyreference', LDAP_MOD_REPLACE, strval)) != 0)
                goto cleanup;
        } else {
            st = EINVAL;
            k5_setmsg(context, st, 'Password policy value null');
            goto cleanup;
        }
    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {
        /*
         * a load is special in that existing entries must have attrs that
         * removed.
         */

        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbpwdpolicyreference', LDAP_MOD_REPLACE, NULL)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_POLICY_CLR) {
        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbpwdpolicyreference', LDAP_MOD_DELETE, NULL)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_KEY_HIST) {
        bersecretkey = krb5_encode_histkey(&princ_ent);
        if (bersecretkey == NULL) {
            st = ENOMEM;
            goto cleanup;
        }

        st = krb5_add_ber_mem_ldap_mod(&mods, 'krbpwdhistory',
                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                                       bersecretkey);
        if (st != 0)
            goto cleanup;
        free_berdata(bersecretkey);
        bersecretkey = NULL;
    }

    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {
        krb5_kvno mkvno;

        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)
            goto cleanup;
        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,
                                                 entry->n_key_data, mkvno);

        if (bersecretkey == NULL) {
            st = ENOMEM;
            goto cleanup;
        }
        /* An empty list of bervals is only accepted for modify operations,
         * not add operations. */
        if (bersecretkey[0] != NULL || !create_standalone) {
            st = krb5_add_ber_mem_ldap_mod(&mods, 'krbprincipalkey',
                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                                           bersecretkey);
            if (st != 0)
                goto cleanup;
        }

        if (!(entry->mask & KADM5_PRINCIPAL)) {
            memset(strval, 0, sizeof(strval));
            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)
                goto cleanup;
            if ((st=krb5_add_str_mem_ldap_mod(&mods,
                                              'krbpasswordexpiration',
                                              LDAP_MOD_REPLACE, strval)) != 0) {
                free (strval[0]);
                goto cleanup;
            }
            free (strval[0]);
        }

        /* Update last password change whenever a new key is set */
        {
            krb5_timestamp last_pw_changed;
            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,
                                                    &last_pw_changed)) != 0)
                goto cleanup;

            memset(strval, 0, sizeof(strval));
            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)
                goto cleanup;

            if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbLastPwdChange',
                                              LDAP_MOD_REPLACE, strval)) != 0) {
                free (strval[0]);
                goto cleanup;
            }
            free (strval[0]);
        }

    } /* Modify Key data ends here */

    /* Auth indicators will also be stored in krbExtraData when processing
     * tl_data. */
    st = update_ldap_mod_auth_ind(context, entry, &mods);
    if (st != 0)
        goto cleanup;

    /* Set tl_data */
    if (entry->tl_data != NULL) {
        int count = 0;
        struct berval **ber_tl_data = NULL;
        krb5_tl_data *ptr;
        krb5_timestamp unlock_time;
        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {
            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE
#ifdef SECURID
                || ptr->tl_data_type == KRB5_TL_DB_ARGS
#endif
                || ptr->tl_data_type == KRB5_TL_KADM_DATA
                || ptr->tl_data_type == KDB_TL_USER_INFO
                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL
                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)
                continue;
            count++;
        }
        if (count != 0) {
            int j;
            ber_tl_data = (struct berval **) calloc (count + 1,
                                                     sizeof (struct berval*));
            if (ber_tl_data == NULL) {
                st = ENOMEM;
                goto cleanup;
            }
            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {
                /* Ignore tl_data that are stored in separate directory
                 * attributes */
                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE
#ifdef SECURID
                    || ptr->tl_data_type == KRB5_TL_DB_ARGS
#endif
                    || ptr->tl_data_type == KRB5_TL_KADM_DATA
                    || ptr->tl_data_type == KDB_TL_USER_INFO
                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL
                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)
                    continue;
                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)
                    break;
                j++;
            }
            if (st == 0) {
                ber_tl_data[count] = NULL;
                st=krb5_add_ber_mem_ldap_mod(&mods, 'krbExtraData',
                                             LDAP_MOD_REPLACE |
                                             LDAP_MOD_BVALUES, ber_tl_data);
            }
            free_berdata(ber_tl_data);
            if (st != 0)
                goto cleanup;
        }
        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,
                                                  &unlock_time)) != 0)
            goto cleanup;
        if (unlock_time != 0) {
            /* Update last admin unlock */
            memset(strval, 0, sizeof(strval));
            if ((strval[0] = getstringtime(unlock_time)) == NULL)
                goto cleanup;

            if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbLastAdminUnlock',
                                              LDAP_MOD_REPLACE, strval)) != 0) {
                free (strval[0]);
                goto cleanup;
            }
            free (strval[0]);
        }
    }

    /* Directory specific attribute */
    if (xargs.tktpolicydn != NULL) {
        int tmask=0;

        if (strlen(xargs.tktpolicydn) != 0) {
            st = checkattributevalue(ld, xargs.tktpolicydn, 'objectclass', policyclass, &tmask);
            CHECK_CLASS_VALIDITY(st, tmask, _('ticket policy object value: '));

            strval[0] = xargs.tktpolicydn;
            strval[1] = NULL;
            if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbticketpolicyreference', LDAP_MOD_REPLACE, strval)) != 0)
                goto cleanup;

        } else {
            /* if xargs.tktpolicydn is a empty string, then delete
             * already existing krbticketpolicyreference attr */
            if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbticketpolicyreference', LDAP_MOD_DELETE, NULL)) != 0)
                goto cleanup;
        }

    }

    if (establish_links == TRUE) {
        memset(strval, 0, sizeof(strval));
        strval[0] = xargs.linkdn;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'krbObjectReferences', LDAP_MOD_REPLACE, strval)) != 0)
            goto cleanup;
    }

    /*
     * in case mods is NULL then return
     * not sure but can happen in a modprinc
     * so no need to return an error
     * addprinc will at least have the principal name
     * and the keys passed in
     */
    if (mods == NULL)
        goto cleanup;

    if (create_standalone == TRUE) {
        memset(strval, 0, sizeof(strval));
        strval[0] = 'krbprincipal';
        strval[1] = 'krbprincipalaux';
        strval[2] = 'krbTicketPolicyAux';

        if ((st=krb5_add_str_mem_ldap_mod(&mods, 'objectclass', LDAP_MOD_ADD, strval)) != 0)
            goto cleanup;

        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);
        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {
            /* a load operation must replace an existing entry */
            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);
            if (st != LDAP_SUCCESS) {
                snprintf(errbuf, sizeof(errbuf),
                         _('Principal delete failed (trying to replace '
                           'entry): %s'), ldap_err2string(st));
                st = translate_ldap_error (st, OP_ADD);
                k5_setmsg(context, st, '%s', errbuf);
                goto cleanup;
            } else {
                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);
            }
        }
        if (st != LDAP_SUCCESS) {
            snprintf(errbuf, sizeof(errbuf), _('Principal add failed: %s'),
                     ldap_err2string(st));
            st = translate_ldap_error (st, OP_ADD);
            k5_setmsg(context, st, '%s', errbuf);
            goto cleanup;
        }
    } else {
        /*
         * Here existing ldap object is modified and can be related
         * to any attribute, so always ensure that the ldap
         * object is extended with all the kerberos related
         * objectclasses so that there are no constraint
         * violations.
         */
        {
            char *attrvalues[] = {'krbprincipalaux', 'krbTicketPolicyAux', NULL};
            int p, q, r=0, amask=0;

            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,
                                        'objectclass', attrvalues, &amask)) != 0)
                goto cleanup;

            memset(strval, 0, sizeof(strval));
            for (p=1, q=0; p<=2; p<<=1, ++q) {
                if ((p & amask) == 0)
                    strval[r++] = attrvalues[q];
            }
            if (r != 0) {
                if ((st=krb5_add_str_mem_ldap_mod(&mods, 'objectclass', LDAP_MOD_ADD, strval)) != 0)
                    goto cleanup;
            }
        }
        if (xargs.dn != NULL)
            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);
        else
            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);

        if (st != LDAP_SUCCESS) {
            snprintf(errbuf, sizeof(errbuf), _('User modification failed: %s'),
                     ldap_err2string(st));
            st = translate_ldap_error (st, OP_MOD);
            k5_setmsg(context, st, '%s', errbuf);
            goto cleanup;
        }

        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)
            entry->fail_auth_count++;
    }

cleanup:
    if (user)
        free(user);

    if (filtuser)
        free(filtuser);

    free_xargs(xargs);

    if (standalone_principal_dn)
        free(standalone_principal_dn);

    if (principal_dn)
        free (principal_dn);

    if (polname != NULL)
        free(polname);

    for (tre = 0; tre < ntrees; tre++)
        free(subtreelist[tre]);
    free(subtreelist);

    if (subtree)
        free (subtree);

    if (bersecretkey) {
        for (l=0; bersecretkey[l]; ++l) {
            if (bersecretkey[l]->bv_val)
                free (bersecretkey[l]->bv_val);
            free (bersecretkey[l]);
        }
        free (bersecretkey);
    }

    if (keys)
        free (keys);

    ldap_mods_free(mods, 1);
    ldap_osa_free_princ_ent(&princ_ent);
    ldap_msgfree(result);
    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);
    return(st);
}
",1,8325
krb5/krb5,e1caf6fb74981da62039846931ebdffed71309d1,"kadm5_ret_t
kadm5_create_principal_3(void *server_handle,
                         kadm5_principal_ent_t entry, long mask,
                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,
                         char *password)
{
    krb5_db_entry               *kdb;
    osa_princ_ent_rec           adb;
    kadm5_policy_ent_rec        polent;
    krb5_boolean                have_polent = FALSE;
    krb5_timestamp              now;
    krb5_tl_data                *tl_data_tail;
    unsigned int                ret;
    kadm5_server_handle_t handle = server_handle;
    krb5_keyblock               *act_mkey;
    krb5_kvno                   act_kvno;
    int                         new_n_ks_tuple = 0;
    krb5_key_salt_tuple         *new_ks_tuple = NULL;

    CHECK_HANDLE(server_handle);

    krb5_clear_error_message(handle->context);

    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);

    /*
     * Argument sanity checking, and opening up the DB
     */
    if (entry == NULL)
        return EINVAL;
    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||
       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||
       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||
       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||
       (mask & KADM5_FAIL_AUTH_COUNT))
        return KADM5_BAD_MASK;
    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)
        return KADM5_BAD_MASK;
    if((mask & KADM5_POLICY) && entry->policy == NULL)
        return KADM5_BAD_MASK;
    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))
        return KADM5_BAD_MASK;
    if((mask & ~ALL_PRINC_MASK))
        return KADM5_BAD_MASK;

    /*
     * Check to see if the principal exists
     */
    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);

    switch(ret) {
    case KADM5_UNK_PRINC:
        break;
    case 0:
        kdb_free_entry(handle, kdb, &adb);
        return KADM5_DUP;
    default:
        return ret;
    }

    kdb = calloc(1, sizeof(*kdb));
    if (kdb == NULL)
        return ENOMEM;
    memset(&adb, 0, sizeof(osa_princ_ent_rec));

    /*
     * If a policy was specified, load it.
     * If we can not find the one specified return an error
     */
    if ((mask & KADM5_POLICY)) {
        ret = get_policy(handle, entry->policy, &polent, &have_polent);
        if (ret)
            goto cleanup;
    }
    if (password) {
        ret = passwd_check(handle, password, have_polent ? &polent : NULL,
                           entry->principal);
        if (ret)
            goto cleanup;
    }
    /*
     * Start populating the various DB fields, using the
     * 'defaults' for fields that were not specified by the
     * mask.
     */
    if ((ret = krb5_timeofday(handle->context, &now)))
        goto cleanup;

    kdb->magic = KRB5_KDB_MAGIC_NUMBER;
    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */

    if ((mask & KADM5_ATTRIBUTES))
        kdb->attributes = entry->attributes;
    else
        kdb->attributes = handle->params.flags;

    if ((mask & KADM5_MAX_LIFE))
        kdb->max_life = entry->max_life;
    else
        kdb->max_life = handle->params.max_life;

    if (mask & KADM5_MAX_RLIFE)
        kdb->max_renewable_life = entry->max_renewable_life;
    else
        kdb->max_renewable_life = handle->params.max_rlife;

    if ((mask & KADM5_PRINC_EXPIRE_TIME))
        kdb->expiration = entry->princ_expire_time;
    else
        kdb->expiration = handle->params.expiration;

    kdb->pw_expiration = 0;
    if (have_polent) {
        if(polent.pw_max_life)
            kdb->pw_expiration = ts_incr(now, polent.pw_max_life);
        else
            kdb->pw_expiration = 0;
    }
    if ((mask & KADM5_PW_EXPIRATION))
        kdb->pw_expiration = entry->pw_expiration;

    kdb->last_success = 0;
    kdb->last_failed = 0;
    kdb->fail_auth_count = 0;

    /* this is kind of gross, but in order to free the tl data, I need
       to free the entire kdb entry, and that will try to free the
       principal. */

    ret = krb5_copy_principal(handle->context, entry->principal, &kdb->princ);
    if (ret)
        goto cleanup;

    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))
        goto cleanup;

    if (mask & KADM5_TL_DATA) {
        /* splice entry->tl_data onto the front of kdb->tl_data */
        for (tl_data_tail = entry->tl_data; tl_data_tail;
             tl_data_tail = tl_data_tail->tl_data_next)
        {
            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);
            if( ret )
                goto cleanup;
        }
    }

    /*
     * We need to have setup the TL data, so we have strings, so we can
     * check enctype policy, which is why we check/initialize ks_tuple
     * this late.
     */
    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,
                               &new_n_ks_tuple, &new_ks_tuple);
    if (ret)
        goto cleanup;

    /* initialize the keys */

    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);
    if (ret)
        goto cleanup;

    if (mask & KADM5_KEY_DATA) {
        /* The client requested no keys for this principal. */
        assert(entry->n_key_data == 0);
    } else if (password) {
        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,
                           new_n_ks_tuple, password,
                           (mask & KADM5_KVNO)?entry->kvno:1,
                           FALSE, kdb);
    } else {
        /* Null password means create with random key (new in 1.8). */
        ret = krb5_dbe_crk(handle->context, &master_keyblock,
                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);
    }
    if (ret)
        goto cleanup;

    /* Record the master key VNO used to encrypt this entry's keys */
    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);
    if (ret)
        goto cleanup;

    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,
                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,
                               new_n_ks_tuple, new_ks_tuple, password);
    if (ret)
        goto cleanup;

    /* populate the admin-server-specific fields.  In the OV server,
       this used to be in a separate database.  Since there's already
       marshalling code for the admin fields, to keep things simple,
       I'm going to keep it, and make all the admin stuff occupy a
       single tl_data record, */

    adb.admin_history_kvno = INITIAL_HIST_KVNO;
    if (mask & KADM5_POLICY) {
        adb.aux_attributes = KADM5_POLICY;

        /* this does *not* need to be strdup'ed, because adb is xdr */
        /* encoded in osa_adb_create_princ, and not ever freed */

        adb.policy = entry->policy;
    }

    /* In all cases key and the principal data is set, let the database provider know */
    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;

    /* store the new db entry */
    ret = kdb_put_entry(handle, kdb, &adb);

    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,
                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,
                                new_n_ks_tuple, new_ks_tuple, password);

cleanup:
    free(new_ks_tuple);
    krb5_db_free_principal(handle->context, kdb);
    if (have_polent)
        (void) kadm5_free_policy_ent(handle->lhandle, &polent);
    return ret;
}
",1,8326
krb5/krb5,e1caf6fb74981da62039846931ebdffed71309d1,"kadm5_ret_t
kadm5_setv4key_principal(void *server_handle,
                         krb5_principal principal,
                         krb5_keyblock *keyblock)
{
    krb5_db_entry               *kdb;
    osa_princ_ent_rec           adb;
    krb5_timestamp              now;
    kadm5_policy_ent_rec        pol;
    krb5_keysalt                keysalt;
    int                         i, kvno, ret;
    krb5_boolean                have_pol = FALSE;
    kadm5_server_handle_t       handle = server_handle;
    krb5_key_data               tmp_key_data;
    krb5_keyblock               *act_mkey;

    memset( &tmp_key_data, 0, sizeof(tmp_key_data));

    CHECK_HANDLE(server_handle);

    krb5_clear_error_message(handle->context);

    if (principal == NULL || keyblock == NULL)
        return EINVAL;
    if (hist_princ && /* this will be NULL when initializing the databse */
        ((krb5_principal_compare(handle->context,
                                 principal, hist_princ)) == TRUE))
        return KADM5_PROTECT_PRINCIPAL;

    if (keyblock->enctype != ENCTYPE_DES_CBC_CRC)
        return KADM5_SETV4KEY_INVAL_ENCTYPE;

    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))
        return(ret);

    for (kvno = 0, i=0; i<kdb->n_key_data; i++)
        if (kdb->key_data[i].key_data_kvno > kvno)
            kvno = kdb->key_data[i].key_data_kvno;

    if (kdb->key_data != NULL)
        cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);

    kdb->key_data = calloc(1, sizeof(krb5_key_data));
    if (kdb->key_data == NULL)
        return ENOMEM;
    kdb->n_key_data = 1;
    keysalt.type = KRB5_KDB_SALTTYPE_V4;
    /* XXX data.magic? */
    keysalt.data.length = 0;
    keysalt.data.data = NULL;

    ret = kdb_get_active_mkey(handle, NULL, &act_mkey);
    if (ret)
        goto done;

    /* use tmp_key_data as temporary location and reallocate later */
    ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey, keyblock,
                                    &keysalt, kvno + 1, kdb->key_data);
    if (ret) {
        goto done;
    }

    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;

    ret = krb5_timeofday(handle->context, &now);
    if (ret)
        goto done;

    if ((adb.aux_attributes & KADM5_POLICY)) {
        ret = get_policy(handle, adb.policy, &pol, &have_pol);
        if (ret)
            goto done;
    }
    if (have_pol) {
        if (pol.pw_max_life)
            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);
        else
            kdb->pw_expiration = 0;
    } else {
        kdb->pw_expiration = 0;
    }

    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);
    if (ret)
        goto done;

    /* unlock principal on this KDC */
    kdb->fail_auth_count = 0;

    /* key data changed, let the database provider know */
    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;

    if ((ret = kdb_put_entry(handle, kdb, &adb)))
        goto done;

    ret = KADM5_OK;
done:
    for (i = 0; i < tmp_key_data.key_data_ver; i++) {
        if (tmp_key_data.key_data_contents[i]) {
            memset (tmp_key_data.key_data_contents[i], 0, tmp_key_data.key_data_length[i]);
            free (tmp_key_data.key_data_contents[i]);
        }
    }

    kdb_free_entry(handle, kdb, &adb);
    if (have_pol)
        kadm5_free_policy_ent(handle->lhandle, &pol);

    return ret;
}
",0,8327
krb5/krb5,e1caf6fb74981da62039846931ebdffed71309d1,"kadm5_ret_t
kadm5_setkey_principal_3(void *server_handle,
                         krb5_principal principal,
                         krb5_boolean keepold,
                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,
                         krb5_keyblock *keyblocks,
                         int n_keys)
{
    kadm5_key_data *key_data;
    kadm5_ret_t ret;
    int i;

    if (keyblocks == NULL)
        return EINVAL;

    if (n_ks_tuple) {
        if (n_ks_tuple != n_keys)
            return KADM5_SETKEY3_ETYPE_MISMATCH;
        for (i = 0; i < n_ks_tuple; i++) {
            if (ks_tuple[i].ks_enctype != keyblocks[i].enctype)
                return KADM5_SETKEY3_ETYPE_MISMATCH;
        }
    }

    key_data = calloc(n_keys, sizeof(kadm5_key_data));
    if (key_data == NULL)
        return ENOMEM;

    for (i = 0; i < n_keys; i++) {
        key_data[i].key = keyblocks[i];
        key_data[i].salt.type =
            n_ks_tuple ? ks_tuple[i].ks_salttype : KRB5_KDB_SALTTYPE_NORMAL;
    }

    ret = kadm5_setkey_principal_4(server_handle, principal, keepold,
                                   key_data, n_keys);
    free(key_data);
    return ret;
}
",0,8328
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"  int bufsize = width*3*tiff_bps/8;
  if(tiff_bps <= 8)
    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);
",1,8329
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"{
  uchar pixel[10];
  unsigned iten=0, isix, i, buffer=0, todo[16];
",1,8330
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"    for (i=0; i < 16; i+=2)
      raw_image[todo[i]] = (todo[i+1] & 0x3ff);
  }
",1,8331
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"void CLASS rollei_load_raw()
{
  uchar pixel[10];
  unsigned iten=0, isix, i, buffer=0, todo[16];

  isix = raw_width * raw_height * 5 / 8;
  while (fread (pixel, 1, 10, ifp) == 10) {
#ifdef LIBRAW_LIBRARY_BUILD
    checkCancel();
#endif
    for (i=0; i < 10; i+=2) {
      todo[i]   = iten++;
      todo[i+1] = pixel[i] << 8 | pixel[i+1];
      buffer    = pixel[i] >> 2 | buffer << 6;
    }
    for (   ; i < 16; i+=2) {
      todo[i]   = isix++;
      todo[i+1] = buffer >> (14-i)*5;
    }
    for (i=0; i < 16; i+=2)
      raw_image[todo[i]] = (todo[i+1] & 0x3ff);
  }
  maximum = 0x3ff;
}
",1,8332
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"void CLASS samsung_load_raw()
{
  int row, col, c, i, dir, op[4], len[4];

  order = 0x4949;
  for (row=0; row < raw_height; row++) {
#ifdef LIBRAW_LIBRARY_BUILD
    checkCancel();
#endif
    fseek (ifp, strip_offset+row*4, SEEK_SET);
    fseek (ifp, data_offset+get4(), SEEK_SET);
    ph1_bits(-1);
    FORC4 len[c] = row < 2 ? 7:4;
    for (col=0; col < raw_width; col+=16) {
      dir = ph1_bits(1);
      FORC4 op[c] = ph1_bits(2);
      FORC4 switch (op[c]) {
	case 3: len[c] = ph1_bits(4);	break;
	case 2: len[c]--;		break;
	case 1: len[c]++;
      }
      for (c=0; c < 16; c+=2) {
	i = len[((c & 1) << 1) | (c >> 3)];
        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +
	  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);
	if (c == 14) c = -1;
      }
    }
  }
  for (row=0; row < raw_height-1; row+=2)
    for (col=0; col < raw_width-1; col+=2)
      SWAP (RAW(row,col+1), RAW(row+1,col));
}
",1,8333
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"void CLASS parse_exif (int base)
{
  unsigned kodak, entries, tag, type, len, save, c;
  double expo,ape;

  kodak = !strncmp(make,'EASTMAN',7) && tiff_nifds < 3;
  entries = get2();
  if(!strncmp(make,'Hasselblad',10) && (tiff_nifds > 3) && (entries > 512)) return;
#ifdef LIBRAW_LIBRARY_BUILD
  INT64 fsize = ifp->size();
#endif
  while (entries--) {
    tiff_get (base, &tag, &type, &len, &save);

#ifdef LIBRAW_LIBRARY_BUILD
    INT64 savepos = ftell(ifp);
    if(len > 8 && savepos + len > fsize*2) continue;
    if(callbacks.exif_cb)
      {
        callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);
        fseek(ifp,savepos,SEEK_SET);
      }
#endif
    switch (tag) {
#ifdef LIBRAW_LIBRARY_BUILD
    case 0xa405:		// FocalLengthIn35mmFormat
      imgdata.lens.FocalLengthIn35mmFormat = get2();
      break;
    case 0xa431:		// BodySerialNumber
      stmread(imgdata.shootinginfo.BodySerial, len, ifp);
      break;
    case 0xa432:		// LensInfo, 42034dec, Lens Specification per EXIF standard
      imgdata.lens.MinFocal = getreal(type);
      imgdata.lens.MaxFocal = getreal(type);
      imgdata.lens.MaxAp4MinFocal = getreal(type);
      imgdata.lens.MaxAp4MaxFocal = getreal(type);
      break;
    case 0xa435:		// LensSerialNumber
      stmread(imgdata.lens.LensSerial, len, ifp);
      break;
    case 0xc630:		// DNG LensInfo, Lens Specification per EXIF standard
      imgdata.lens.dng.MinFocal = getreal(type);
      imgdata.lens.dng.MaxFocal = getreal(type);
      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);
      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);
      break;
    case 0xa433:		// LensMake
      stmread(imgdata.lens.LensMake, len, ifp);
      break;
    case 0xa434:		// LensModel
      stmread(imgdata.lens.Lens, len, ifp);
      if (!strncmp(imgdata.lens.Lens, '----', 4))
        imgdata.lens.Lens[0] = 0;
      break;
    case 0x9205:
      imgdata.lens.EXIF_MaxAp = libraw_powf64(2.0f, (getreal(type) / 2.0f));
      break;
#endif
      case 33434:  tiff_ifd[tiff_nifds-1].t_shutter =
		   shutter = getreal(type);		break;
      case 33437:  aperture = getreal(type);		break;  // 0x829d FNumber
      case 34855:  iso_speed = get2();			break;
      case 34866:
        if (iso_speed == 0xffff && (!strncasecmp(make, 'SONY',4) || !strncasecmp(make, 'CANON',5)))
          iso_speed = getreal(type);
        break;
      case 36867:
      case 36868:  get_timestamp(0);			break;
      case 37377:  if ((expo = -getreal(type)) < 128 && shutter == 0.)
		     tiff_ifd[tiff_nifds-1].t_shutter =
			shutter = libraw_powf64(2.0, expo);
		break;
      case 37378:                                       // 0x9202 ApertureValue
        if ((fabs(ape = getreal(type))<256.0) && (!aperture))
          aperture = libraw_powf64(2.0, ape/2);
        break;
      case 37385:  flash_used = getreal(type);          break;
      case 37386:  focal_len = getreal(type);		break;
      case 37500:  	                         // tag 0x927c
#ifdef LIBRAW_LIBRARY_BUILD
       if (((make[0] == '\0') && (!strncmp(model, 'ov5647',6))) ||
           ((!strncmp(make, 'RaspberryPi',11)) && (!strncmp(model, 'RP_OV5647',9))) ||
           ((!strncmp(make, 'RaspberryPi',11)) && (!strncmp(model, 'RP_imx219',9)))) {
         char mn_text[512];
         char* pos;
         char ccms[512];
         ushort l;
         float num;

         fgets(mn_text, len, ifp);
         pos = strstr(mn_text, 'gain_r=');
         if (pos) cam_mul[0] = atof(pos+7);
         pos = strstr(mn_text, 'gain_b=');
         if (pos) cam_mul[2] = atof(pos+7);
         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;
         else cam_mul[0] = cam_mul[2] = 0.0f;

         pos = strstr(mn_text, 'ccm=') + 4;
         l = strstr(pos, ' ') - pos;
         memcpy (ccms, pos, l);
         ccms[l] = '\0';

         pos = strtok (ccms, ',');
         for (l=0; l<4; l++) {
           num = 0.0;
           for (c=0; c<3; c++) {
             imgdata.color.ccm[l][c] = (float)atoi(pos);
             num += imgdata.color.ccm[l][c];
             pos = strtok (NULL, ',');
           }
           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;
         }
       }
       else
#endif
        parse_makernote (base, 0);
       break;
      case 40962:  if (kodak) raw_width  = get4();	break;
      case 40963:  if (kodak) raw_height = get4();	break;
      case 41730:
	if (get4() == 0x20002)
	  for (exif_cfa=c=0; c < 8; c+=2)
	    exif_cfa |= fgetc(ifp) * 0x01010101 << c;
    }
    fseek (ifp, save, SEEK_SET);
  }
}
",1,8334
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"float CLASS find_green (int bps, int bite, int off0, int off1)
{
  UINT64 bitbuf=0;
  int vbits, col, i, c;
  ushort img[2][2064];
  double sum[]={0,0};

  FORC(2) {
    fseek (ifp, c ? off1:off0, SEEK_SET);
    for (vbits=col=0; col < width; col++) {
      for (vbits -= bps; vbits < 0; vbits += bite) {
	bitbuf <<= bite;
	for (i=0; i < bite; i+=8)
	  bitbuf |= (unsigned) (fgetc(ifp) << i);
      }
      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);
    }
  }
  FORC(width-1) {
    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);
    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);
  }
  return 100 * log(sum[0]/sum[1]);
}
",1,8335
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"static void remove_trailing_spaces(char *string, size_t len)
{
  if(len<1) return; // not needed, b/c sizeof of make/model is 64
  string[len-1]=0;
  if(len<3) return; // also not needed
  len = strnlen(string,len-1);
  for(int i=len-1; i>=0; i--)
  {
    if(isspace(string[i]))
      string[i]=0;
    else
      break;
  }
}
",1,8337
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"    checkCancel();
#endif
    if (tiff_bps == 16)
",0,8338
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"  fseek (ifp, data_offset, SEEK_SET);
  getbits(-1);
#ifdef LIBRAW_LIBRARY_BUILD
",0,8339
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"int CLASS foveon_apply_curve (short *curve, int i)
{
  if (abs(i) >= curve[0]) return 0;
  return i < 0 ? -curve[1-i] : curve[1+i];
}
",0,8340
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"void CLASS foveon_sd_load_raw()
{
#ifdef LIBRAW_LIBRARY_BUILD
  if(!image)
    throw LIBRAW_EXCEPTION_IO_CORRUPT;
#endif
  struct decode *dindex;
  short diff[1024];
  unsigned bitbuf=0;
  int pred[3], row, col, bit=-1, c, i;

  read_shorts ((ushort *) diff, 1024);
  if (!load_flags) foveon_decoder (1024, 0);

  for (row=0; row < height; row++) {
#ifdef LIBRAW_LIBRARY_BUILD
    checkCancel();
#endif
    memset (pred, 0, sizeof pred);
    if (!bit && !load_flags && atoi(model+2) < 14) get4();
    for (col=bit=0; col < width; col++) {
      if (load_flags) {
	bitbuf = get4();
	FORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];
      }
      else FORC3 {
	for (dindex=first_decode; dindex->branch[0]; ) {
	  if ((bit = (bit-1) & 31) == 31)
	    for (i=0; i < 4; i++)
	      bitbuf = (bitbuf << 8) + fgetc(ifp);
	  dindex = dindex->branch[bitbuf >> bit & 1];
	}
	pred[c] += diff[dindex->leaf];
	if (pred[c] >> 16 && ~pred[c] >> 16) derror();
      }
      FORC3 image[row*width+col][c] = pred[c];
    }
  }
}
",0,8341
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"int CLASS minolta_z2()
{
  int i, nz;
  char tail[424];

  fseek (ifp, -sizeof tail, SEEK_END);
  fread (tail, 1, sizeof tail, ifp);
  for (nz=i=0; i < sizeof tail; i++)
    if (tail[i]) nz++;
  return nz > 20;
}
",0,8342
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"  static int vbits=0, reset=0;
#else
#define bitbuf tls->getbits.bitbuf
",0,8343
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"
void CLASS cubic_spline (const int *x_, const int *y_, const int len)
{
",0,8344
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"#include <math.h>
",0,8345
LibRaw/LibRaw,fd6330292501983ac75fe4162275794b18445bd9,"void CLASS recover_highlights()
{
  float *map, sum, wgt, grow;
  int hsat[4], count, spread, change, val, i;
  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;
  ushort *pixel;
  static const signed char dir[8][2] =
    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };

#ifdef DCRAW_VERBOSE
  if (verbose) fprintf (stderr,_('Rebuilding highlights...\n'));
#endif

  grow = pow (2.0, 4-highlight);
  FORCC hsat[c] = 32000 * pre_mul[c];
  for (kc=0, c=1; c < colors; c++)
    if (pre_mul[kc] < pre_mul[c]) kc = c;
  high = height / SCALE;
  wide =  width / SCALE;
  map = (float *) calloc (high, wide*sizeof *map);
  merror (map, 'recover_highlights()');
  FORCC if (c != kc) {
#ifdef LIBRAW_LIBRARY_BUILD
      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);
#endif
    memset (map, 0, high*wide*sizeof *map);
    for (mrow=0; mrow < high; mrow++)
      for (mcol=0; mcol < wide; mcol++) {
	sum = wgt = count = 0;
	for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)
	  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {
	    pixel = image[row*width+col];
	    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {
	      sum += pixel[c];
	      wgt += pixel[kc];
	      count++;
	    }
	  }
	if (count == SCALE*SCALE)
	  map[mrow*wide+mcol] = sum / wgt;
      }
    for (spread = 32/grow; spread--; ) {
      for (mrow=0; mrow < high; mrow++)
	for (mcol=0; mcol < wide; mcol++) {
	  if (map[mrow*wide+mcol]) continue;
	  sum = count = 0;
	  for (d=0; d < 8; d++) {
	    y = mrow + dir[d][0];
	    x = mcol + dir[d][1];
	    if (y < high && x < wide && map[y*wide+x] > 0) {
	      sum  += (1 + (d & 1)) * map[y*wide+x];
	      count += 1 + (d & 1);
	    }
	  }
	  if (count > 3)
	    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);
	}
      for (change=i=0; i < high*wide; i++)
	if (map[i] < 0) {
	  map[i] = -map[i];
	  change = 1;
	}
      if (!change) break;
    }
    for (i=0; i < high*wide; i++)
      if (map[i] == 0) map[i] = 1;
    for (mrow=0; mrow < high; mrow++)
      for (mcol=0; mcol < wide; mcol++) {
	for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)
	  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {
	    pixel = image[row*width+col];
	    if (pixel[c] / hsat[c] > 1) {
	      val = pixel[kc] * map[mrow*wide+mcol];
	      if (pixel[c] < val) pixel[c] = CLIP(val);
	    }
	  }
      }
  }
  free (map);
}
",0,8346
tats/w3m,f70b8f0a23e407c18e09dc5acbee7444844839d8,"void
formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
    Buffer save;
    char *p;
    int spos, epos, rows, c_rows, pos, col = 0;
    Line *l;

    copyBuffer(&save, buf);
    gotoLine(buf, a->start.line);
    switch (form->type) {
    case FORM_TEXTAREA:
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
    case FORM_SELECT:
#endif				/* MENU_SELECT */
	spos = a->start.pos;
	epos = a->end.pos;
	break;
    default:
	spos = a->start.pos + 1;
	epos = a->end.pos - 1;
    }
    switch (form->type) {
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
	if (buf->currentLine == NULL ||
	    spos >= buf->currentLine->len || spos < 0)
	    break;
	if (form->checked)
	    buf->currentLine->lineBuf[spos] = '*';
	else
	    buf->currentLine->lineBuf[spos] = ' ';
	break;
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_TEXTAREA:
#ifdef MENU_SELECT
    case FORM_SELECT:
	if (form->type == FORM_SELECT) {
	    p = form->label->ptr;
	    updateSelectOption(form, form->select_option);
	}
	else
#endif				/* MENU_SELECT */
	{
	    if (!form->value)
		break;
	    p = form->value->ptr;
	}
	l = buf->currentLine;
	if (!l)
	    break;
	if (form->type == FORM_TEXTAREA) {
	    int n = a->y - buf->currentLine->linenumber;
	    if (n > 0)
		for (; l && n; l = l->prev, n--) ;
	    else if (n < 0)
		for (; l && n; l = l->prev, n++) ;
	    if (!l)
		break;
	}
	rows = form->rows ? form->rows : 1;
	col = COLPOS(l, a->start.pos);
	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
	    if (rows > 1) {
		pos = columnPos(l, col);
		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
		if (a == NULL)
		    break;
		spos = a->start.pos;
		epos = a->end.pos;
	    }
	    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||
		spos < 0 || epos < 0 || COLPOS(l, epos) < col)
		break;
	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
				   rows > 1,
				   form->type == FORM_INPUT_PASSWORD);
	    if (pos != epos) {
		shiftAnchorPosition(buf->href, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->name, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->img, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->formitem, buf->hmarklist,
				    a->start.line, spos, pos - epos);
	    }
	}
	break;
    }
    copyBuffer(buf, &save);
    arrangeLine(buf);
}
",1,8347
tats/w3m,f70b8f0a23e407c18e09dc5acbee7444844839d8,"static struct pre_form_item *
add_pre_form_item(struct pre_form *pf, struct pre_form_item *prev, int type,
		  char *name, char *value, char *checked)
{
    struct pre_form_item *new;

    if (!pf)
	return NULL;
    if (prev)
	new = prev->next = New(struct pre_form_item);
    else
	new = pf->item = New(struct pre_form_item);
    new->type = type;
    new->name = name;
    new->value = value;
    if (checked && *checked && (!strcmp(checked, '0') ||
				!strcasecmp(checked, 'off')
				|| !strcasecmp(checked, 'no')))
	new->checked = 0;
    else
	new->checked = 1;
    new->next = NULL;
    return new;
}
",0,8348
ImageMagick/ImageMagick,1fbed78912c830ccd82eecdb8a1db4882abb8276,"static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define ThrowDCMException(exception,message) \
{ \
  if (data != (unsigned char *) NULL) \
    data=(unsigned char *) RelinquishMagickMemory(data); \
  if (graymap != (int *) NULL) \
    graymap=(int *) RelinquishMagickMemory(graymap); \
  if (bluemap != (int *) NULL) \
    bluemap=(int *) RelinquishMagickMemory(bluemap); \
  if (greenmap != (int *) NULL) \
    greenmap=(int *) RelinquishMagickMemory(greenmap); \
  if (redmap != (int *) NULL) \
    redmap=(int *) RelinquishMagickMemory(redmap); \
  if (stream_info != (DCMStreamInfo *) NULL) \
    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \
  ThrowReaderException((exception),(message)); \
}

  char
    explicit_vr[MagickPathExtent],
    implicit_vr[MagickPathExtent],
    magick[MagickPathExtent],
    photometric[MagickPathExtent];

  DCMInfo
    info;

  DCMStreamInfo
    *stream_info;

  Image
    *image;

  int
    *bluemap,
    datum,
    *greenmap,
    *graymap,
    *redmap;

  MagickBooleanType
    explicit_file,
    explicit_retry,
    sequence,
    use_explicit;

  MagickOffsetType
    offset;

  register unsigned char
    *p;

  register ssize_t
    i;

  size_t
    colors,
    height,
    length,
    number_scenes,
    quantum,
    status,
    width;

  ssize_t
    count,
    scene;

  unsigned char
    *data;

  unsigned short
    group,
    element;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  image->depth=8UL;
  image->endian=LSBEndian;
  /*
    Read DCM preamble.
  */
  data=(unsigned char *) NULL;
  graymap=(int *) NULL;
  redmap=(int *) NULL;
  greenmap=(int *) NULL;
  bluemap=(int *) NULL;
  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));
  if (stream_info == (DCMStreamInfo *) NULL)
    ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));
  count=ReadBlob(image,128,(unsigned char *) magick);
  if (count != 128)
    ThrowDCMException(CorruptImageError,'ImproperImageHeader');
  count=ReadBlob(image,4,(unsigned char *) magick);
  if ((count != 4) || (LocaleNCompare(magick,'DICM',4) != 0))
    {
      offset=SeekBlob(image,0L,SEEK_SET);
      if (offset < 0)
        ThrowDCMException(CorruptImageError,'ImproperImageHeader');
    }
  /*
    Read DCM Medical image.
  */
  (void) CopyMagickString(photometric,'MONOCHROME1 ',MagickPathExtent);
  info.polarity=MagickFalse;
  info.scale=(Quantum *) NULL;
  info.bits_allocated=8;
  info.bytes_per_pixel=1;
  info.depth=8;
  info.mask=0xffff;
  info.max_value=255UL;
  info.samples_per_pixel=1;
  info.signed_data=(~0UL);
  info.significant_bits=0;
  info.rescale=MagickFalse;
  info.rescale_intercept=0.0;
  info.rescale_slope=1.0;
  info.window_center=0.0;
  info.window_width=0.0;
  data=(unsigned char *) NULL;
  element=0;
  explicit_vr[2]='\0';
  explicit_file=MagickFalse;
  colors=0;
  redmap=(int *) NULL;
  greenmap=(int *) NULL;
  bluemap=(int *) NULL;
  graymap=(int *) NULL;
  height=0;
  number_scenes=1;
  sequence=MagickFalse;
  use_explicit=MagickFalse;
  explicit_retry = MagickFalse;
  width=0;
  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||
                (sequence != MagickFalse); )
  {
    /*
      Read a group.
    */
    image->offset=(ssize_t) TellBlob(image);
    group=ReadBlobLSBShort(image);
    element=ReadBlobLSBShort(image);
    if ((group != 0x0002) && (image->endian == MSBEndian))
      {
        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));
        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));
      }
    quantum=0;
    /*
      Find corresponding VR for this group and element.
    */
    for (i=0; dicom_info[i].group < 0xffff; i++)
      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))
        break;
    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);
    count=ReadBlob(image,2,(unsigned char *) explicit_vr);
    if (count != 2)
      ThrowDCMException(CorruptImageError,'ImproperImageHeader');
    /*
      Check for 'explicitness', but meta-file headers always explicit.
    */
    if ((explicit_file == MagickFalse) && (group != 0x0002))
      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&
        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?
        MagickTrue : MagickFalse;
    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||
      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;
    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,'xs',2) == 0))
      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);
    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,'!!',2) == 0))
      {
        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);
        if (offset < 0)
          ThrowDCMException(CorruptImageError,'ImproperImageHeader');
        quantum=4;
      }
    else
      {
        /*
          Assume explicit type.
        */
        quantum=2;
        if ((strncmp(explicit_vr,'OB',2) == 0) ||
            (strncmp(explicit_vr,'UN',2) == 0) ||
            (strncmp(explicit_vr,'OW',2) == 0) ||
            (strncmp(explicit_vr,'SQ',2) == 0))
          {
            (void) ReadBlobLSBShort(image);
            quantum=4;
          }
      }
    datum=0;
    if (quantum == 4)
      {
        if (group == 0x0002)
          datum=ReadBlobLSBSignedLong(image);
        else
          datum=ReadBlobSignedLong(image);
      }
    else
      if (quantum == 2)
        {
          if (group == 0x0002)
            datum=ReadBlobLSBSignedShort(image);
          else
            datum=ReadBlobSignedShort(image);
        }
    quantum=0;
    length=1;
    if (datum != 0)
      {
        if ((strncmp(implicit_vr,'SS',2) == 0) ||
            (strncmp(implicit_vr,'US',2) == 0))
          quantum=2;
        else
          if ((strncmp(implicit_vr,'UL',2) == 0) ||
              (strncmp(implicit_vr,'SL',2) == 0) ||
              (strncmp(implicit_vr,'FL',2) == 0))
            quantum=4;
          else
            if (strncmp(implicit_vr,'FD',2) != 0)
              quantum=1;
            else
              quantum=8;
        if (datum != ~0)
          length=(size_t) datum/quantum;
        else
          {
            /*
              Sequence and item of undefined length.
            */
            quantum=0;
            length=0;
          }
      }
    if (image_info->verbose != MagickFalse)
      {
        /*
          Display Dicom info.
        */
        if (use_explicit == MagickFalse)
          explicit_vr[0]='\0';
        for (i=0; dicom_info[i].description != (char *) NULL; i++)
          if ((group == dicom_info[i].group) &&
              (element == dicom_info[i].element))
            break;
        (void) FormatLocaleFile(stdout,'0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)',
          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,
          (unsigned long) group,(unsigned long) element);
        if (dicom_info[i].description != (char *) NULL)
          (void) FormatLocaleFile(stdout,' %s',dicom_info[i].description);
        (void) FormatLocaleFile(stdout,': ');
      }
    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))
      {
        if (image_info->verbose != MagickFalse)
          (void) FormatLocaleFile(stdout,'\n');
        break;
      }
    /*
      Allocate space and read an array.
    */
    data=(unsigned char *) NULL;
    if ((length == 1) && (quantum == 1))
      datum=ReadBlobByte(image);
    else
      if ((length == 1) && (quantum == 2))
        {
          if (group == 0x0002)
            datum=ReadBlobLSBSignedShort(image);
          else
            datum=ReadBlobSignedShort(image);
        }
      else
        if ((length == 1) && (quantum == 4))
          {
            if (group == 0x0002)
              datum=ReadBlobLSBSignedLong(image);
            else
              datum=ReadBlobSignedLong(image);
          }
        else
          if ((quantum != 0) && (length != 0))
            {
              if (length > GetBlobSize(image))
                ThrowDCMException(CorruptImageError,
                  'InsufficientImageDataInFile');
              if (~length >= 1)
                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*
                  sizeof(*data));
              if (data == (unsigned char *) NULL)
                ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
              count=ReadBlob(image,(size_t) quantum*length,data);
              if (count != (ssize_t) (quantum*length))
                {
                  if (image_info->verbose != MagickFalse)
                    (void) FormatLocaleFile(stdout,'count=%d quantum=%d '
                      'length=%d group=%d\n',(int) count,(int) quantum,(int)
                      length,(int) group);
                   ThrowDCMException(CorruptImageError,
                     'InsufficientImageDataInFile');
                }
              data[length*quantum]='\0';
            }
          else
            if ((unsigned int) datum == 0xFFFFFFFFU)
              {
                sequence=MagickTrue;
                continue;
              }
    if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)
      {
        if (data != (unsigned char *) NULL)
          data=(unsigned char *) RelinquishMagickMemory(data);
        sequence=MagickFalse;
        continue;
      }
    if (sequence != MagickFalse)
      {
        if (data != (unsigned char *) NULL)
          data=(unsigned char *) RelinquishMagickMemory(data);
        continue;
      }
    switch (group)
    {
      case 0x0002:
      {
        switch (element)
        {
          case 0x0010:
          {
            char
              transfer_syntax[MagickPathExtent];

            /*
              Transfer Syntax.
            */
            if ((datum == 0) && (explicit_retry == MagickFalse))
              {
                explicit_retry=MagickTrue;
                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);
                group=0;
                element=0;
                if (image_info->verbose != MagickFalse)
                  (void) FormatLocaleFile(stdout,
                    'Corrupted image - trying explicit format\n');
                break;
              }
            *transfer_syntax='\0';
            if (data != (unsigned char *) NULL)
              (void) CopyMagickString(transfer_syntax,(char *) data,
                MagickPathExtent);
            if (image_info->verbose != MagickFalse)
              (void) FormatLocaleFile(stdout,'transfer_syntax=%s\n',
                (const char *) transfer_syntax);
            if (strncmp(transfer_syntax,'1.2.840.10008.1.2',17) == 0)
              {
                int
                  subtype,
                  type;

                type=1;
                subtype=0;
                if (strlen(transfer_syntax) > 17)
                  {
                    count=(ssize_t) sscanf(transfer_syntax+17,'.%d.%d',&type,
                      &subtype);
                    if (count < 1)
                      ThrowDCMException(CorruptImageError,
                        'ImproperImageHeader');
                  }
                switch (type)
                {
                  case 1:
                  {
                    image->endian=LSBEndian;
                    break;
                  }
                  case 2:
                  {
                    image->endian=MSBEndian;
                    break;
                  }
                  case 4:
                  {
                    if ((subtype >= 80) && (subtype <= 81))
                      image->compression=JPEGCompression;
                    else
                      if ((subtype >= 90) && (subtype <= 93))
                        image->compression=JPEG2000Compression;
                      else
                        image->compression=JPEGCompression;
                    break;
                  }
                  case 5:
                  {
                    image->compression=RLECompression;
                    break;
                  }
                }
              }
            break;
          }
          default:
            break;
        }
        break;
      }
      case 0x0028:
      {
        switch (element)
        {
          case 0x0002:
          {
            /*
              Samples per pixel.
            */
            info.samples_per_pixel=(size_t) datum;
            break;
          }
          case 0x0004:
          {
            /*
              Photometric interpretation.
            */
            if (data == (unsigned char *) NULL)
              break;
            for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)
              photometric[i]=(char) data[i];
            photometric[i]='\0';
            info.polarity=LocaleCompare(photometric,'MONOCHROME1 ') == 0 ?
              MagickTrue : MagickFalse;
            break;
          }
          case 0x0006:
          {
            /*
              Planar configuration.
            */
            if (datum == 1)
              image->interlace=PlaneInterlace;
            break;
          }
          case 0x0008:
          {
            /*
              Number of frames.
            */
            if (data == (unsigned char *) NULL)
              break;
            number_scenes=StringToUnsignedLong((char *) data);
            break;
          }
          case 0x0010:
          {
            /*
              Image rows.
            */
            height=(size_t) datum;
            break;
          }
          case 0x0011:
          {
            /*
              Image columns.
            */
            width=(size_t) datum;
            break;
          }
          case 0x0100:
          {
            /*
              Bits allocated.
            */
            info.bits_allocated=(size_t) datum;
            info.bytes_per_pixel=1;
            if (datum > 8)
              info.bytes_per_pixel=2;
            info.depth=info.bits_allocated;
            if (info.depth > 32)
              ThrowDCMException(CorruptImageError,'ImproperImageHeader');
            info.max_value=(1UL << info.bits_allocated)-1;
            image->depth=info.depth;
            break;
          }
          case 0x0101:
          {
            /*
              Bits stored.
            */
            info.significant_bits=(size_t) datum;
            info.bytes_per_pixel=1;
            if (info.significant_bits > 8)
              info.bytes_per_pixel=2;
            info.depth=info.significant_bits;
            if (info.depth > 32)
              ThrowDCMException(CorruptImageError,'ImproperImageHeader');
            info.max_value=(1UL << info.significant_bits)-1;
            info.mask=(size_t) GetQuantumRange(info.significant_bits);
            image->depth=info.depth;
            break;
          }
          case 0x0102:
          {
            /*
              High bit.
            */
            break;
          }
          case 0x0103:
          {
            /*
              Pixel representation.
            */
            info.signed_data=(size_t) datum;
            break;
          }
          case 0x1050:
          {
            /*
              Visible pixel range: center.
            */
            if (data != (unsigned char *) NULL)
              info.window_center=StringToDouble((char *) data, (char **) NULL);
            break;
          }
          case 0x1051:
          {
            /*
              Visible pixel range: width.
            */
            if (data != (unsigned char *) NULL)
              info.window_width=StringToDouble((char *) data, (char **) NULL);
            break;
          }
          case 0x1052:
          {
            /*
              Rescale intercept
            */
            if (data != (unsigned char *) NULL)
              info.rescale_intercept=StringToDouble((char *) data,
                (char **) NULL);
            break;
          }
          case 0x1053:
          {
            /*
              Rescale slope
            */
            if (data != (unsigned char *) NULL)
              info.rescale_slope=StringToDouble((char *) data, (char **) NULL);
            break;
          }
          case 0x1200:
          case 0x3006:
          {
            /*
              Populate graymap.
            */
            if (data == (unsigned char *) NULL)
              break;
            colors=(size_t) (length/info.bytes_per_pixel);
            datum=(int) colors;
            if (graymap != (int *) NULL)
              graymap=(int *) RelinquishMagickMemory(graymap);
            graymap=(int *) AcquireQuantumMemory((size_t) colors,
              sizeof(*graymap));
            if (graymap == (int *) NULL)
              ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
            for (i=0; i < (ssize_t) colors; i++)
              if (info.bytes_per_pixel == 1)
                graymap[i]=(int) data[i];
              else
                graymap[i]=(int) ((short *) data)[i];
            break;
          }
          case 0x1201:
          {
            unsigned short
              index;

            /*
              Populate redmap.
            */
            if (data == (unsigned char *) NULL)
              break;
            colors=(size_t) (length/2);
            datum=(int) colors;
            redmap=(int *) AcquireQuantumMemory((size_t) colors,
              sizeof(*redmap));
            if (redmap == (int *) NULL)
              ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
            p=data;
            for (i=0; i < (ssize_t) colors; i++)
            {
              if (image->endian == MSBEndian)
                index=(unsigned short) ((*p << 8) | *(p+1));
              else
                index=(unsigned short) (*p | (*(p+1) << 8));
              redmap[i]=(int) index;
              p+=2;
            }
            break;
          }
          case 0x1202:
          {
            unsigned short
              index;

            /*
              Populate greenmap.
            */
            if (data == (unsigned char *) NULL)
              break;
            colors=(size_t) (length/2);
            datum=(int) colors;
            greenmap=(int *) AcquireQuantumMemory((size_t) colors,
              sizeof(*greenmap));
            if (greenmap == (int *) NULL)
              ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
            p=data;
            for (i=0; i < (ssize_t) colors; i++)
            {
              if (image->endian == MSBEndian)
                index=(unsigned short) ((*p << 8) | *(p+1));
              else
                index=(unsigned short) (*p | (*(p+1) << 8));
              greenmap[i]=(int) index;
              p+=2;
            }
            break;
          }
          case 0x1203:
          {
            unsigned short
              index;

            /*
              Populate bluemap.
            */
            if (data == (unsigned char *) NULL)
              break;
            colors=(size_t) (length/2);
            datum=(int) colors;
            bluemap=(int *) AcquireQuantumMemory((size_t) colors,
              sizeof(*bluemap));
            if (bluemap == (int *) NULL)
              ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
            p=data;
            for (i=0; i < (ssize_t) colors; i++)
            {
              if (image->endian == MSBEndian)
                index=(unsigned short) ((*p << 8) | *(p+1));
              else
                index=(unsigned short) (*p | (*(p+1) << 8));
              bluemap[i]=(int) index;
              p+=2;
            }
            break;
          }
          default:
            break;
        }
        break;
      }
      case 0x2050:
      {
        switch (element)
        {
          case 0x0020:
          {
            if ((data != (unsigned char *) NULL) &&
                (strncmp((char *) data,'INVERSE',7) == 0))
              info.polarity=MagickTrue;
            break;
          }
          default:
            break;
        }
        break;
      }
      default:
        break;
    }
    if (data != (unsigned char *) NULL)
      {
        char
          *attribute;

        for (i=0; dicom_info[i].description != (char *) NULL; i++)
          if ((group == dicom_info[i].group) &&
              (element == dicom_info[i].element))
            break;
        if (dicom_info[i].description != (char *) NULL)
          {
            attribute=AcquireString('dcm:');
            (void) ConcatenateString(&attribute,dicom_info[i].description);
            for (i=0; i < (ssize_t) MagickMax(length,4); i++)
              if (isprint((int) data[i]) == MagickFalse)
                break;
            if ((i == (ssize_t) length) || (length > 4))
              {
                (void) SubstituteString(&attribute,' ','');
                (void) SetImageProperty(image,attribute,(char *) data,
                  exception);
              }
            attribute=DestroyString(attribute);
          }
      }
    if (image_info->verbose != MagickFalse)
      {
        if (data == (unsigned char *) NULL)
          (void) FormatLocaleFile(stdout,'%d\n',datum);
        else
          {
            /*
              Display group data.
            */
            for (i=0; i < (ssize_t) MagickMax(length,4); i++)
              if (isprint((int) data[i]) == MagickFalse)
                break;
            if ((i != (ssize_t) length) && (length <= 4))
              {
                ssize_t
                  j;

                datum=0;
                for (j=(ssize_t) length-1; j >= 0; j--)
                  datum=(256*datum+data[j]);
                (void) FormatLocaleFile(stdout,'%d',datum);
              }
            else
              for (i=0; i < (ssize_t) length; i++)
                if (isprint((int) data[i]) != MagickFalse)
                  (void) FormatLocaleFile(stdout,'%c',data[i]);
                else
                  (void) FormatLocaleFile(stdout,'%c','.');
            (void) FormatLocaleFile(stdout,'\n');
          }
      }
    if (data != (unsigned char *) NULL)
      data=(unsigned char *) RelinquishMagickMemory(data);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,'UnexpectedEndOfFile',
          image->filename);
        break;
      }
  }
  if ((width == 0) || (height == 0))
    ThrowDCMException(CorruptImageError,'ImproperImageHeader');
  image->columns=(size_t) width;
  image->rows=(size_t) height;
  if (info.signed_data == 0xffff)
    info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);
  if ((image->compression == JPEGCompression) ||
      (image->compression == JPEG2000Compression))
    {
      Image
        *images;

      ImageInfo
        *read_info;

      int
        c;

      /*
        Read offset table.
      */
      for (i=0; i < (ssize_t) stream_info->remaining; i++)
        (void) ReadBlobByte(image);
      (void)((ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image));
      length=(size_t) ReadBlobLSBLong(image);
      stream_info->offset_count=length >> 2;
      if (stream_info->offset_count != 0)
        {
          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(
            stream_info->offset_count,sizeof(*stream_info->offsets));
          if (stream_info->offsets == (ssize_t *) NULL)
            ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
          for (i=0; i < (ssize_t) stream_info->offset_count; i++)
            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);
          offset=TellBlob(image);
          for (i=0; i < (ssize_t) stream_info->offset_count; i++)
            stream_info->offsets[i]+=offset;
        }
      /*
        Handle non-native image formats.
      */
      read_info=CloneImageInfo(image_info);
      SetImageInfoBlob(read_info,(void *) NULL,0);
      images=NewImageList();
      for (scene=0; scene < (ssize_t) number_scenes; scene++)
      {
        char
          filename[MagickPathExtent];

        const char
          *property;

        FILE
          *file;

        Image
          *jpeg_image;

        int
          unique_file;

        unsigned int
          tag;

        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);
        length=(size_t) ReadBlobLSBLong(image);
        if (tag == 0xFFFEE0DD)
          break; /* sequence delimiter tag */
        if (tag != 0xFFFEE000)
          ThrowDCMException(CorruptImageError,'ImproperImageHeader');
        file=(FILE *) NULL;
        unique_file=AcquireUniqueFileResource(filename);
        if (unique_file != -1)
          file=fdopen(unique_file,'wb');
        if (file == (FILE *) NULL)
          {
            (void) RelinquishUniqueFileResource(filename);
            ThrowFileException(exception,FileOpenError,
              'UnableToCreateTemporaryFile',filename);
            break;
          }
        for ( ; length != 0; length--)
        {
          c=ReadBlobByte(image);
          if (c == EOF)
            {
              ThrowFileException(exception,CorruptImageError,
                'UnexpectedEndOfFile',image->filename);
              break;
            }
          (void) fputc(c,file);
        }
        (void) fclose(file);
        (void) FormatLocaleString(read_info->filename,MagickPathExtent,
          'jpeg:%s',filename);
        if (image->compression == JPEG2000Compression)
          (void) FormatLocaleString(read_info->filename,MagickPathExtent,
            'j2k:%s',filename);
        jpeg_image=ReadImage(read_info,exception);
        if (jpeg_image != (Image *) NULL)
          {
            ResetImagePropertyIterator(image);
            property=GetNextImageProperty(image);
            while (property != (const char *) NULL)
            {
              (void) SetImageProperty(jpeg_image,property,
                GetImageProperty(image,property,exception),exception);
              property=GetNextImageProperty(image);
            }
            AppendImageToList(&images,jpeg_image);
          }
        (void) RelinquishUniqueFileResource(filename);
      }
      if (stream_info->offsets != (ssize_t *) NULL)
        stream_info->offsets=(ssize_t *)
          RelinquishMagickMemory(stream_info->offsets);
      stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);
      read_info=DestroyImageInfo(read_info);
      image=DestroyImage(image);
      return(GetFirstImageInList(images));
    }
  if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))
    {
      QuantumAny
        range;

      /*
        Compute pixel scaling table.
      */
      length=(size_t) (GetQuantumRange(info.depth)+1);
      info.scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*info.scale));
      if (info.scale == (Quantum *) NULL)
        ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
      range=GetQuantumRange(info.depth);
      for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)
        info.scale[i]=ScaleAnyToQuantum((size_t) i,range);
    }
  if (image->compression == RLECompression)
    {
      unsigned int
        tag;

      /*
        Read RLE offset table.
      */
      for (i=0; i < (ssize_t) stream_info->remaining; i++)
      {
        int
          c;

        c=ReadBlobByte(image);
        if (c == EOF)
          break;
      }
      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);
      (void) tag;
      length=(size_t) ReadBlobLSBLong(image);
      stream_info->offset_count=length >> 2;
      if (stream_info->offset_count != 0)
        {
          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(
            stream_info->offset_count,sizeof(*stream_info->offsets));
          if (stream_info->offsets == (ssize_t *) NULL)
            ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
          for (i=0; i < (ssize_t) stream_info->offset_count; i++)
          {
            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);
            if (EOFBlob(image) != MagickFalse)
              break;
          }
          offset=TellBlob(image)+8;
          for (i=0; i < (ssize_t) stream_info->offset_count; i++)
            stream_info->offsets[i]+=offset;
        }
    }
  for (scene=0; scene < (ssize_t) number_scenes; scene++)
  {
    if (image_info->ping != MagickFalse)
      break;
    image->columns=(size_t) width;
    image->rows=(size_t) height;
    image->depth=info.depth;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      break;
    image->colorspace=RGBColorspace;
    (void) SetImageBackgroundColor(image,exception);
    if ((image->colormap == (PixelInfo *) NULL) &&
        (info.samples_per_pixel == 1))
      {
        int
          index;

        size_t
          one;

        one=1;
        if (colors == 0)
          colors=one << info.depth;
        if (AcquireImageColormap(image,colors,exception) == MagickFalse)
          ThrowDCMException(ResourceLimitError,'MemoryAllocationFailed');
        if (redmap != (int *) NULL)
          for (i=0; i < (ssize_t) colors; i++)
          {
            index=redmap[i];
            if ((info.scale != (Quantum *) NULL) &&
                (index <= (int) info.max_value))
              index=(int) info.scale[index];
            image->colormap[i].red=(MagickRealType) index;
          }
        if (greenmap != (int *) NULL)
          for (i=0; i < (ssize_t) colors; i++)
          {
            index=greenmap[i];
            if ((info.scale != (Quantum *) NULL) &&
                (index <= (int) info.max_value))
              index=(int) info.scale[index];
            image->colormap[i].green=(MagickRealType) index;
          }
        if (bluemap != (int *) NULL)
          for (i=0; i < (ssize_t) colors; i++)
          {
            index=bluemap[i];
            if ((info.scale != (Quantum *) NULL) &&
                (index <= (int) info.max_value))
              index=(int) info.scale[index];
            image->colormap[i].blue=(MagickRealType) index;
          }
        if (graymap != (int *) NULL)
          for (i=0; i < (ssize_t) colors; i++)
          {
            index=graymap[i];
            if ((info.scale != (Quantum *) NULL) &&
                (index <= (int) info.max_value))
              index=(int) info.scale[index];
            image->colormap[i].red=(MagickRealType) index;
            image->colormap[i].green=(MagickRealType) index;
            image->colormap[i].blue=(MagickRealType) index;
          }
      }
    if (image->compression == RLECompression)
      {
        unsigned int
          tag;

        /*
          Read RLE segment table.
        */
        for (i=0; i < (ssize_t) stream_info->remaining; i++)
          (void) ReadBlobByte(image);
        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);
        stream_info->remaining=(size_t) ReadBlobLSBLong(image);
        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||
            (EOFBlob(image) != MagickFalse))
          {
            if (stream_info->offsets != (ssize_t *) NULL)
              stream_info->offsets=(ssize_t *)
                RelinquishMagickMemory(stream_info->offsets);
            if (info.scale != (Quantum *) NULL)
              info.scale=(Quantum *) RelinquishMagickMemory(info.scale);
            ThrowDCMException(CorruptImageError,'ImproperImageHeader');
          }
        stream_info->count=0;
        stream_info->segment_count=ReadBlobLSBLong(image);
        for (i=0; i < 15; i++)
          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);
        stream_info->remaining-=64;
        if (stream_info->segment_count > 1)
          {
            info.bytes_per_pixel=1;
            info.depth=8;
            if (stream_info->offset_count > 0)
              (void) SeekBlob(image,(MagickOffsetType) stream_info->offsets[0]+
                stream_info->segments[0],SEEK_SET);
          }
      }
    if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))
      {
        register ssize_t
          x;

        register Quantum
          *q;

        ssize_t
          y;

        /*
          Convert Planar RGB DCM Medical image to pixel packets.
        */
        for (i=0; i < (ssize_t) info.samples_per_pixel; i++)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              switch ((int) i)
              {
                case 0:
                {
                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                    ReadDCMByte(stream_info,image)),q);
                  break;
                }
                case 1:
                {
                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                    ReadDCMByte(stream_info,image)),q);
                  break;
                }
                case 2:
                {
                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                    ReadDCMByte(stream_info,image)),q);
                  break;
                }
                case 3:
                {
                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                    ReadDCMByte(stream_info,image)),q);
                  break;
                }
                default:
                  break;
              }
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                  image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
      }
    else
      {
        const char
          *option;

        /*
          Convert DCM Medical image to pixel packets.
        */
        option=GetImageOption(image_info,'dcm:display-range');
        if (option != (const char *) NULL)
          {
            if (LocaleCompare(option,'reset') == 0)
              info.window_width=0;
          }
        option=GetImageOption(image_info,'dcm:window');
        if (option != (char *) NULL)
          {
            GeometryInfo
              geometry_info;

            MagickStatusType
              flags;

            flags=ParseGeometry(option,&geometry_info);
            if (flags & RhoValue)
              info.window_center=geometry_info.rho;
            if (flags & SigmaValue)
              info.window_width=geometry_info.sigma;
            info.rescale=MagickTrue;
          }
        option=GetImageOption(image_info,'dcm:rescale');
        if (option != (char *) NULL)
          info.rescale=IsStringTrue(option);
        if ((info.window_center != 0) && (info.window_width == 0))
          info.window_width=info.window_center;
        status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);
        if ((status != MagickFalse) && (stream_info->segment_count > 1))
          {
            if (stream_info->offset_count > 0)
              (void) SeekBlob(image,(MagickOffsetType) stream_info->offsets[0]+
                stream_info->segments[1],SEEK_SET);
            (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,exception);
          }
      }
    if (SetImageGray(image,exception) != MagickFalse)
      (void) SetImageColorspace(image,GRAYColorspace,exception);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,'UnexpectedEndOfFile',
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    if (scene < (ssize_t) (number_scenes-1))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  }
  /*
    Free resources.
  */
  if (stream_info->offsets != (ssize_t *) NULL)
    stream_info->offsets=(ssize_t *)
      RelinquishMagickMemory(stream_info->offsets);
  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);
  if (info.scale != (Quantum *) NULL)
    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);
  if (graymap != (int *) NULL)
    graymap=(int *) RelinquishMagickMemory(graymap);
  if (bluemap != (int *) NULL)
    bluemap=(int *) RelinquishMagickMemory(bluemap);
  if (greenmap != (int *) NULL)
    greenmap=(int *) RelinquishMagickMemory(greenmap);
  if (redmap != (int *) NULL)
    redmap=(int *) RelinquishMagickMemory(redmap);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",1,8349
ImageMagick/ImageMagick,1fbed78912c830ccd82eecdb8a1db4882abb8276,"static int ReadDCMByte(DCMStreamInfo *stream_info,Image *image)
{
  if (image->compression != RLECompression)
    return(ReadBlobByte(image));
  if (stream_info->count == 0)
    {
      int
        byte;

      ssize_t
        count;

      if (stream_info->remaining <= 2)
        stream_info->remaining=0;
      else
        stream_info->remaining-=2;
      count=(ssize_t) ReadBlobByte(image);
      byte=ReadBlobByte(image);
      if (count == 128)
        return(0);
      else
        if (count < 128)
          {
            /*
              Literal bytes.
            */
            stream_info->count=count;
            stream_info->byte=(-1);
            return(byte);
          }
        else
          {
            /*
              Repeated bytes.
            */
            stream_info->count=256-count;
            stream_info->byte=byte;
            return(byte);
          }
    }
  stream_info->count--;
  if (stream_info->byte >= 0)
    return(stream_info->byte);
  if (stream_info->remaining > 0)
    stream_info->remaining--;
  return(ReadBlobByte(image));
}
",0,8350
OpenMPT/openmpt,b60b322cf9f0ffa624018f1bb9783edf0dc908c3,"static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)
{
	if(!src.HasSampleData()) return;

	dest.FreeSample();
	dest = src;
	dest.nLength = len;
	dest.pSample = nullptr;

	if(!dest.AllocateSample())
	{
		return;
	}

	// only preserve cue points if the target sample length is the same
	if(len != src.nLength)
		MemsetZero(dest.cues);

	std::memcpy(dest.pSample8, src.pSample8 + start, len);
	dest.uFlags.set(CHN_LOOP, loop);
	if(loop)
	{
		dest.nLoopStart = 0;
		dest.nLoopEnd = len;
	} else
	{
		dest.nLoopStart = 0;
		dest.nLoopEnd = 0;
	}
}
",1,8351
OpenMPT/openmpt,b60b322cf9f0ffa624018f1bb9783edf0dc908c3,"static void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)
{
	// This should only modify a sample if it has more than one loop
	// (otherwise, it behaves like a normal sample loop)
	if(!smp.HasSampleData() || loopList.size() < 2) return;

	ModSample newSmp = smp;
	newSmp.nLength = 0;
	newSmp.pSample = nullptr;

	size_t numLoops = loopList.size();

	// Get the total length of the sample after combining all looped sections
	for(size_t i = 0; i < numLoops; i++)
	{
		STPLoopInfo &info = loopList[i];

		// If adding this loop would cause the sample length to exceed maximum,
		// then limit and bail out
		if((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||
		   (info.loopLength > MAX_SAMPLE_LENGTH) ||
		   (info.loopStart + info.loopLength > smp.nLength))
		{
			numLoops = i;
			break;
		}

		newSmp.nLength += info.loopLength;
	}

	if(!newSmp.AllocateSample())
	{
		return;
	}

	// start copying the looped sample data parts
	SmpLength start = 0;

	for(size_t i = 0; i < numLoops; i++)
	{
		STPLoopInfo &info = loopList[i];

		memcpy(newSmp.pSample8 + start, smp.pSample8 + info.loopStart, info.loopLength);

		// update loop info based on position in edited sample
		info.loopStart = start;
		if(i > 0 && i <= mpt::size(newSmp.cues))
		{
			newSmp.cues[i - 1] = start;
		}
		start += info.loopLength;
	}

	// replace old sample with new one
	smp.FreeSample();
	smp = newSmp;

	smp.nLoopStart = 0;
	smp.nLoopEnd = smp.nLength;
	smp.uFlags.set(CHN_LOOP);
}
",1,8352
OpenMPT/openmpt,b60b322cf9f0ffa624018f1bb9783edf0dc908c3,"static bool ValidateHeader(const STPFileHeader &fileHeader)
{
	if(std::memcmp(fileHeader.magic, 'STP3', 4)
		|| fileHeader.version > 2
		|| fileHeader.numOrders > 128
		|| fileHeader.numSamples >= MAX_SAMPLES
		|| fileHeader.timerCount == 0
		|| fileHeader.midiCount != 50)
	{
		return false;
	}
	return true;
}
",0,8353
torvalds/linux,5c25f65fd1e42685f7ccd80e0621829c105785d9,"static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
{
	struct tun_struct *tun;
	struct tun_file *tfile = file->private_data;
	struct net_device *dev;
	int err;

	if (tfile->detached)
		return -EINVAL;

	dev = __dev_get_by_name(net, ifr->ifr_name);
	if (dev) {
		if (ifr->ifr_flags & IFF_TUN_EXCL)
			return -EBUSY;
		if ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)
			tun = netdev_priv(dev);
		else if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)
			tun = netdev_priv(dev);
		else
			return -EINVAL;

		if (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=
		    !!(tun->flags & IFF_MULTI_QUEUE))
			return -EINVAL;

		if (tun_not_capable(tun))
			return -EPERM;
		err = security_tun_dev_open(tun->security);
		if (err < 0)
			return err;

		err = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);
		if (err < 0)
			return err;

		if (tun->flags & IFF_MULTI_QUEUE &&
		    (tun->numqueues + tun->numdisabled > 1)) {
			/* One or more queue has already been attached, no need
			 * to initialize the device again.
			 */
			return 0;
		}
	}
	else {
		char *name;
		unsigned long flags = 0;
		int queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?
			     MAX_TAP_QUEUES : 1;

		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
			return -EPERM;
		err = security_tun_dev_create();
		if (err < 0)
			return err;

		/* Set dev type */
		if (ifr->ifr_flags & IFF_TUN) {
			/* TUN device */
			flags |= IFF_TUN;
			name = 'tun%d';
		} else if (ifr->ifr_flags & IFF_TAP) {
			/* TAP device */
			flags |= IFF_TAP;
			name = 'tap%d';
		} else
			return -EINVAL;

		if (*ifr->ifr_name)
			name = ifr->ifr_name;

		dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,
				       NET_NAME_UNKNOWN, tun_setup, queues,
				       queues);

		if (!dev)
			return -ENOMEM;
		err = dev_get_valid_name(net, dev, name);
		if (err)
			goto err_free_dev;

		dev_net_set(dev, net);
		dev->rtnl_link_ops = &tun_link_ops;
		dev->ifindex = tfile->ifindex;
		dev->sysfs_groups[0] = &tun_attr_group;

		tun = netdev_priv(dev);
		tun->dev = dev;
		tun->flags = flags;
		tun->txflt.count = 0;
		tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);

		tun->align = NET_SKB_PAD;
		tun->filter_attached = false;
		tun->sndbuf = tfile->socket.sk->sk_sndbuf;
		tun->rx_batched = 0;

		tun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);
		if (!tun->pcpu_stats) {
			err = -ENOMEM;
			goto err_free_dev;
		}

		spin_lock_init(&tun->lock);

		err = security_tun_dev_alloc_security(&tun->security);
		if (err < 0)
			goto err_free_stat;

		tun_net_init(dev);
		tun_flow_init(tun);

		dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |
				   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |
				   NETIF_F_HW_VLAN_STAG_TX;
		dev->features = dev->hw_features | NETIF_F_LLTX;
		dev->vlan_features = dev->features &
				     ~(NETIF_F_HW_VLAN_CTAG_TX |
				       NETIF_F_HW_VLAN_STAG_TX);

		INIT_LIST_HEAD(&tun->disabled);
		err = tun_attach(tun, file, false);
		if (err < 0)
			goto err_free_flow;

		err = register_netdevice(tun->dev);
		if (err < 0)
			goto err_detach;
	}

	netif_carrier_on(tun->dev);

	tun_debug(KERN_INFO, tun, 'tun_set_iff\n');

	tun->flags = (tun->flags & ~TUN_FEATURES) |
		(ifr->ifr_flags & TUN_FEATURES);

	/* Make sure persistent devices do not get stuck in
	 * xoff state.
	 */
	if (netif_running(tun->dev))
		netif_tx_wake_all_queues(tun->dev);

	strcpy(ifr->ifr_name, tun->dev->name);
	return 0;

err_detach:
	tun_detach_all(dev);
	/* register_netdevice() already called tun_free_netdev() */
	goto err_free_dev;

err_free_flow:
	tun_flow_uninit(tun);
	security_tun_dev_free_security(tun->security);
err_free_stat:
	free_percpu(tun->pcpu_stats);
err_free_dev:
	free_netdev(dev);
	return err;
}
",1,8355
torvalds/linux,5c25f65fd1e42685f7ccd80e0621829c105785d9,"#define TUN_VNET_BE     0x40000000

#define TUN_FEATURES (IFF_NO_PI | IFF_ONE_QUEUE | IFF_VNET_HDR | \
		      IFF_MULTI_QUEUE)
",0,8356
ec-/Quake3e,fea3c4144c7b325634cdf638d1582c772a2db3bd,"char *Cmd_Args( void ) {
	static char cmd_args[MAX_STRING_CHARS];
	int i;

	cmd_args[0] = '\0';
	for ( i = 1 ; i < cmd_argc ; i++ ) {
		strcat( cmd_args, cmd_argv[i] );
		if ( i != cmd_argc-1 ) {
			strcat( cmd_args, ' ' );
		}
	}

	return cmd_args;
}
",1,8357
ec-/Quake3e,fea3c4144c7b325634cdf638d1582c772a2db3bd,"char *Cmd_ArgsFrom( int arg ) {
	static char cmd_args[BIG_INFO_STRING];
	int i;

	cmd_args[0] = '\0';
	if (arg < 0)
		arg = 0;
	for ( i = arg ; i < cmd_argc ; i++ ) {
		strcat( cmd_args, cmd_argv[i] );
		if ( i != cmd_argc-1 ) {
			strcat( cmd_args, ' ' );
		}
	}

	return cmd_args;
}
",1,8358
ec-/Quake3e,fea3c4144c7b325634cdf638d1582c772a2db3bd,"void Cmd_Args_Sanitize( void )
{
	int i;

	for(i = 1; i < cmd_argc; i++)
	{
		char *c = cmd_argv[i];
		
		if(strlen(c) > MAX_CVAR_VALUE_STRING - 1)
			c[MAX_CVAR_VALUE_STRING - 1] = '\0';
		
		while ( (c = strpbrk(c, '\n\r')) != NULL ) {
			*c = ' ';
			++c;
		}
	}
}
",1,8359
ec-/Quake3e,fea3c4144c7b325634cdf638d1582c772a2db3bd,"static void Cmd_TokenizeString2( const char *text_in, qboolean ignoreQuotes ) {
	const char *text;
	char *textOut;

#ifdef TKN_DBG
  // FIXME TTimo blunt hook to try to find the tokenization of userinfo
  Com_DPrintf('Cmd_TokenizeString: %s\n', text_in);
#endif

	// clear previous args
	cmd_argc = 0;

	if ( !text_in ) {
		return;
	}
	
	Q_strncpyz( cmd_cmd, text_in, sizeof(cmd_cmd) );

	text = text_in;
	textOut = cmd_tokenized;

	while ( 1 ) {
		if ( cmd_argc >= MAX_STRING_TOKENS ) {
			return;			// this is usually something malicious
		}

		while ( 1 ) {
			// skip whitespace
			while ( *text && *text <= ' ' ) {
				text++;
			}
			if ( !*text ) {
				return;			// all tokens parsed
			}

			// skip // comments
			if ( text[0] == '/' && text[1] == '/' ) {
				return;			// all tokens parsed
			}

			// skip /* */ comments
			if ( text[0] == '/' && text[1] =='*' ) {
				while ( *text && ( text[0] != '*' || text[1] != '/' ) ) {
					text++;
				}
				if ( !*text ) {
					return;		// all tokens parsed
				}
				text += 2;
			} else {
				break;			// we are ready to parse a token
			}
		}

		// handle quoted strings
		// NOTE TTimo this doesn't handle \' escaping
		if ( !ignoreQuotes && *text == ''' ) {
			cmd_argv[cmd_argc] = textOut;
			cmd_argc++;
			text++;
			while ( *text && *text != ''' ) {
				*textOut++ = *text++;
			}
			*textOut++ = '\0';
			if ( !*text ) {
				return;		// all tokens parsed
			}
			text++;
			continue;
		}

		// regular token
		cmd_argv[cmd_argc] = textOut;
		cmd_argc++;

		// skip until whitespace, quote, or command
		while ( *text > ' ' ) {
			if ( !ignoreQuotes && text[0] == ''' ) {
				break;
			}

			if ( text[0] == '/' && text[1] == '/' ) {
				break;
			}

			// skip /* */ comments
			if ( text[0] == '/' && text[1] =='*' ) {
				break;
			}

			*textOut++ = *text++;
		}

		*textOut++ = '\0';

		if ( !*text ) {
			return;		// all tokens parsed
		}
	}
	
}
",1,8360
ec-/Quake3e,fea3c4144c7b325634cdf638d1582c772a2db3bd,"void Cmd_CompleteArgument( const char *command, char *args, int argNum ) {
	cmd_function_t *cmd;

	for( cmd = cmd_functions; cmd; cmd = cmd->next ) {
		if( !Q_stricmp( command, cmd->name ) ) {
			if ( cmd->complete ) {
				cmd->complete( args, argNum );
			}
			return;
		}
	}
}
",0,8361
ec-/Quake3e,fea3c4144c7b325634cdf638d1582c772a2db3bd,"void Cbuf_Execute( void )
{
	int i;
	char *text;
	char line[MAX_CMD_LINE];
	int quotes;

	// This will keep // style comments all on one line by not breaking on
	// a semicolon.  It will keep /* ... */ style comments all on one line by not
	// breaking it for semicolon or newline.
	qboolean in_star_comment = qfalse;
	qboolean in_slash_comment = qfalse;
	while ( cmd_text.cursize > 0 )
	{
		if ( cmd_wait > 0 ) {
			// skip out while text still remains in buffer, leaving it
			// for next frame
			cmd_wait--;
			break;
		}

		// find a \n or ; line break or comment: // or /* */
		text = (char *)cmd_text.data;

		quotes = 0;
		for ( i = 0 ; i< cmd_text.cursize ; i++ )
		{
			if (text[i] == ''')
				quotes++;

			if ( !(quotes&1)) {
				if ( i < cmd_text.cursize - 1 ) {
					if ( !in_star_comment && text[i] == '/' && text[i+1] == '/' )
						in_slash_comment = qtrue;
					else if ( !in_slash_comment && text[i] == '/' && text[i+1] == '*' )
						in_star_comment = qtrue;
					else if ( in_star_comment && text[i] == '*' && text[i+1] == '/' ) {
						in_star_comment = qfalse;
						// If we are in a star comment, then the part after it is valid
						// Note: This will cause it to NUL out the terminating '/'
						// but ExecuteString doesn't require it anyway.
						i++;
						break;
					}
				}
				if ( !in_slash_comment && !in_star_comment && text[i] == ';')
					break;
			}
			if ( !in_star_comment && (text[i] == '\n' || text[i] == '\r') ) {
				in_slash_comment = qfalse;
				break;
			}
		}

		if ( i >= (MAX_CMD_LINE - 1) )
			i = MAX_CMD_LINE - 1;

		Com_Memcpy( line, text, i );
		line[i] = '\0';
		
		// delete the text from the command buffer and move remaining commands down
		// this is necessary because commands (exec) can insert data at the
		// beginning of the text buffer

		if ( i == cmd_text.cursize )
			cmd_text.cursize = 0;
		else
		{
			i++;
			cmd_text.cursize -= i;
			// skip all repeating newlines/semicolons
			while ( ( text[i] == '\n' || text[i] == '\r' || text[i] == ';' ) && cmd_text.cursize > 0 ) {
				cmd_text.cursize--;
				i++;
			}
			memmove( text, text+i, cmd_text.cursize );
		}

		// execute the command line
		Cmd_ExecuteString( line );
	}
}
",0,8362
ec-/Quake3e,fea3c4144c7b325634cdf638d1582c772a2db3bd,"static void Cmd_List_f( void )
{
	const cmd_function_t *cmd;
	const char *match;
	int i;

	if ( Cmd_Argc() > 1 ) {
		match = Cmd_Argv( 1 );
	} else {
		match = NULL;
	}

	i = 0;
	for ( cmd = cmd_functions ; cmd ; cmd=cmd->next ) {
		if ( match && !Com_Filter( match, cmd->name, qfalse ) )
			continue;
		Com_Printf( '%s\n', cmd->name );
		i++;
	}
	Com_Printf( '%i commands\n', i );
}
",0,8363
ec-/Quake3e,fea3c4144c7b325634cdf638d1582c772a2db3bd,"char *Cmd_Cmd( void )
{
	return cmd_cmd;
}
",0,8364
DaveGamble/cJSON,be749d7efa7c9021da746e685bd6dec79f9dd99b,"    }

    return current_element;
",1,8365
DaveGamble/cJSON,be749d7efa7c9021da746e685bd6dec79f9dd99b,"static void cjson_get_object_item_case_sensitive_should_get_object_items(void)
{
    cJSON *item = NULL;
    cJSON *found = NULL;

    item = cJSON_Parse('{\'one\':1, \'Two\':2, \'tHree\':3}');

    found = cJSON_GetObjectItemCaseSensitive(NULL, 'test');
    TEST_ASSERT_NULL_MESSAGE(found, 'Failed to fail on NULL pointer.');

    found = cJSON_GetObjectItemCaseSensitive(item, NULL);
    TEST_ASSERT_NULL_MESSAGE(found, 'Failed to fail on NULL string.');

    found = cJSON_GetObjectItemCaseSensitive(item, 'one');
    TEST_ASSERT_NOT_NULL_MESSAGE(found, 'Failed to find first item.');
    TEST_ASSERT_EQUAL_DOUBLE(found->valuedouble, 1);

    found = cJSON_GetObjectItemCaseSensitive(item, 'Two');
    TEST_ASSERT_NOT_NULL_MESSAGE(found, 'Failed to find first item.');
    TEST_ASSERT_EQUAL_DOUBLE(found->valuedouble, 2);

    found = cJSON_GetObjectItemCaseSensitive(item, 'tHree');
    TEST_ASSERT_NOT_NULL_MESSAGE(found, 'Failed to find item.');
    TEST_ASSERT_EQUAL_DOUBLE(found->valuedouble, 3);

    found = cJSON_GetObjectItemCaseSensitive(item, 'One');
    TEST_ASSERT_NULL_MESSAGE(found, 'Should not find something that isn't there.');

    cJSON_Delete(item);
}
",1,8366
DaveGamble/cJSON,be749d7efa7c9021da746e685bd6dec79f9dd99b,"
        /* This is at most how much we need for the output */
        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
",0,8367
DaveGamble/cJSON,be749d7efa7c9021da746e685bd6dec79f9dd99b,"        {
            p->hooks.deallocate(p->buffer);
            p->length = 0;
",0,8368
univention/univention-corporate-server,a28053045bd2e778c50ed1acaf4e52e1e34f6e34,"int data_on_connection(int fd, callback_remove_handler remove)
{
	int nread;
	char *network_packet;
	char network_line[8192];
	char *p;
	unsigned long id;

	char string[1024];
	unsigned long msg_id = UINT32_MAX;
	enum network_protocol version = network_client_get_version(fd);

	ioctl(fd, FIONREAD, &nread);

	univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'new connection data = %d\n',nread);

	if(nread == 0)
	{
		univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, '%d failed, got 0 close connection to listener ', fd);
		close(fd);
		FD_CLR(fd, &readfds);
		remove(fd);
		network_client_dump ();
		return 0;
	}


	if ( nread >= 8192 ) {

		univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, '%d failed, more than 8192 close connection to listener ', fd);
		close(fd);
		FD_CLR(fd, &readfds);
		remove(fd);

		return 0;
	}

	/* read the whole package */
	network_packet=malloc((nread+1) * sizeof(char));
	read(fd, network_packet, nread);
	network_packet[nread]='\0';

	memset(network_line, 0, 8192);
	p=network_packet;
	p_sem(sem_id);

	while ( get_network_line(p, network_line) ) {

		if ( strlen(network_line) > 0 ) {
			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'line = [%s]',network_line);
		}

		
		if ( !strncmp(network_line, 'MSGID: ', strlen('MSGID: ')) ) {
			/* read message id  */

			msg_id=strtoul(&(network_line[strlen('MSGID: ')]), NULL, 10);

			p+=strlen(network_line);


		} else if ( !strncmp(network_line, 'Version: ', strlen('Version: ')) ) {
			char *head = network_line, *end;

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'RECV: VERSION');

			version = strtoul(head + 9, &end, 10);
			if (!head[9] || *end)
				goto failed;

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'VERSION=%d', version);

			if (version < network_procotol_version) {
				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, 'Forbidden VERSION=%d < %d, close connection to listener', version, network_procotol_version);
				goto close;
			} else if (version >= PROTOCOL_LAST) {
				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, 'Future VERSION=%d', version);
				version = PROTOCOL_LAST - 1;
			}
			network_client_set_version(fd, version);
			
			/* reset message id */
			msg_id = UINT32_MAX;

			p+=strlen(network_line);


		} else if ( !strncmp(network_line, 'Capabilities: ', strlen('Capabilities: ')) ) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'RECV: Capabilities');

			if ( version > PROTOCOL_UNKNOWN ) {

				memset(string, 0, sizeof(string));
				
				snprintf(string, sizeof(string), 'Version: %d\nCapabilities: \n\n', version);

				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'SEND: %s', string);

				write(fd, string, strlen(string));

			} else {
				
				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'Capabilities recv, but no version line');
				
			}

			p+=strlen(network_line);


		} else if ( !strncmp(network_line, 'GET_DN ', strlen('GET_DN ')) && msg_id != UINT32_MAX && network_client_get_version(fd) > 0) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'RECV: GET_DN');

			id=strtoul(&(network_line[strlen('GET_DN ')]), NULL, 10);

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'id: %ld',id);

			if ( id <= notify_last_id.id) {

				char *dn_string = NULL;

				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'try to read %ld from cache', id);

				/* try to read from cache */
				if ( (dn_string = notifier_cache_get(id)) == NULL ) {

					univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, '%ld not found in cache', id);

					univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, '%ld get one dn', id);

					/* read from transaction file, because not in cache */
					if( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) {

						univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, '%ld failed ', id);
						/* TODO: maybe close connection? */

						univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, '%d failed, close connection to listener ', fd);
						close(fd);
						FD_CLR(fd, &readfds);
						remove(fd);

						return 0;
					}
				}

				if ( dn_string != NULL ) {

					snprintf(string, sizeof(string), 'MSGID: %ld\n%s\n\n',msg_id,dn_string);

					univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, '--> %d: [%s]',fd, string);

					write(fd, string, strlen(string));

					free(dn_string);

				}


			} else {
				/* set wanted id */

				network_client_set_next_id(fd, id);
				network_client_set_msg_id(fd, msg_id);

			}

			p+=strlen(network_line)+1;
			msg_id = UINT32_MAX;

		} else if (!strncmp(p, 'WAIT_ID ', 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) {
			char *head = network_line, *end;
			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'RECV: WAIT_ID');
			id = strtoul(head + 8, &end, 10);
			if (!head[8] || *end)
				goto failed;
			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'id: %ld', id);

			if (id <= notify_last_id.id) {
				snprintf(string, sizeof(string), 'MSGID: %ld\n%ld\n\n', msg_id, notify_last_id.id);
				write(fd, string, strlen(string));
			} else {
				/* set wanted id */
				network_client_set_next_id(fd, id);
				network_client_set_msg_id(fd, msg_id);
			}

			p += strlen(network_line) + 1;
			msg_id = UINT32_MAX;

		} else if ( !strncmp(network_line, 'GET_ID', strlen('GET_ID')) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'RECV: GET_ID');

			memset(string, 0, sizeof(string));

			snprintf(string, sizeof(string), 'MSGID: %ld\n%ld\n\n',msg_id,notify_last_id.id);

			write(fd, string, strlen(string));

			p+=strlen(network_line)+1;
			msg_id = UINT32_MAX;


		} else if ( !strncmp(network_line, 'GET_SCHEMA_ID', strlen('GET_SCHEMA_ID')) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'RECV: GET_SCHEMA_ID');

			memset(string, 0, sizeof(string));

			snprintf(string, sizeof(string), 'MSGID: %ld\n%ld\n\n',msg_id,SCHEMA_ID);

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, '--> %d: [%s]',fd, string);

			write(fd, string, strlen(string));

			p+=strlen(network_line)+1;
			msg_id = UINT32_MAX;


		} else if ( !strncmp(network_line, 'ALIVE', strlen('ALIVE')) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'RECV: ALIVE');

			snprintf(string, sizeof(string), 'MSGID: %ld\nOKAY\n\n',msg_id);

			write(fd, string, strlen(string));

			p+=strlen(network_line)+1;
			msg_id = UINT32_MAX;

		} else {

			p+=strlen(network_line);

			if (strlen(network_line) == 0 ) {
				p+=1;
 			} else {
				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, 'Drop package [%s]', network_line);
			}

		}
	}
	v_sem(sem_id);

	univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, 'END Package');
	

	network_client_dump ();

	return 0;

failed:
	univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, 'Failed parsing [%s]', p);
close:
	close(fd);
	FD_CLR(fd, &readfds);
	remove(fd);
	return 0;
}
",1,8369
univention/univention-corporate-server,a28053045bd2e778c50ed1acaf4e52e1e34f6e34,"
	memset(network_line, 0, 8192);

",0,8370
dbry/WavPack,f68a9555b548306c5b1ee45199ccdc4a16a6101b,"
            if (debug_logging_mode) {
                char formatstr [5];
",1,8371
dbry/WavPack,f68a9555b548306c5b1ee45199ccdc4a16a6101b,"int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    uint32_t chan_chunk = 0, channel_layout = 0, bcount;
    unsigned char *channel_identities = NULL;
    unsigned char *channel_reorder = NULL;
    int64_t total_samples = 0, infilesize;
    CAFFileHeader caf_file_header;
    CAFChunkHeader caf_chunk_header;
    CAFAudioFormat caf_audio_format;
    int i;

    infilesize = DoGetFileSize (infile);
    memcpy (&caf_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
        bcount != sizeof (CAFFileHeader) - 4)) {
            error_line ('%s is not a valid .CAF file!', infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
            error_line ('%s', WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);

    if (caf_file_header.mFileVersion != 1) {
        error_line ('%s: can't handle version %d .CAF files!', infilename, caf_file_header.mFileVersion);
        return WAVPACK_SOFT_ERROR;
    }

    // loop through all elements of the RIFF wav header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
            bcount != sizeof (CAFChunkHeader)) {
                error_line ('%s is not a valid .CAF file!', infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                error_line ('%s', WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);

        // if it's the format chunk, we want to get some info out of there and
        // make sure it's a .caf file we can handle

        if (!strncmp (caf_chunk_header.mChunkType, 'desc', 4)) {
            int supported = TRUE;

            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line ('%s is not a valid .CAF file!', infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line ('%s', WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);

            if (debug_logging_mode) {
                char formatstr [5];

                memcpy (formatstr, caf_audio_format.mFormatID, 4);
                formatstr [4] = 0;
                error_line ('format = %s, flags = %x, sampling rate = %g',
                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                error_line ('packet = %d bytes and %d frames',
                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                error_line ('channels per frame = %d, bits per channel = %d',
                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
            }

            if (strncmp (caf_audio_format.mFormatID, 'lpcm', 4) || (caf_audio_format.mFormatFlags & ~3))
                supported = FALSE;
            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                    supported = FALSE;
            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                supported = FALSE;
            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                    supported = FALSE;
            else if (caf_audio_format.mFramesPerPacket != 1 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                    supported = FALSE;

            if (!supported) {
                error_line ('%s is an unsupported .CAF format!', infilename);
                return WAVPACK_SOFT_ERROR;
            }

            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
            config->bits_per_sample = caf_audio_format.mBitsPerChannel;
            config->num_channels = caf_audio_format.mChannelsPerFrame;
            config->sample_rate = (int) caf_audio_format.mSampleRate;

            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                config->qmode |= QMODE_BIG_ENDIAN;

            if (config->bytes_per_sample == 1)
                config->qmode |= QMODE_SIGNED_BYTES;

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line ('data format: 32-bit %s-endian floating point', (config->qmode & QMODE_BIG_ENDIAN) ? 'big' : 'little');
                else
                    error_line ('data format: %d-bit %s-endian integers stored in %d byte(s)',
                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? 'big' : 'little', config->bytes_per_sample);
            }
        }
        else if (!strncmp (caf_chunk_header.mChunkType, 'chan', 4)) {
            CAFChannelLayout *caf_channel_layout;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||
                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {
                    error_line ('this .CAF file has an invalid 'chan' chunk!');
                    return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (''chan' chunk is %d bytes', (int) caf_chunk_header.mChunkSize);

            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line ('%s is not a valid .CAF file!', infilename);
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line ('%s', WavpackGetErrorMessage (wpc));
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
            chan_chunk = 1;

            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                error_line ('this CAF file already has channel order information!');
                free (caf_channel_layout);
                return WAVPACK_SOFT_ERROR;
            }

            switch (caf_channel_layout->mChannelLayoutTag) {
                case kCAFChannelLayoutTag_UseChannelDescriptions:
                    {
                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                        int label, cindex = 0, idents = 0;

                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                            num_descriptions != config->num_channels) {
                                error_line ('channel descriptions in 'chan' chunk are the wrong size!');
                                free (caf_channel_layout);
                                return WAVPACK_SOFT_ERROR;
                        }

                        if (num_descriptions >= 256) {
                            error_line ('%d channel descriptions is more than we can handle...ignoring!');
                            break;
                        }

                        // we allocate (and initialize to invalid values) a channel reorder array
                        // (even though we might not end up doing any reordering) and a string for
                        // any non-Microsoft channels we encounter

                        channel_reorder = malloc (num_descriptions);
                        memset (channel_reorder, -1, num_descriptions);
                        channel_identities = malloc (num_descriptions+1);

                        // convert the descriptions array to our native endian so it's easy to access

                        for (i = 0; i < num_descriptions; ++i) {
                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);

                            if (debug_logging_mode)
                                error_line ('chan %d --> %d', i + 1, descriptions [i].mChannelLabel);
                        }

                        // first, we go though and find any MS channels present, and move those to the beginning

                        for (label = 1; label <= 18; ++label)
                            for (i = 0; i < num_descriptions; ++i)
                                if (descriptions [i].mChannelLabel == label) {
                                    config->channel_mask |= 1 << (label - 1);
                                    channel_reorder [i] = cindex++;
                                    break;
                                }

                        // next, we go though the channels again assigning any we haven't done

                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] == (unsigned char) -1) {
                                uint32_t clabel = descriptions [i].mChannelLabel;

                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                    channel_identities [idents++] = 0xff;
                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                else {
                                    error_line ('warning: unknown channel descriptions label: %d', clabel);
                                    channel_identities [idents++] = 0xff;
                                }

                                channel_reorder [i] = cindex++;
                            }

                        // then, go through the reordering array and see if we really have to reorder

                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] != i)
                                break;

                        if (i == num_descriptions) {
                            free (channel_reorder);                 // no reordering required, so don't
                            channel_reorder = NULL;
                        }
                        else {
                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout
                            channel_layout = num_descriptions;
                        }

                        if (!idents) {                              // if no non-MS channels, free the identities string
                            free (channel_identities);
                            channel_identities = NULL;
                        }
                        else
                            channel_identities [idents] = 0;        // otherwise NULL terminate it

                        if (debug_logging_mode) {
                            error_line ('layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS',
                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                caf_channel_layout->mNumberChannelDescriptions, idents);

                            // if debugging, display the reordering as a string (but only little ones)

                            if (channel_reorder && num_descriptions <= 8) {
                                char reorder_string [] = '12345678';

                                for (i = 0; i < num_descriptions; ++i)
                                    reorder_string [i] = channel_reorder [i] + '1';

                                reorder_string [i] = 0;
                                error_line ('reordering string = \'%s\'\n', reorder_string);
                            }
                        }
                    }

                    break;

                case kCAFChannelLayoutTag_UseChannelBitmap:
                    config->channel_mask = caf_channel_layout->mChannelBitmap;

                    if (debug_logging_mode)
                        error_line ('layout_tag = 0x%08x, so using supplied bitmap of 0x%08x',
                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);

                    break;

                default:
                    for (i = 0; i < NUM_LAYOUTS; ++i)
                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                            config->channel_mask = layouts [i].mChannelBitmap;
                            channel_layout = layouts [i].mChannelLayoutTag;

                            if (layouts [i].mChannelReorder) {
                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                config->qmode |= QMODE_REORDERED_CHANS;
                            }

                            if (layouts [i].mChannelIdentities)
                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);

                            if (debug_logging_mode)
                                error_line ('layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s',
                                    channel_layout, config->channel_mask, channel_reorder ? 'yes' : 'no', channel_identities ? 'yes' : 'no');

                            break;
                        }

                    if (i == NUM_LAYOUTS && debug_logging_mode)
                        error_line ('layout_tag 0x%08x not found in table...all channels unassigned',
                            caf_channel_layout->mChannelLayoutTag);

                    break;
            }

            free (caf_channel_layout);
        }
        else if (!strncmp (caf_chunk_header.mChunkType, 'data', 4)) {     // on the data chunk, get size and exit loop
            uint32_t mEditCount;

            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                bcount != sizeof (mEditCount)) {
                    error_line ('%s is not a valid .CAF file!', infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                    error_line ('%s', WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                    error_line ('.CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!', infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                    error_line ('.CAF file %s has an invalid data chunk size, probably is corrupt!', infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;

                if (!total_samples) {
                    error_line ('this .CAF file has no audio samples, probably is corrupt!');
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line ('%s has too many samples for WavPack!', infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            break;
        }
        else {          // just copy unknown chunks to output file

            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                error_line ('%s is not a valid .CAF file!', infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line ('extra unknown chunk \'%c%c%c%c\' of %d bytes',
                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line ('%s', WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
        config->channel_mask = 0x5 - config->num_channels;

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
        error_line ('%s', WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    if (channel_identities)
        free (channel_identities);

    if (channel_layout || channel_reorder) {
        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
            error_line ('problem with setting channel layout (should not happen)');
            return WAVPACK_SOFT_ERROR;
        }

        if (channel_reorder)
            free (channel_reorder);
    }

    return WAVPACK_NO_ERROR;
}
",1,8372
dbry/WavPack,f68a9555b548306c5b1ee45199ccdc4a16a6101b,"extern int debug_logging_mode;

typedef struct
{
    char mFileType [4];
    uint16_t mFileVersion;
    uint16_t mFileFlags;
} CAFFileHeader;

",0,8373
dbry/WavPack,f68a9555b548306c5b1ee45199ccdc4a16a6101b,"                    supported = FALSE;
            else if (caf_audio_format.mFramesPerPacket != 1 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
",0,8374
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"static inline void pipe_buf_get(struct pipe_inode_info *pipe,
				struct pipe_buffer *buf)
{
	buf->ops->get(pipe, buf);
}
",1,8375
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,
				struct pipe_buffer *buf)
{
	struct buffer_ref *ref = (struct buffer_ref *)buf->private;

	ref->ref++;
}
",1,8376
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,
			       struct pipe_inode_info *opipe,
			       size_t len, unsigned int flags)
{
	struct pipe_buffer *ibuf, *obuf;
	int ret = 0, nbuf;
	bool input_wakeup = false;


retry:
	ret = ipipe_prep(ipipe, flags);
	if (ret)
		return ret;

	ret = opipe_prep(opipe, flags);
	if (ret)
		return ret;

	/*
	 * Potential ABBA deadlock, work around it by ordering lock
	 * grabbing by pipe info address. Otherwise two different processes
	 * could deadlock (one doing tee from A -> B, the other from B -> A).
	 */
	pipe_double_lock(ipipe, opipe);

	do {
		if (!opipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}

		if (!ipipe->nrbufs && !ipipe->writers)
			break;

		/*
		 * Cannot make any progress, because either the input
		 * pipe is empty or the output pipe is full.
		 */
		if (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {
			/* Already processed some buffers, break */
			if (ret)
				break;

			if (flags & SPLICE_F_NONBLOCK) {
				ret = -EAGAIN;
				break;
			}

			/*
			 * We raced with another reader/writer and haven't
			 * managed to process any buffers.  A zero return
			 * value means EOF, so retry instead.
			 */
			pipe_unlock(ipipe);
			pipe_unlock(opipe);
			goto retry;
		}

		ibuf = ipipe->bufs + ipipe->curbuf;
		nbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);
		obuf = opipe->bufs + nbuf;

		if (len >= ibuf->len) {
			/*
			 * Simply move the whole buffer from ipipe to opipe
			 */
			*obuf = *ibuf;
			ibuf->ops = NULL;
			opipe->nrbufs++;
			ipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);
			ipipe->nrbufs--;
			input_wakeup = true;
		} else {
			/*
			 * Get a reference to this pipe buffer,
			 * so we can copy the contents over.
			 */
			pipe_buf_get(ipipe, ibuf);
			*obuf = *ibuf;

			/*
			 * Don't inherit the gift flag, we need to
			 * prevent multiple steals of this page.
			 */
			obuf->flags &= ~PIPE_BUF_FLAG_GIFT;

			obuf->len = len;
			opipe->nrbufs++;
			ibuf->offset += obuf->len;
			ibuf->len -= obuf->len;
		}
		ret += obuf->len;
		len -= obuf->len;
	} while (len);

	pipe_unlock(ipipe);
	pipe_unlock(opipe);

	/*
	 * If we put data in the output pipe, wakeup any potential readers.
	 */
	if (ret > 0)
		wakeup_pipe_readers(opipe);

	if (input_wakeup)
		wakeup_pipe_writers(ipipe);

	return ret;
}
",1,8377
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"static int link_pipe(struct pipe_inode_info *ipipe,
		     struct pipe_inode_info *opipe,
		     size_t len, unsigned int flags)
{
	struct pipe_buffer *ibuf, *obuf;
	int ret = 0, i = 0, nbuf;

	/*
	 * Potential ABBA deadlock, work around it by ordering lock
	 * grabbing by pipe info address. Otherwise two different processes
	 * could deadlock (one doing tee from A -> B, the other from B -> A).
	 */
	pipe_double_lock(ipipe, opipe);

	do {
		if (!opipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}

		/*
		 * If we have iterated all input buffers or ran out of
		 * output room, break.
		 */
		if (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)
			break;

		ibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));
		nbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);

		/*
		 * Get a reference to this pipe buffer,
		 * so we can copy the contents over.
		 */
		pipe_buf_get(ipipe, ibuf);

		obuf = opipe->bufs + nbuf;
		*obuf = *ibuf;

		/*
		 * Don't inherit the gift flag, we need to
		 * prevent multiple steals of this page.
		 */
		obuf->flags &= ~PIPE_BUF_FLAG_GIFT;

		if (obuf->len > len)
			obuf->len = len;

		opipe->nrbufs++;
		ret += obuf->len;
		len -= obuf->len;
		i++;
	} while (len);

	/*
	 * return EAGAIN if we have the potential of some data in the
	 * future, otherwise just return 0
	 */
	if (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))
		ret = -EAGAIN;

	pipe_unlock(ipipe);
	pipe_unlock(opipe);

	/*
	 * If we put data in the output pipe, wakeup any potential readers.
	 */
	if (ret > 0)
		wakeup_pipe_readers(opipe);

	return ret;
}
",1,8378
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)
{
	get_page(buf->page);
}
",1,8379
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"void trace_buffer_unlock_commit_regs(struct trace_array *tr,
				     struct ring_buffer *buffer,
				     struct ring_buffer_event *event,
				     unsigned long flags, int pc,
				     struct pt_regs *regs)
{
	__buffer_unlock_commit(buffer, event);

	/*
	 * If regs is not set, then skip the necessary functions.
	 * Note, we can still get here via blktrace, wakeup tracer
	 * and mmiotrace, but that's ok if they lose a function or
	 * two. They are not that meaningful.
	 */
	ftrace_trace_stack(tr, buffer, flags, regs ? 0 : STACK_SKIP, pc, regs);
	ftrace_trace_userstack(buffer, flags, pc);
}
",0,8380
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"int do_pipe_flags(int *fd, int flags)
{
	struct file *files[2];
	int error = __do_pipe_flags(fd, files, flags);
	if (!error) {
		fd_install(fd[0], files[0]);
		fd_install(fd[1], files[1]);
	}
	return error;
}
",0,8381
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)
{
	while (size) {
		if (!cs->len) {
			int err = fuse_copy_fill(cs);
			if (err)
				return err;
		}
		fuse_copy_do(cs, &val, &size);
	}
	return 0;
}
",0,8382
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"static int trace_set_options(struct trace_array *tr, char *option)
{
	char *cmp;
	int neg = 0;
	int ret;
	size_t orig_len = strlen(option);
	int len;

	cmp = strstrip(option);

	len = str_has_prefix(cmp, 'no');
	if (len)
		neg = 1;

	cmp += len;

	mutex_lock(&trace_types_lock);

	ret = match_string(trace_options, -1, cmp);
	/* If no option could be set, test the specific tracer options */
	if (ret < 0)
		ret = set_tracer_option(tr, cmp, neg);
	else
		ret = set_tracer_flag(tr, 1 << ret, !neg);

	mutex_unlock(&trace_types_lock);

	/*
	 * If the first trailing whitespace is replaced with '\0' by strstrip,
	 * turn it back into a space.
	 */
	if (orig_len > strlen(option))
		option[strlen(option)] = ' ';

	return ret;
}
",0,8383
torvalds/linux,15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,"static void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)
{
	if (sd->need_wakeup)
		wakeup_pipe_writers(pipe);
}
",0,8384
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"TEST_F(HeaderTableTests, set_capacity) {
  HPACKHeader accept('accept-encoding', 'gzip');
  uint32_t max = 10;
",1,8385
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"  bigvalue.append(capacity, 'x');
  HPACKHeader bigheader('user-agent', bigvalue);
  EXPECT_EQ(table.add(bigheader), false);
  EXPECT_EQ(table.size(), 0);
  EXPECT_EQ(table.names().size(), 0);
}

TEST_F(HeaderTableTests, set_capacity) {
  HPACKHeader accept('accept-encoding', 'gzip');
  uint32_t max = 10;
  uint32_t capacity = accept.bytes() * max;
  HeaderTable table(capacity);

",1,8386
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"  HeaderTable table(capacity);

  // fill the table
",1,8388
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"    EXPECT_EQ(table.add(accept), true);
  }
  EXPECT_EQ(table.size(), max);
  EXPECT_EQ(table.add(accept2), true);
  // evict the first one
  EXPECT_EQ(table[1], accept2);
  auto ilist = table.names().find('accept-encoding')->second;
  EXPECT_EQ(ilist.size(), max);
  // evict all the 'accept' headers
  for (size_t i = 0; i < max - 1; i++) {
    EXPECT_EQ(table.add(accept2), true);
  }
  EXPECT_EQ(table.size(), max);
  EXPECT_EQ(table[max], accept2);
  EXPECT_EQ(table.names().size(), 1);
  // add an entry that will cause 2 evictions
  EXPECT_EQ(table.add(accept3), true);
  EXPECT_EQ(table[1], accept3);
  EXPECT_EQ(table.size(), max - 1);

  // add a super huge header
  string bigvalue;
  bigvalue.append(capacity, 'x');
  HPACKHeader bigheader('user-agent', bigvalue);
  EXPECT_EQ(table.add(bigheader), false);
  EXPECT_EQ(table.size(), 0);
  EXPECT_EQ(table.names().size(), 0);
}

TEST_F(HeaderTableTests, set_capacity) {
  HPACKHeader accept('accept-encoding', 'gzip');
  uint32_t max = 10;
  uint32_t capacity = accept.bytes() * max;
  HeaderTable table(capacity);

  // fill the table
  for (size_t i = 0; i < max; i++) {
    EXPECT_EQ(table.add(accept), true);
  }
  // change capacity
  table.setCapacity(capacity / 2);
  EXPECT_EQ(table.size(), max / 2);
",1,8389
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"  HPACKHeader accept('accept-encoding', 'gzip');
  uint32_t max = 10;
  uint32_t capacity = accept.bytes() * max;
  HeaderTable table(capacity);

",1,8390
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"
  // fill the table
  for (size_t i = 0; i < max; i++) {
",1,8391
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"}

}
",1,8392
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"TEST_F(HeaderTableTests, set_capacity) {
  HPACKHeader accept('accept-encoding', 'gzip');
  uint32_t max = 10;
  uint32_t capacity = accept.bytes() * max;
  HeaderTable table(capacity);

  // fill the table
  for (size_t i = 0; i < max; i++) {
    EXPECT_EQ(table.add(accept), true);
  }
  // change capacity
  table.setCapacity(capacity / 2);
  EXPECT_EQ(table.size(), max / 2);
  EXPECT_EQ(table.bytes(), capacity / 2);
}
",1,8393
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"  max = 8;
  table.setCapacity(accept.bytes() * max);

",0,8394
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"TEST_F(HeaderTableTests, add) {
  HeaderTable table(4096);
  table.add(HPACKHeader('accept-encoding', 'gzip'));
",0,8395
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"    EXPECT_EQ(table.add(accept), true);
  }
  EXPECT_EQ(table.size(), max);
",0,8397
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"TEST_F(HeaderTableTests, comparison) {
  uint32_t capacity = 128;
  HeaderTable t1(capacity);
  HeaderTable t2(capacity);

  HPACKHeader h1('Content-Encoding', 'gzip');
  HPACKHeader h2('Content-Encoding', 'deflate');
  // different in number of elements
  t1.add(h1);
  EXPECT_FALSE(t1 == t2);
  // different in size (bytes)
  t2.add(h2);
  EXPECT_FALSE(t1 == t2);

  // make them the same
  t1.add(h2);
  t2.add(h1);
  EXPECT_TRUE(t1 == t2);

  // make them mismatch on refset
  t1.addReference(1);
  EXPECT_FALSE(t1 == t2);
}
",0,8400
facebook/proxygen,f43b134cc5c19d8532e7fb670a1c02e85f7a8d4f,"  // evict the first one
  EXPECT_EQ(table[1], accept2);
  auto ilist = table.names().find('accept-encoding')->second;
",0,8401
netblue30/firejail,eecf35c2f8249489a1d3e512bb07f0d427183134,"void preproc_mount_mnt_dir(void) {
	// mount tmpfs on top of /run/firejail/mnt
	if (!tmpfs_mounted) {
		if (arg_debug)
			printf('Mounting tmpfs on %s directory\n', RUN_MNT_DIR);
		if (mount('tmpfs', RUN_MNT_DIR, 'tmpfs', MS_NOSUID | MS_STRICTATIME,  'mode=755,gid=0') < 0)
			errExit('mounting /run/firejail/mnt');
		tmpfs_mounted = 1;
		fs_logger2('tmpfs', RUN_MNT_DIR);

#ifdef HAVE_SECCOMP
		if (arg_seccomp_block_secondary)
			copy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed
		else {
			//copy default seccomp files
			copy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed
		}
		if (arg_allow_debuggers)
			copy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed
		else
			copy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed

		if (arg_memory_deny_write_execute)
			copy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed
		// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files
		create_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);
		if (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))
			errExit('set_perms');
		create_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);
		if (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))
			errExit('set_perms');
#endif
	}
}
",1,8402
netblue30/firejail,eecf35c2f8249489a1d3e512bb07f0d427183134,"void fslib_copy_libs(const char *full_path) {
	assert(full_path);
	if (arg_debug || arg_debug_private_lib)
		printf('    fslib_copy_libs %s\n', full_path);

	// if library/executable does not exist or the user does not have read access to it
	// print a warning and exit the function.
	if (access(full_path, R_OK)) {
		if (arg_debug || arg_debug_private_lib)
			printf('cannot find %s for private-lib, skipping...\n', full_path);
		return;
	}

	// create an empty RUN_LIB_FILE and allow the user to write to it
	unlink(RUN_LIB_FILE);			  // in case is there
	create_empty_file_as_root(RUN_LIB_FILE, 0644);
	if (chown(RUN_LIB_FILE, getuid(), getgid()))
		errExit('chown');

	// run fldd to extract the list of files
	if (arg_debug || arg_debug_private_lib)
		printf('    running fldd %s\n', full_path);
	sbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);

	// open the list of libraries and install them on by one
	FILE *fp = fopen(RUN_LIB_FILE, 'r');
	if (!fp)
		errExit('fopen');

	char buf[MAXBUF];
	while (fgets(buf, MAXBUF, fp)) {
		// remove \n
		char *ptr = strchr(buf, '\n');
		if (ptr)
			*ptr = '\0';
		fslib_duplicate(buf);
	}
	fclose(fp);
}
",1,8403
netblue30/firejail,eecf35c2f8249489a1d3e512bb07f0d427183134,"int sandbox(void* sandbox_arg) {
	// Get rid of unused parameter warning
	(void)sandbox_arg;

	pid_t child_pid = getpid();
	if (arg_debug)
		printf('Initializing child process\n');

 	// close each end of the unused pipes
 	close(parent_to_child_fds[1]);
 	close(child_to_parent_fds[0]);

 	// wait for parent to do base setup
 	wait_for_other(parent_to_child_fds[0]);

	if (arg_debug && child_pid == 1)
		printf('PID namespace installed\n');


	//****************************
	// set hostname
	//****************************
	if (cfg.hostname) {
		if (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)
			errExit('sethostname');
	}

	//****************************
	// mount namespace
	//****************************
	// mount events are not forwarded between the host the sandbox
	if (mount(NULL, '/', NULL, MS_SLAVE | MS_REC, NULL) < 0) {
		chk_chroot();
	}
	// ... and mount a tmpfs on top of /run/firejail/mnt directory
	preproc_mount_mnt_dir();
	// bind-mount firejail binaries and helper programs
	if (mount(LIBDIR '/firejail', RUN_FIREJAIL_LIB_DIR, 'none', MS_BIND, NULL) < 0)
		errExit('mounting ' RUN_FIREJAIL_LIB_DIR);

	//****************************
	// log sandbox data
	//****************************
	if (cfg.name)
		fs_logger2('sandbox name:', cfg.name);
	fs_logger2int('sandbox pid:', (int) sandbox_pid);
	if (cfg.chrootdir)
		fs_logger('sandbox filesystem: chroot');
	else if (arg_overlay)
		fs_logger('sandbox filesystem: overlay');
	else
		fs_logger('sandbox filesystem: local');
	fs_logger('install mount namespace');

	//****************************
	// netfilter
	//****************************
	if (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter
		netfilter(arg_netfilter_file);
	}
	if (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter
		netfilter6(arg_netfilter6_file);
	}

	//****************************
	// networking
	//****************************
	int gw_cfg_failed = 0; // default gw configuration flag
	if (arg_nonetwork) {
		net_if_up('lo');
		if (arg_debug)
			printf('Network namespace enabled, only loopback interface available\n');
	}
	else if (arg_netns) {
		netns(arg_netns);
		if (arg_debug)
			printf('Network namespace '%s' activated\n', arg_netns);
	}
	else if (any_bridge_configured() || any_interface_configured()) {
		// configure lo and eth0...eth3
		net_if_up('lo');

		if (mac_not_zero(cfg.bridge0.macsandbox))
			net_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);
		sandbox_if_up(&cfg.bridge0);

		if (mac_not_zero(cfg.bridge1.macsandbox))
			net_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);
		sandbox_if_up(&cfg.bridge1);

		if (mac_not_zero(cfg.bridge2.macsandbox))
			net_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);
		sandbox_if_up(&cfg.bridge2);

		if (mac_not_zero(cfg.bridge3.macsandbox))
			net_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);
		sandbox_if_up(&cfg.bridge3);


		// moving an interface in a namespace using --interface will reset the interface configuration;
		// we need to put the configuration back
		if (cfg.interface0.configured && cfg.interface0.ip) {
			if (arg_debug)
				printf('Configuring %d.%d.%d.%d address on interface %s\n', PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);
			net_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);
		}
		if (cfg.interface1.configured && cfg.interface1.ip) {
			if (arg_debug)
				printf('Configuring %d.%d.%d.%d address on interface %s\n', PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);
			net_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);
		}
		if (cfg.interface2.configured && cfg.interface2.ip) {
			if (arg_debug)
				printf('Configuring %d.%d.%d.%d address on interface %s\n', PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);
			net_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);
		}
		if (cfg.interface3.configured && cfg.interface3.ip) {
			if (arg_debug)
				printf('Configuring %d.%d.%d.%d address on interface %s\n', PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);
			net_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);
		}

		// add a default route
		if (cfg.defaultgw) {
			// set the default route
			if (net_add_route(0, 0, cfg.defaultgw)) {
				fwarning('cannot configure default route\n');
				gw_cfg_failed = 1;
			}
		}

		if (arg_debug)
			printf('Network namespace enabled\n');
	}

	// print network configuration
	if (!arg_quiet) {
		if (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {
			fmessage('\n');
			if (any_bridge_configured() || any_interface_configured()) {
				if (arg_scan)
					sbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, 'printif', 'scan');
				else
					sbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, 'printif');

			}
			if (cfg.defaultgw != 0) {
				if (gw_cfg_failed)
					fmessage('Default gateway configuration failed\n');
				else
					fmessage('Default gateway %d.%d.%d.%d\n', PRINT_IP(cfg.defaultgw));
			}
			if (cfg.dns1 != NULL)
				fmessage('DNS server %s\n', cfg.dns1);
			if (cfg.dns2 != NULL)
				fmessage('DNS server %s\n', cfg.dns2);
			if (cfg.dns3 != NULL)
				fmessage('DNS server %s\n', cfg.dns3);
			if (cfg.dns4 != NULL)
				fmessage('DNS server %s\n', cfg.dns4);
			fmessage('\n');
		}
	}

	// load IBUS env variables
	if (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {
		// do nothing - there are problems with ibus version 1.5.11
	}
	else {
		EUID_USER();
		env_ibus_load();
		EUID_ROOT();
	}

	//****************************
	// fs pre-processing:
	//  - build seccomp filters
	//  - create an empty /etc/ld.so.preload
	//****************************
#ifdef HAVE_SECCOMP
	if (cfg.protocol) {
		if (arg_debug)
			printf('Build protocol filter: %s\n', cfg.protocol);

		// build the seccomp filter as a regular user
		int rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,
			PATH_FSECCOMP, 'protocol', 'build', cfg.protocol, RUN_SECCOMP_PROTOCOL);
		if (rv)
			exit(rv);
	}
	if (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))
		arg_seccomp_postexec = 1;
#endif

	// need ld.so.preload if tracing or seccomp with any non-default lists
	bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;
	// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS
	// and drop all capabilities
	if (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {
		enforce_filters();
		need_preload = arg_trace || arg_tracelog;
	}

	// trace pre-install
	if (need_preload)
		fs_trace_preload();

	// store hosts file
	if (cfg.hosts_file)
		fs_store_hosts_file();

	//****************************
	// configure filesystem
	//****************************
#ifdef HAVE_CHROOT
	if (cfg.chrootdir) {
		fs_chroot(cfg.chrootdir);

		//****************************
		// trace pre-install, this time inside chroot
		//****************************
		if (need_preload)
			fs_trace_preload();
	}
	else
#endif
#ifdef HAVE_OVERLAYFS
	if (arg_overlay)
		fs_overlayfs();
	else
#endif
		fs_basic_fs();

	//****************************
	// private mode
	//****************************
	if (arg_private) {
		if (cfg.home_private) {	// --private=
			if (cfg.chrootdir)
				fwarning('private=directory feature is disabled in chroot\n');
			else if (arg_overlay)
				fwarning('private=directory feature is disabled in overlay\n');
			else
				fs_private_homedir();
		}
		else if (cfg.home_private_keep) { // --private-home=
			if (cfg.chrootdir)
				fwarning('private-home= feature is disabled in chroot\n');
			else if (arg_overlay)
				fwarning('private-home= feature is disabled in overlay\n');
			else
				fs_private_home_list();
		}
		else // --private
			fs_private();
	}

	if (arg_private_dev)
		fs_private_dev();

	if (arg_private_etc) {
		if (cfg.chrootdir)
			fwarning('private-etc feature is disabled in chroot\n');
		else if (arg_overlay)
			fwarning('private-etc feature is disabled in overlay\n');
		else {
			fs_private_dir_list('/etc', RUN_ETC_DIR, cfg.etc_private_keep);
			// create /etc/ld.so.preload file again
			if (need_preload)
				fs_trace_preload();
		}
	}

	if (arg_private_opt) {
		if (cfg.chrootdir)
			fwarning('private-opt feature is disabled in chroot\n');
		else if (arg_overlay)
			fwarning('private-opt feature is disabled in overlay\n');
		else {
			fs_private_dir_list('/opt', RUN_OPT_DIR, cfg.opt_private_keep);
		}
	}

	if (arg_private_srv) {
		if (cfg.chrootdir)
			fwarning('private-srv feature is disabled in chroot\n');
		else if (arg_overlay)
			fwarning('private-srv feature is disabled in overlay\n');
		else {
			fs_private_dir_list('/srv', RUN_SRV_DIR, cfg.srv_private_keep);
		}
	}

	// private-bin is disabled for appimages
	if (arg_private_bin && !arg_appimage) {
		if (cfg.chrootdir)
			fwarning('private-bin feature is disabled in chroot\n');
		else if (arg_overlay)
			fwarning('private-bin feature is disabled in overlay\n');
		else {
			// for --x11=xorg we need to add xauth command
			if (arg_x11_xorg) {
				EUID_USER();
				char *tmp;
				if (asprintf(&tmp, '%s,xauth', cfg.bin_private_keep) == -1)
					errExit('asprintf');
				cfg.bin_private_keep = tmp;
				EUID_ROOT();
			}
			fs_private_bin_list();
		}
	}

	// private-lib is disabled for appimages
	if (arg_private_lib && !arg_appimage) {
		if (cfg.chrootdir)
			fwarning('private-lib feature is disabled in chroot\n');
		else if (arg_overlay)
			fwarning('private-lib feature is disabled in overlay\n');
		else {
			fs_private_lib();
		}
	}

	if (arg_private_cache) {
		if (cfg.chrootdir)
			fwarning('private-cache feature is disabled in chroot\n');
		else if (arg_overlay)
			fwarning('private-cache feature is disabled in overlay\n');
		else
			fs_private_cache();
	}

	if (arg_private_tmp) {
		// private-tmp is implemented as a whitelist
		EUID_USER();
		fs_private_tmp();
		EUID_ROOT();
	}

	//****************************
	// Session D-BUS
	//****************************
	if (arg_nodbus)
		dbus_session_disable();


	//****************************
	// hosts and hostname
	//****************************
	if (cfg.hostname)
		fs_hostname(cfg.hostname);

	if (cfg.hosts_file)
		fs_mount_hosts_file();

	//****************************
	// /etc overrides from the network namespace
	//****************************
	if (arg_netns)
		netns_mounts(arg_netns);

	//****************************
	// update /proc, /sys, /dev, /boot directory
	//****************************
	fs_proc_sys_dev_boot();

	//****************************
	// handle /mnt and /media
	//****************************
	if (checkcfg(CFG_DISABLE_MNT))
		fs_mnt(1);
	else if (arg_disable_mnt)
		fs_mnt(0);

	//****************************
	// apply the profile file
	//****************************
	// apply all whitelist commands ...
	fs_whitelist();

	// ... followed by blacklist commands
	fs_blacklist(); // mkdir and mkfile are processed all over again

	//****************************
	// nosound/no3d/notv/novideo and fix for pulseaudio 7.0
	//****************************
	if (arg_nosound) {
		// disable pulseaudio
		pulseaudio_disable();

		// disable /dev/snd
		fs_dev_disable_sound();
	}
	else if (!arg_noautopulse)
		pulseaudio_init();

	if (arg_no3d)
		fs_dev_disable_3d();

	if (arg_notv)
		fs_dev_disable_tv();

	if (arg_nodvd)
		fs_dev_disable_dvd();

	if (arg_nou2f)
	        fs_dev_disable_u2f();

	if (arg_novideo)
		fs_dev_disable_video();

	//****************************
	// install trace
	//****************************
	if (need_preload)
		fs_trace();

	//****************************
	// set dns
	//****************************
	fs_resolvconf();

	//****************************
	// fs post-processing
	//****************************
	fs_logger_print();
	fs_logger_change_owner();

	//****************************
	// set application environment
	//****************************
	EUID_USER();
	int cwd = 0;
	if (cfg.cwd) {
		if (chdir(cfg.cwd) == 0)
			cwd = 1;
	}

	if (!cwd) {
		if (chdir('/') < 0)
			errExit('chdir');
		if (cfg.homedir) {
			struct stat s;
			if (stat(cfg.homedir, &s) == 0) {
				/* coverity[toctou] */
				if (chdir(cfg.homedir) < 0)
					errExit('chdir');
			}
		}
	}
	if (arg_debug) {
		char *cpath = get_current_dir_name();
		if (cpath) {
			printf('Current directory: %s\n', cpath);
			free(cpath);
		}
	}

	EUID_ROOT();
	// clean /tmp/.X11-unix sockets
	fs_x11();
	if (arg_x11_xorg)
		x11_xorg();

	// save original umask
	save_umask();

	//****************************
	// set security filters
	//****************************
	// save state of nonewprivs
	save_nonewprivs();

	// set capabilities
	set_caps();

	// save cpu affinity mask to CPU_CFG file
	save_cpu();

	// save cgroup in CGROUP_CFG file
	save_cgroup();

	// set seccomp
#ifdef HAVE_SECCOMP
	// install protocol filter
#ifdef SYS_socket
	if (cfg.protocol) {
		if (arg_debug)
			printf('Install protocol filter: %s\n', cfg.protocol);
		seccomp_load(RUN_SECCOMP_PROTOCOL);	// install filter
		protocol_filter_save();	// save filter in RUN_PROTOCOL_CFG
	}
	else {
		int rv = unlink(RUN_SECCOMP_PROTOCOL);
		(void) rv;
	}
#endif

	// if a keep list is available, disregard the drop list
	if (arg_seccomp == 1) {
		if (cfg.seccomp_list_keep)
			seccomp_filter_keep();
		else
			seccomp_filter_drop();

	}
	else { // clean seccomp files under /run/firejail/mnt
		int rv = unlink(RUN_SECCOMP_CFG);
		rv |= unlink(RUN_SECCOMP_32);
		(void) rv;
	}

	if (arg_memory_deny_write_execute) {
		if (arg_debug)
			printf('Install memory write&execute filter\n');
		seccomp_load(RUN_SECCOMP_MDWX);	// install filter
	}
	else {
		int rv = unlink(RUN_SECCOMP_MDWX);
		(void) rv;
	}
#endif

	//****************************************
	// communicate progress of sandbox set up
	// to --join
	//****************************************

	FILE *rj = create_ready_for_join_file();

	//****************************************
	// create a new user namespace
	//     - too early to drop privileges
	//****************************************
	save_nogroups();
	if (arg_noroot) {
		int rv = unshare(CLONE_NEWUSER);
		if (rv == -1) {
			fwarning('cannot create a new user namespace, going forward without it...\n');
			arg_noroot = 0;
		}
	}

	// notify parent that new user namespace has been created so a proper
 	// UID/GID map can be setup
 	notify_other(child_to_parent_fds[1]);
 	close(child_to_parent_fds[1]);

 	// wait for parent to finish setting up a proper UID/GID map
 	wait_for_other(parent_to_child_fds[0]);
 	close(parent_to_child_fds[0]);

	// somehow, the new user namespace resets capabilities;
	// we need to do them again
	if (arg_noroot) {
		if (arg_debug)
			printf('noroot user namespace installed\n');
		set_caps();
	}

	//****************************************
	// Set NO_NEW_PRIVS if desired
	//****************************************
	if (arg_nonewprivs) {
		prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);

		if (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {
			fwarning('cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\n');
			if (force_nonewprivs) {
				fprintf(stderr, 'Error: NO_NEW_PRIVS required for this sandbox, exiting ...\n');
				exit(1);
			}
		}
		else if (arg_debug)
			printf('NO_NEW_PRIVS set\n');
	}

	//****************************************
	// drop privileges
	//****************************************
	drop_privs(arg_nogroups);

	// kill the sandbox in case the parent died
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);

	//****************************************
	// set cpu affinity
	//****************************************

	if (cfg.cpus)
		set_cpu_affinity();

	//****************************************
	// fork the application and monitor it
	//****************************************
	pid_t app_pid = fork();
	if (app_pid == -1)
		errExit('fork');

	if (app_pid == 0) {
#ifdef HAVE_APPARMOR
		if (checkcfg(CFG_APPARMOR) && arg_apparmor) {
			errno = 0;
			if (aa_change_onexec('firejail-default')) {
				fwarning('Cannot confine the application using AppArmor.\n'
					'Maybe firejail-default AppArmor profile is not loaded into the kernel.\n'
					'As root, run \'aa-enforce firejail-default\' to load it.\n');
			}
			else if (arg_debug)
				printf('AppArmor enabled\n');
		}
#endif
		// set nice and rlimits
		if (arg_nice)
			set_nice(cfg.nice);
		set_rlimits();

		start_application(0, rj);
	}

	fclose(rj);

	int status = monitor_application(app_pid);	// monitor application
	flush_stdin();

	if (WIFEXITED(status)) {
		// if we had a proper exit, return that exit status
		return WEXITSTATUS(status);
	} else {
		// something else went wrong!
		return -1;
	}
}
",1,8404
netblue30/firejail,eecf35c2f8249489a1d3e512bb07f0d427183134,"
	if (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {
		create_empty_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);
	}

",0,8405
netblue30/firejail,eecf35c2f8249489a1d3e512bb07f0d427183134,"static void save_umask(void) {
	FILE *fp = fopen(RUN_UMASK_FILE, 'wxe');
	if (fp) {
		fprintf(fp, '%o\n', orig_umask);
		SET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644
		fclose(fp);
	}
	else {
		fprintf(stderr, 'Error: cannot save umask\n');
		exit(1);
	}
}
",0,8406
netblue30/firejail,eecf35c2f8249489a1d3e512bb07f0d427183134,"	// don't copy it if the file is already there
	char *ptr = strrchr(full_path, '/');
	if (!ptr)
		return;
	ptr++;
	if (*ptr == '\0')
		return;

	char *name;
",0,8407
ImageMagick/ImageMagick,35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34,"static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define BoundingBox  'BoundingBox:'
#define BeginDocument  'BeginDocument:'
#define BeginXMPPacket  '<?xpacket begin='
#define EndXMPPacket  '<?xpacket end='
#define ICCProfile 'BeginICCProfile:'
#define CMYKCustomColor  'CMYKCustomColor:'
#define CMYKProcessColor  'CMYKProcessColor:'
#define DocumentMedia  'DocumentMedia:'
#define DocumentCustomColors  'DocumentCustomColors:'
#define DocumentProcessColors  'DocumentProcessColors:'
#define EndDocument  'EndDocument:'
#define HiResBoundingBox  'HiResBoundingBox:'
#define ImageData  'ImageData:'
#define PageBoundingBox  'PageBoundingBox:'
#define LanguageLevel  'LanguageLevel:'
#define PageMedia  'PageMedia:'
#define Pages  'Pages:'
#define PhotoshopProfile  'BeginPhotoshop:'
#define PostscriptLevel  '!PS-'
#define RenderPostscriptText  '  Rendering Postscript...  '
#define SpotColor  '+ '

  char
    command[MagickPathExtent],
    *density,
    filename[MagickPathExtent],
    geometry[MagickPathExtent],
    input_filename[MagickPathExtent],
    message[MagickPathExtent],
    *options,
    postscript_filename[MagickPathExtent];

  const char
    *option;

  const DelegateInfo
    *delegate_info;

  GeometryInfo
    geometry_info;

  Image
    *image,
    *next,
    *postscript_image;

  ImageInfo
    *read_info;

  int
    c,
    file;

  MagickBooleanType
    cmyk,
    fitPage,
    skip,
    status;

  MagickStatusType
    flags;

  PointInfo
    delta,
    resolution;

  RectangleInfo
    page;

  register char
    *p;

  register ssize_t
    i;

  SegmentInfo
    bounds,
    hires_bounds;

  short int
    hex_digits[256];

  size_t
    length;

  ssize_t
    count,
    priority;

  StringInfo
    *profile;

  unsigned long
    columns,
    extent,
    language_level,
    pages,
    rows,
    scene,
    spotcolor;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),'%s',
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);
  if (status == MagickFalse)
    {
      ThrowFileException(exception,FileOpenError,'UnableToCreateTemporaryFile',
        image_info->filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Initialize hex values.
  */
  (void) memset(hex_digits,0,sizeof(hex_digits));
  hex_digits[(int) '0']=0;
  hex_digits[(int) '1']=1;
  hex_digits[(int) '2']=2;
  hex_digits[(int) '3']=3;
  hex_digits[(int) '4']=4;
  hex_digits[(int) '5']=5;
  hex_digits[(int) '6']=6;
  hex_digits[(int) '7']=7;
  hex_digits[(int) '8']=8;
  hex_digits[(int) '9']=9;
  hex_digits[(int) 'a']=10;
  hex_digits[(int) 'b']=11;
  hex_digits[(int) 'c']=12;
  hex_digits[(int) 'd']=13;
  hex_digits[(int) 'e']=14;
  hex_digits[(int) 'f']=15;
  hex_digits[(int) 'A']=10;
  hex_digits[(int) 'B']=11;
  hex_digits[(int) 'C']=12;
  hex_digits[(int) 'D']=13;
  hex_digits[(int) 'E']=14;
  hex_digits[(int) 'F']=15;
  /*
    Set the page density.
  */
  delta.x=DefaultResolution;
  delta.y=DefaultResolution;
  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))
    {
      flags=ParseGeometry(PSDensityGeometry,&geometry_info);
      image->resolution.x=geometry_info.rho;
      image->resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        image->resolution.y=image->resolution.x;
    }
  if (image_info->density != (char *) NULL)
    {
      flags=ParseGeometry(image_info->density,&geometry_info);
      image->resolution.x=geometry_info.rho;
      image->resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        image->resolution.y=image->resolution.x;
    }
  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  resolution=image->resolution;
  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);
  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);
  /*
    Determine page geometry from the Postscript bounding box.
  */
  (void) memset(&bounds,0,sizeof(bounds));
  (void) memset(command,0,sizeof(command));
  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
  (void) memset(&hires_bounds,0,sizeof(hires_bounds));
  columns=0;
  rows=0;
  priority=0;
  rows=0;
  extent=0;
  spotcolor=0;
  language_level=1;
  pages=(~0UL);
  skip=MagickFalse;
  p=command;
  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
  {
    /*
      Note document structuring comments.
    */
    *p++=(char) c;
    if ((strchr('\n\r%',c) == (char *) NULL) &&
        ((size_t) (p-command) < (MagickPathExtent-1)))
      continue;
    *p='\0';
    p=command;
    /*
      Skip %%BeginDocument thru %%EndDocument.
    */
    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)
      skip=MagickTrue;
    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)
      skip=MagickFalse;
    if (skip != MagickFalse)
      continue;
    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)
      {
        (void) SetImageProperty(image,'ps:Level',command+4,exception);
        if (GlobExpression(command,'*EPSF-*',MagickTrue) != MagickFalse)
          pages=1;
      }
    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)
      (void) sscanf(command,LanguageLevel ' %lu',&language_level);
    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)
      (void) sscanf(command,Pages ' %lu',&pages);
    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)
      (void) sscanf(command,ImageData ' %lu %lu',&columns,&rows);
    /*
      Is this a CMYK document?
    */
    length=strlen(DocumentProcessColors);
    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)
      {
        if ((GlobExpression(command,'*Cyan*',MagickTrue) != MagickFalse) ||
            (GlobExpression(command,'*Magenta*',MagickTrue) != MagickFalse) ||
            (GlobExpression(command,'*Yellow*',MagickTrue) != MagickFalse))
          cmyk=MagickTrue;
      }
    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)
      cmyk=MagickTrue;
    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)
      cmyk=MagickTrue;
    length=strlen(DocumentCustomColors);
    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||
        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||
        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))
      {
        char
          property[MagickPathExtent],
          *value;

        register char
          *q;

        /*
          Note spot names.
        */
        (void) FormatLocaleString(property,MagickPathExtent,
          'ps:SpotColor-%.20g',(double) (spotcolor++));
        for (q=command; *q != '\0'; q++)
          if (isspace((int) (unsigned char) *q) != 0)
            break;
        value=ConstantString(q);
        (void) SubstituteString(&value,'(','');
        (void) SubstituteString(&value,')','');
        (void) StripString(value);
        if (*value != '\0')
          (void) SetImageProperty(image,property,value,exception);
        value=DestroyString(value);
        continue;
      }
    if (image_info->page != (char *) NULL)
      continue;
    /*
      Note region defined by bounding box.
    */
    count=0;
    i=0;
    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)
      {
        count=(ssize_t) sscanf(command,BoundingBox ' %lf %lf %lf %lf',
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=2;
      }
    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)
      {
        count=(ssize_t) sscanf(command,DocumentMedia ' %lf %lf %lf %lf',
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=1;
      }
    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)
      {
        count=(ssize_t) sscanf(command,HiResBoundingBox ' %lf %lf %lf %lf',
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=3;
      }
    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)
      {
        count=(ssize_t) sscanf(command,PageBoundingBox ' %lf %lf %lf %lf',
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=1;
      }
    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)
      {
        count=(ssize_t) sscanf(command,PageMedia ' %lf %lf %lf %lf',
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=1;
      }
    if ((count != 4) || (i < (ssize_t) priority))
      continue;
    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||
        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))
      if (i ==  (ssize_t) priority)
        continue;
    hires_bounds=bounds;
    priority=i;
  }
  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&
      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))
    {
      /*
        Set Postscript render geometry.
      */
      (void) FormatLocaleString(geometry,MagickPathExtent,'%gx%g%+.15g%+.15g',
        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,
        hires_bounds.x1,hires_bounds.y1);
      (void) SetImageProperty(image,'ps:HiResBoundingBox',geometry,exception);
      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*
        resolution.x/delta.x)-0.5);
      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*
        resolution.y/delta.y)-0.5);
    }
  fitPage=MagickFalse;
  option=GetImageOption(image_info,'eps:fit-page');
  if (option != (char *) NULL)
    {
      char
        *page_geometry;

      page_geometry=GetPageGeometry(option);
      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,
        &page.height);
      if (flags == NoValue)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            'InvalidGeometry','`%s'',option);
          image=DestroyImage(image);
          return((Image *) NULL);
        }
      page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)
        -0.5);
      page.height=(size_t) ceil((double) (page.height*image->resolution.y/
        delta.y) -0.5);
      page_geometry=DestroyString(page_geometry);
      fitPage=MagickTrue;
    }
  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)
    cmyk=MagickFalse;
  /*
    Create Ghostscript control file.
  */
  file=AcquireUniqueFileResource(postscript_filename);
  if (file == -1)
    {
      ThrowFileException(exception,FileOpenError,'UnableToOpenFile',
        image_info->filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) CopyMagickString(command,'/setpagedevice {pop} bind 1 index where {'
    'dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\n'
    '<</UseCIEColor true>>setpagedevice\n',MagickPathExtent);
  count=write(file,command,(unsigned int) strlen(command));
  if (image_info->page == (char *) NULL)
    {
      char
        translate_geometry[MagickPathExtent];

      (void) FormatLocaleString(translate_geometry,MagickPathExtent,
        '%g %g translate\n',-bounds.x1,-bounds.y1);
      count=write(file,translate_geometry,(unsigned int)
        strlen(translate_geometry));
    }
  file=close(file)-1;
  /*
    Render Postscript with the Ghostscript delegate.
  */
  if (image_info->monochrome != MagickFalse)
    delegate_info=GetDelegateInfo('ps:mono',(char *) NULL,exception);
  else
    if (cmyk != MagickFalse)
      delegate_info=GetDelegateInfo('ps:cmyk',(char *) NULL,exception);
    else
      delegate_info=GetDelegateInfo('ps:alpha',(char *) NULL,exception);
  if (delegate_info == (const DelegateInfo *) NULL)
    {
      (void) RelinquishUniqueFileResource(postscript_filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  density=AcquireString('');
  options=AcquireString('');
  (void) FormatLocaleString(density,MagickPathExtent,'%gx%g',resolution.x,
    resolution.y);
  (void) FormatLocaleString(options,MagickPathExtent,'-g%.20gx%.20g ',(double)
    page.width,(double) page.height);
  read_info=CloneImageInfo(image_info);
  *read_info->magick='\0';
  if (read_info->number_scenes != 0)
    {
      char
        pages[MagickPathExtent];

      (void) FormatLocaleString(pages,MagickPathExtent,'-dFirstPage=%.20g '
        '-dLastPage=%.20g ',(double) read_info->scene+1,(double)
        (read_info->scene+read_info->number_scenes));
      (void) ConcatenateMagickString(options,pages,MagickPathExtent);
      read_info->number_scenes=0;
      if (read_info->scenes != (char *) NULL)
        *read_info->scenes='\0';
    }
  if (*image_info->magick == 'E')
    {
      option=GetImageOption(image_info,'eps:use-cropbox');
      if ((option == (const char *) NULL) ||
          (IsStringTrue(option) != MagickFalse))
        (void) ConcatenateMagickString(options,'-dEPSCrop ',MagickPathExtent);
      if (fitPage != MagickFalse)
        (void) ConcatenateMagickString(options,'-dEPSFitPage ',
          MagickPathExtent);
    }
  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);
  (void) AcquireUniqueFilename(filename);
  (void) RelinquishUniqueFileResource(filename);
  (void) ConcatenateMagickString(filename,'%d',MagickPathExtent);
  (void) FormatLocaleString(command,MagickPathExtent,
    GetDelegateCommands(delegate_info),
    read_info->antialias != MagickFalse ? 4 : 1,
    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,
    postscript_filename,input_filename);
  options=DestroyString(options);
  density=DestroyString(density);
  *message='\0';
  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);
  (void) InterpretImageFilename(image_info,image,filename,1,
    read_info->filename,exception);
  if ((status == MagickFalse) ||
      (IsPostscriptRendered(read_info->filename) == MagickFalse))
    {
      (void) ConcatenateMagickString(command,' -c showpage',MagickPathExtent);
      status=InvokePostscriptDelegate(read_info->verbose,command,message,
        exception);
    }
  (void) RelinquishUniqueFileResource(postscript_filename);
  (void) RelinquishUniqueFileResource(input_filename);
  postscript_image=(Image *) NULL;
  if (status == MagickFalse)
    for (i=1; ; i++)
    {
      (void) InterpretImageFilename(image_info,image,filename,(int) i,
        read_info->filename,exception);
      if (IsPostscriptRendered(read_info->filename) == MagickFalse)
        break;
      (void) RelinquishUniqueFileResource(read_info->filename);
    }
  else
    for (i=1; ; i++)
    {
      (void) InterpretImageFilename(image_info,image,filename,(int) i,
        read_info->filename,exception);
      if (IsPostscriptRendered(read_info->filename) == MagickFalse)
        break;
      read_info->blob=NULL;
      read_info->length=0;
      next=ReadImage(read_info,exception);
      (void) RelinquishUniqueFileResource(read_info->filename);
      if (next == (Image *) NULL)
        break;
      AppendImageToList(&postscript_image,next);
    }
  (void) RelinquishUniqueFileResource(read_info->filename);
  read_info=DestroyImageInfo(read_info);
  if (postscript_image == (Image *) NULL)
    {
      if (*message != '\0')
        (void) ThrowMagickException(exception,GetMagickModule(),
          DelegateError,'PostscriptDelegateFailed','`%s'',message);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  if (LocaleCompare(postscript_image->magick,'BMP') == 0)
    {
      Image
        *cmyk_image;

      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);
      if (cmyk_image != (Image *) NULL)
        {
          postscript_image=DestroyImageList(postscript_image);
          postscript_image=cmyk_image;
        }
    }
  (void) SeekBlob(image,0,SEEK_SET);
  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
  {
    /*
      Note document structuring comments.
    */
    *p++=(char) c;
    if ((strchr('\n\r%',c) == (char *) NULL) &&
        ((size_t) (p-command) < (MagickPathExtent-1)))
      continue;
    *p='\0';
    p=command;
    /*
      Skip %%BeginDocument thru %%EndDocument.
    */
    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)
      skip=MagickTrue;
    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)
      skip=MagickFalse;
    if (skip != MagickFalse)
      continue;
    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)
      {
        unsigned char
          *datum;

        /*
          Read ICC profile.
        */
        profile=AcquireStringInfo(MagickPathExtent);
        datum=GetStringInfoDatum(profile);
        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)
        {
          if (i >= (ssize_t) GetStringInfoLength(profile))
            {
              SetStringInfoLength(profile,(size_t) i << 1);
              datum=GetStringInfoDatum(profile);
            }
          datum[i]=(unsigned char) c;
        }
        SetStringInfoLength(profile,(size_t) i+1);
        (void) SetImageProfile(image,'icc',profile,exception);
        profile=DestroyStringInfo(profile);
        continue;
      }
    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)
      {
        unsigned char
          *q;

        /*
          Read Photoshop profile.
        */
        count=(ssize_t) sscanf(command,PhotoshopProfile ' %lu',&extent);
        if (count != 1)
          continue;
        length=extent;
        if ((MagickSizeType) length > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,'InsufficientImageDataInFile');
        profile=BlobToStringInfo((const void *) NULL,length);
        if (profile != (StringInfo *) NULL)
          {
            q=GetStringInfoDatum(profile);
            for (i=0; i < (ssize_t) length; i++)
              *q++=(unsigned char) ProfileInteger(image,hex_digits);
            (void) SetImageProfile(image,'8bim',profile,exception);
            profile=DestroyStringInfo(profile);
          }
        continue;
      }
    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)
      {
        /*
          Read XMP profile.
        */
        p=command;
        profile=StringToStringInfo(command);
        for (i=(ssize_t) GetStringInfoLength(profile)-1; c != EOF; i++)
        {
          SetStringInfoLength(profile,(size_t) (i+1));
          c=ReadBlobByte(image);
          GetStringInfoDatum(profile)[i]=(unsigned char) c;
          *p++=(char) c;
          if ((strchr('\n\r%',c) == (char *) NULL) &&
              ((size_t) (p-command) < (MagickPathExtent-1)))
            continue;
          *p='\0';
          p=command;
          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)
            break;
        }
        SetStringInfoLength(profile,(size_t) i);
        (void) SetImageProfile(image,'xmp',profile,exception);
        profile=DestroyStringInfo(profile);
        continue;
      }
  }
  (void) CloseBlob(image);
  if (image_info->number_scenes != 0)
    {
      Image
        *clone_image;

      /*
        Add place holder images to meet the subimage specification requirement.
      */
      for (i=0; i < (ssize_t) image_info->scene; i++)
      {
        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);
        if (clone_image != (Image *) NULL)
          PrependImageToList(&postscript_image,clone_image);
      }
    }
  do
  {
    (void) CopyMagickString(postscript_image->filename,filename,
      MagickPathExtent);
    (void) CopyMagickString(postscript_image->magick,image->magick,
      MagickPathExtent);
    if (columns != 0)
      postscript_image->magick_columns=columns;
    if (rows != 0)
      postscript_image->magick_rows=rows;
    postscript_image->page=page;
    (void) CloneImageProfiles(postscript_image,image);
    (void) CloneImageProperties(postscript_image,image);
    next=SyncNextImageInList(postscript_image);
    if (next != (Image *) NULL)
      postscript_image=next;
  } while (next != (Image *) NULL);
  image=DestroyImageList(image);
  scene=0;
  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )
  {
    next->scene=scene++;
    next=GetNextImageInList(next);
  }
  return(GetFirstImageInList(postscript_image));
}
",1,8408
ImageMagick/ImageMagick,35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34,"static inline int ProfileInteger(Image *image,short int *hex_digits)
{
  int
    c,
    l,
    value;

  register ssize_t
    i;

  l=0;
  value=0;
  for (i=0; i < 2; )
  {
    c=ReadBlobByte(image);
    if ((c == EOF) || ((c == '%') && (l == '%')))
      {
        value=(-1);
        break;
      }
    l=c;
    c&=0xff;
    if (isxdigit(c) == MagickFalse)
      continue;
    value=(int) ((size_t) value << 4)+hex_digits[c];
    i++;
  }
  return(value);
}
",0,8409
ImageMagick/ImageMagick,d4fc44b58a14f76b1ac997517d742ee12c9dc5d3,"static inline Quantum GetPixelChannel(const Image *magick_restrict image,
  const PixelChannel channel,const Quantum *magick_restrict pixel)
{
  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)
    return((Quantum) 0);
  return(pixel[image->channel_map[channel].offset]);
}
",1,8410
ImageMagick/ImageMagick,d4fc44b58a14f76b1ac997517d742ee12c9dc5d3,"static inline void SetPixelGreen(const Image *magick_restrict image,
  const Quantum green,Quantum *magick_restrict pixel)
{
  pixel[image->channel_map[GreenPixelChannel].offset]=green;
}
",0,8411
ImageMagick/ImageMagick,5e409ae7a389cdf2ed17469303be3f3f21cec450,"static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)
{
  MagickPixelPacket
    **pixels;

  register ssize_t
    i,
    j;

  size_t
    number_threads;

  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
  pixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,
    sizeof(*pixels));
  if (pixels == (MagickPixelPacket **) NULL)
    return((MagickPixelPacket **) NULL);
  (void) memset(pixels,0,number_threads*sizeof(*pixels));
  for (i=0; i < (ssize_t) number_threads; i++)
  {
    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(image->columns,
      sizeof(**pixels));
    if (pixels[i] == (MagickPixelPacket *) NULL)
      return(DestroyPixelThreadSet(pixels));
    for (j=0; j < (ssize_t) image->columns; j++)
      GetMagickPixelPacket(image,&pixels[i][j]);
  }
  return(pixels);
}
",1,8412
ImageMagick/ImageMagick,5e409ae7a389cdf2ed17469303be3f3f21cec450,"static void GetNonpeakPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)
{
  register SkipList
    *list;

  register ssize_t
    channel;

  size_t
    color,
    next,
    previous;

  ssize_t
    count;

  unsigned short
    channels[5];

  /*
    Finds the non peak value for each of the colors.
  */
  for (channel=0; channel < 5; channel++)
  {
    list=pixel_list->lists+channel;
    color=65536L;
    next=list->nodes[color].next[0];
    count=0;
    do
    {
      previous=color;
      color=next;
      next=list->nodes[color].next[0];
      count+=list->nodes[color].count;
    } while (count <= (ssize_t) (pixel_list->length >> 1));
    if ((previous == 65536UL) && (next != 65536UL))
      color=next;
    else
      if ((previous != 65536UL) && (next == 65536UL))
        color=previous;
    channels[channel]=(unsigned short) color;
  }
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}
",0,8413
stephane/libmodbus,5ccdf5ef79d742640355d1132fa9e2abc7fbaefc,"int modbus_reply(modbus_t *ctx, const uint8_t *req,
                 int req_length, modbus_mapping_t *mb_mapping)
{
    int offset;
    int slave;
    int function;
    uint16_t address;
    uint8_t rsp[MAX_MESSAGE_LENGTH];
    int rsp_length = 0;
    sft_t sft;

    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }

    offset = ctx->backend->header_length;
    slave = req[offset - 1];
    function = req[offset];
    address = (req[offset + 1] << 8) + req[offset + 2];

    sft.slave = slave;
    sft.function = function;
    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);

    /* Data are flushed on illegal number of values errors. */
    switch (function) {
    case MODBUS_FC_READ_COILS:
    case MODBUS_FC_READ_DISCRETE_INPUTS: {
        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);
        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;
        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;
        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;
        const char * const name = is_input ? 'read_input_bits' : 'read_bits';
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        /* The mapping can be shifted to reduce memory consumption and it
           doesn't always start at address zero. */
        int mapping_address = address - start_bits;

        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                'Illegal nb of values %d in %s (max %d)\n',
                nb, name, MODBUS_MAX_READ_BITS);
        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                'Illegal data address 0x%0X in %s\n',
                mapping_address < 0 ? address : address + nb, name);
        } else {
            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);
            rsp_length = response_io_status(tab_bits, mapping_address, nb,
                                            rsp, rsp_length);
        }
    }
        break;
    case MODBUS_FC_READ_HOLDING_REGISTERS:
    case MODBUS_FC_READ_INPUT_REGISTERS: {
        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);
        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;
        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;
        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;
        const char * const name = is_input ? 'read_input_registers' : 'read_registers';
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        /* The mapping can be shifted to reduce memory consumption and it
           doesn't always start at address zero. */
        int mapping_address = address - start_registers;

        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                'Illegal nb of values %d in %s (max %d)\n',
                nb, name, MODBUS_MAX_READ_REGISTERS);
        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                'Illegal data address 0x%0X in %s\n',
                mapping_address < 0 ? address : address + nb, name);
        } else {
            int i;

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = nb << 1;
            for (i = mapping_address; i < mapping_address + nb; i++) {
                rsp[rsp_length++] = tab_registers[i] >> 8;
                rsp[rsp_length++] = tab_registers[i] & 0xFF;
            }
        }
    }
        break;
    case MODBUS_FC_WRITE_SINGLE_COIL: {
        int mapping_address = address - mb_mapping->start_bits;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                'Illegal data address 0x%0X in write_bit\n',
                address);
        } else {
            int data = (req[offset + 3] << 8) + req[offset + 4];

            if (data == 0xFF00 || data == 0x0) {
                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;
                memcpy(rsp, req, req_length);
                rsp_length = req_length;
            } else {
                rsp_length = response_exception(
                    ctx, &sft,
                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,
                    'Illegal data value 0x%0X in write_bit request at address %0X\n',
                    data, address);
            }
        }
    }
        break;
    case MODBUS_FC_WRITE_SINGLE_REGISTER: {
        int mapping_address = address - mb_mapping->start_registers;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                'Illegal data address 0x%0X in write_register\n',
                address);
        } else {
            int data = (req[offset + 3] << 8) + req[offset + 4];

            mb_mapping->tab_registers[mapping_address] = data;
            memcpy(rsp, req, req_length);
            rsp_length = req_length;
        }
    }
        break;
    case MODBUS_FC_WRITE_MULTIPLE_COILS: {
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        int mapping_address = address - mb_mapping->start_bits;

        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) {
            /* May be the indication has been truncated on reading because of
             * invalid address (eg. nb is 0 but the request contains values to
             * write) so it's necessary to flush. */
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                'Illegal number of values %d in write_bits (max %d)\n',
                nb, MODBUS_MAX_WRITE_BITS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_bits) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                'Illegal data address 0x%0X in write_bits\n',
                mapping_address < 0 ? address : address + nb);
        } else {
            /* 6 = byte count */
            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,
                                       &req[offset + 6]);

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            /* 4 to copy the bit address (2) and the quantity of bits */
            memcpy(rsp + rsp_length, req + rsp_length, 4);
            rsp_length += 4;
        }
    }
        break;
    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        int mapping_address = address - mb_mapping->start_registers;

        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                'Illegal number of values %d in write_registers (max %d)\n',
                nb, MODBUS_MAX_WRITE_REGISTERS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                'Illegal data address 0x%0X in write_registers\n',
                mapping_address < 0 ? address : address + nb);
        } else {
            int i, j;
            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {
                /* 6 and 7 = first value */
                mb_mapping->tab_registers[i] =
                    (req[offset + j] << 8) + req[offset + j + 1];
            }

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            /* 4 to copy the address (2) and the no. of registers */
            memcpy(rsp + rsp_length, req + rsp_length, 4);
            rsp_length += 4;
        }
    }
        break;
    case MODBUS_FC_REPORT_SLAVE_ID: {
        int str_len;
        int byte_count_pos;

        rsp_length = ctx->backend->build_response_basis(&sft, rsp);
        /* Skip byte count for now */
        byte_count_pos = rsp_length++;
        rsp[rsp_length++] = _REPORT_SLAVE_ID;
        /* Run indicator status to ON */
        rsp[rsp_length++] = 0xFF;
        /* LMB + length of LIBMODBUS_VERSION_STRING */
        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);
        memcpy(rsp + rsp_length, 'LMB' LIBMODBUS_VERSION_STRING, str_len);
        rsp_length += str_len;
        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;
    }
        break;
    case MODBUS_FC_READ_EXCEPTION_STATUS:
        if (ctx->debug) {
            fprintf(stderr, 'FIXME Not implemented\n');
        }
        errno = ENOPROTOOPT;
        return -1;
        break;
    case MODBUS_FC_MASK_WRITE_REGISTER: {
        int mapping_address = address - mb_mapping->start_registers;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                'Illegal data address 0x%0X in write_register\n',
                address);
        } else {
            uint16_t data = mb_mapping->tab_registers[mapping_address];
            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];
            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];

            data = (data & and) | (or & (~and));
            mb_mapping->tab_registers[mapping_address] = data;
            memcpy(rsp, req, req_length);
            rsp_length = req_length;
        }
    }
        break;
    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];
        int nb_write = (req[offset + 7] << 8) + req[offset + 8];
        int nb_write_bytes = req[offset + 9];
        int mapping_address = address - mb_mapping->start_registers;
        int mapping_address_write = address_write - mb_mapping->start_registers;

        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||
            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||
            nb_write_bytes != nb_write * 2) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                'Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n',
                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_registers ||
                   mapping_address < 0 ||
                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                'Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n',
                mapping_address < 0 ? address : address + nb,
                mapping_address_write < 0 ? address_write : address_write + nb_write);
        } else {
            int i, j;
            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = nb << 1;

            /* Write first.
               10 and 11 are the offset of the first values to write */
            for (i = mapping_address_write, j = 10;
                 i < mapping_address_write + nb_write; i++, j += 2) {
                mb_mapping->tab_registers[i] =
                    (req[offset + j] << 8) + req[offset + j + 1];
            }

            /* and read the data for the response */
            for (i = mapping_address; i < mapping_address + nb; i++) {
                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;
                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
            }
        }
    }
        break;

    default:
        rsp_length = response_exception(
            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,
            'Unknown Modbus function code: 0x%0X\n', function);
        break;
    }

    /* Suppress any responses when the request was a broadcast */
    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&
            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);
}
",1,8414
stephane/libmodbus,5ccdf5ef79d742640355d1132fa9e2abc7fbaefc,"    case EMBXMEMPAR:
        return 'Memory parity error';
",0,8415
z3APA3A/3proxy,3b67dc844789dc0f00e934270c7b349bcb547865,"void * adminchild(struct clientparam* param) {
 int i, res;
 char * buf;
 char username[256];
 char *sb;
 char *req = NULL;
 struct printparam pp;
 int contentlen = 0;
 int isform = 0;

 pp.inbuf = 0;
 pp.cp = param;

 buf = myalloc(LINESIZE);
 if(!buf) {RETURN(555);}
 i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]);
 if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && 
	   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))
 {
	RETURN(701);
 }
 buf[i] = 0;
 sb = strchr(buf+5, ' ');
 if(!sb){
	RETURN(702);
 }
 *sb = 0;
 req = mystrdup(buf + ((*buf == 'P')? 6 : 5));
 while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){
	buf[i] = 0;
	if(i > 19 && (!strncasecmp(buf, 'authorization', 13))){
		sb = strchr(buf, ':');
		if(!sb)continue;
		++sb;
		while(isspace(*sb))sb++;
		if(!*sb || strncasecmp(sb, 'basic', 5)){
			continue;
		}
		sb+=5;
		while(isspace(*sb))sb++;
		i = de64((unsigned char *)sb, (unsigned char *)username, 255);
		if(i<=0)continue;
		username[i] = 0;
		sb = strchr((char *)username, ':');
		if(sb){
			*sb = 0;
			if(param->password)myfree(param->password);
			param->password = (unsigned char *)mystrdup(sb+1);
		}
		if(param->username) myfree(param->username);
		param->username = (unsigned char *)mystrdup(username);
		continue;
	}
	else if(i > 15 && (!strncasecmp(buf, 'content-length:', 15))){
		sb = buf + 15;
		while(isspace(*sb))sb++;
		contentlen = atoi(sb);
	}
	else if(i > 13 && (!strncasecmp(buf, 'content-type:', 13))){
		sb = buf + 13;
		while(isspace(*sb))sb++;
		if(!strncasecmp(sb, 'x-www-form-urlencoded', 21)) isform = 1;
	}
 }
 param->operation = ADMIN;
 if(isform && contentlen) {
	printstr(&pp, 'HTTP/1.0 100 Continue\r\n\r\n');
	stdpr(&pp, NULL, 0);
 }
 res = (*param->srv->authfunc)(param);
 if(res && res != 10) {
	printstr(&pp, authreq);
	RETURN(res);
 }
 if(param->srv->singlepacket || param->redirected){
	if(*req == 'C') req[1] = 0;
	else *req = 0;
 }
 sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:'3proxy', conf.stringtable?(char *)conf.stringtable[2]:'3[APA3A] tiny proxy', conf.stringtable?(char *)conf.stringtable[3]:'');
 if(*req != 'S') printstr(&pp, buf);
 switch(*req){
	case 'C':
		printstr(&pp, counters);
		{
			struct trafcount *cp; 
			int num = 0;
			for(cp = conf.trafcounter; cp; cp = cp->next, num++){
			 int inbuf = 0;

			 if(cp->ace && (param->srv->singlepacket || param->redirected)){
				if(!ACLmatches(cp->ace, param))continue;
			 }
			 if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;
			 if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;
			 inbuf += sprintf(buf,	'<tr>'
						'<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>',
						(cp->comment)?cp->comment:'&nbsp;',
						(cp->disabled)?'S':'D',
						num,
						(cp->disabled)?'NO':'YES'
					);
			 if(!cp->ace || !cp->ace->users){
				inbuf += sprintf(buf+inbuf, '<center>ANY</center>');
			 }
			 else {
				inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, ',<br />\r\n');
			 }
			 inbuf += sprintf(buf+inbuf, '</td><td>');
			 if(!cp->ace || !cp->ace->src){
				inbuf += sprintf(buf+inbuf, '<center>ANY</center>');
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, ',<br />\r\n');
			 }
			 inbuf += sprintf(buf+inbuf, '</td><td>');
			 if(!cp->ace || !cp->ace->dst){
				inbuf += sprintf(buf+inbuf, '<center>ANY</center>');
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, ',<br />\r\n');
			 }
			 inbuf += sprintf(buf+inbuf, '</td><td>');
			 if(!cp->ace || !cp->ace->ports){
				inbuf += sprintf(buf+inbuf, '<center>ANY</center>');
			 }
			 else {
				inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, ',<br />\r\n');
			 }
			 if(cp->type == NONE) {
			  inbuf += sprintf(buf+inbuf,	
					'</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n'
				 );
			 }
			 else {
			  inbuf += sprintf(buf+inbuf,	
					'</td><td>%'PRINTF_INT64_MODIFIER'u</td>'
					'<td>MB%s</td>'
					'<td>%'PRINTF_INT64_MODIFIER'u</td>'
					'<td>%s</td>',
				 cp->traflim64 / (1024 * 1024),
				 rotations[cp->type],
				 cp->traf64,
				 cp->cleared?ctime(&cp->cleared):'never'
				);
			 inbuf += sprintf(buf + inbuf,
					'<td>%s</td>'
					'<td>%i</td>'
					'</tr>\r\n',

				 cp->updated?ctime(&cp->updated):'never',
				 cp->number
				);
			 }
			 printstr(&pp, buf);
			}

		}
		printstr(&pp, counterstail);
		break;
		
	case 'R':
		conf.needreload = 1;
		printstr(&pp, '<h3>Reload scheduled</h3>');
		break;
	case 'S':
		{
			if(req[1] == 'X'){
				printstr(&pp, style);
				break;
			}
			printstr(&pp, xml);
			printval(conf.services, TYPE_SERVER, 0, &pp);
			printstr(&pp, postxml);
		}
			break;
	case 'F':
		{
			FILE *fp;
			char buf[256];

			fp = confopen();
			if(!fp){
				printstr(&pp, '<h3><font color=\'red\'>Failed to open config file</font></h3>');
				break;
			}
				printstr(&pp, '<h3>Please be careful editing config file remotely</h3>');
				printstr(&pp, '<form method=\'POST\' action=\'/U\'><textarea cols=\'80\' rows=\'30\' name=\'conffile\'>');
				while(fgets(buf, 256, fp)){
					printstr(&pp, buf);
				}
				if(!writable) fclose(fp);
				printstr(&pp, '</textarea><br><input type=\'Submit\'></form>');
			break;
		}
	case 'U':
		{
			int l=0;
			int error = 0;

			if(!writable || fseek(writable, 0, 0)){
				error = 1;
			}
			while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){
				if(i > (contentlen - l)) i = (contentlen - l);
				buf[i] = 0;
				if(!l){
					if(strncasecmp(buf, 'conffile=', 9)) error = 1;
				}
				if(!error){
					decodeurl((unsigned char *)buf, 1);
					fprintf(writable, '%s', l? buf : buf + 9);
				}
				l += i;
				if(l >= contentlen) break;
			}
			if(writable && !error){
				fflush(writable);
#ifndef _WINCE
				ftruncate(fileno(writable), ftell(writable));
#endif
			}
			printstr(&pp, error?    '<h3><font color=\'red\'>Config file is not writable</font></h3>Make sure you have \'writable\' command in configuration file':
						'<h3>Configuration updated</h3>');

		}
		break;
	default:
		printstr(&pp, (char *)conf.stringtable[WEBBANNERS]);
		break;
 }
 if(*req != 'S') printstr(&pp, tail);

CLEANRET:


 printstr(&pp, NULL);
 if(buf) myfree(buf);
 (*param->srv->logfunc)(param, (unsigned char *)req);
 if(req)myfree(req);
 freeparam(param);
 return (NULL);
}
",1,8416
z3APA3A/3proxy,3b67dc844789dc0f00e934270c7b349bcb547865,"static int printuserlist(char *buf, int bufsize, struct userlist* ul, char * delim){
	int printed = 0;

	for(; ul; ul = ul->next){
		if(printed > (bufsize - 64)) break;
		printed += sprintf(buf+printed, '%s%s', ul->user, ul->next?delim:'');
		if(printed > (bufsize - 64)) {
			printed += sprintf(buf+printed, '...');
			break;
		}
	}
	return printed;
}
",0,8417
WebAssembly/binaryen,1e49231e48674db03e1c9cb45aedcb78846d0745,"static void validateExports(Module& module, ValidationInfo& info) {
  for (auto& curr : module.exports) {
    if (curr->kind == ExternalKind::Function) {
      if (info.validateWeb) {
        Function* f = module.getFunction(curr->value);
        info.shouldBeUnequal(f->result,
                             i64,
                             f->name,
                             'Exported function must not have i64 return type');
        for (auto param : f->params) {
          info.shouldBeUnequal(
            param,
            i64,
            f->name,
            'Exported function must not have i64 parameters');
        }
      }
    } else if (curr->kind == ExternalKind::Global &&
               !module.features.hasMutableGlobals()) {
      if (Global* g = module.getGlobalOrNull(curr->value)) {
        info.shouldBeFalse(
          g->mutable_, g->name, 'Exported global cannot be mutable');
      }
    }
  }
  std::unordered_set<Name> exportNames;
  for (auto& exp : module.exports) {
    Name name = exp->value;
    if (exp->kind == ExternalKind::Function) {
      info.shouldBeTrue(module.getFunctionOrNull(name),
                        name,
                        'module function exports must be found');
    } else if (exp->kind == ExternalKind::Global) {
      info.shouldBeTrue(module.getGlobalOrNull(name),
                        name,
                        'module global exports must be found');
    } else if (exp->kind == ExternalKind::Table) {
      info.shouldBeTrue(name == Name('0') || name == module.table.name,
                        name,
                        'module table exports must be found');
    } else if (exp->kind == ExternalKind::Memory) {
      info.shouldBeTrue(name == Name('0') || name == module.memory.name,
                        name,
                        'module memory exports must be found');
    } else if (exp->kind == ExternalKind::Event) {
      info.shouldBeTrue(module.getEventOrNull(name),
                        name,
                        'module event exports must be found');
    } else {
      WASM_UNREACHABLE();
    }
    Name exportName = exp->name;
    info.shouldBeFalse(exportNames.count(exportName) > 0,
                       exportName,
                       'module exports must be unique');
    exportNames.insert(exportName);
  }
}
",1,8418
WebAssembly/binaryen,1e49231e48674db03e1c9cb45aedcb78846d0745,"                     T curr,
                     const char* text,
                     Function* func = nullptr) {
",0,8419
torvalds/linux,6a3eb3360667170988f8a6477f6686242061488a,"int
SMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,
	   unsigned int *nbytes, struct kvec *iov, int n_vec)
{
	struct smb_rqst rqst;
	int rc = 0;
	struct smb2_write_req *req = NULL;
	struct smb2_write_rsp *rsp = NULL;
	int resp_buftype;
	struct kvec rsp_iov;
	int flags = 0;
	unsigned int total_len;

	*nbytes = 0;

	if (n_vec < 1)
		return rc;

	rc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, (void **) &req,
			     &total_len);
	if (rc)
		return rc;

	if (io_parms->tcon->ses->server == NULL)
		return -ECONNABORTED;

	if (smb3_encryption_required(io_parms->tcon))
		flags |= CIFS_TRANSFORM_REQ;

	req->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);

	req->PersistentFileId = io_parms->persistent_fid;
	req->VolatileFileId = io_parms->volatile_fid;
	req->WriteChannelInfoOffset = 0;
	req->WriteChannelInfoLength = 0;
	req->Channel = 0;
	req->Length = cpu_to_le32(io_parms->length);
	req->Offset = cpu_to_le64(io_parms->offset);
	req->DataOffset = cpu_to_le16(
				offsetof(struct smb2_write_req, Buffer));
	req->RemainingBytes = 0;

	trace_smb3_write_enter(xid, io_parms->persistent_fid,
		io_parms->tcon->tid, io_parms->tcon->ses->Suid,
		io_parms->offset, io_parms->length);

	iov[0].iov_base = (char *)req;
	/* 1 for Buffer */
	iov[0].iov_len = total_len - 1;

	memset(&rqst, 0, sizeof(struct smb_rqst));
	rqst.rq_iov = iov;
	rqst.rq_nvec = n_vec + 1;

	rc = cifs_send_recv(xid, io_parms->tcon->ses, &rqst,
			    &resp_buftype, flags, &rsp_iov);
	cifs_small_buf_release(req);
	rsp = (struct smb2_write_rsp *)rsp_iov.iov_base;

	if (rc) {
		trace_smb3_write_err(xid, req->PersistentFileId,
				     io_parms->tcon->tid,
				     io_parms->tcon->ses->Suid,
				     io_parms->offset, io_parms->length, rc);
		cifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);
		cifs_dbg(VFS, 'Send error in write = %d\n', rc);
	} else {
		*nbytes = le32_to_cpu(rsp->DataLength);
		trace_smb3_write_done(xid, req->PersistentFileId,
				     io_parms->tcon->tid,
				     io_parms->tcon->ses->Suid,
				     io_parms->offset, *nbytes);
	}

	free_rsp_buf(resp_buftype, rsp);
	return rc;
}
",1,8420
torvalds/linux,6a3eb3360667170988f8a6477f6686242061488a,"static struct create_posix *
create_posix_buf(umode_t mode)
{
	struct create_posix *buf;

	buf = kzalloc(sizeof(struct create_posix),
			GFP_KERNEL);
	if (!buf)
		return NULL;

	buf->ccontext.DataOffset =
		cpu_to_le16(offsetof(struct create_posix, Mode));
	buf->ccontext.DataLength = cpu_to_le32(4);
	buf->ccontext.NameOffset =
		cpu_to_le16(offsetof(struct create_posix, Name));
	buf->ccontext.NameLength = cpu_to_le16(16);

	/* SMB2_CREATE_TAG_POSIX is '0x93AD25509CB411E7B42383DE968BCD7C' */
	buf->Name[0] = 0x93;
	buf->Name[1] = 0xAD;
	buf->Name[2] = 0x25;
	buf->Name[3] = 0x50;
	buf->Name[4] = 0x9C;
	buf->Name[5] = 0xB4;
	buf->Name[6] = 0x11;
	buf->Name[7] = 0xE7;
	buf->Name[8] = 0xB4;
	buf->Name[9] = 0x23;
	buf->Name[10] = 0x83;
	buf->Name[11] = 0xDE;
	buf->Name[12] = 0x96;
	buf->Name[13] = 0x8B;
	buf->Name[14] = 0xCD;
	buf->Name[15] = 0x7C;
	buf->Mode = cpu_to_le32(mode);
	cifs_dbg(FYI, 'mode on posix create 0%o', mode);
	return buf;
}
",0,8421
trusteddomainproject/OpenDMARC,f6b615e345037408b88b2ffd1acd03239af8a858,"static void
dmarcf_config_reload(void)
{
	struct dmarcf_config *new;
	char errbuf[BUFRSZ + 1];

	pthread_mutex_lock(&conf_lock);

	if (!reload)
	{
		pthread_mutex_unlock(&conf_lock);
		return;
	}

	if (conffile == NULL)
	{
		if (curconf->conf_dolog)
			syslog(LOG_ERR, 'ignoring reload signal');

		reload = FALSE;

		pthread_mutex_unlock(&conf_lock);
		return;
	}

	new = dmarcf_config_new();
	if (new == NULL)
	{
		if (curconf->conf_dolog)
			syslog(LOG_ERR, 'malloc(): %s', strerror(errno));
	}
	else
	{
		_Bool err = FALSE;
		u_int line;
		struct config *cfg;
		char *missing;
		char path[MAXPATHLEN + 1];

		memset(path, '\0', sizeof path);
		strncpy(path, conffile, sizeof path - 1);

		cfg = config_load(conffile, dmarcf_config, &line,
		                  path, sizeof path);

		if (cfg == NULL)
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_ERR,
				       '%s: configuration error at line %u: %s',
				        path, line, config_error());
			}
			dmarcf_config_free(new);
			err = TRUE;
		}

		if (!err)
		{
			missing = config_check(cfg, dmarcf_config);
			if (missing != NULL)
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR,
					        '%s: required parameter \'%s\' missing',
					        conffile, missing);
				}
				config_free(cfg);
				dmarcf_config_free(new);
				err = TRUE;
			}
		}

		if (!err && dmarcf_config_load(cfg, new, errbuf,
		                               sizeof errbuf) != 0)
		{
			if (curconf->conf_dolog)
				syslog(LOG_ERR, '%s: %s', conffile, errbuf);
			config_free(cfg);
			dmarcf_config_free(new);
			err = TRUE;
		}

		if (!err && new->conf_pslist != NULL)
		{
			if (opendmarc_tld_read_file(new->conf_pslist, '//',
			                            '*.', '!') != 0)
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR, '%s: read/parse error',
					       new->conf_pslist);
				}

				config_free(cfg);
				dmarcf_config_free(new);
				err = TRUE;
			}
		}
 
		if (!err)
		{
			if (curconf->conf_refcnt == 0)
				dmarcf_config_free(curconf);

			dolog = new->conf_dolog;
			curconf = new;
			new->conf_data = cfg;

			if (new->conf_dolog)
			{
				syslog(LOG_INFO,
				       'configuration reloaded from %s',
				       conffile);
			}
		}
	}

	reload = FALSE;

	pthread_mutex_unlock(&conf_lock);

	return;
}

/*
**  DMARCF_CLEANUP -- release local resources related to a message
**
**  Parameters:
**  	ctx -- milter context
**
**  Return value:
**  	None.
*/

static void
dmarcf_cleanup(SMFICTX *ctx)
{
	DMARCF_MSGCTX dfc;
	DMARCF_CONNCTX cc;

	assert(ctx != NULL);

	cc = (DMARCF_CONNCTX) dmarcf_getpriv(ctx);

	if (cc == NULL)
		return;

	dfc = cc->cctx_msg;

	/* release memory, reset state */
	if (dfc != NULL)
	{
		if (dfc->mctx_histbuf != NULL)
			dmarcf_dstring_free(dfc->mctx_histbuf);
		if (dfc->mctx_afrf != NULL)
			dmarcf_dstring_free(dfc->mctx_afrf);

		if (dfc->mctx_hqhead != NULL)
		{
			struct dmarcf_header *hdr;
			struct dmarcf_header *prev;

			hdr = dfc->mctx_hqhead;
			while (hdr != NULL)
			{
				TRYFREE(hdr->hdr_name);
				TRYFREE(hdr->hdr_value);
				prev = hdr;
				hdr = hdr->hdr_next;
				TRYFREE(prev);
			}
		}

		free(dfc);
		cc->cctx_msg = NULL;
	}
}

#if SMFI_VERSION >= 0x01000000
/*
**  MLFI_NEGOTIATE -- handler called on new SMTP connection to negotiate
**                    MTA options
**
**  Parameters:
**  	ctx -- milter context
**	f0  -- actions offered by the MTA
**	f1  -- protocol steps offered by the MTA
**	f2  -- reserved for future extensions
**	f3  -- reserved for future extensions
**	pf0 -- actions requested by the milter
**	pf1 -- protocol steps requested by the milter
**	pf2 -- reserved for future extensions
**	pf3 -- reserved for future extensions
**
**  Return value:
**  	An SMFIS_* constant.
*/

sfsistat
mlfi_negotiate(SMFICTX *ctx,
	unsigned long f0, unsigned long f1,
	unsigned long f2, unsigned long f3,
	unsigned long *pf0, unsigned long *pf1,
	unsigned long *pf2, unsigned long *pf3)
{
	unsigned long reqactions = SMFIF_ADDHDRS|SMFIF_QUARANTINE;
	unsigned long wantactions = 0;
	unsigned long protosteps = (
#if !WITH_SPF
				    SMFIP_NOHELO |
#endif /* !WITH_SPF */
	                            SMFIP_NOUNKNOWN |
	                            SMFIP_NOBODY |
	                            SMFIP_NODATA |
	                            SMFIP_SKIP );
	DMARCF_CONNCTX cc;
	struct dmarcf_config *conf;

	dmarcf_config_reload();

	/* initialize connection context */
	cc = malloc(sizeof(struct dmarcf_connctx));
	if (cc == NULL)
	{
		if (curconf->conf_dolog)
		{
			syslog(LOG_ERR, 'mlfi_negotiate(): malloc(): %s',
			       strerror(errno));
		}

		return SMFIS_TEMPFAIL;
	}

	memset(cc, '\0', sizeof(struct dmarcf_connctx));

	pthread_mutex_lock(&conf_lock);

	cc->cctx_config = curconf;
	curconf->conf_refcnt++;
	conf = curconf;

	pthread_mutex_unlock(&conf_lock);

	if (conf->conf_copyfailsto != NULL)
		reqactions |= SMFIF_ADDRCPT;

	/* verify the actions we need are available */
	if ((f0 & reqactions) != reqactions)
	{
		if (conf->conf_dolog)
		{
			syslog(LOG_ERR,
			       'mlfi_negotiate(): required milter action(s) not available (got 0x%lx, need 0x%lx)',
			       f0, reqactions);
		}

		pthread_mutex_lock(&conf_lock);
		conf->conf_refcnt--;
		pthread_mutex_unlock(&conf_lock);

		free(cc);

		return SMFIS_REJECT;
	}

	/* also try to get some nice features */
	wantactions = (wantactions & f0);

	/* set the actions we want */
	*pf0 = (reqactions | wantactions);

	/* disable as many protocol steps we don't need as are available */
	*pf1 = (protosteps & f1);
	*pf2 = 0;
	*pf3 = 0;

	/* set 'milterv2' flag if SMFIP_SKIP was available */
	if ((f1 & SMFIP_SKIP) != 0)
		cc->cctx_milterv2 = TRUE;

	(void) dmarcf_setpriv(ctx, cc);

	return SMFIS_CONTINUE;
}
#endif /* SMFI_VERSION >= 0x01000000 */

/*
**  MLFI_CONNECT -- connection handler
**
**  Parameters:
**  	ctx -- milter context
**  	host -- hostname
**  	ip -- address, in in_addr form
**
**  Return value:
**  	An SMFIS_* constant.
*/

sfsistat
mlfi_connect(SMFICTX *ctx, char *host, _SOCK_ADDR *ip)
{
	DMARCF_CONNCTX cc;
	struct dmarcf_config *conf;

	dmarcf_config_reload();

	if (dmarcf_checkhost(host, ignore) ||
	    (ip != NULL && dmarcf_checkip(ip, ignore)))
	{
		if (curconf->conf_dolog)
			syslog(LOG_INFO, 'ignoring connection from %s', host);
		return SMFIS_ACCEPT;
	}

	/* copy hostname and IP information to a connection context */
	cc = dmarcf_getpriv(ctx);
	if (cc == NULL)
	{
		cc = malloc(sizeof(struct dmarcf_connctx));
		if (cc == NULL)
		{
			pthread_mutex_lock(&conf_lock);

			if (curconf->conf_dolog)
			{
				syslog(LOG_ERR, '%s malloc(): %s', host,
				       strerror(errno));
			}

			pthread_mutex_unlock(&conf_lock);

			return SMFIS_TEMPFAIL;
		}

		memset(cc, '\0', sizeof(struct dmarcf_connctx));

		pthread_mutex_lock(&conf_lock);

		cc->cctx_config = curconf;
		curconf->conf_refcnt++;

		conf = curconf;

		pthread_mutex_unlock(&conf_lock);

		dmarcf_setpriv(ctx, cc);
	}
	else
	{
		conf = cc->cctx_config;
	}

	if (host != NULL)
		strncpy(cc->cctx_host, host, sizeof cc->cctx_host - 1);

	if (ip == NULL)
	{
		struct sockaddr_in sa;

		memset(&sa, '\0', sizeof sa);
		sa.sin_family = AF_INET;
		sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

		memcpy(&cc->cctx_ip, &sa, sizeof sa);
		(void) inet_ntop(AF_INET, &sa.sin_addr, cc->cctx_ipstr,
		                 sizeof cc->cctx_ipstr);
		cc->cctx_dmarc = opendmarc_policy_connect_init(cc->cctx_ipstr,
		                                               FALSE);
	}
	else if (ip->sa_family == AF_INET)
	{
		struct sockaddr_in sa;

		memcpy(&sa, ip, sizeof(struct sockaddr_in));
		(void) inet_ntop(AF_INET, &sa.sin_addr, cc->cctx_ipstr,
		                 sizeof cc->cctx_ipstr);
		cc->cctx_dmarc = opendmarc_policy_connect_init(cc->cctx_ipstr,
		                                               FALSE);

		memcpy(&cc->cctx_ip, ip, sizeof(struct sockaddr_in));
	}
#ifdef AF_INET6
	else if (ip->sa_family == AF_INET6)
	{
		struct sockaddr_in6 sa;

		memcpy(&sa, ip, sizeof(struct sockaddr_in6));
		(void) inet_ntop(AF_INET6, &sa.sin6_addr, cc->cctx_ipstr,
		                 sizeof cc->cctx_ipstr);
		cc->cctx_dmarc = opendmarc_policy_connect_init(cc->cctx_ipstr,
		                                               TRUE);

		memcpy(&cc->cctx_ip, ip, sizeof(struct sockaddr_in6));
	}
#endif /* AF_INET6 */

	if (cc->cctx_dmarc == NULL)
	{
		if (curconf->conf_dolog)
		{
			syslog(LOG_ERR,
			       '%s: DMARC context initialization failed',
			       host);
		}
	}

	cc->cctx_msg = NULL;

	return SMFIS_CONTINUE;
}

#if WITH_SPF
/*
**  MLFI_HELO -- handler for HELO/EHLO command; only used for spf checks if configured.
**
**  Parameters:
**  	ctx -- milter context
**  	helo_domain -- possible helo domain
**
**  Return value:
**  	An SMFIS_* constant.
*/

sfsistat
mlfi_helo(SMFICTX *ctx, char *helo_domain)
{
	DMARCF_CONNCTX cc;
	struct dmarcf_config *conf;

	assert(ctx != NULL);

	cc = (DMARCF_CONNCTX) dmarcf_getpriv(ctx);
	if (cc != NULL)
	{
		conf = cc->cctx_config;
		if (!conf->conf_spfselfvalidate)
			return SMFIS_CONTINUE;

		if (helo_domain != NULL)
		{
			strncpy(cc->cctx_helo, helo_domain,
			        sizeof cc->cctx_helo - 1);
		}
	}
	return SMFIS_CONTINUE;
}
#endif /* WITH_SPF */

/*
**  MLFI_ENVFROM -- handler for MAIL FROM command; used to reset for a message
**
**  Parameters:
**  	ctx -- milter context
**  	envfrom -- array of arguments
**
**  Return value:
**  	An SMFIS_* constant.
*/

sfsistat
mlfi_envfrom(SMFICTX *ctx, char **envfrom)
{
	DMARCF_MSGCTX dfc;
	DMARCF_CONNCTX cc;
	struct dmarcf_config *conf;

	assert(ctx != NULL);

	cc = (DMARCF_CONNCTX) dmarcf_getpriv(ctx);
	assert(cc != NULL);
	conf = cc->cctx_config;

	if (cc->cctx_msg != NULL)
		dmarcf_cleanup(ctx);

	if (conf->conf_ignoreauthclients &&
	    dmarcf_getsymval(ctx, '{auth_authen}') != NULL)
		return SMFIS_ACCEPT;

	dfc = (DMARCF_MSGCTX) malloc(sizeof(struct dmarcf_msgctx));
	if (dfc == NULL)
	{
		if (conf->conf_dolog)
			syslog(LOG_ERR, 'malloc(): %s', strerror(errno));

		return SMFIS_TEMPFAIL;
	}

	memset(dfc, '\0', sizeof(struct dmarcf_msgctx));

	cc->cctx_msg = dfc;

	dfc->mctx_jobid = JOBIDUNKNOWN;
	dfc->mctx_spfresult = -1;

	dfc->mctx_histbuf = dmarcf_dstring_new(BUFRSZ, 0);
	if (dfc->mctx_histbuf == NULL)
	{
		if (conf->conf_dolog)
			syslog(LOG_ERR, 'malloc(): %s', strerror(errno));

		return SMFIS_TEMPFAIL;
	}

	if (cc->cctx_dmarc != NULL)
		(void) opendmarc_policy_connect_rset(cc->cctx_dmarc);

	if (envfrom[0] != NULL)
	{
		size_t len;
		unsigned char *p;
		unsigned char *q;

#if WITH_SPF
		strncpy(cc->cctx_rawmfrom, envfrom[0],
			sizeof cc->cctx_rawmfrom - 1);
#endif
		strncpy(dfc->mctx_envfrom, envfrom[0],
		        sizeof dfc->mctx_envfrom - 1);

		len = strlen(dfc->mctx_envfrom);
		p = dfc->mctx_envfrom;
		q = dfc->mctx_envfrom + len - 1;

		while (len >= 2 && *p == '<' && *q == '>')
		{
			p++;
			q--;
			len -= 2;
		}

		if (p != dfc->mctx_envfrom)
		{
			*(q + 1) = '\0';
			memmove(dfc->mctx_envfrom, p, len + 1);
		}

		p = strchr(dfc->mctx_envfrom, '@');
		if (p != NULL)
			strncpy(dfc->mctx_envdomain, p + 1, strlen(p + 1));
	}

	return SMFIS_CONTINUE;
}

/*
**  MLFI_HEADER -- handler for mail headers; stores the header in a vector
**                 of headers for later perusal, removing RFC822 comment
**                 substrings
**
**  Parameters:
**  	ctx -- milter context
**  	headerf -- header
**  	headerv -- value
**
**  Return value:
**  	An SMFIS_* constant.
*/

sfsistat
mlfi_header(SMFICTX *ctx, char *headerf, char *headerv)
{
	DMARCF_MSGCTX dfc;
	DMARCF_CONNCTX cc;
	struct dmarcf_header *newhdr;
	struct dmarcf_config *conf;

	assert(ctx != NULL);
	assert(headerf != NULL);
	assert(headerv != NULL);

	cc = (DMARCF_CONNCTX) dmarcf_getpriv(ctx);
	assert(cc != NULL);
	dfc = cc->cctx_msg;
	assert(dfc != NULL);
	conf = cc->cctx_config;

	newhdr = (struct dmarcf_header *) malloc(sizeof(struct dmarcf_header));
	if (newhdr == NULL)
	{
		if (conf->conf_dolog)
			syslog(LOG_ERR, 'malloc(): %s', strerror(errno));

		dmarcf_cleanup(ctx);
		return SMFIS_TEMPFAIL;
	}

	(void) memset(newhdr, '\0', sizeof(struct dmarcf_header));

	newhdr->hdr_name = strdup(headerf);
	newhdr->hdr_value = strdup(headerv);
	newhdr->hdr_next = NULL;
	newhdr->hdr_prev = dfc->mctx_hqtail;

	if (newhdr->hdr_name == NULL || newhdr->hdr_value == NULL)
	{
		if (conf->conf_dolog)
			syslog(LOG_ERR, 'malloc(): %s', strerror(errno));

		TRYFREE(newhdr->hdr_name);
		TRYFREE(newhdr->hdr_value);
		TRYFREE(newhdr);
		dmarcf_cleanup(ctx);
		return SMFIS_TEMPFAIL;
	}

	if (dfc->mctx_hqhead == NULL)
		dfc->mctx_hqhead = newhdr;

	if (dfc->mctx_hqtail != NULL)
		dfc->mctx_hqtail->hdr_next = newhdr;

	dfc->mctx_hqtail = newhdr;

	return SMFIS_CONTINUE;
}

/*
**  MLFI_EOM -- handler called at the end of the message; we can now decide
**              based on the configuration if and how to add the text
**              to this message, then release resources
**
**  Parameters:
**  	ctx -- milter context
**
**  Return value:
**  	An SMFIS_* constant.
*/

sfsistat
mlfi_eom(SMFICTX *ctx)
{
	_Bool wspf = FALSE;
	int c;
	int pc;
	int policy;
	int status;
	int adkim;
	int aspf;
	int pct;
	int p;
	int sp;
	int align_dkim;
	int align_spf;
	int result;
	sfsistat ret = SMFIS_CONTINUE;
	OPENDMARC_STATUS_T ostatus;
	OPENDMARC_STATUS_T apused;
	char *apolicy = NULL;
	char *aresult = NULL;
	char *adisposition = NULL;
	char *hostname = NULL;
	char *authservid = NULL;
	char *spfaddr;
	DMARCF_CONNCTX cc;
	DMARCF_MSGCTX dfc;
	struct dmarcf_config *conf;
	struct dmarcf_header *hdr;
	struct dmarcf_header *from;
	u_char *reqhdrs_error = NULL;
	u_char *user;
	u_char *domain;
	u_char *bang;
	u_char **ruv;
	unsigned char header[MAXHEADER + 1];
	unsigned char addrbuf[BUFRSZ + 1];
	unsigned char replybuf[BUFRSZ + 1];
	unsigned char pdomain[MAXHOSTNAMELEN + 1];
	struct authres ar;

	assert(ctx != NULL);

	cc = (DMARCF_CONNCTX) dmarcf_getpriv(ctx);
	assert(cc != NULL);
	dfc = cc->cctx_msg;
	assert(dfc != NULL);
	conf = cc->cctx_config;

	/*
	**  If necessary, try again to get the job ID in case it came down
	**  later than expected (e.g. postfix).
	*/

	if (strcmp((char *) dfc->mctx_jobid, JOBIDUNKNOWN) == 0)
	{
		dfc->mctx_jobid = (u_char *) dmarcf_getsymval(ctx, 'i');
		if (dfc->mctx_jobid == NULL)
		{
			if (no_i_whine && conf->conf_dolog)
			{
				syslog(LOG_WARNING,
				       'WARNING: symbol 'i' not available');
				no_i_whine = FALSE;
			}
			dfc->mctx_jobid = (u_char *) JOBIDUNKNOWN;
		}
	}

	/* get hostname; used in software header and new MIME boundaries */
	hostname = dmarcf_getsymval(ctx, 'j');
	if (hostname == NULL)
		hostname = myhostname;

	/* select authserv-id to use when generating result headers */
	authservid = conf->conf_authservid;
	if (authservid == NULL)
	{
		authservid = hostname;

		if (conf->conf_dolog)
		{
			syslog(LOG_INFO, 'implicit authentication service: %s',
			       authservid);
		}
	}

	/* ensure there was a From field */
	from = dmarcf_findheader(dfc, 'From', 0);

	/* verify RFC5322-required headers (RFC5322 3.6) */
	if (from == NULL ||
	    dmarcf_findheader(dfc, 'From', 1) != NULL)
		reqhdrs_error = 'not exactly one From field';

	if (dmarcf_findheader(dfc, 'Date', 0) == NULL ||
	    dmarcf_findheader(dfc, 'Date', 1) != NULL)
		reqhdrs_error = 'not exactly one Date field';

	if (dmarcf_findheader(dfc, 'Reply-To', 1) != NULL)
		reqhdrs_error = 'multiple Reply-To fields';

	if (dmarcf_findheader(dfc, 'To', 1) != NULL)
		reqhdrs_error = 'multiple To fields';

	if (dmarcf_findheader(dfc, 'Cc', 1) != NULL)
		reqhdrs_error = 'multiple Cc fields';

	if (dmarcf_findheader(dfc, 'Bcc', 1) != NULL)
		reqhdrs_error = 'multiple Bcc fields';

	if (dmarcf_findheader(dfc, 'Message-Id', 1) != NULL)
		reqhdrs_error = 'multiple Message-Id fields';

	if (dmarcf_findheader(dfc, 'In-Reply-To', 1) != NULL)
		reqhdrs_error = 'multiple In-Reply-To fields';

	if (dmarcf_findheader(dfc, 'References', 1) != NULL)
		reqhdrs_error = 'multiple References fields';

	if (dmarcf_findheader(dfc, 'Subject', 1) != NULL)
		reqhdrs_error = 'multiple Subject fields';

	if (conf->conf_reqhdrs && reqhdrs_error != NULL)
	{
		if (conf->conf_dolog)
		{
			syslog(LOG_INFO,
			       '%s: RFC5322 requirement error: %s',
			       dfc->mctx_jobid, reqhdrs_error);
		}

		return SMFIS_REJECT;
	}

	/* if there was no From:, there's nothing to process past here */
	if (from == NULL)
	{
		if (conf->conf_dolog)
		{
			syslog(LOG_INFO,
			       '%s: RFC5322 requirement error: missing From field; accepting',
			       dfc->mctx_jobid);
		}

		return SMFIS_ACCEPT;
	}

	/* extract From: domain */
	memset(addrbuf, '\0', sizeof addrbuf);
	strncpy(addrbuf, from->hdr_value, sizeof addrbuf - 1);
	status = dmarcf_mail_parse(addrbuf, &user, &domain);
	if (status != 0 || user == NULL || domain == NULL)
	{
		if (conf->conf_dolog)
		{
			syslog(LOG_ERR,
			       '%s: unable to parse From header field',
			       dfc->mctx_jobid);
		}

		if (conf->conf_reqhdrs)
			return SMFIS_REJECT;
		else
			return SMFIS_ACCEPT;
	}

	if (conf->conf_ignoredomains != NULL &&
	    dmarcf_match(domain, conf->conf_ignoredomains, TRUE))
	{
		if (conf->conf_dolog)
		{
			syslog(LOG_INFO, '%s: ignoring mail from %s',
			       dfc->mctx_jobid, domain);
		}

		return SMFIS_ACCEPT;
	}

	strncpy(dfc->mctx_fromdomain, domain, sizeof dfc->mctx_fromdomain - 1);

	ostatus = opendmarc_policy_store_from_domain(cc->cctx_dmarc,
	                                             from->hdr_value);
	if (ostatus != DMARC_PARSE_OKAY)
	{
		if (conf->conf_dolog)
		{
			syslog(LOG_ERR,
			       '%s: opendmarc_policy_store_from_domain() returned status %d',
			       dfc->mctx_jobid, ostatus);
		}

		return SMFIS_TEMPFAIL;
	}

	/* first part of the history buffer */
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'job %s\n', dfc->mctx_jobid);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'reporter %s\n', hostname);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'received %ld\n', time(NULL));
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'ipaddr %s\n', cc->cctx_ipstr);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'from %s\n',
	                      dfc->mctx_fromdomain);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'mfrom %s\n',
	                      dfc->mctx_envdomain);

	/*
	**  Walk through Authentication-Results fields and pull out data.
	*/

	for (hdr = dfc->mctx_hqhead, c = 0;
	     hdr != NULL;
	     hdr = hdr->hdr_next, c++)
	{
		/* skip it if it's not Authentication-Results */
		if (strcasecmp(hdr->hdr_name, AUTHRESHDRNAME) != 0)
			continue;

		/* parse it */
		memset(&ar, '\0', sizeof ar);
		if (ares_parse(hdr->hdr_value, &ar) != 0)
			continue;

		/* skip it if it's not one of ours */
		if (strcasecmp(ar.ares_host, authservid) != 0 &&
		    (conf->conf_trustedauthservids == NULL ||
		     !dmarcf_match(ar.ares_host, conf->conf_trustedauthservids,
		                   FALSE)))
		{
			unsigned char *slash;

			if (!conf->conf_authservidwithjobid)
			{
				if (conf->conf_dolog)
				{
					syslog(LOG_DEBUG,
					       '%s ignoring Authentication-Results at %d from %s',
					       dfc->mctx_jobid, c,
					       ar.ares_host);
				}

				continue;
			}

			slash = (unsigned char *) strchr(ar.ares_host, '/');
			if (slash == NULL)
			{
				if (conf->conf_dolog)
				{
					syslog(LOG_DEBUG,
					       '%s ignoring Authentication-Results at %d from %s',
					       dfc->mctx_jobid, c,
					       ar.ares_host);
				}

				continue;
			}

			*slash = '\0';
			if ((strcasecmp(ar.ares_host, authservid) != 0 &&
			     (conf->conf_trustedauthservids == NULL ||
			      !dmarcf_match(ar.ares_host,
			                    conf->conf_trustedauthservids,
			                    FALSE))) ||
			    strcmp(slash + 1, dfc->mctx_jobid) != 0)
			{
				*slash = '/';

				if (conf->conf_dolog)
				{
					syslog(LOG_DEBUG,
					       '%s ignoring Authentication-Results at %d from %s',
					       dfc->mctx_jobid, c,
					       ar.ares_host);
				}

				continue;
			}

			*slash = '/';
		}

		/* walk through what was found */
		for (c = 0; c < ar.ares_count; c++)
		{
			if (ar.ares_result[c].result_method == ARES_METHOD_SPF
#if WITH_SPF
			    && !conf->conf_spfignoreresults
#endif
			)
			{
				int spfmode;

				dfc->mctx_spfresult = ar.ares_result[c].result_result;

				if (ar.ares_result[c].result_result != ARES_RESULT_PASS)
					continue;

				spfaddr = NULL;
				spfmode = DMARC_POLICY_SPF_ORIGIN_HELO;

				memset(addrbuf, '\0', sizeof addrbuf);

				for (pc = 0;
				     pc < ar.ares_result[c].result_props;
				     pc++)
				{
					if (ar.ares_result[c].result_ptype[pc] == ARES_PTYPE_SMTP)
					{
						if (strcasecmp(ar.ares_result[c].result_property[pc],
					                       'mailfrom') == 0)
						{
							spfaddr = ar.ares_result[c].result_value[pc];
							if (strchr(spfaddr, '@') != NULL)
							{
								strncpy(addrbuf,
								        spfaddr,
								        sizeof addrbuf - 1);
							}
							else
							{
								snprintf(addrbuf,
								         sizeof addrbuf,
								         'UNKNOWN@%s',
								         spfaddr);
							}

							spfmode = DMARC_POLICY_SPF_ORIGIN_MAILFROM;
						}
						else if (strcasecmp(ar.ares_result[c].result_property[pc],
					                           'helo') == 0 &&
						         addrbuf[0] == '\0')
						{
							spfaddr = ar.ares_result[c].result_value[pc];
							snprintf(addrbuf,
							         sizeof addrbuf,
							         'UNKNOWN@%s',
							         spfaddr);
							spfmode = DMARC_POLICY_SPF_ORIGIN_HELO;
						}
					}
				}

				if (spfaddr == NULL)
				{
					if (conf->conf_dolog)
					{
						syslog(LOG_ERR,
						       '%s: can't extract SPF address from Authentication-Results',
						       dfc->mctx_jobid);
					}

					continue;
				}

				status = dmarcf_mail_parse(addrbuf, &user,
				                           &domain);
				if (status != 0 || domain == NULL ||
				    domain[0] == '\0')
				{
					if (conf->conf_dolog)
					{
						syslog(LOG_ERR,
						       '%s: unable to parse validated SPF address <%s>',
						       dfc->mctx_jobid,
						       spfaddr);
					}

					continue;
				}

				ostatus = opendmarc_policy_store_spf(cc->cctx_dmarc,
				                                     domain,
				                                     DMARC_POLICY_SPF_OUTCOME_PASS,
				                                     spfmode,
				                                     NULL);
				                                     
				if (ostatus != DMARC_PARSE_OKAY)
				{
					if (conf->conf_dolog)
					{
						syslog(LOG_ERR,
						       '%s: opendmarc_policy_store_spf() returned status %d',
						       dfc->mctx_jobid, ostatus);
					}

					return SMFIS_TEMPFAIL;
				}

				dmarcf_dstring_printf(dfc->mctx_histbuf,
				                      'spf %d\n',
				                      dfc->mctx_spfresult);
				wspf = TRUE;
			}
			else if (ar.ares_result[c].result_method == ARES_METHOD_DKIM)
			{
				domain = NULL;

				for (pc = 0;
				     pc < ar.ares_result[c].result_props;
				     pc++)
				{
					if (ar.ares_result[c].result_ptype[pc] == ARES_PTYPE_HEADER)
					{
						if (ar.ares_result[c].result_property[pc][0] == 'd')
						{
							domain = ar.ares_result[c].result_value[pc];
						}
					}
				}

				if (domain == NULL)
					continue;

				dmarcf_dstring_printf(dfc->mctx_histbuf,
				                      'dkim %s %d\n', domain,
				                      ar.ares_result[c].result_result);

				if (ar.ares_result[c].result_result != ARES_RESULT_PASS)
					continue;

		                                     
				ostatus = opendmarc_policy_store_dkim(cc->cctx_dmarc,
				                                      domain,
				                                      DMARC_POLICY_DKIM_OUTCOME_PASS,
				                                      NULL);

				if (ostatus != DMARC_PARSE_OKAY)
				{
					if (conf->conf_dolog)
					{
						syslog(LOG_ERR,
						       '%s: opendmarc_policy_store_from_dkim() returned status %d',
						       dfc->mctx_jobid, ostatus);
					}

					return SMFIS_TEMPFAIL;
				}
			}
		}
	}

	/* 
	**  If we didn't get Authentication-Results for SPF, parse any
	**  Received-SPF we might have.
	*/

	if (!wspf
#if WITH_SPF
	    && !conf->conf_spfignoreresults
#endif
	)
	{
		for (hdr = dfc->mctx_hqhead;
		     hdr != NULL && !wspf;
		     hdr = hdr->hdr_next)
		{
			if (strcasecmp(hdr->hdr_name, RECEIVEDSPF) == 0)
			{
				int spfres;
				int spfmode;

				if (dfc->mctx_fromdomain[0] == '\0')
					spfmode = DMARC_POLICY_SPF_ORIGIN_HELO;
				else
					spfmode = DMARC_POLICY_SPF_ORIGIN_MAILFROM;

				spfres = dmarcf_parse_received_spf(hdr->hdr_value);

				dmarcf_dstring_printf(dfc->mctx_histbuf,
				                      'spf %d\n', spfres);

				dfc->mctx_spfresult = spfres;

				switch (dfc->mctx_spfresult)
				{
				    case ARES_RESULT_PASS:
					spfres = DMARC_POLICY_SPF_OUTCOME_PASS;
					break;

				    case ARES_RESULT_NONE:
					spfres = DMARC_POLICY_SPF_OUTCOME_NONE;
					break;

				    case ARES_RESULT_TEMPERROR:
					spfres = DMARC_POLICY_SPF_OUTCOME_TMPFAIL;
					break;

				    case ARES_RESULT_FAIL:
				    case ARES_RESULT_NEUTRAL:
				    case ARES_RESULT_SOFTFAIL:
					spfres = DMARC_POLICY_SPF_OUTCOME_FAIL;
					break;

				    default: /* e.g. ARES_RESULT_PERMERROR */
					spfres = DMARC_POLICY_SPF_OUTCOME_NONE;
					break;
				}

				/* use the MAIL FROM domain */
				ostatus = opendmarc_policy_store_spf(cc->cctx_dmarc,
				                                     dfc->mctx_envdomain,
				                                     spfres,
				                                     spfmode,
				                                     NULL);
				wspf = TRUE;
			}
		}
	}

	/*
	**  Interact with libopendmarc.
	*/

	if (!wspf)
	{
#if WITH_SPF
		if (conf->conf_spfselfvalidate)
		{
			int spf_result;
			char human[512];
			int used_mfrom;
			char *use_domain;
			int spf_mode;
			char *pass_fail;

# if HAVE_SPF2_H
			spf_result = opendmarc_spf2_test(
# else /* HAVE_SPF2_H */
			spf_result = opendmarc_spf_test(
# endif /* HAVE_SPF2_H */
				cc->cctx_ipstr,
				cc->cctx_rawmfrom,
				cc->cctx_helo,
				NULL,
				FALSE,
				human,
				sizeof human,
				&used_mfrom);
			if (used_mfrom == TRUE)
			{
				use_domain = dfc->mctx_envfrom;
				spf_mode   = DMARC_POLICY_SPF_ORIGIN_MAILFROM;
			}
			else
			{
				use_domain = cc->cctx_helo;
				spf_mode   = DMARC_POLICY_SPF_ORIGIN_HELO;
			}
			ostatus = opendmarc_policy_store_spf(cc->cctx_dmarc, 
				                                     use_domain,
				                                     spf_result,
				                                     spf_mode,
				                                     human);
			switch (spf_result)
			{
			    case DMARC_POLICY_SPF_OUTCOME_PASS:
				pass_fail = 'pass';
				dfc->mctx_spfresult = ARES_RESULT_PASS;
				break;

			    case DMARC_POLICY_SPF_OUTCOME_NONE:
				pass_fail = 'none';
				dfc->mctx_spfresult = ARES_RESULT_NONE;
				break;

			    case DMARC_POLICY_SPF_OUTCOME_TMPFAIL:
				pass_fail = 'tempfail';
				dfc->mctx_spfresult = ARES_RESULT_TEMPERROR;
				break;

			    case DMARC_POLICY_SPF_OUTCOME_FAIL:
				dfc->mctx_spfresult = ARES_RESULT_FAIL;
				pass_fail = 'fail';
				break;

			    default:
				dfc->mctx_spfresult = ARES_RESULT_PERMERROR;
				pass_fail = 'permerror';
				break;
			}

			if (spf_mode == DMARC_POLICY_SPF_ORIGIN_HELO)
			{
				snprintf(header, sizeof header,
					 '%s; spf=%s smtp.helo=%s',
					 authservid, pass_fail, use_domain);
			}
			else
			{
				snprintf(header, sizeof header,
					 '%s; spf=%s smtp.mailfrom=%s',
					 authservid, pass_fail, use_domain);
			}

			if (dmarcf_insheader(ctx, 1, AUTHRESULTSHDR,
					     header) == MI_FAILURE)
			{
				if (conf->conf_dolog)
				{
					syslog(LOG_ERR,
					       '%s: %s header add failed',
					       dfc->mctx_jobid,
					       AUTHRESULTSHDR);
				}
			}

			if (conf->conf_dolog)
			{
				char *mode;

				if (spf_mode == DMARC_POLICY_SPF_ORIGIN_HELO)
					mode = 'helo';
				else
					mode = 'mailfrom';

				syslog(LOG_INFO,
				       '%s: SPF(%s): %s %s',
				       dfc->mctx_jobid,
				       mode,
				       use_domain,
				       pass_fail);
			}
		}
#endif /* WITH_SPF */

		dmarcf_dstring_printf(dfc->mctx_histbuf, 'spf %d\n',
		                      dfc->mctx_spfresult);
	}

	ostatus = opendmarc_policy_query_dmarc(cc->cctx_dmarc,
	                                       dfc->mctx_fromdomain);
	if (ostatus == DMARC_PARSE_ERROR_NULL_CTX ||
	    ostatus == DMARC_PARSE_ERROR_EMPTY)
	{
		if (conf->conf_dolog)
		{
			syslog(LOG_ERR,
			       '%s: opendmarc_policy_query_dmarc(%s) returned status %d',
			       dfc->mctx_jobid, dfc->mctx_fromdomain, ostatus);
		}

		return SMFIS_TEMPFAIL;
	}
	else if (ostatus == DMARC_PARSE_ERROR_BAD_VERSION ||
	         ostatus == DMARC_PARSE_ERROR_BAD_VALUE ||
	         ostatus == DMARC_PARSE_ERROR_NO_REQUIRED_P ||
	         ostatus == DMARC_PARSE_ERROR_NO_DOMAIN)
	{
		if (conf->conf_dolog)
		{
			syslog(LOG_ERR,
			       '%s: opendmarc_policy_query_dmarc(%s) returned status %d',
			       dfc->mctx_jobid, dfc->mctx_fromdomain, ostatus);
		}

		snprintf(header, sizeof header,
		         '%s; dmarc=permerror header.from=%s',
		         authservid, dfc->mctx_fromdomain);

		if (dmarcf_insheader(ctx, 1, AUTHRESULTSHDR,
		                     header) == MI_FAILURE)
		{
			if (conf->conf_dolog)
			{
				syslog(LOG_ERR,
				       '%s: %s header add failed',
				       dfc->mctx_jobid,
				       AUTHRESULTSHDR);
			}
		}

		return SMFIS_ACCEPT;
	}

	memset(pdomain, '\0', sizeof pdomain);
	opendmarc_policy_fetch_utilized_domain(cc->cctx_dmarc,
	                                       pdomain, sizeof pdomain);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'pdomain %s\n', pdomain);

	policy = opendmarc_get_policy_to_enforce(cc->cctx_dmarc);
	if (ostatus == DMARC_DNS_ERROR_NO_RECORD)
		policy = DMARC_POLICY_ABSENT;
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'policy %d\n', policy);

	ruv = opendmarc_policy_fetch_rua(cc->cctx_dmarc, NULL, 0, TRUE);
	if (ruv != NULL)
	{
		for (c = 0; ruv[c] != NULL; c++)
		{
			dmarcf_dstring_printf(dfc->mctx_histbuf, 'rua %s\n',
			                      ruv[c]);
		}
	}
	else
	{
		dmarcf_dstring_printf(dfc->mctx_histbuf, 'rua -\n');
	}

	opendmarc_policy_fetch_pct(cc->cctx_dmarc, &pct);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'pct %d\n', pct);

	opendmarc_policy_fetch_adkim(cc->cctx_dmarc, &adkim);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'adkim %d\n', adkim);

	opendmarc_policy_fetch_aspf(cc->cctx_dmarc, &aspf);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'aspf %d\n', aspf);

	opendmarc_policy_fetch_p(cc->cctx_dmarc, &p);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'p %d\n', p);

	opendmarc_policy_fetch_sp(cc->cctx_dmarc, &sp);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'sp %d\n', sp);

	opendmarc_policy_fetch_alignment(cc->cctx_dmarc, &align_dkim,
	                                 &align_spf);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'align_dkim %d\n',
	                      align_dkim);
	dmarcf_dstring_printf(dfc->mctx_histbuf, 'align_spf %d\n', align_spf);

	/* prepare human readable policy string for later processing */
	apused = opendmarc_get_policy_token_used(cc->cctx_dmarc);
	switch (apused == DMARC_USED_POLICY_IS_SP ? sp : p)
	{
	  case DMARC_RECORD_P_QUARANTINE:
		apolicy = 'quarantine';
		break;

	  case DMARC_RECORD_P_REJECT:
		apolicy = 'reject';
		break;

	  case DMARC_RECORD_P_UNSPECIFIED:
	  case DMARC_RECORD_P_NONE:
	  default:
		apolicy = 'none';
		break;
	}

	/*
	**  Generate a failure report.
	*/

	ruv = opendmarc_policy_fetch_ruf(cc->cctx_dmarc, NULL, 0, TRUE);
	if ((policy == DMARC_POLICY_REJECT ||
	     policy == DMARC_POLICY_QUARANTINE ||
	     (conf->conf_afrfnone && policy == DMARC_POLICY_NONE)) &&
	    conf->conf_afrf &&
	    (conf->conf_afrfbcc != NULL || ruv != NULL))
	{
		_Bool first = TRUE;

		if (dfc->mctx_afrf == NULL)
		{
			dfc->mctx_afrf = dmarcf_dstring_new(BUFRSZ, 0);

			if (dfc->mctx_afrf == NULL)
			{
				if (conf->conf_dolog)
				{
					syslog(LOG_ERR,
					       '%s: unable to create buffer for failure report',
					       dfc->mctx_jobid);
				}

				return SMFIS_TEMPFAIL;
			}
		}
		else
		{
			dmarcf_dstring_blank(dfc->mctx_afrf);
		}

		if (conf->conf_afrfas != NULL)
		{
			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'From: %s\n',
			                      conf->conf_afrfas);
		}
		else
		{
			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'From: %s <%s@%s>\n',
			                      DMARCF_PRODUCT,
			                      myname, hostname);
		}

		for (c = 0; ruv != NULL && ruv[c] != NULL; c++)
		{
			if (strncasecmp(ruv[c], 'mailto:', 7) != 0)
				continue;

			bang = strchr(ruv[c], '!');
			if (bang != NULL)
				*bang = '\0';

			if (ruv[c][7] == '\0')
				continue;

			if (first)
			{
				dmarcf_dstring_cat(dfc->mctx_afrf, 'To: ');
				first = FALSE;
			}
			else
			{
				dmarcf_dstring_cat(dfc->mctx_afrf, ', ');
			}

			dmarcf_dstring_cat(dfc->mctx_afrf, &ruv[c][7]);
		}

		if (conf->conf_afrfbcc != NULL)
		{
			if (first)
			{
				dmarcf_dstring_cat(dfc->mctx_afrf, 'To: ');
				dmarcf_dstring_cat(dfc->mctx_afrf,
				                   conf->conf_afrfbcc);
				first = FALSE;
			}
		}

		if (!first)
		{
			time_t now;
			struct dmarcf_header *h;
			struct tm *tm;
			FILE *out;
			char timebuf[BUFRSZ];

			/* finish To: from above */
			dmarcf_dstring_cat(dfc->mctx_afrf, '\n');

			/* Bcc: */
			if (ruv != NULL && conf->conf_afrfbcc != NULL)
			{
				dmarcf_dstring_cat(dfc->mctx_afrf, 'Bcc: ');
				dmarcf_dstring_cat(dfc->mctx_afrf,
				                   conf->conf_afrfbcc);
				dmarcf_dstring_cat(dfc->mctx_afrf, '\n');
			}
			
			/* Date: */
			(void) time(&now);
			tm = localtime(&now);
			(void) strftime(timebuf, sizeof timebuf,
			                '%a, %e %b %Y %H:%M:%S %z (%Z)', tm);
			dmarcf_dstring_printf(dfc->mctx_afrf, 'Date: %s\n',
			                      timebuf);

			h = dmarcf_findheader(dfc, 'subject', 0);
			if (h == NULL)
			{
				dmarcf_dstring_printf(dfc->mctx_afrf,
				                      'Subject: DMARC failure report for job %s\n',
				                      dfc->mctx_jobid);
			}
			else
			{
				dmarcf_dstring_printf(dfc->mctx_afrf,
				                      'Subject: FW: %s\n',
				                      h->hdr_value);
			}

			dmarcf_dstring_cat(dfc->mctx_afrf,
			                   'MIME-Version: 1.0\n');

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'Content-Type: multipart/report;'
			                      '\n\treport-type=feedback-report;'
			                      '\n\tboundary=\'%s:%s\'\n',
			                      hostname, dfc->mctx_jobid);

			dmarcf_dstring_cat(dfc->mctx_afrf, '\n');

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      '--%s:%s\n'
			                      'Content-Type: text/plain\n\n',
			                      hostname, dfc->mctx_jobid);

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'This is an authentication '
			                      'failure report for an email '
			                      'message received from IP\n'
			                      '%s on %s.\n\n',
			                      cc->cctx_ipstr, timebuf);

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      '--%s:%s\n'
			                      'Content-Type: message/feedback-report\n\n',
			                      hostname, dfc->mctx_jobid);

			dmarcf_dstring_cat(dfc->mctx_afrf,
			                   'Feedback-Type: auth-failure\n'
			                   'Version: 1\n');

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'User-Agent: %s/%s\n',
			                      DMARCF_PRODUCTNS, VERSION);

			dmarcf_dstring_cat(dfc->mctx_afrf,
			                   'Auth-Failure: dmarc\n');

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'Authentication-Results: %s; dmarc=fail header.from=%s\n',
			                      authservid,
			                      dfc->mctx_fromdomain);

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'Original-Envelope-Id: %s\n',
			                      dfc->mctx_jobid);

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'Original-Mail-From: %s\n',
			                      dfc->mctx_envfrom);

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'Source-IP: %s (%s)\n',
			                      cc->cctx_ipstr,
			                      cc->cctx_host);

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      'Reported-Domain: %s\n\n',
			                      dfc->mctx_fromdomain);

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      '--%s:%s\n'
			                      'Content-Type: text/rfc822-headers\n\n',
			                      hostname, dfc->mctx_jobid);

			for (h = dfc->mctx_hqhead; h != NULL; h = h->hdr_next)
			{
				dmarcf_dstring_printf(dfc->mctx_afrf,
				                      '%s: %s\n',
				                      h->hdr_name,
				                      h->hdr_value);
			}

			dmarcf_dstring_printf(dfc->mctx_afrf,
			                      '\n--%s:%s--\n',
			                      hostname, dfc->mctx_jobid);

			out = popen(conf->conf_reportcmd, 'w');
			if (out == NULL)
			{
				if (conf->conf_dolog)
				{
					syslog(LOG_ERR, '%s: popen(): %s',
					       dfc->mctx_jobid,
					       strerror(errno));
				}
			}
			else
			{
				fwrite(dmarcf_dstring_get(dfc->mctx_afrf),
				       1, dmarcf_dstring_len(dfc->mctx_afrf),
				       out);

				status = pclose(out);
				if (status != 0 && conf->conf_dolog)
				{
					int val;
					const char *how;

					if (WIFEXITED(status))
					{
						how = 'exited with status';
						val = WEXITSTATUS(status);
					}
					else if (WIFSIGNALED(status))
					{
						how = 'killed with signal';
						val = WTERMSIG(status);
					}
					else
					{
						how = 'returned status';
						val = status;
					}

					syslog(LOG_ERR, '%s: pclose() %s %d',
					       dfc->mctx_jobid, how, val);
				}
			}
		}
	}

	/*
	**  Enact policy based on DMARC results.
	*/

	result = DMARC_RESULT_ACCEPT;

	switch (policy)
	{
	  case DMARC_POLICY_ABSENT:		/* No DMARC record found */
	  case DMARC_FROM_DOMAIN_ABSENT:	/* No From: domain */
		aresult = 'none';
		ret = SMFIS_ACCEPT;
		result = DMARC_RESULT_ACCEPT;
		break;

	  case DMARC_POLICY_NONE:		/* Alignment failed, but policy is none: */
		aresult = 'fail';		/* Accept and report */
		ret = SMFIS_ACCEPT;
		result = DMARC_RESULT_ACCEPT;
		break;

	  case DMARC_POLICY_PASS:		/* Explicit accept */
		aresult = 'pass';
		ret = SMFIS_ACCEPT;
		result = DMARC_RESULT_ACCEPT;
		break;

	  case DMARC_POLICY_REJECT:		/* Explicit reject */
		aresult = 'fail';

		if (conf->conf_rejectfail && random() % 100 < pct)
		{
			snprintf(replybuf, sizeof replybuf,
			         'rejected by DMARC policy for %s', pdomain);

			status = dmarcf_setreply(ctx, DMARC_REJECT_SMTP,
			                         DMARC_REJECT_ESC, replybuf);
			if (status != MI_SUCCESS && conf->conf_dolog)
			{
				syslog(LOG_ERR, '%s: smfi_setreply() failed',
				       dfc->mctx_jobid);
			}

			ret = SMFIS_REJECT;
			result = DMARC_RESULT_REJECT;
		}

		if (conf->conf_copyfailsto != NULL)
		{
			status = dmarcf_addrcpt(ctx, conf->conf_copyfailsto);
			if (status != MI_SUCCESS && conf->conf_dolog)
			{
				syslog(LOG_ERR, '%s: smfi_addrcpt() failed',
				       dfc->mctx_jobid);
			}
		}

		break;

	  case DMARC_POLICY_QUARANTINE:		/* Explicit quarantine */
		aresult = 'fail';

		if (conf->conf_rejectfail && random() % 100 < pct)
		{
			snprintf(replybuf, sizeof replybuf,
			         'quarantined by DMARC policy for %s',
			         pdomain);

			status = smfi_quarantine(ctx, replybuf);
			if (status != MI_SUCCESS && conf->conf_dolog)
			{
				syslog(LOG_ERR, '%s: smfi_quarantine() failed',
				       dfc->mctx_jobid);
			}

			ret = SMFIS_ACCEPT;
			result = DMARC_RESULT_QUARANTINE;
		}

		if (conf->conf_copyfailsto != NULL)
		{
			status = dmarcf_addrcpt(ctx, conf->conf_copyfailsto);
			if (status != MI_SUCCESS && conf->conf_dolog)
			{
				syslog(LOG_ERR, '%s: smfi_addrcpt() failed',
				       dfc->mctx_jobid);
			}
		}

		break;

	  default:
		aresult = 'temperror';
		ret = SMFIS_TEMPFAIL;
		result = DMARC_RESULT_TEMPFAIL;
		break;
	}

	/* prepare human readable dispositon string for later processing */
	switch (result)
	{
	  case DMARC_RESULT_REJECT:
		adisposition = 'reject';
		break;

	  case DMARC_RESULT_QUARANTINE:
		adisposition = 'quarantine';
		break;

	  default:
		adisposition = 'none';
		break;
	}

	if (conf->conf_dolog)
	{
		syslog(LOG_INFO, '%s: %s %s', dfc->mctx_jobid,
		       dfc->mctx_fromdomain, aresult);
	}

	/* if the final action isn't TEMPFAIL or REJECT, add an A-R field */
	if (ret != SMFIS_TEMPFAIL && ret != SMFIS_REJECT)
	{
		snprintf(header, sizeof header,
		         '%s%s%s; dmarc=%s (p=%s dis=%s) header.from=%s',
		         authservid,
		         conf->conf_authservidwithjobid ? '/' : '',
		         conf->conf_authservidwithjobid ? dfc->mctx_jobid : '',
		         aresult, apolicy, adisposition, dfc->mctx_fromdomain);

		if (dmarcf_insheader(ctx, 1, AUTHRESULTSHDR,
		                     header) == MI_FAILURE)
		{
			if (conf->conf_dolog)
			{
				syslog(LOG_ERR,
				       '%s: %s header add failed',
				       dfc->mctx_jobid,
				       AUTHRESULTSHDR);
			}
		}
	}

	dmarcf_dstring_printf(dfc->mctx_histbuf, 'action %d\n', result);

	/*
	**  Record activity in the history file.
	*/

	if (conf->conf_historyfile != NULL &&
	    (conf->conf_recordall || ostatus != DMARC_DNS_ERROR_NO_RECORD))
	{
		FILE *f;

		f = fopen(conf->conf_historyfile, 'a');
		if (f == NULL)
		{
			if (conf->conf_dolog)
			{
				syslog(LOG_ERR, '%s: %s: fopen(): %s',
				       dfc->mctx_jobid,
				       conf->conf_historyfile,
				       strerror(errno));
			}

			return SMFIS_TEMPFAIL;
		}

#ifdef LOCK_EX
		if (flock(fileno(f), LOCK_EX) != 0)
		{
			syslog(LOG_WARNING, '%s: %s: flock(LOCK_EX): %s',
#else
# ifdef F_LOCK
		if (lockf(fileno(f), F_LOCK, 0)  != 0)
		{
			syslog(LOG_WARNING, '%s: %s: lockf(F_LOCK): %s',
# endif
#endif /* LOCK_EX */
			       dfc->mctx_jobid,
			       conf->conf_historyfile,
			       strerror(errno));
		}

		/* write out the buffer */
		clearerr(f);
		fwrite(dmarcf_dstring_get(dfc->mctx_histbuf), 1,
		       dmarcf_dstring_len(dfc->mctx_histbuf), f);
		if (ferror(f) && conf->conf_dolog)
		{
			syslog(LOG_ERR, '%s: %s: fwrite(): %s',
			       dfc->mctx_jobid,
			       conf->conf_historyfile,
			       strerror(errno));
		}

#ifdef LOCK_EX
		if (flock(fileno(f), LOCK_UN) != 0)
		{
			syslog(LOG_WARNING, '%s: %s: flock(LOCK_UN): %s',
#else
# ifdef F_LOCK
		if (lockf(fileno(f), F_ULOCK, 0)  != 0)
		{
			syslog(LOG_WARNING, '%s: %s: lockf(F_ULOCK): %s',
# endif
#endif /* LOCK_EX */
			       dfc->mctx_jobid,
			       conf->conf_historyfile,
			       strerror(errno));
		}

		fclose(f);
	}

	if (conf->conf_addswhdr)
	{
		snprintf(header, sizeof header, '%s v%s %s %s',
		         DMARCF_PRODUCT, VERSION, hostname,
		         dfc->mctx_jobid != NULL ? dfc->mctx_jobid
		                                 : JOBIDUNKNOWN);

		if (dmarcf_insheader(ctx, 1, SWHEADERNAME,
		                     header) == MI_FAILURE)
		{
			if (conf->conf_dolog)
			{
				syslog(LOG_ERR,
				       '%s: %s header add failed',
				       dfc->mctx_jobid,
				       SWHEADERNAME);
			}
		}
	}

	dmarcf_cleanup(ctx);

	return ret;
}

/*
**  MLFI_ABORT -- handler called if an earlier filter in the filter process
**                rejects the message
**
**  Parameters:
**  	ctx -- milter context
**
**  Return value:
**  	An SMFIS_* constant.
*/

sfsistat
mlfi_abort(SMFICTX *ctx)
{
	dmarcf_cleanup(ctx);
	return SMFIS_CONTINUE;
}

/*
**  MLFI_CLOSE -- handler called on connection shutdown
**
**  Parameters:
**  	ctx -- milter context
**
**  Return value:
**  	An SMFIS_* constant.
*/

sfsistat
mlfi_close(SMFICTX *ctx)
{
	DMARCF_CONNCTX cc;

	dmarcf_cleanup(ctx);

	cc = (DMARCF_CONNCTX) dmarcf_getpriv(ctx);
	if (cc != NULL)
	{
		pthread_mutex_lock(&conf_lock);

		cc->cctx_config->conf_refcnt--;

		if (cc->cctx_config->conf_refcnt == 0 &&
		    cc->cctx_config != curconf)
			dmarcf_config_free(cc->cctx_config);

		pthread_mutex_unlock(&conf_lock);

		(void) opendmarc_policy_connect_shutdown(cc->cctx_dmarc);

		free(cc);
		dmarcf_setpriv(ctx, NULL);
	}

	return SMFIS_CONTINUE;
}

/*
**  smfilter -- the milter module description
*/

struct smfiDesc smfilter =
{
	DMARCF_PRODUCT,	/* filter name */
	SMFI_VERSION,	/* version code -- do not change */
	0,		/* flags; updated in main() */
	mlfi_connect,	/* connection info filter */
#if WITH_SPF
	mlfi_helo,	/* SMTP HELO command filter */
#else
	NULL,		/* SMTP HELO command filter */
#endif
	mlfi_envfrom,	/* envelope sender filter */
	NULL,		/* envelope recipient filter */
	mlfi_header,	/* header filter */
	NULL,		/* end of header */
	NULL,		/* body block filter */
	mlfi_eom,	/* end of message */
	mlfi_abort,	/* message aborted */
	mlfi_close,	/* shutdown */
#if SMFI_VERSION > 2
	NULL,		/* unrecognised command */
#endif
#if SMFI_VERSION > 3
	NULL,		/* DATA */
#endif
#if SMFI_VERSION >= 0x01000000
	mlfi_negotiate	/* negotiation callback */
#endif
};

/*
**  DMARCF_SIGHANDLER -- signal handler
**
**  Parameters:
**  	sig -- signal received
**
**  Return value:
**  	None.
*/

static void
dmarcf_sighandler(int sig)
{
	if (sig == SIGINT || sig == SIGTERM || sig == SIGHUP)
	{
		diesig = sig;
		die = TRUE;
	}
	else if (sig == SIGUSR1)
	{
		if (conffile != NULL)
			reload = TRUE;
	}
}

/*
**  DMARCF_RELOADER -- reload signal thread
**
**  Parameters:
**  	vp -- void pointer required by thread API but not used
**
**  Return value:
**  	NULL.
*/

static void *
dmarcf_reloader(/* UNUSED */ void *vp)
{
	int sig;
	sigset_t mask;

	(void) pthread_detach(pthread_self());

	sigemptyset(&mask);
	sigaddset(&mask, SIGUSR1);

	while (!die)
	{
		(void) sigwait(&mask, &sig);

		if (conffile != NULL)
			reload = TRUE;
	}

	return NULL;
}

/*
**  DMARCF_KILLCHILD -- kill child process
**
**  Parameters:
**  	pid -- process ID to signal
**  	sig -- signal to use
**  	dolog -- log it?
**
**  Return value:
**  	None.
*/

static void
dmarcf_killchild(pid_t pid, int sig, _Bool dolog)
{
	if (kill(pid, sig) == -1 && dolog)
	{
		syslog(LOG_ERR, 'kill(%d, %d): %s', pid, sig,
		       strerror(errno));
	}
}

/*
**  DMARCF_RESTART_CHECK -- initialize/check restart rate information
**
**  Parameters:
**  	n -- size of restart rate array to initialize/enforce
**  	t -- maximum time range for restarts (0 == init)
**
**  Return value:
**  	TRUE -- OK to continue
**  	FALSE -- error
*/

static _Bool
dmarcf_restart_check(int n, time_t t)
{
	static int idx;				/* last filled slot */
	static int alen;			/* allocated length */
	static time_t *list;

	if (t == 0)
	{
		alen = n * sizeof(time_t);

		list = (time_t *) malloc(alen);

		if (list == NULL)
			return FALSE;

		memset(list, '\0', alen);

		idx = 0;
		alen = n;

		return TRUE;
	}
	else
	{
		int which;

		time_t now;

		(void) time(&now);

		which = (idx - 1) % alen;
		if (which == -1)
			which = alen - 1;

		if (list[which] != 0 &&
		    list[which] + t > now)
			return FALSE;

		list[which] = t;
		idx++;

		return TRUE;
	}
}

/*
**  DMARCF_STDIO -- set up the base descriptors to go nowhere
**
**  Parameters:
**  	None.
**
**  Return value:
**  	None.
*/

static void
dmarcf_stdio(void)
{
	int devnull;

	/* this only fails silently, but that's OK */
	devnull = open(_PATH_DEVNULL, O_RDWR, 0);
	if (devnull != -1)
	{
		(void) dup2(devnull, 0);
		(void) dup2(devnull, 1);
		(void) dup2(devnull, 2);
		if (devnull > 2)
			(void) close(devnull);
	}

	(void) setsid();
}

/*
**  DMARCF_CONFIG_NEW -- get a new configuration handle
**
**  Parameters:
**  	None.
**
**  Return value:
**  	A new configuration handle, or NULL on error.
*/

static struct dmarcf_config *
dmarcf_config_new(void)
{
	struct dmarcf_config *new;

	new = (struct dmarcf_config *) malloc(sizeof(struct dmarcf_config));
	if (new == NULL)
		return NULL;

	memset(new, '\0', sizeof(struct dmarcf_config));

	new->conf_reportcmd = DEFREPORTCMD;

	return new;
}

/*
**  DMARCF_CONFIG_FREE -- destroy a configuration handle
**
**  Parameters:
**  	conf -- pointer to the configuration handle to be destroyed
**
**  Return value:
**  	None.
*/

static void
dmarcf_config_free(struct dmarcf_config *conf)
{
	assert(conf != NULL);
	assert(conf->conf_refcnt == 0);

	if (conf->conf_data != NULL)
		config_free(conf->conf_data);

	if (conf->conf_ignoredomains != NULL)
		dmarcf_freearray(conf->conf_ignoredomains);

	if (conf->conf_trustedauthservids != NULL)
		dmarcf_freearray(conf->conf_trustedauthservids);

	if (conf->conf_authservid != NULL)
		free(conf->conf_authservid);

	free(conf);
}

/*
**  USAGE -- print a usage message and exit
**
**  Parameters:
**  	None.
**
**  Return value:
**  	EX_USAGE
*/

int
usage(void)
{
	fprintf(stderr, '%s: usage: %s [options]\n'
	                '\t-A         \tenable auto-restart\n'
	                '\t-c file    \tconfiguration file\n'
	                '\t-f         \trun in the foreground\n'
	                '\t-l         \tlog to syslog\n'
	                '\t-n         \ttest configuration and exit\n'
	                '\t-p sockspec\tspecify milter socket\n'
	                '\t-P file    \twrite process ID to specified file\n'
	                '\t-t file    \tevaluate a single message\n'
	                '\t-u user    \ttry to become the named user\n'
	                '\t-v         \tincrease verbose output\n'
	                '\t-V         \tprint version and exit\n',
	        progname, progname);

	return EX_USAGE;
}

/*
**  MAIN -- program mainline
**
**  Parameters:
**  	argc, argv -- the usual
**
**  Return value:
**  	Exit status.
*/

int
main(int argc, char **argv)
{
	_Bool autorestart = FALSE;
	_Bool gotp = FALSE;
	_Bool dofork = TRUE;
	_Bool stricttest = FALSE;
	_Bool configonly = FALSE;
	int c;
	int status;
	int n;
	int verbose = 0;
	int maxrestarts = 0;
	int maxrestartrate_n = 0;
	int filemask = -1;
	int mdebug = 0;
#ifdef HAVE_SMFI_VERSION
	u_int mvmajor;
	u_int mvminor;
	u_int mvrelease;
#endif /* HAVE_SMFI_VERSION */
	time_t now;
	gid_t gid = (gid_t) -1;
	sigset_t sigset;
	time_t maxrestartrate_t = 0;
	pthread_t rt;
	const char *args = CMDLINEOPTS;
	FILE *f;
	struct passwd *pw = NULL;
	struct group *gr = NULL;
	char *become = NULL;
	char *chrootdir = NULL;
	char *extract = NULL;
	char *ignorefile = NULL;
	char *p;
	char *pidfile = NULL;
	char *testfile = NULL;
	struct config *cfg = NULL;
	char *end;
	char argstr[MAXARGV];
	char err[BUFRSZ + 1];
	OPENDMARC_LIB_T libopendmarc;

	/* initialize */
	testmode = FALSE;
	reload = FALSE;
	sock = NULL;
	no_i_whine = TRUE;
	conffile = NULL;
	ignore = NULL;

	memset(myhostname, '\0', sizeof myhostname);
	(void) gethostname(myhostname, sizeof myhostname);

	progname = (p = strrchr(argv[0], '/')) == NULL ? argv[0] : p + 1;

	(void) time(&now);
	srandom(now);

	curconf = dmarcf_config_new();
	if (curconf == NULL)
	{
		fprintf(stderr, '%s: malloc(): %s\n', progname,
		        strerror(errno));

		return EX_OSERR;
	}

	/* process command line options */
	while ((c = getopt(argc, argv, args)) != -1)
	{
		switch (c)
		{
		  case 'A':
			autorestart = TRUE;
			break;

		  case 'c':
			if (optarg == NULL || *optarg == '\0')
				return usage();
			conffile = optarg;
			break;

		  case 'f':
			dofork = FALSE;
			break;

		  case 'l':
			curconf->conf_dolog = TRUE;
			break;

		  case 'n':
			configonly = TRUE;
			break;

		  case 'p':
			if (optarg == NULL || *optarg == '\0')
				return usage();
			sock = optarg;
			(void) smfi_setconn(optarg);
			gotp = TRUE;
			break;

		  case 'P':
			if (optarg == NULL || *optarg == '\0')
				return usage();
			pidfile = optarg;
			break;

		  case 't':
			if (optarg == NULL || *optarg == '\0')
				return usage();
			testmode = TRUE;
			testfile = optarg;
			break;

		  case 'u':
			if (optarg == NULL || *optarg == '\0')
				return usage();
			become = optarg;
			break;

		  case 'v':
			verbose++;
			break;

		  case 'V':
			printf('%s: %s v%s\n', progname, DMARCF_PRODUCT,
			       VERSION);
			printf('\tSMFI_VERSION 0x%x\n', SMFI_VERSION);
#ifdef HAVE_SMFI_VERSION
			(void) smfi_version(&mvmajor, &mvminor, &mvrelease);
			printf('\tlibmilter version %d.%d.%d\n',
			       mvmajor, mvminor, mvrelease);
#endif /* HAVE_SMFI_VERSION */
			dmarcf_optlist(stdout);
			return EX_OK;

		  default:
			return usage();
		}
	}

	if (optind != argc)
		return usage();

	/* if there's a default config file readable, use it */
	if (conffile == NULL && access(DEFCONFFILE, R_OK) == 0)
		conffile = DEFCONFFILE;

	if (conffile != NULL)
	{
		u_int line = 0;
		char *missing;
		char path[MAXPATHLEN + 1];

		cfg = config_load(conffile, dmarcf_config,
		                  &line, path, sizeof path);

		if (cfg == NULL)
		{
			fprintf(stderr,
			        '%s: %s: configuration error at line %u: %s\n',
			        progname, path, line,
			        config_error());
			dmarcf_config_free(curconf);
			return EX_CONFIG;
		}

#ifdef DEBUG
		(void) config_dump(cfg, stdout, NULL);
#endif /* DEBUG */

		missing = config_check(cfg, dmarcf_config);
		if (missing != NULL)
		{
			fprintf(stderr,
			        '%s: %s: required parameter \'%s\' missing\n',
			        progname, conffile, missing);
			config_free(cfg);
			dmarcf_config_free(curconf);
			return EX_CONFIG;
		}
	}

	if (dmarcf_config_load(cfg, curconf, err, sizeof err) != 0)
	{
		if (conffile == NULL)
			conffile = '(stdin)';
		fprintf(stderr, '%s: %s: %s\n', progname, conffile, err);
		config_free(cfg);
		dmarcf_config_free(curconf);
		return EX_CONFIG;
	}

	if (configonly)
	{
		config_free(cfg);
		dmarcf_config_free(curconf);
		return EX_OK;
	}

	if (extract)
	{
		int ret = EX_OK;

		if (cfg != NULL)
		{
			if (!config_validname(dmarcf_config, extract))
				ret = EX_DATAERR;
			else if (config_dump(cfg, stdout, extract) == 0)
				ret = EX_CONFIG;
			config_free(cfg);
			dmarcf_config_free(curconf);
		}
		return ret;
	}

	dolog = curconf->conf_dolog;
	curconf->conf_data = cfg;

	/*
	**  Use values found in the configuration file, if any.  Note that
	**  these are operational parameters for the filter (e.g which socket
	**  to use which userid to become, etc.) and aren't reloaded upon a
	**  reload signal.  Reloadable values are handled via the
	**  dmarcf_config_load() function, which has already been called.
	*/

	if (cfg != NULL)
	{
		if (!autorestart)
		{
			(void) config_get(cfg, 'AutoRestart', &autorestart,
			                  sizeof autorestart);
		}

		if (autorestart)
		{
			char *rate = NULL;

			(void) config_get(cfg, 'AutoRestartCount',
			                  &maxrestarts, sizeof maxrestarts);

			(void) config_get(cfg, 'AutoRestartRate', &rate,
			                  sizeof rate);

			if (rate != NULL)
			{
				time_t t;
				char *q;

				p = strchr(rate, '/');
				if (p == NULL)
				{
					fprintf(stderr,
					        '%s: AutoRestartRate invalid\n',
					        progname);
					config_free(cfg);
					return EX_CONFIG;
				}

				*p = '\0';
				n = strtol(rate, &q, 10);
				if (n < 0 || *q != '\0')
				{
					fprintf(stderr,
					        '%s: AutoRestartRate invalid\n',
					        progname);
					config_free(cfg);
					return EX_CONFIG;
				}

				t = (time_t) strtoul(p + 1, &q, 10);
				switch (*q)
				{
				  case 'd':
				  case 'D':
					t *= 86400;
					break;

				  case 'h':
				  case 'H':
					t *= 3600;
					break;

				  case 'm':
				  case 'M':
					t *= 60;
					break;

				  case '\0':
				  case 's':
				  case 'S':
					break;

				  default:
					t = 0;
					break;
				}

				if (*q != '\0' && *(q + 1) != '\0')
					t = 0;

				if (t == 0)
				{
					fprintf(stderr,
					        '%s: AutoRestartRate invalid\n',
					        progname);
					config_free(cfg);
					return EX_CONFIG;
				}

				maxrestartrate_n = n;
				maxrestartrate_t = t;
			}
		}

		if (dofork)
		{
			(void) config_get(cfg, 'Background', &dofork,
			                  sizeof dofork);
		}

		(void) config_get(cfg, 'MilterDebug', &mdebug, sizeof mdebug);

		if (!gotp)
		{
			(void) config_get(cfg, 'Socket', &sock, sizeof sock);
			if (sock != NULL)
			{
				gotp = TRUE;
				(void) smfi_setconn(sock);
			}
		}

		if (pidfile == NULL)
		{
			(void) config_get(cfg, 'PidFile', &pidfile,
			                  sizeof pidfile);
		}

		(void) config_get(cfg, 'UMask', &filemask, sizeof filemask);

		if (become == NULL)
		{
			(void) config_get(cfg, 'Userid', &become,
			                  sizeof become);
		}

		(void) config_get(cfg, 'ChangeRootDirectory', &chrootdir,
		                  sizeof chrootdir);

		(void) config_get(cfg, 'IgnoreHosts', &ignorefile,
		                  sizeof ignorefile);
	}

	if (ignorefile != NULL)
	{
		if (!dmarcf_loadlist(ignorefile, &ignore))
		{
			fprintf(stderr,
			        '%s: can't load ignore list from %s: %s\n',
			        progname, ignorefile, strerror(errno));
			return EX_DATAERR;
		}
	}
	else if (!testmode)
	{
		dmarcf_addlist('127.0.0.1', &ignore);
	}

	if (!gotp && !testmode)
	{
		fprintf(stderr, '%s: milter socket must be specified\n',
		        progname);
		if (argc == 1)
			fprintf(stderr, '\t(use \'-?\' for help)\n');
		return EX_CONFIG;
	}

	/* suppress a bunch of things if we're in test mode */
	if (testmode)
	{
		curconf->conf_dolog = FALSE;
		autorestart = FALSE;
		dofork = FALSE;
		become = NULL;
		pidfile = NULL;
		chrootdir = NULL;
	}

	dmarcf_setmaxfd();

	/* prepare to change user if appropriate */
	if (become != NULL)
	{
		char *colon;

		/* see if there was a group specified; if so, validate */
		colon = strchr(become, ':');
		if (colon != NULL)
		{
			*colon = '\0';

			gr = getgrnam(colon + 1);
			if (gr == NULL)
			{
				char *q;

				gid = (gid_t) strtol(colon + 1, &q, 10);
				if (*q == '\0')
					gr = getgrgid(gid);

				if (gr == NULL)
				{
					if (curconf->conf_dolog)
					{
						syslog(LOG_ERR,
						       'no such group or gid '%s'',
						       colon + 1);
					}

					fprintf(stderr,
					        '%s: no such group '%s'\n',
					        progname, colon + 1);

					return EX_DATAERR;
				}
			}
		}

		/* validate the user */
		pw = getpwnam(become);
		if (pw == NULL)
		{
			char *q;
			uid_t uid;

			uid = (uid_t) strtoul(become, &q, 10);
			if (*q == '\0')
				pw = getpwuid(uid);

			if (pw == NULL)
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR,
					       'no such user or uid '%s'',
					       become);
				}

				fprintf(stderr, '%s: no such user '%s'\n',
				        progname, become);

				return EX_DATAERR;
			}
		}

		if (gr == NULL)
			gid = pw->pw_gid;
		else
			gid = gr->gr_gid;
	}

	/* change root if requested */
	if (chrootdir != NULL)
	{
		/* warn if doing so as root without then giving up root */
		if (become == NULL && getuid() == 0)
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_WARNING,
				       'using ChangeRootDirectory without Userid not advised');
			}

			fprintf(stderr,
			        '%s: use of ChangeRootDirectory without Userid not advised\n',
			        progname);
		}

		/* change to the new root first */
		if (chdir(chrootdir) != 0)
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_ERR, '%s: chdir(): %s',
				       chrootdir, strerror(errno));
			}

			fprintf(stderr, '%s: %s: chdir(): %s\n', progname,
			        chrootdir, strerror(errno));
			return EX_OSERR;
		}

		/* now change the root */
		if (chroot(chrootdir) != 0)
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_ERR, '%s: chroot(): %s',
				       chrootdir, strerror(errno));
			}

			fprintf(stderr, '%s: %s: chroot(): %s\n', progname,
			        chrootdir, strerror(errno));
			return EX_OSERR;
		}
	}

	/* now enact the user change */
	if (become != NULL)
	{
		/* make all the process changes */
		if (getuid() != pw->pw_uid)
		{
			if (initgroups(pw->pw_name, gid) != 0)
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR, 'initgroups(): %s',
					       strerror(errno));
				}

				fprintf(stderr, '%s: initgroups(): %s\n',
				        progname, strerror(errno));

				return EX_NOPERM;
			}
			else if (setgid(gid) != 0)
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR, 'setgid(): %s',
					       strerror(errno));
				}

				fprintf(stderr, '%s: setgid(): %s\n', progname,
				        strerror(errno));

				return EX_NOPERM;
			}
			else if (setuid(pw->pw_uid) != 0)
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR, 'setuid(): %s',
					       strerror(errno));
				}

				fprintf(stderr, '%s: setuid(): %s\n', progname,
				        strerror(errno));

				return EX_NOPERM;
			}
		}

		(void) endpwent();
	}
	else
	{
	}

	if (curconf->conf_enablecores)
	{
		_Bool enabled = FALSE;

#ifdef __linux__
		if (prctl(PR_SET_DUMPABLE, 1) == -1)
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_ERR, 'prctl(): %s',
				       strerror(errno));
			}

			fprintf(stderr, '%s: prctl(): %s\n',
			        progname, strerror(errno));
		}
		else
		{
			enabled = TRUE;
		}
#endif /* __linux__ */

		if (!enabled)
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_WARNING,
				       'can't enable coredumps; continuing');
			}

			fprintf(stderr,
			        '%s: can't enable coredumps; continuing\n',
			        progname);
		}
	}

	die = FALSE;

	if (autorestart)
	{
		_Bool quitloop = FALSE;
		int restarts = 0;
		int status;
		pid_t pid;
		pid_t wpid;
		struct sigaction sa;

		if (dofork)
		{
			pid = fork();
			switch (pid)
			{
			  case -1:
				if (curconf->conf_dolog)
				{
					int saveerrno;

					saveerrno = errno;

					syslog(LOG_ERR, 'fork(): %s',
					       strerror(errno));

					errno = saveerrno;
				}

				fprintf(stderr, '%s: fork(): %s\n',
				        progname, strerror(errno));

				return EX_OSERR;

			  case 0:
				dmarcf_stdio();
				break;

			  default:
				return EX_OK;
			}
		}

		if (pidfile != NULL)
		{
			f = fopen(pidfile, 'w');
			if (f != NULL)
			{
				fprintf(f, '%ld\n', (long) getpid());
				(void) fclose(f);
			}
			else
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR,
					       'can't write pid to %s: %s',
					       pidfile, strerror(errno));
				}
			}
		}

		sa.sa_handler = dmarcf_sighandler;
		sigemptyset(&sa.sa_mask);
		sigaddset(&sa.sa_mask, SIGHUP);
		sigaddset(&sa.sa_mask, SIGINT);
		sigaddset(&sa.sa_mask, SIGTERM);
		sigaddset(&sa.sa_mask, SIGUSR1);
		sa.sa_flags = 0;

		if (sigaction(SIGHUP, &sa, NULL) != 0 ||
		    sigaction(SIGINT, &sa, NULL) != 0 ||
		    sigaction(SIGTERM, &sa, NULL) != 0 ||
		    sigaction(SIGUSR1, &sa, NULL) != 0)
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_ERR, '[parent] sigaction(): %s',
				       strerror(errno));
			}
		}

		if (maxrestartrate_n > 0)
			dmarcf_restart_check(maxrestartrate_n, 0);

		while (!quitloop)
		{
			status = dmarcf_socket_cleanup(sock);
			if (status != 0)
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR,
					       '[parent] socket cleanup failed: %s',
					       strerror(status));
				}
				return EX_UNAVAILABLE;
			}

			pid = fork();
			switch (pid)
			{
			  case -1:
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR, 'fork(): %s',
					       strerror(errno));
				}

				return EX_OSERR;

			  case 0:
				sa.sa_handler = SIG_DFL;

				if (sigaction(SIGHUP, &sa, NULL) != 0 ||
				    sigaction(SIGINT, &sa, NULL) != 0 ||
				    sigaction(SIGTERM, &sa, NULL) != 0)
				{
					if (curconf->conf_dolog)
					{
						syslog(LOG_ERR,
						       '[child] sigaction(): %s',
						       strerror(errno));
					}
				}

				quitloop = TRUE;
				break;

			  default:
				for (;;)
				{
					wpid = wait(&status);

					if (wpid == -1 && errno == EINTR)
					{
						if (die)
						{
							dmarcf_killchild(pid,
							                diesig,
							                curconf->conf_dolog);
							while (wpid != pid)
								wpid = wait(&status);

							if (pidfile != NULL)
								(void) unlink(pidfile);

							exit(EX_OK);
						}
						else if (reload)
						{
							dmarcf_killchild(pid,
							                SIGUSR1,
							                curconf->conf_dolog);

							reload = FALSE;

							continue;
						}
					}

					if (pid != wpid)
						continue;

					if (wpid != -1 && curconf->conf_dolog)
					{
						if (WIFSIGNALED(status))
						{
							syslog(LOG_NOTICE,
							       'terminated with signal %d, restarting',
							       WTERMSIG(status));
						}
						else if (WIFEXITED(status))
						{
							if (WEXITSTATUS(status) == EX_CONFIG ||
							    WEXITSTATUS(status) == EX_SOFTWARE)
							{
								syslog(LOG_NOTICE,
								       'exited with status %d',
								       WEXITSTATUS(status));
								quitloop = TRUE;
							}
							else
							{
								syslog(LOG_NOTICE,
								       'exited with status %d, restarting',
								       WEXITSTATUS(status));
							}
						}
					}

					if (conffile != NULL)
						reload = TRUE;

					break;
				}
				break;
			}

			if (maxrestarts > 0 && restarts >= maxrestarts)
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR,
					       'maximum restart count exceeded');
				}

				return EX_UNAVAILABLE;
			}

			if (maxrestartrate_n > 0 &&
			    maxrestartrate_t > 0 &&
			    !dmarcf_restart_check(0, maxrestartrate_t))
			{
				if (curconf->conf_dolog)
				{
					syslog(LOG_ERR,
					       'maximum restart rate exceeded');
				}

				return EX_UNAVAILABLE;
			}

			restarts++;
		}
	}

	if (filemask != -1)
		(void) umask((mode_t) filemask);

	if (mdebug > 0)
		(void) smfi_setdbg(mdebug);

	if (!testmode)
	{
		/* try to clean up the socket */
		status = dmarcf_socket_cleanup(sock);
		if (status != 0)
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_ERR, 'socket cleanup failed: %s',
				       strerror(status));
			}

			fprintf(stderr, '%s: socket cleanup failed: %s\n',
				progname, strerror(status));

			if (!autorestart && pidfile != NULL)
				(void) unlink(pidfile);

			return EX_UNAVAILABLE;
		}

		smfilter.xxfi_flags = SMFIF_ADDHDRS|SMFIF_QUARANTINE;
#ifdef SMFIF_SETSYMLIST
		smfilter.xxfi_flags |= SMFIF_SETSYMLIST;
#endif /* SMFIF_SETSYMLIST */

		/* register with the milter interface */
		if (smfi_register(smfilter) == MI_FAILURE)
		{
			if (curconf->conf_dolog)
				syslog(LOG_ERR, 'smfi_register() failed');

			fprintf(stderr, '%s: smfi_register() failed\n',
				progname);

			if (!autorestart && pidfile != NULL)
				(void) unlink(pidfile);

			return EX_UNAVAILABLE;
		}

#ifdef HAVE_SMFI_OPENSOCKET
		/* try to establish the milter socket */
		if (smfi_opensocket(FALSE) == MI_FAILURE)
		{
			if (curconf->conf_dolog)
				syslog(LOG_ERR, 'smfi_opensocket() failed');

			fprintf(stderr, '%s: smfi_opensocket() failed\n',
				progname);

			return EX_UNAVAILABLE;
		}
#endif /* HAVE_SMFI_OPENSOCKET */
	}

	if (!autorestart && dofork)
	{
		pid_t pid;

		pid = fork();
		switch (pid)
		{
		  case -1:
			if (curconf->conf_dolog)
			{
				int saveerrno;

				saveerrno = errno;

				syslog(LOG_ERR, 'fork(): %s', strerror(errno));

				errno = saveerrno;
			}

			fprintf(stderr, '%s: fork(): %s\n', progname,
			        strerror(errno));

			return EX_OSERR;

		  case 0:
			dmarcf_stdio();
			break;

		  default:
			return EX_OK;
		}
	}

	/* write out the pid */
	if (!autorestart && pidfile != NULL)
	{
		f = fopen(pidfile, 'w');
		if (f != NULL)
		{
			fprintf(f, '%ld\n', (long) getpid());
			(void) fclose(f);
		}
		else
		{
			if (curconf->conf_dolog)
			{
				syslog(LOG_ERR, 'can't write pid to %s: %s',
				       pidfile, strerror(errno));
			}
		}
	}

	/*
	**  Block SIGUSR1 for use of our reload thread, and SIGHUP, SIGINT
	**  and SIGTERM for use of libmilter's signal handling thread.
	*/

	sigemptyset(&sigset);
	sigaddset(&sigset, SIGUSR1);
	sigaddset(&sigset, SIGHUP);
	sigaddset(&sigset, SIGTERM);
	sigaddset(&sigset, SIGINT);
	status = pthread_sigmask(SIG_BLOCK, &sigset, NULL);
	if (status != 0)
	{
		if (curconf->conf_dolog)
		{
			syslog(LOG_ERR, 'pthread_sigprocmask(): %s',
			       strerror(status));
		}

		fprintf(stderr, '%s: pthread_sigprocmask(): %s\n', progname,
		        strerror(status));

		return EX_OSERR;
	}

	pthread_mutex_init(&conf_lock, NULL);

	/* initialize libopendmarc */
	(void) memset(&libopendmarc, '\0', sizeof libopendmarc);
	if (curconf->conf_pslist != NULL)
	{
		libopendmarc.tld_type = OPENDMARC_TLD_TYPE_MOZILLA;
		strncpy(libopendmarc.tld_source_file, curconf->conf_pslist,
		        sizeof libopendmarc.tld_source_file - 1);
	}

	if (opendmarc_policy_library_init(&libopendmarc) != 0)
	{
		if (curconf->conf_dolog)
		{
			syslog(LOG_ERR,
			       'opendmarc_policy_library_init() failed');
		}

		if (!autorestart && pidfile != NULL)
			(void) unlink(pidfile);

		return EX_OSERR;
	}

	/* figure out who I am */
	if (pw == NULL)
		pw = getpwuid(getuid());
	if (pw == NULL)
		myname = 'postmaster';
	else
		myname = pw->pw_name;

	/* perform test mode */
	if (testfile != NULL)
	{
		status = dmarcf_testfiles(testfile, stricttest, verbose);
		return status;
	}

	if (curconf->conf_dolog)
	{
		memset(argstr, '\0', sizeof argstr);
		end = &argstr[sizeof argstr - 1];
		n = sizeof argstr;
		for (c = 1, p = argstr; c < argc && p < end; c++)
		{
			if (strchr(argv[c], ' ') != NULL)
			{
				status = snprintf(p, n, '%s \'%s\'',
				                  c == 1 ? 'args:' : '',
				                  argv[c]);
			}
			else
			{
				status = snprintf(p, n, '%s %s',
				                  c == 1 ? 'args:' : '',
				                  argv[c]);
			}

			p += status;
			n -= status;
		}

		syslog(LOG_INFO, '%s v%s starting (%s)', DMARCF_PRODUCT,
		       VERSION, argstr);

		memset(argstr, '\0', sizeof argstr);
		strlcpy(argstr, '(none)', sizeof argstr);
		n = sizeof argstr;
		for (c = 0;
		     curconf->conf_trustedauthservids != NULL &&
		     curconf->conf_trustedauthservids[c] != NULL;
		     c++)
		{
			if (c == 0)
			{
				strlcpy(argstr, 
				        curconf->conf_trustedauthservids[c],
				        n);
			}
			else
			{
				strlcat(argstr, ', ', n);
				strlcat(argstr,
				        curconf->conf_trustedauthservids[c],
				        n);
			}
		}

		syslog(LOG_INFO,
		       'additional trusted authentication services: %s',
		       argstr);
	}

	/* spawn the SIGUSR1 handler */
	status = pthread_create(&rt, NULL, dmarcf_reloader, NULL);
	if (status != 0)
	{
		if (curconf->conf_dolog)
		{
			syslog(LOG_ERR, 'pthread_create(): %s',
			       strerror(status));
		}

		if (!autorestart && pidfile != NULL)
			(void) unlink(pidfile);

		return EX_OSERR;
	}

	/* call the milter mainline */
	errno = 0;
	status = smfi_main();

	/* shut down libopendmarc */
	(void) opendmarc_policy_library_shutdown(&libopendmarc);

	if (curconf->conf_dolog)
	{
		syslog(LOG_INFO,
		       '%s v%s terminating with status %d, errno = %d',
		       DMARCF_PRODUCT, VERSION, status, errno);
	}

	/* release memory */
	dmarcf_config_free(curconf);
	if (ignore != NULL)
		dmarcf_freelist(ignore);

	/* tell the reloader thread to die */
	die = TRUE;
	(void) raise(SIGUSR1);

	if (!autorestart && pidfile != NULL)
		(void) unlink(pidfile);

	return status;
}
",1,8422
trusteddomainproject/OpenDMARC,f6b615e345037408b88b2ffd1acd03239af8a858,"int
main(int argc, char **argv)
{
	TEST_FINEDDOMAIN_T *domp;
	TEST_FINEDDOMAIN_T domain_test[] = {
		/* 1 */  {'Joe Johnson <joe@joe.com>', 'joe.com'},
		/* 2 */  {'\'Johnson, Joe <joe@joe.com>\' joe@joe.com', 'joe.com'},
		/* 3 */  {'\'Joe Johnson\' <joe@joe.com>', 'joe.com'},
		/* 4 */  {'(Joe Johnson) joe@joe.com', 'joe.com'},
		/* 5 */  {'joe@joe.com', 'joe.com'},
		/* 6 */  {'<<<><joe@joe.com>>>', 'joe.com'},
		/* 7 */  {'Joe Johnson <joe@joe.com>, ace@ace.com', 'joe.com'},
		/* 8 */  {'joe@joe.com, ace@ace.com', 'joe.com'},
		/* 9 */  {'Mail From:<joe@joe.com>', 'joe.com'},
		/* 10 */ {'\'Mandel, Bob\' <joe@joe.com>', 'joe.com'},
		/* 11 */ {'(,) joe@joe.com', 'joe.com'},
		/* 12 */ {'\'( bob@bob.com)\' joe@joe.com', 'joe.com'},
		/* 12 */ {'From: Davide D'Marco <user@blah.com>', 'blah.com'},
			 {NULL, NULL},
	};
	u_char dbuf[256];
	int	pass, fails, count;
	u_char	*dp;
	
	pass = fails = count = 0;
	for (domp = domain_test; domp != NULL && domp->raw != NULL; ++domp)
	{
		count += 1;
		dp = opendmarc_util_finddomain(domp->raw, dbuf, sizeof dbuf);
		if (dp == NULL)
		{
			(void) printf('\t%s: %s\n', domp->raw, strerror(errno));
			++fails;
			continue;
		}
		if (strcmp(dbuf, domp->should_get) == 0)
		{
			//printf('\tFinddomain test: %d: PASS\n', count);
			pass += 1;
		}
		else
		{
			printf('\tFinddomain test: %d: FAIL\n', count);
			fails += 1;
		}
	}
	printf('Finddomain test: pass=%d, fail=%d\n', pass, fails);
	return fails;
}
",1,8423
trusteddomainproject/OpenDMARC,f6b615e345037408b88b2ffd1acd03239af8a858,"char *
dmarcf_getsymval(SMFICTX *ctx, char *sym)
{
	assert(ctx != NULL);
	assert(sym != NULL);

	if (testmode)
		return dmarcf_test_getsymval(ctx, sym);
	else
		return smfi_getsymval(ctx, sym);
}
",0,8424
trusteddomainproject/OpenDMARC,f6b615e345037408b88b2ffd1acd03239af8a858,"int
dmarcf_parse_received_spf(char *str)
{
	_Bool copying = FALSE;
	_Bool escaped = FALSE;
	int parens = 0;
	char *p;
	char *r;
	char *end;
	char result[MAXSPFRESULT + 1];

	assert(str != NULL);

	memset(result, '\0', sizeof result);
	r = result;
	end = &result[sizeof result - 1];

	for (p = str; *p != '\0'; p++)
	{
		if (escaped)
		{
			if (copying)
			{
				if (r < end)
					*r++ = *p;
			}

			escaped = FALSE;
		}
		else if (copying)
		{
			if (!escaped && *p == '\\')
			{
				escaped = TRUE;
			}
			else if (*p == '(')
			{
				copying = FALSE;
				parens++;
			}
 			else if (isascii(*p) && isspace(*p))
			{
				copying = FALSE;
			}
			else if (r < end)
			{
				*r++ = *p;
			}
		}
		else if (*p == '(')
		{
			parens++;
		}
		else if (*p == ')' && parens > 0)
		{
			parens--;
		}
		else if (parens == 0)
		{
			if (isascii(*p) && isspace(*p))
				continue;

			if (!copying)
			{
				if (result[0] != '\0')
					break;

				copying = TRUE;
				if (r < end)
					*r++ = *p;
			}
		}
	}

	if (strcasecmp(result, 'pass') == 0)
		return ARES_RESULT_PASS;
	else if (strcasecmp(result, 'fail') == 0)
		return ARES_RESULT_FAIL;
	else if (strcasecmp(result, 'softfail') == 0)
		return ARES_RESULT_SOFTFAIL;
	else if (strcasecmp(result, 'neutral') == 0)
		return ARES_RESULT_NEUTRAL;
	else if (strcasecmp(result, 'temperror') == 0)
		return ARES_RESULT_TEMPERROR;
	else if (strcasecmp(result, 'none') == 0)
		return ARES_RESULT_NONE;
	else
		return ARES_RESULT_PERMERROR;
}
",0,8425
torvalds/linux,ca7a03c4175366a92cee0ccc4fec0038c3266e26,"static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)
{
	struct fib6_result *res = arg->result;
	struct rt6_info *rt = res->rt6;
	struct net_device *dev = NULL;

	if (!rt)
		return false;

	if (rt->rt6i_idev)
		dev = rt->rt6i_idev->dev;

	/* do not accept result if the route does
	 * not meet the required prefix length
	 */
	if (rt->rt6i_dst.plen <= rule->suppress_prefixlen)
		goto suppress_route;

	/* do not accept result if the route uses a device
	 * belonging to a forbidden interface group
	 */
	if (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)
		goto suppress_route;

	return false;

suppress_route:
	ip6_rt_put(rt);
	return true;
}
",1,8426
torvalds/linux,ca7a03c4175366a92cee0ccc4fec0038c3266e26,"struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
				   const struct sk_buff *skb,
				   int flags, pol_lookup_t lookup)
{
	if (net->ipv6.fib6_has_custom_rules) {
		struct fib6_result res = {};
		struct fib_lookup_arg arg = {
			.lookup_ptr = lookup,
			.lookup_data = skb,
			.result = &res,
			.flags = FIB_LOOKUP_NOREF,
		};

		/* update flow if oif or iif point to device enslaved to l3mdev */
		l3mdev_update_flow(net, flowi6_to_flowi(fl6));

		fib_rules_lookup(net->ipv6.fib6_rules_ops,
				 flowi6_to_flowi(fl6), flags, &arg);

		if (res.rt6)
			return &res.rt6->dst;
	} else {
		struct rt6_info *rt;

		rt = lookup(net, net->ipv6.fib6_local_tbl, fl6, skb, flags);
		if (rt != net->ipv6.ip6_null_entry && rt->dst.error != -EAGAIN)
			return &rt->dst;
		ip6_rt_put_flags(rt, flags);
		rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);
		if (rt->dst.error != -EAGAIN)
			return &rt->dst;
		ip6_rt_put_flags(rt, flags);
	}

	if (!(flags & RT6_LOOKUP_F_DST_NOREF))
		dst_hold(&net->ipv6.ip6_null_entry->dst);
	return &net->ipv6.ip6_null_entry->dst;
}
",0,8427
file/file,46a8443f76cec4b41ec736eca396984c74664f84," */

#include 'file.h'

#ifndef lint
FILE_RCSID('@(#)$File: cdf.c,v 1.115 2019/08/23 14:29:14 christos Exp $')
#endif

#include <assert.h>
",1,8428
file/file,46a8443f76cec4b41ec736eca396984c74664f84,"FILE_RCSID('@(#)$File: cdf.c,v 1.115 2019/08/23 14:29:14 christos Exp $')
#endif

#include <assert.h>
#ifdef CDF_DEBUG
",1,8429
file/file,46a8443f76cec4b41ec736eca396984c74664f84,"int
cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)
{
	const cdf_section_header_t *shp;
	cdf_section_header_t sh;
	const uint8_t *p, *q, *e;
	size_t i, o4, nelements, j, slen, left;
	cdf_property_info_t *inp;

	if (offs > UINT32_MAX / 4) {
		errno = EFTYPE;
		goto out;
	}
	shp = CAST(const cdf_section_header_t *,
	    cdf_offset(sst->sst_tab, offs));
	if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)
		goto out;
	sh.sh_len = CDF_TOLE4(shp->sh_len);
	if (sh.sh_len > CDF_SHLEN_LIMIT) {
		errno = EFTYPE;
		goto out;
	}

	if (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)
		goto out;

	sh.sh_properties = CDF_TOLE4(shp->sh_properties);
	DPRINTF(('section len: %u properties %u\n', sh.sh_len,
	    sh.sh_properties));
	if (sh.sh_properties > CDF_PROP_LIMIT)
		goto out;
	inp = cdf_grow_info(info, maxcount, sh.sh_properties);
	if (inp == NULL)
		goto out;
	inp += *count;
	*count += sh.sh_properties;
	p = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));
	e = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));
	if (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
		goto out;

	for (i = 0; i < sh.sh_properties; i++) {
		if ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)
			goto out;
		inp[i].pi_id = CDF_GETUINT32(p, i << 1);
		left = CAST(size_t, e - q);
		if (left < sizeof(uint32_t)) {
			DPRINTF(('short info (no type)_\n'));
			goto out;
		}
		inp[i].pi_type = CDF_GETUINT32(q, 0);
		DPRINTF(('%' SIZE_T_FORMAT 'u) id=%#x type=%#x offs=%#tx,%#x\n',
		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
		if (inp[i].pi_type & CDF_VECTOR) {
			if (left < sizeof(uint32_t) * 2) {
				DPRINTF(('missing CDF_VECTOR length\n'));
				goto out;
			}
			nelements = CDF_GETUINT32(q, 1);
			if (nelements == 0) {
				DPRINTF(('CDF_VECTOR with nelements == 0\n'));
				goto out;
			}
			slen = 2;
		} else {
			nelements = 1;
			slen = 1;
		}
		o4 = slen * sizeof(uint32_t);
		if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))
			goto unknown;
		switch (inp[i].pi_type & CDF_TYPEMASK) {
		case CDF_NULL:
		case CDF_EMPTY:
			break;
		case CDF_SIGNED16:
			if (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))
				goto unknown;
			break;
		case CDF_SIGNED32:
		case CDF_BOOL:
		case CDF_UNSIGNED32:
		case CDF_FLOAT:
			if (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))
				goto unknown;
			break;
		case CDF_SIGNED64:
		case CDF_UNSIGNED64:
		case CDF_DOUBLE:
		case CDF_FILETIME:
			if (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))
				goto unknown;
			break;
		case CDF_LENGTH32_STRING:
		case CDF_LENGTH32_WSTRING:
			if (nelements > 1) {
				size_t nelem = inp - *info;
				inp = cdf_grow_info(info, maxcount, nelements);
				if (inp == NULL)
					goto out;
				inp += nelem;
			}
			DPRINTF(('nelements = %' SIZE_T_FORMAT 'u\n',
			    nelements));
			for (j = 0; j < nelements && i < sh.sh_properties;
			    j++, i++)
			{
				uint32_t l;

				if (o4 + sizeof(uint32_t) > left)
					goto out;

				l = CDF_GETUINT32(q, slen);
				o4 += sizeof(uint32_t);
				if (o4 + l > left)
					goto out;

				inp[i].pi_str.s_len = l;
				inp[i].pi_str.s_buf = CAST(const char *,
				    CAST(const void *, &q[o4]));

				DPRINTF(('o=%' SIZE_T_FORMAT 'u l=%d(%'
				    SIZE_T_FORMAT 'u), t=%' SIZE_T_FORMAT
				    'u s=%s\n', o4, l, CDF_ROUND(l, sizeof(l)),
				    left, inp[i].pi_str.s_buf));

				if (l & 1)
					l++;

				slen += l >> 1;
				o4 = slen * sizeof(uint32_t);
			}
			i--;
			break;
		case CDF_CLIPBOARD:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			break;
		default:
		unknown:
			memset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));
			DPRINTF(('Don't know how to deal with %#x\n',
			    inp[i].pi_type));
			break;
		}
	}
	return 0;
out:
	free(*info);
	*info = NULL;
	*count = 0;
	*maxcount = 0;
	errno = EFTYPE;
	return -1;
}
",1,8430
file/file,46a8443f76cec4b41ec736eca396984c74664f84,"	d->cl_word[1] = CDF_TOLE2(d->cl_word[1]);
",0,8431
file/file,46a8443f76cec4b41ec736eca396984c74664f84,"static int
cdf_namecmp(const char *d, const uint16_t *s, size_t l)
{
	for (; l--; d++, s++)
		if (*d != CDF_TOLE2(*s))
			return CAST(unsigned char, *d) - CDF_TOLE2(*s);
	return 0;
}
",0,8432
file/file,46a8443f76cec4b41ec736eca396984c74664f84,"int
cdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)
{
	size_t i;

	for (i = 0; i < __arraycount(vn); i++)
		if (vn[i].v == p)
			return snprintf(buf, bufsiz, '%s', vn[i].n);
	return snprintf(buf, bufsiz, '%#x', p);
}
",0,8433
libidn/libidn2,e4d1558aa2c1c04a05066ee8600f37603890ba8c,"int
idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)
{
  uint32_t *input_u32;
  uint8_t *input_u8, *output_u8;
  size_t length;
  int rc;

  if (!input)
    {
      if (output)
	*output = 0;
      return IDN2_OK;
    }

  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));
  if (!input_u32)
    return IDN2_MALLOC;

  u32_cpy (input_u32, input, inlen);
  input_u32[inlen] = 0;

  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);
  free (input_u32);
  if (!input_u8)
    {
      if (errno == ENOMEM)
	return IDN2_MALLOC;
      return IDN2_ENCODING_ERROR;
    }

  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);
  free (input_u8);

  if (rc == IDN2_OK)
    {
      /* wow, this is ugly, but libidn manpage states:
       * char * out  output zero terminated string that must have room for at
       * least 63 characters plus the terminating zero.
       */
      if (output)
	strcpy (output, (const char *) output_u8);

      free(output_u8);
    }

  return rc;
}
",1,8434
libidn/libidn2,e4d1558aa2c1c04a05066ee8600f37603890ba8c,"  uint32_t *tmp = (uint32_t *) malloc ((len2 + 1) * sizeof (uint32_t));
  if (!tmp)
    {
",0,8435
torvalds/linux,c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed,"static ssize_t sof_dfsentry_write(struct file *file, const char __user *buffer,
				  size_t count, loff_t *ppos)
{
#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)
	struct snd_sof_dfsentry *dfse = file->private_data;
	struct snd_sof_dev *sdev = dfse->sdev;
	unsigned long ipc_duration_ms = 0;
	bool flood_duration_test = false;
	unsigned long ipc_count = 0;
	struct dentry *dentry;
	int err;
#endif
	size_t size;
	char *string;
	int ret;

	string = kzalloc(count, GFP_KERNEL);
	if (!string)
		return -ENOMEM;

	size = simple_write_to_buffer(string, count, ppos, buffer, count);
	ret = size;

#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)
	/*
	 * write op is only supported for ipc_flood_count or
	 * ipc_flood_duration_ms debugfs entries atm.
	 * ipc_flood_count floods the DSP with the number of IPC's specified.
	 * ipc_duration_ms test floods the DSP for the time specified
	 * in the debugfs entry.
	 */
	dentry = file->f_path.dentry;
	if (strcmp(dentry->d_name.name, 'ipc_flood_count') &&
	    strcmp(dentry->d_name.name, 'ipc_flood_duration_ms'))
		return -EINVAL;

	if (!strcmp(dentry->d_name.name, 'ipc_flood_duration_ms'))
		flood_duration_test = true;

	/* test completion criterion */
	if (flood_duration_test)
		ret = kstrtoul(string, 0, &ipc_duration_ms);
	else
		ret = kstrtoul(string, 0, &ipc_count);
	if (ret < 0)
		goto out;

	/* limit max duration/ipc count for flood test */
	if (flood_duration_test) {
		if (!ipc_duration_ms) {
			ret = size;
			goto out;
		}

		/* find the minimum. min() is not used to avoid warnings */
		if (ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS)
			ipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS;
	} else {
		if (!ipc_count) {
			ret = size;
			goto out;
		}

		/* find the minimum. min() is not used to avoid warnings */
		if (ipc_count > MAX_IPC_FLOOD_COUNT)
			ipc_count = MAX_IPC_FLOOD_COUNT;
	}

	ret = pm_runtime_get_sync(sdev->dev);
	if (ret < 0) {
		dev_err_ratelimited(sdev->dev,
				    'error: debugfs write failed to resume %d\n',
				    ret);
		pm_runtime_put_noidle(sdev->dev);
		goto out;
	}

	/* flood test */
	ret = sof_debug_ipc_flood_test(sdev, dfse, flood_duration_test,
				       ipc_duration_ms, ipc_count);

	pm_runtime_mark_last_busy(sdev->dev);
	err = pm_runtime_put_autosuspend(sdev->dev);
	if (err < 0)
		dev_err_ratelimited(sdev->dev,
				    'error: debugfs write failed to idle %d\n',
				    err);

	/* return size if test is successful */
	if (ret >= 0)
		ret = size;
out:
#endif
	kfree(string);
	return ret;
}
",1,8436
torvalds/linux,c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed,"static ssize_t sof_dfsentry_read(struct file *file, char __user *buffer,
				 size_t count, loff_t *ppos)
{
	struct snd_sof_dfsentry *dfse = file->private_data;
	struct snd_sof_dev *sdev = dfse->sdev;
	loff_t pos = *ppos;
	size_t size_ret;
	int skip = 0;
	int size;
	u8 *buf;

#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)
	struct dentry *dentry;

	dentry = file->f_path.dentry;
	if ((!strcmp(dentry->d_name.name, 'ipc_flood_count') ||
	     !strcmp(dentry->d_name.name, 'ipc_flood_duration_ms')) &&
	    dfse->cache_buf) {
		if (*ppos)
			return 0;

		count = strlen(dfse->cache_buf);
		size_ret = copy_to_user(buffer, dfse->cache_buf, count);
		if (size_ret)
			return -EFAULT;

		*ppos += count;
		return count;
	}
#endif
	size = dfse->size;

	/* validate position & count */
	if (pos < 0)
		return -EINVAL;
	if (pos >= size || !count)
		return 0;
	/* find the minimum. min() is not used since it adds sparse warnings */
	if (count > size - pos)
		count = size - pos;

	/* align io read start to u32 multiple */
	pos = ALIGN_DOWN(pos, 4);

	/* intermediate buffer size must be u32 multiple */
	size = ALIGN(count, 4);

	/* if start position is unaligned, read extra u32 */
	if (unlikely(pos != *ppos)) {
		skip = *ppos - pos;
		if (pos + size + 4 < dfse->size)
			size += 4;
	}

	buf = kzalloc(size, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	if (dfse->type == SOF_DFSENTRY_TYPE_IOMEM) {
#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)
		/*
		 * If the DSP is active: copy from IO.
		 * If the DSP is suspended:
		 *	- Copy from IO if the memory is always accessible.
		 *	- Otherwise, copy from cached buffer.
		 */
		if (pm_runtime_active(sdev->dev) ||
		    dfse->access_type == SOF_DEBUGFS_ACCESS_ALWAYS) {
			memcpy_fromio(buf, dfse->io_mem + pos, size);
		} else {
			dev_info(sdev->dev,
				 'Copying cached debugfs data\n');
			memcpy(buf, dfse->cache_buf + pos, size);
		}
#else
		/* if the DSP is in D3 */
		if (!pm_runtime_active(sdev->dev) &&
		    dfse->access_type == SOF_DEBUGFS_ACCESS_D0_ONLY) {
			dev_err(sdev->dev,
				'error: debugfs entry cannot be read in DSP D3\n');
			kfree(buf);
			return -EINVAL;
		}

		memcpy_fromio(buf, dfse->io_mem + pos, size);
#endif
	} else {
		memcpy(buf, ((u8 *)(dfse->buf) + pos), size);
	}

	/* copy to userspace */
	size_ret = copy_to_user(buffer, buf + skip, count);

	kfree(buf);

	/* update count & position if copy succeeded */
	if (size_ret)
		return -EFAULT;

	*ppos = pos + count;

	return count;
}
",0,8437
torvalds/linux,bbe692e349e2a1edf3fe0a29a0e05899c9c94d51,"static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,
				       struct iov_iter *from)
{
	struct file *filp = iocb->ki_filp;
	struct rpmsg_eptdev *eptdev = filp->private_data;
	size_t len = iov_iter_count(from);
	void *kbuf;
	int ret;

	kbuf = kzalloc(len, GFP_KERNEL);
	if (!kbuf)
		return -ENOMEM;

	if (!copy_from_iter_full(kbuf, len, from))
		return -EFAULT;

	if (mutex_lock_interruptible(&eptdev->ept_lock)) {
		ret = -ERESTARTSYS;
		goto free_kbuf;
	}

	if (!eptdev->ept) {
		ret = -EPIPE;
		goto unlock_eptdev;
	}

	if (filp->f_flags & O_NONBLOCK)
		ret = rpmsg_trysend(eptdev->ept, kbuf, len);
	else
		ret = rpmsg_send(eptdev->ept, kbuf, len);

unlock_eptdev:
	mutex_unlock(&eptdev->ept_lock);

free_kbuf:
	kfree(kbuf);
	return ret < 0 ? ret : len;
}
",1,8438
torvalds/linux,bbe692e349e2a1edf3fe0a29a0e05899c9c94d51,"static long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,
				unsigned long arg)
{
	struct rpmsg_ctrldev *ctrldev = fp->private_data;
	void __user *argp = (void __user *)arg;
	struct rpmsg_endpoint_info eptinfo;
	struct rpmsg_channel_info chinfo;

	if (cmd != RPMSG_CREATE_EPT_IOCTL)
		return -EINVAL;

	if (copy_from_user(&eptinfo, argp, sizeof(eptinfo)))
		return -EFAULT;

	memcpy(chinfo.name, eptinfo.name, RPMSG_NAME_SIZE);
	chinfo.name[RPMSG_NAME_SIZE-1] = '\0';
	chinfo.src = eptinfo.src;
	chinfo.dst = eptinfo.dst;

	return rpmsg_eptdev_create(ctrldev, chinfo);
};
",0,8439
torvalds/linux,a7b2df76b42bdd026e3106cf2ba97db41345a177,"int cx23888_ir_probe(struct cx23885_dev *dev)
{
	struct cx23888_ir_state *state;
	struct v4l2_subdev *sd;
	struct v4l2_subdev_ir_parameters default_params;
	int ret;

	state = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);
	if (state == NULL)
		return -ENOMEM;

	spin_lock_init(&state->rx_kfifo_lock);
	if (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))
		return -ENOMEM;

	state->dev = dev;
	sd = &state->sd;

	v4l2_subdev_init(sd, &cx23888_ir_controller_ops);
	v4l2_set_subdevdata(sd, state);
	/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */
	snprintf(sd->name, sizeof(sd->name), '%s/888-ir', dev->name);
	sd->grp_id = CX23885_HW_888_IR;

	ret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);
	if (ret == 0) {
		/*
		 * Ensure no interrupts arrive from '888 specific conditions,
		 * since we ignore them in this driver to have commonality with
		 * similar IR controller cores.
		 */
		cx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);

		mutex_init(&state->rx_params_lock);
		default_params = default_rx_params;
		v4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);

		mutex_init(&state->tx_params_lock);
		default_params = default_tx_params;
		v4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);
	} else {
		kfifo_free(&state->rx_kfifo);
	}
	return ret;
}
",1,8440
torvalds/linux,a7b2df76b42bdd026e3106cf2ba97db41345a177,"static void control_rx_s_carrier_window(struct cx23885_dev *dev,
					unsigned int carrier,
					unsigned int *carrier_range_low,
					unsigned int *carrier_range_high)
{
	u32 v;
	unsigned int c16 = carrier * 16;

	if (*carrier_range_low < DIV_ROUND_CLOSEST(c16, 16 + 3)) {
		v = CNTRL_WIN_3_4;
		*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 4);
	} else {
		v = CNTRL_WIN_3_3;
		*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 3);
	}

	if (*carrier_range_high > DIV_ROUND_CLOSEST(c16, 16 - 3)) {
		v |= CNTRL_WIN_4_3;
		*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 4);
	} else {
		v |= CNTRL_WIN_3_3;
		*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 3);
	}
	cx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_WIN, v);
}
",0,8441
torvalds/linux,b4b814fec1a5a849383f7b3886b654a13abbda7d,"static struct scatterlist *alloc_sgtable(int size)
{
	int alloc_size, nents, i;
	struct page *new_page;
	struct scatterlist *iter;
	struct scatterlist *table;

	nents = DIV_ROUND_UP(size, PAGE_SIZE);
	table = kcalloc(nents, sizeof(*table), GFP_KERNEL);
	if (!table)
		return NULL;
	sg_init_table(table, nents);
	iter = table;
	for_each_sg(table, iter, sg_nents(table), i) {
		new_page = alloc_page(GFP_KERNEL);
		if (!new_page) {
			/* release all previous allocated pages in the table */
			iter = table;
			for_each_sg(table, iter, sg_nents(table), i) {
				new_page = sg_page(iter);
				if (new_page)
					__free_page(new_page);
			}
			return NULL;
		}
		alloc_size = min_t(int, size, PAGE_SIZE);
		size -= PAGE_SIZE;
		sg_set_page(iter, new_page, alloc_size, 0);
	}
	return table;
}
",1,8442
torvalds/linux,b4b814fec1a5a849383f7b3886b654a13abbda7d,"int iwl_fw_start_dbg_conf(struct iwl_fw_runtime *fwrt, u8 conf_id)
{
	u8 *ptr;
	int ret;
	int i;

	if (WARN_ONCE(conf_id >= ARRAY_SIZE(fwrt->fw->dbg.conf_tlv),
		      'Invalid configuration %d\n', conf_id))
		return -EINVAL;

	/* EARLY START - firmware's configuration is hard coded */
	if ((!fwrt->fw->dbg.conf_tlv[conf_id] ||
	     !fwrt->fw->dbg.conf_tlv[conf_id]->num_of_hcmds) &&
	    conf_id == FW_DBG_START_FROM_ALIVE)
		return 0;

	if (!fwrt->fw->dbg.conf_tlv[conf_id])
		return -EINVAL;

	if (fwrt->dump.conf != FW_DBG_INVALID)
		IWL_WARN(fwrt, 'FW already configured (%d) - re-configuring\n',
			 fwrt->dump.conf);

	/* Send all HCMDs for configuring the FW debug */
	ptr = (void *)&fwrt->fw->dbg.conf_tlv[conf_id]->hcmd;
	for (i = 0; i < fwrt->fw->dbg.conf_tlv[conf_id]->num_of_hcmds; i++) {
		struct iwl_fw_dbg_conf_hcmd *cmd = (void *)ptr;
		struct iwl_host_cmd hcmd = {
			.id = cmd->id,
			.len = { le16_to_cpu(cmd->len), },
			.data = { cmd->data, },
		};

		ret = iwl_trans_send_cmd(fwrt->trans, &hcmd);
		if (ret)
			return ret;

		ptr += sizeof(*cmd);
		ptr += le16_to_cpu(cmd->len);
	}

	fwrt->dump.conf = conf_id;

	return 0;
}
",0,8443
torvalds/linux,3f93616951138a598d930dcaec40f2bfd9ce43bb,"int rtl_usb_probe(struct usb_interface *intf,
		  const struct usb_device_id *id,
		  struct rtl_hal_cfg *rtl_hal_cfg)
{
	int err;
	struct ieee80211_hw *hw = NULL;
	struct rtl_priv *rtlpriv = NULL;
	struct usb_device	*udev;
	struct rtl_usb_priv *usb_priv;

	hw = ieee80211_alloc_hw(sizeof(struct rtl_priv) +
				sizeof(struct rtl_usb_priv), &rtl_ops);
	if (!hw) {
		WARN_ONCE(true, 'rtl_usb: ieee80211 alloc failed\n');
		return -ENOMEM;
	}
	rtlpriv = hw->priv;
	rtlpriv->hw = hw;
	rtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),
				    GFP_KERNEL);
	if (!rtlpriv->usb_data)
		return -ENOMEM;

	/* this spin lock must be initialized early */
	spin_lock_init(&rtlpriv->locks.usb_lock);
	INIT_WORK(&rtlpriv->works.fill_h2c_cmd,
		  rtl_fill_h2c_cmd_work_callback);
	INIT_WORK(&rtlpriv->works.lps_change_work,
		  rtl_lps_change_work_callback);

	rtlpriv->usb_data_index = 0;
	init_completion(&rtlpriv->firmware_loading_complete);
	SET_IEEE80211_DEV(hw, &intf->dev);
	udev = interface_to_usbdev(intf);
	usb_get_dev(udev);
	usb_priv = rtl_usbpriv(hw);
	memset(usb_priv, 0, sizeof(*usb_priv));
	usb_priv->dev.intf = intf;
	usb_priv->dev.udev = udev;
	usb_set_intfdata(intf, hw);
	/* init cfg & intf_ops */
	rtlpriv->rtlhal.interface = INTF_USB;
	rtlpriv->cfg = rtl_hal_cfg;
	rtlpriv->intf_ops = &rtl_usb_ops;
	/* Init IO handler */
	_rtl_usb_io_handler_init(&udev->dev, hw);
	rtlpriv->cfg->ops->read_chip_version(hw);
	/*like read eeprom and so on */
	rtlpriv->cfg->ops->read_eeprom_info(hw);
	err = _rtl_usb_init(hw);
	if (err)
		goto error_out2;
	rtl_usb_init_sw(hw);
	/* Init mac80211 sw */
	err = rtl_init_core(hw);
	if (err) {
		pr_err('Can't allocate sw for mac80211\n');
		goto error_out2;
	}
	if (rtlpriv->cfg->ops->init_sw_vars(hw)) {
		pr_err('Can't init_sw_vars\n');
		goto error_out;
	}
	rtlpriv->cfg->ops->init_sw_leds(hw);

	err = ieee80211_register_hw(hw);
	if (err) {
		pr_err('Can't register mac80211 hw.\n');
		err = -ENODEV;
		goto error_out;
	}
	rtlpriv->mac80211.mac80211_registered = 1;

	set_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);
	return 0;

error_out:
	rtl_deinit_core(hw);
error_out2:
	_rtl_usb_io_handler_release(hw);
	usb_put_dev(udev);
	complete(&rtlpriv->firmware_loading_complete);
	return -ENODEV;
}
",1,8444
torvalds/linux,3f93616951138a598d930dcaec40f2bfd9ce43bb,"static void _rtl_rx_completed(struct urb *urb);
",0,8445
CESNET/libyang,f6d684ade99dd37b21babaa8a856f64faa1e2e0d,"static int
make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)
{
    const uint16_t buf_len = 511;
    char buf[buf_len + 1];
    struct lys_type_bit **bits = NULL;
    struct lyxp_expr *exp;
    const char *module_name, *cur_expr, *end;
    int i, j, count;
    int64_t num;
    uint64_t unum;
    uint8_t c;

    switch (type) {
    case LY_TYPE_BITS:
        bits = (struct lys_type_bit **)data1;
        count = *((int *)data2);
        /* in canonical form, the bits are ordered by their position */
        buf[0] = '\0';
        for (i = 0; i < count; i++) {
            if (!bits[i]) {
                /* bit not set */
                continue;
            }
            if (buf[0]) {
                sprintf(buf + strlen(buf), ' %s', bits[i]->name);
            } else {
                strcpy(buf, bits[i]->name);
            }
        }
        break;

    case LY_TYPE_IDENT:
        module_name = (const char *)data1;
        /* identity must always have a prefix */
        if (!strchr(*value, ':')) {
            sprintf(buf, '%s:%s', module_name, *value);
        } else {
            strcpy(buf, *value);
        }
        break;

    case LY_TYPE_INST:
        exp = lyxp_parse_expr(ctx, *value);
        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), 0);

        module_name = NULL;
        count = 0;
        for (i = 0; (unsigned)i < exp->used; ++i) {
            cur_expr = &exp->expr[exp->expr_pos[i]];

            /* copy WS */
            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {
                if (count + (cur_expr - end) > buf_len) {
                    LOGINT(ctx);
                    lyxp_expr_free(exp);
                    return 0;
                }
                strncpy(&buf[count], end, cur_expr - end);
                count += cur_expr - end;
            }

            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {
                /* get the module name with ':' */
                ++end;
                j = end - cur_expr;

                if (!module_name || strncmp(cur_expr, module_name, j)) {
                    /* print module name with colon, it does not equal to the parent one */
                    if (count + j > buf_len) {
                        LOGINT(ctx);
                        lyxp_expr_free(exp);
                        return 0;
                    }
                    strncpy(&buf[count], cur_expr, j);
                    count += j;
                }
                module_name = cur_expr;

                /* copy the rest */
                if (count + (exp->tok_len[i] - j) > buf_len) {
                    LOGINT(ctx);
                    lyxp_expr_free(exp);
                    return 0;
                }
                strncpy(&buf[count], end, exp->tok_len[i] - j);
                count += exp->tok_len[i] - j;
            } else {
                if (count + exp->tok_len[i] > buf_len) {
                    LOGINT(ctx);
                    lyxp_expr_free(exp);
                    return 0;
                }
                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);
                count += exp->tok_len[i];
            }
        }
        if (count > buf_len) {
            LOGINT(ctx);
            lyxp_expr_free(exp);
            return 0;
        }
        buf[count] = '\0';

        lyxp_expr_free(exp);
        break;

    case LY_TYPE_DEC64:
        num = *((int64_t *)data1);
        c = *((uint8_t *)data2);
        if (num) {
            count = sprintf(buf, '%'PRId64' ', num);
            if ( (num > 0 && (count - 1) <= c)
                 || (count - 2) <= c ) {
                /* we have 0. value, print the value with the leading zeros
                 * (one for 0. and also keep the correct with of num according
                 * to fraction-digits value)
                 * for (num<0) - extra character for '-' sign */
                count = sprintf(buf, '%0*'PRId64' ', (num > 0) ? (c + 1) : (c + 2), num);
            }
            for (i = c, j = 1; i > 0 ; i--) {
                if (j && i > 1 && buf[count - 2] == '0') {
                    /* we have trailing zero to skip */
                    buf[count - 1] = '\0';
                } else {
                    j = 0;
                    buf[count - 1] = buf[count - 2];
                }
                count--;
            }
            buf[count - 1] = '.';
        } else {
            /* zero */
            sprintf(buf, '0.0');
        }
        break;

    case LY_TYPE_INT8:
    case LY_TYPE_INT16:
    case LY_TYPE_INT32:
    case LY_TYPE_INT64:
        num = *((int64_t *)data1);
        sprintf(buf, '%'PRId64, num);
        break;

    case LY_TYPE_UINT8:
    case LY_TYPE_UINT16:
    case LY_TYPE_UINT32:
    case LY_TYPE_UINT64:
        unum = *((uint64_t *)data1);
        sprintf(buf, '%'PRIu64, unum);
        break;

    default:
        /* should not be even called - just do nothing */
        return 0;
    }

    if (strcmp(buf, *value)) {
        lydict_remove(ctx, *value);
        *value = lydict_insert(ctx, buf, 0);
        return 1;
    }

    return 0;
}
",1,8446
CESNET/libyang,f6d684ade99dd37b21babaa8a856f64faa1e2e0d,"struct lys_type *
lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *xml,
                struct lyd_node_leaf_list *leaf, struct lyd_attr *attr, struct lys_module *local_mod,
                int store, int dflt, int trusted)
{
    struct lys_type *ret = NULL, *t;
    struct lys_tpdf *tpdf;
    enum int_log_opts prev_ilo;
    int c, len, found = 0;
    unsigned int i, j;
    int64_t num;
    uint64_t unum, uind, u = 0;
    const char *ptr, *value = *value_, *itemname, *old_val_str = NULL;
    struct lys_type_bit **bits = NULL;
    struct lys_ident *ident;
    lyd_val *val, old_val;
    LY_DATA_TYPE *val_type, old_val_type;
    uint8_t *val_flags, old_val_flags;
    struct lyd_node *contextnode;
    struct ly_ctx *ctx = type->parent->module->ctx;

    assert(leaf || attr);

    if (leaf) {
        assert(!attr);
        if (!local_mod) {
            local_mod = leaf->schema->module;
        }
        val = &leaf->value;
        val_type = &leaf->value_type;
        val_flags = &leaf->value_flags;
        contextnode = (struct lyd_node *)leaf;
        itemname = leaf->schema->name;
    } else {
        assert(!leaf);
        if (!local_mod) {
            local_mod = attr->annotation->module;
        }
        val = &attr->value;
        val_type = &attr->value_type;
        val_flags = &attr->value_flags;
        contextnode = attr->parent;
        itemname = attr->name;
    }

    /* fully clear the value */
    if (store) {
        old_val_str = lydict_insert(ctx, *value_, 0);
        lyd_free_value(*val, *val_type, *val_flags, type, old_val_str, &old_val, &old_val_type, &old_val_flags);
        *val_flags &= ~LY_VALUE_UNRES;
    }

    switch (type->base) {
    case LY_TYPE_BINARY:
        /* get number of octets for length validation */
        unum = 0;
        ptr = NULL;
        if (value) {
            /* silently skip leading/trailing whitespaces */
            for (uind = 0; isspace(value[uind]); ++uind);
            ptr = &value[uind];
            u = strlen(ptr);
            while (u && isspace(ptr[u - 1])) {
                --u;
            }
            unum = u;
            for (uind = 0; uind < u; ++uind) {
                if (ptr[uind] == '\n') {
                    unum--;
                } else if ((ptr[uind] < '/' && ptr[uind] != '+') ||
                    (ptr[uind] > '9' && ptr[uind] < 'A') ||
                    (ptr[uind] > 'Z' && ptr[uind] < 'a') || ptr[uind] > 'z') {
                    if (ptr[uind] == '=') {
                        /* padding */
                        if (uind == u - 2 && ptr[uind + 1] == '=') {
                            found = 2;
                            uind++;
                        } else if (uind == u - 1) {
                            found = 1;
                        }
                    }
                    if (!found) {
                        /* error */
                        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYD, contextnode, ptr[uind], &ptr[uind]);
                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, 'Invalid Base64 character.');
                        goto error;
                    }
                }
            }
        }

        if (unum & 3) {
            /* base64 length must be multiple of 4 chars */
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value);
            }
            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, 'Base64 encoded value length must be divisible by 4.');
            goto error;
        }

        /* length of the encoded string */
        len = ((unum / 4) * 3) - found;
        if (!trusted && validate_length_range(0, len, 0, 0, 0, type, value, contextnode)) {
            goto error;
        }

        if (value && (ptr != value || ptr[u] != '\0')) {
            /* update the changed value */
            ptr = lydict_insert(ctx, ptr, u);
            lydict_remove(ctx, *value_);
            *value_ = ptr;
        }

        if (store) {
            /* store the result */
            val->binary = value;
            *val_type = LY_TYPE_BINARY;
        }
        break;

    case LY_TYPE_BITS:
        /* locate bits structure with the bits definitions
         * since YANG 1.1 allows restricted bits, it is the first
         * bits type with some explicit bit specification */
        for (; !type->info.bits.count; type = &type->der->type);

        if (value || store) {
            /* allocate the array of pointers to bits definition */
            bits = calloc(type->info.bits.count, sizeof *bits);
            LY_CHECK_ERR_GOTO(!bits, LOGMEM(ctx), error);
        }

        if (!value) {
            /* no bits set */
            if (store) {
                /* store empty array */
                val->bit = bits;
                *val_type = LY_TYPE_BITS;
            }
            break;
        }

        c = 0;
        i = 0;
        while (value[c]) {
            /* skip leading whitespaces */
            while (isspace(value[c])) {
                c++;
            }
            if (!value[c]) {
                /* trailing white spaces */
                break;
            }

            /* get the length of the bit identifier */
            for (len = 0; value[c] && !isspace(value[c]); c++, len++);

            /* go back to the beginning of the identifier */
            c = c - len;

            /* find bit definition, identifiers appear ordered by their position */
            for (found = i = 0; i < type->info.bits.count; i++) {
                if (!strncmp(type->info.bits.bit[i].name, &value[c], len) && !type->info.bits.bit[i].name[len]) {
                    /* we have match, check if the value is enabled ... */
                    for (j = 0; !trusted && (j < type->info.bits.bit[i].iffeature_size); j++) {
                        if (!resolve_iffeature(&type->info.bits.bit[i].iffeature[j])) {
                            if (leaf) {
                                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);
                            } else {
                                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value);
                            }
                            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,
                                   'Bit \'%s\' is disabled by its %d. if-feature condition.',
                                   type->info.bits.bit[i].name, j + 1);
                            free(bits);
                            goto error;
                        }
                    }
                    /* check that the value was not already set */
                    if (bits[i]) {
                        if (leaf) {
                            LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);
                        } else {
                            LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value);
                        }
                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, 'Bit \'%s\' used multiple times.',
                               type->info.bits.bit[i].name);
                        free(bits);
                        goto error;
                    }
                    /* ... and then store the pointer */
                    bits[i] = &type->info.bits.bit[i];

                    /* stop searching */
                    found = 1;
                    break;
                }
            }

            if (!found) {
                /* referenced bit value does not exist */
                if (leaf) {
                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);
                } else {
                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value);
                }
                free(bits);
                goto error;
            }
            c = c + len;
        }

        make_canonical(ctx, LY_TYPE_BITS, value_, bits, &type->info.bits.count);

        if (store) {
            /* store the result */
            val->bit = bits;
            *val_type = LY_TYPE_BITS;
        } else {
            free(bits);
        }
        break;

    case LY_TYPE_BOOL:
        if (value && !strcmp(value, 'true')) {
            if (store) {
                val->bln = 1;
            }
        } else if (!value || strcmp(value, 'false')) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value ? value : '', itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value ? value : '');
            }
            goto error;
        } else {
            if (store) {
                val->bln = 0;
            }
        }

        if (store) {
            *val_type = LY_TYPE_BOOL;
        }
        break;

    case LY_TYPE_DEC64:
        if (!value || !value[0]) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, '', itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, '');
            }
            goto error;
        }

        ptr = value;
        if (parse_range_dec64(&ptr, type->info.dec64.dig, &num) || ptr[0]) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value);
            }
            goto error;
        }

        if (!trusted && validate_length_range(2, 0, 0, num, type->info.dec64.dig, type, value, contextnode)) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_DEC64, value_, &num, &type->info.dec64.dig);

        if (store) {
            /* store the result */
            val->dec64 = num;
            *val_type = LY_TYPE_DEC64;
        }
        break;

    case LY_TYPE_EMPTY:
        if (value && value[0]) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value);
            }
            goto error;
        }

        if (store) {
            *val_type = LY_TYPE_EMPTY;
        }
        break;

    case LY_TYPE_ENUM:
        /* locate enums structure with the enumeration definitions,
         * since YANG 1.1 allows restricted enums, it is the first
         * enum type with some explicit enum specification */
        for (; !type->info.enums.count; type = &type->der->type);

        /* find matching enumeration value */
        for (i = found = 0; i < type->info.enums.count; i++) {
            if (value && !strcmp(value, type->info.enums.enm[i].name)) {
                /* we have match, check if the value is enabled ... */
                for (j = 0; !trusted && (j < type->info.enums.enm[i].iffeature_size); j++) {
                    if (!resolve_iffeature(&type->info.enums.enm[i].iffeature[j])) {
                        if (leaf) {
                            LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);
                        } else {
                            LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value);
                        }
                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, 'Enum \'%s\' is disabled by its %d. if-feature condition.',
                               value, j + 1);
                        goto error;
                    }
                }
                /* ... and store pointer to the definition */
                if (store) {
                    val->enm = &type->info.enums.enm[i];
                    *val_type = LY_TYPE_ENUM;
                }
                found = 1;
                break;
            }
        }

        if (!found) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value ? value : '', itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, value ? value : '');
            }
            goto error;
        }
        break;

    case LY_TYPE_IDENT:
        if (!value) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, '', itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, '');
            }
            goto error;
        }

        if (xml) {
            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);
            /* first, convert value into the json format, silently */
            value = transform_xml2json(ctx, value, xml, 0, 0);
            ly_ilo_restore(NULL, prev_ilo, NULL, 0);
            if (!value) {
                /* invalid identityref format */
                if (leaf) {
                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);
                } else {
                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, *value_);
                }
                goto error;
            }

            /* the value has no prefix (default namespace), but the element's namespace has a prefix, find default namespace */
            if (!strchr(value, ':') && xml->ns->prefix) {
                value = ident_val_add_module_prefix(value, xml, ctx);
                if (!value) {
                    goto error;
                }
            }
        } else if (dflt) {
            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);
            /* the value actually uses module's prefixes instead of the module names as in JSON format,
             * we have to convert it */
            value = transform_schema2json(local_mod, value);
            ly_ilo_restore(NULL, prev_ilo, NULL, 0);
            if (!value) {
                /* invalid identityref format or it was already transformed, so ignore the error here */
                value = lydict_insert(ctx, *value_, 0);
            }
        } else {
            value = lydict_insert(ctx, *value_, 0);
        }
        /* value is now in the dictionary, whether it differs from *value_ or not */

        ident = resolve_identref(type, value, contextnode, local_mod, dflt);
        if (!ident) {
            lydict_remove(ctx, value);
            goto error;
        } else if (store) {
            /* store the result */
            val->ident = ident;
            *val_type = LY_TYPE_IDENT;
        }

        /* the value is always changed and includes prefix */
        if (dflt) {
            type->parent->flags |= LYS_DFLTJSON;
        }

        make_canonical(ctx, LY_TYPE_IDENT, &value, (void*)lys_main_module(local_mod)->name, NULL);

        /* replace the old value with the new one (even if they may be the same) */
        lydict_remove(ctx, *value_);
        *value_ = value;
        break;

    case LY_TYPE_INST:
        if (!value) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, '', itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, '');
            }
            goto error;
        }

        if (xml) {
            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);
            /* first, convert value into the json format, silently */
            value = transform_xml2json(ctx, value, xml, 1, 1);
            ly_ilo_restore(NULL, prev_ilo, NULL, 0);
            if (!value) {
                /* invalid instance-identifier format */
                if (leaf) {
                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);
                } else {
                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, *value_);
                }
                goto error;
            } else if (ly_strequal(value, *value_, 1)) {
                /* we have actually created the same expression (prefixes are the same as the module names)
                 * so we have just increased dictionary's refcount - fix it */
                lydict_remove(ctx, value);
            }
        } else if (dflt) {
            /* turn logging off */
            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);

            /* the value actually uses module's prefixes instead of the module names as in JSON format,
             * we have to convert it */
            value = transform_schema2json(local_mod, value);
            if (!value) {
                /* invalid identityref format or it was already transformed, so ignore the error here */
                value = *value_;
            } else if (ly_strequal(value, *value_, 1)) {
                /* we have actually created the same expression (prefixes are the same as the module names)
                 * so we have just increased dictionary's refcount - fix it */
                lydict_remove(ctx, value);
            }
            /* turn logging back on */
            ly_ilo_restore(NULL, prev_ilo, NULL, 0);
        } else {
            if (make_canonical(ctx, LY_TYPE_INST, &value, NULL, NULL)) {
                /* if a change occurred, value was removed from the dictionary so fix the pointers */
                *value_ = value;
            }
        }

        if (store) {
            /* note that the data node is an unresolved instance-identifier */
            val->instance = NULL;
            *val_type = LY_TYPE_INST;
            *val_flags |= LY_VALUE_UNRES;
        }

        if (!ly_strequal(value, *value_, 1)) {
            /* update the changed value */
            lydict_remove(ctx, *value_);
            *value_ = value;

            /* we have to remember the conversion into JSON format to be able to print it in correct form */
            if (dflt) {
                type->parent->flags |= LYS_DFLTJSON;
            }
        }
        break;

    case LY_TYPE_LEAFREF:
        if (!value) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, '', itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, '');
            }
            goto error;
        }

        /* it is called not only to get the final type, but mainly to update value to canonical or JSON form
         * if needed */
        t = lyp_parse_value(&type->info.lref.target->type, value_, xml, leaf, attr, NULL, store, dflt, trusted);
        value = *value_; /* refresh possibly changed value */
        if (!t) {
            /* already logged */
            goto error;
        }

        if (store) {
            /* make the note that the data node is an unresolved leafref (value union was already filled) */
            *val_flags |= LY_VALUE_UNRES;
        }

        type = t;
        break;

    case LY_TYPE_STRING:
        if (!trusted && validate_length_range(0, (value ? ly_strlen_utf8(value) : 0), 0, 0, 0, type, value, contextnode)) {
            goto error;
        }

        if (!trusted && validate_pattern(ctx, value, type, contextnode)) {
            goto error;
        }

        /* special handling of ietf-yang-types xpath1.0 */
        for (tpdf = type->der;
             tpdf->module && (strcmp(tpdf->name, 'xpath1.0') || strcmp(tpdf->module->name, 'ietf-yang-types'));
             tpdf = tpdf->type.der);
        if (tpdf->module && xml) {
            /* convert value into the json format */
            value = transform_xml2json(ctx, value ? value : '', xml, 1, 1);
            if (!value) {
                /* invalid instance-identifier format */
                if (leaf) {
                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);
                } else {
                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, *value_);
                }
                goto error;
            }

            if (!ly_strequal(value, *value_, 1)) {
                /* update the changed value */
                lydict_remove(ctx, *value_);
                *value_ = value;
            }
        }

        if (store) {
            /* store the result */
            val->string = value;
            *val_type = LY_TYPE_STRING;
        }
        break;

    case LY_TYPE_INT8:
        if (parse_int(value, __INT64_C(-128), __INT64_C(127), dflt ? 0 : 10, &num, contextnode)
                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_INT8, value_, &num, NULL);

        if (store) {
            /* store the result */
            val->int8 = (int8_t)num;
            *val_type = LY_TYPE_INT8;
        }
        break;

    case LY_TYPE_INT16:
        if (parse_int(value, __INT64_C(-32768), __INT64_C(32767), dflt ? 0 : 10, &num, contextnode)
                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_INT16, value_, &num, NULL);

        if (store) {
            /* store the result */
            val->int16 = (int16_t)num;
            *val_type = LY_TYPE_INT16;
        }
        break;

    case LY_TYPE_INT32:
        if (parse_int(value, __INT64_C(-2147483648), __INT64_C(2147483647), dflt ? 0 : 10, &num, contextnode)
                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_INT32, value_, &num, NULL);

        if (store) {
            /* store the result */
            val->int32 = (int32_t)num;
            *val_type = LY_TYPE_INT32;
        }
        break;

    case LY_TYPE_INT64:
        if (parse_int(value, __INT64_C(-9223372036854775807) - __INT64_C(1), __INT64_C(9223372036854775807),
                      dflt ? 0 : 10, &num, contextnode)
                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_INT64, value_, &num, NULL);

        if (store) {
            /* store the result */
            val->int64 = num;
            *val_type = LY_TYPE_INT64;
        }
        break;

    case LY_TYPE_UINT8:
        if (parse_uint(value, __UINT64_C(255), dflt ? 0 : 10, &unum, contextnode)
                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_UINT8, value_, &unum, NULL);

        if (store) {
            /* store the result */
            val->uint8 = (uint8_t)unum;
            *val_type = LY_TYPE_UINT8;
        }
        break;

    case LY_TYPE_UINT16:
        if (parse_uint(value, __UINT64_C(65535), dflt ? 0 : 10, &unum, contextnode)
                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_UINT16, value_, &unum, NULL);

        if (store) {
            /* store the result */
            val->uint16 = (uint16_t)unum;
            *val_type = LY_TYPE_UINT16;
        }
        break;

    case LY_TYPE_UINT32:
        if (parse_uint(value, __UINT64_C(4294967295), dflt ? 0 : 10, &unum, contextnode)
                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_UINT32, value_, &unum, NULL);

        if (store) {
            /* store the result */
            val->uint32 = (uint32_t)unum;
            *val_type = LY_TYPE_UINT32;
        }
        break;

    case LY_TYPE_UINT64:
        if (parse_uint(value, __UINT64_C(18446744073709551615), dflt ? 0 : 10, &unum, contextnode)
                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {
            goto error;
        }

        make_canonical(ctx, LY_TYPE_UINT64, value_, &unum, NULL);

        if (store) {
            /* store the result */
            val->uint64 = unum;
            *val_type = LY_TYPE_UINT64;
        }
        break;

    case LY_TYPE_UNION:
        if (store) {
            /* unresolved union type */
            memset(val, 0, sizeof(lyd_val));
            *val_type = LY_TYPE_UNION;
        }

        if (type->info.uni.has_ptr_type) {
            /* we are not resolving anything here, only parsing, and in this case we cannot decide
             * the type without resolving it -> we return the union type (resolve it with resolve_union()) */
            if (xml) {
                /* in case it should resolve into a instance-identifier, we can only do the JSON conversion here */
                ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);
                val->string = transform_xml2json(ctx, value, xml, 1, 1);
                ly_ilo_restore(NULL, prev_ilo, NULL, 0);
                if (!val->string) {
                    /* invalid instance-identifier format, likely some other type */
                    val->string = lydict_insert(ctx, value, 0);
                }
            }
            break;
        }

        t = NULL;
        found = 0;

        /* turn logging off, we are going to try to validate the value with all the types in order */
        ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);

        while ((t = lyp_get_next_union_type(type, t, &found))) {
            found = 0;
            ret = lyp_parse_value(t, value_, xml, leaf, attr, NULL, store, dflt, 0);
            if (ret) {
                /* we have the result */
                type = ret;
                break;
            }

            if (store) {
                /* erase possible present and invalid value data */
                lyd_free_value(*val, *val_type, *val_flags, t, *value_, NULL, NULL, NULL);
                memset(val, 0, sizeof(lyd_val));
            }
        }

        /* turn logging back on */
        ly_ilo_restore(NULL, prev_ilo, NULL, 0);

        if (!t) {
            /* not found */
            if (store) {
                *val_type = 0;
            }
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_ ? *value_ : '', itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, '<none>', itemname, *value_);
            }
            goto error;
        }
        break;

    default:
        LOGINT(ctx);
        goto error;
    }

    /* search user types in case this value is supposed to be stored in a custom way */
    if (store && type->der && type->der->module) {
        c = lytype_store(type->der->module, type->der->name, value_, val);
        if (c == -1) {
            goto error;
        } else if (!c) {
            *val_flags |= LY_VALUE_USER;
        }
    }

    /* free backup */
    if (store) {
        lyd_free_value(old_val, old_val_type, old_val_flags, type, old_val_str, NULL, NULL, NULL);
        lydict_remove(ctx, old_val_str);
    }
    return type;

error:
    /* restore the backup */
    if (store) {
        *val = old_val;
        *val_type = old_val_type;
        *val_flags = old_val_flags;
        lydict_remove(ctx, old_val_str);
    }
    return NULL;
}
",1,8447
CESNET/libyang,f6d684ade99dd37b21babaa8a856f64faa1e2e0d,"    [LY_STMT_OUTPUT] = 'output',
    [LY_STMT_RPC] = 'rpc',
",0,8448
CESNET/libyang,f6d684ade99dd37b21babaa8a856f64faa1e2e0d,"
    if (node->nodetype & (LYS_RPC | LYS_ACTION)) {
        return 1;
",0,8449
torvalds/linux,4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,"static void ext4_clamp_want_extra_isize(struct super_block *sb)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	struct ext4_super_block *es = sbi->s_es;

	/* determine the minimum size of new large inodes, if present */
	if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&
	    sbi->s_want_extra_isize == 0) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						     EXT4_GOOD_OLD_INODE_SIZE;
		if (ext4_has_feature_extra_isize(sb)) {
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(es->s_want_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(es->s_want_extra_isize);
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(es->s_min_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(es->s_min_extra_isize);
		}
	}
	/* Check if enough inode space is available */
	if (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
							sbi->s_inode_size) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						       EXT4_GOOD_OLD_INODE_SIZE;
		ext4_msg(sb, KERN_INFO,
			 'required extra inode space not available');
	}
}
",1,8450
torvalds/linux,4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,"static int __ext4_expand_extra_isize(struct inode *inode,
				     unsigned int new_extra_isize,
				     struct ext4_iloc *iloc,
				     handle_t *handle, int *no_expand)
{
	struct ext4_inode *raw_inode;
	struct ext4_xattr_ibody_header *header;
	int error;

	raw_inode = ext4_raw_inode(iloc);

	header = IHDR(inode, raw_inode);

	/* No extended attributes present */
	if (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||
	    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {
		memset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE +
		       EXT4_I(inode)->i_extra_isize, 0,
		       new_extra_isize - EXT4_I(inode)->i_extra_isize);
		EXT4_I(inode)->i_extra_isize = new_extra_isize;
		return 0;
	}

	/* try to expand with EAs present */
	error = ext4_expand_extra_isize_ea(inode, new_extra_isize,
					   raw_inode, handle);
	if (error) {
		/*
		 * Inode size expansion failed; don't try again
		 */
		*no_expand = 1;
	}

	return error;
}
",1,8451
torvalds/linux,4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,"static int ext4_writepages(struct address_space *mapping,
			   struct writeback_control *wbc)
{
	pgoff_t	writeback_index = 0;
	long nr_to_write = wbc->nr_to_write;
	int range_whole = 0;
	int cycled = 1;
	handle_t *handle = NULL;
	struct mpage_da_data mpd;
	struct inode *inode = mapping->host;
	int needed_blocks, rsv_blocks = 0, ret = 0;
	struct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);
	bool done;
	struct blk_plug plug;
	bool give_up_on_write = false;

	if (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))
		return -EIO;

	percpu_down_read(&sbi->s_journal_flag_rwsem);
	trace_ext4_writepages(inode, wbc);

	/*
	 * No pages to write? This is mainly a kludge to avoid starting
	 * a transaction for special inodes like journal inode on last iput()
	 * because that could violate lock ordering on umount
	 */
	if (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))
		goto out_writepages;

	if (ext4_should_journal_data(inode)) {
		ret = generic_writepages(mapping, wbc);
		goto out_writepages;
	}

	/*
	 * If the filesystem has aborted, it is read-only, so return
	 * right away instead of dumping stack traces later on that
	 * will obscure the real source of the problem.  We test
	 * EXT4_MF_FS_ABORTED instead of sb->s_flag's SB_RDONLY because
	 * the latter could be true if the filesystem is mounted
	 * read-only, and in that case, ext4_writepages should
	 * *never* be called, so if that ever happens, we would want
	 * the stack trace.
	 */
	if (unlikely(ext4_forced_shutdown(EXT4_SB(mapping->host->i_sb)) ||
		     sbi->s_mount_flags & EXT4_MF_FS_ABORTED)) {
		ret = -EROFS;
		goto out_writepages;
	}

	/*
	 * If we have inline data and arrive here, it means that
	 * we will soon create the block for the 1st page, so
	 * we'd better clear the inline data here.
	 */
	if (ext4_has_inline_data(inode)) {
		/* Just inode will be modified... */
		handle = ext4_journal_start(inode, EXT4_HT_INODE, 1);
		if (IS_ERR(handle)) {
			ret = PTR_ERR(handle);
			goto out_writepages;
		}
		BUG_ON(ext4_test_inode_state(inode,
				EXT4_STATE_MAY_INLINE_DATA));
		ext4_destroy_inline_data(handle, inode);
		ext4_journal_stop(handle);
	}

	if (ext4_should_dioread_nolock(inode)) {
		/*
		 * We may need to convert up to one extent per block in
		 * the page and we may dirty the inode.
		 */
		rsv_blocks = 1 + ext4_chunk_trans_blocks(inode,
						PAGE_SIZE >> inode->i_blkbits);
	}

	if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)
		range_whole = 1;

	if (wbc->range_cyclic) {
		writeback_index = mapping->writeback_index;
		if (writeback_index)
			cycled = 0;
		mpd.first_page = writeback_index;
		mpd.last_page = -1;
	} else {
		mpd.first_page = wbc->range_start >> PAGE_SHIFT;
		mpd.last_page = wbc->range_end >> PAGE_SHIFT;
	}

	mpd.inode = inode;
	mpd.wbc = wbc;
	ext4_io_submit_init(&mpd.io_submit, wbc);
retry:
	if (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)
		tag_pages_for_writeback(mapping, mpd.first_page, mpd.last_page);
	done = false;
	blk_start_plug(&plug);

	/*
	 * First writeback pages that don't need mapping - we can avoid
	 * starting a transaction unnecessarily and also avoid being blocked
	 * in the block layer on device congestion while having transaction
	 * started.
	 */
	mpd.do_map = 0;
	mpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);
	if (!mpd.io_submit.io_end) {
		ret = -ENOMEM;
		goto unplug;
	}
	ret = mpage_prepare_extent_to_map(&mpd);
	/* Unlock pages we didn't use */
	mpage_release_unused_pages(&mpd, false);
	/* Submit prepared bio */
	ext4_io_submit(&mpd.io_submit);
	ext4_put_io_end_defer(mpd.io_submit.io_end);
	mpd.io_submit.io_end = NULL;
	if (ret < 0)
		goto unplug;

	while (!done && mpd.first_page <= mpd.last_page) {
		/* For each extent of pages we use new io_end */
		mpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);
		if (!mpd.io_submit.io_end) {
			ret = -ENOMEM;
			break;
		}

		/*
		 * We have two constraints: We find one extent to map and we
		 * must always write out whole page (makes a difference when
		 * blocksize < pagesize) so that we don't block on IO when we
		 * try to write out the rest of the page. Journalled mode is
		 * not supported by delalloc.
		 */
		BUG_ON(ext4_should_journal_data(inode));
		needed_blocks = ext4_da_writepages_trans_blocks(inode);

		/* start a new transaction */
		handle = ext4_journal_start_with_reserve(inode,
				EXT4_HT_WRITE_PAGE, needed_blocks, rsv_blocks);
		if (IS_ERR(handle)) {
			ret = PTR_ERR(handle);
			ext4_msg(inode->i_sb, KERN_CRIT, '%s: jbd2_start: '
			       '%ld pages, ino %lu; err %d', __func__,
				wbc->nr_to_write, inode->i_ino, ret);
			/* Release allocated io_end */
			ext4_put_io_end(mpd.io_submit.io_end);
			mpd.io_submit.io_end = NULL;
			break;
		}
		mpd.do_map = 1;

		trace_ext4_da_write_pages(inode, mpd.first_page, mpd.wbc);
		ret = mpage_prepare_extent_to_map(&mpd);
		if (!ret) {
			if (mpd.map.m_len)
				ret = mpage_map_and_submit_extent(handle, &mpd,
					&give_up_on_write);
			else {
				/*
				 * We scanned the whole range (or exhausted
				 * nr_to_write), submitted what was mapped and
				 * didn't find anything needing mapping. We are
				 * done.
				 */
				done = true;
			}
		}
		/*
		 * Caution: If the handle is synchronous,
		 * ext4_journal_stop() can wait for transaction commit
		 * to finish which may depend on writeback of pages to
		 * complete or on page lock to be released.  In that
		 * case, we have to wait until after after we have
		 * submitted all the IO, released page locks we hold,
		 * and dropped io_end reference (for extent conversion
		 * to be able to complete) before stopping the handle.
		 */
		if (!ext4_handle_valid(handle) || handle->h_sync == 0) {
			ext4_journal_stop(handle);
			handle = NULL;
			mpd.do_map = 0;
		}
		/* Unlock pages we didn't use */
		mpage_release_unused_pages(&mpd, give_up_on_write);
		/* Submit prepared bio */
		ext4_io_submit(&mpd.io_submit);

		/*
		 * Drop our io_end reference we got from init. We have
		 * to be careful and use deferred io_end finishing if
		 * we are still holding the transaction as we can
		 * release the last reference to io_end which may end
		 * up doing unwritten extent conversion.
		 */
		if (handle) {
			ext4_put_io_end_defer(mpd.io_submit.io_end);
			ext4_journal_stop(handle);
		} else
			ext4_put_io_end(mpd.io_submit.io_end);
		mpd.io_submit.io_end = NULL;

		if (ret == -ENOSPC && sbi->s_journal) {
			/*
			 * Commit the transaction which would
			 * free blocks released in the transaction
			 * and try again
			 */
			jbd2_journal_force_commit_nested(sbi->s_journal);
			ret = 0;
			continue;
		}
		/* Fatal error - ENOMEM, EIO... */
		if (ret)
			break;
	}
unplug:
	blk_finish_plug(&plug);
	if (!ret && !cycled && wbc->nr_to_write > 0) {
		cycled = 1;
		mpd.last_page = writeback_index - 1;
		mpd.first_page = 0;
		goto retry;
	}

	/* Update index */
	if (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))
		/*
		 * Set the writeback_index so that range_cyclic
		 * mode will write it back later
		 */
		mapping->writeback_index = mpd.first_page;

out_writepages:
	trace_ext4_writepages_result(inode, wbc, ret,
				     nr_to_write - wbc->nr_to_write);
	percpu_up_read(&sbi->s_journal_flag_rwsem);
	return ret;
}
",0,8452
torvalds/linux,4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,"static void ext4_init_journal_params(struct super_block *sb, journal_t *journal)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);

	journal->j_commit_interval = sbi->s_commit_interval;
	journal->j_min_batch_time = sbi->s_min_batch_time;
	journal->j_max_batch_time = sbi->s_max_batch_time;

	write_lock(&journal->j_state_lock);
	if (test_opt(sb, BARRIER))
		journal->j_flags |= JBD2_BARRIER;
	else
		journal->j_flags &= ~JBD2_BARRIER;
	if (test_opt(sb, DATA_ERR_ABORT))
		journal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;
	else
		journal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;
	write_unlock(&journal->j_state_lock);
}
",0,8453
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
	return F2FS_M_SB(page->mapping);
}
",1,8454
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline bool f2fs_force_buffered_io(struct inode *inode,
				struct kiocb *iocb, struct iov_iter *iter)
{
	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
	int rw = iov_iter_rw(iter);

	if (f2fs_post_read_required(inode))
		return true;
	if (f2fs_is_multi_device(sbi))
		return true;
	/*
	 * for blkzoned device, fallback direct IO to buffered IO, so
	 * all IOs can be serialized by log-structured write.
	 */
	if (f2fs_sb_has_blkzoned(sbi))
		return true;
	if (test_opt(sbi, LFS) && (rw == WRITE) &&
				block_unaligned_IO(inode, iocb, iter))
		return true;
	if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))
		return true;

	return false;
}
",1,8455
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"	int ret = 0;

	block_in_file = (sector_t)page->index;
	last_block = block_in_file + nr_pages;
	last_block_in_file = (i_size_read(inode) + blocksize - 1) >>
",1,8456
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"			list_del(&page->lru);
			if (add_to_page_cache_lru(page, mapping,
						  page->index,
						  readahead_gfp_mask(mapping)))
				goto next_page;
		}
",1,8457
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"			unlock_page(page);
		}
next_page:
		if (pages)
			put_page(page);
	}
	BUG_ON(pages && !list_empty(pages));
	if (bio)
		__submit_bio(F2FS_I_SB(inode), bio, DATA);
	return pages ? 0 : ret;
}

static int f2fs_read_data_page(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int ret = -EAGAIN;

	trace_f2fs_readpage(page, DATA);
",1,8458
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"	if (f2fs_has_inline_data(inode))
		ret = f2fs_read_inline_data(inode, page);
	if (ret == -EAGAIN)
		ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);
	return ret;
}

static int f2fs_read_data_pages(struct file *file,
			struct address_space *mapping,
			struct list_head *pages, unsigned nr_pages)
{
	struct inode *inode = mapping->host;
	struct page *page = list_last_entry(pages, struct page, lru);

	trace_f2fs_readpages(inode, page, nr_pages);

	/* If the file has inline data, skip readpages */
	if (f2fs_has_inline_data(inode))
		return 0;

	return f2fs_mpage_readpages(mapping, pages, NULL, nr_pages, true);
}

static int encrypt_one_page(struct f2fs_io_info *fio)
{
	struct inode *inode = fio->page->mapping->host;
	struct page *mpage;
	gfp_t gfp_flags = GFP_NOFS;

	if (!f2fs_encrypted_file(inode))
		return 0;

	/* wait for GCed page writeback via META_MAPPING */
	f2fs_wait_on_block_writeback(inode, fio->old_blkaddr);

retry_encrypt:
	fio->encrypted_page = fscrypt_encrypt_page(inode, fio->page,
			PAGE_SIZE, 0, fio->page->index, gfp_flags);
	if (IS_ERR(fio->encrypted_page)) {
		/* flush pending IOs and wait for a while in the ENOMEM case */
		if (PTR_ERR(fio->encrypted_page) == -ENOMEM) {
			f2fs_flush_merged_writes(fio->sbi);
			congestion_wait(BLK_RW_ASYNC, HZ/50);
			gfp_flags |= __GFP_NOFAIL;
			goto retry_encrypt;
		}
		return PTR_ERR(fio->encrypted_page);
	}

	mpage = find_lock_page(META_MAPPING(fio->sbi), fio->old_blkaddr);
	if (mpage) {
		if (PageUptodate(mpage))
			memcpy(page_address(mpage),
				page_address(fio->encrypted_page), PAGE_SIZE);
		f2fs_put_page(mpage, 1);
	}
	return 0;
}

static inline bool check_inplace_update_policy(struct inode *inode,
				struct f2fs_io_info *fio)
{
",1,8459
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"}

static int f2fs_set_data_page_dirty(struct page *page)
{
	struct address_space *mapping = page->mapping;
	struct inode *inode = mapping->host;

	trace_f2fs_set_page_dirty(page, DATA);

",1,8460
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"		SetPageUptodate(page);

	if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
		if (!IS_ATOMIC_WRITTEN_PAGE(page)) {
			f2fs_register_inmem_page(inode, page);
			return 1;
",1,8461
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static enum count_type __read_io_type(struct page *page)
{
	struct address_space *mapping = page->mapping;

	if (mapping) {
		struct inode *inode = mapping->host;
		struct f2fs_sb_info *sbi = F2FS_I_SB(inode);

		if (inode->i_ino == F2FS_META_INO(sbi))
			return F2FS_RD_META;

		if (inode->i_ino == F2FS_NODE_INO(sbi))
			return F2FS_RD_NODE;
	}
	return F2FS_RD_DATA;
}
",1,8462
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static int f2fs_read_single_page(struct inode *inode, struct page *page,
					unsigned nr_pages,
					struct f2fs_map_blocks *map,
					struct bio **bio_ret,
					sector_t *last_block_in_bio,
					bool is_readahead)
{
	struct bio *bio = *bio_ret;
	const unsigned blkbits = inode->i_blkbits;
	const unsigned blocksize = 1 << blkbits;
	sector_t block_in_file;
	sector_t last_block;
	sector_t last_block_in_file;
	sector_t block_nr;
	int ret = 0;

	block_in_file = (sector_t)page->index;
	last_block = block_in_file + nr_pages;
	last_block_in_file = (i_size_read(inode) + blocksize - 1) >>
							blkbits;
	if (last_block > last_block_in_file)
		last_block = last_block_in_file;

	/* just zeroing out page which is beyond EOF */
	if (block_in_file >= last_block)
		goto zero_out;
	/*
	 * Map blocks using the previous result first.
	 */
	if ((map->m_flags & F2FS_MAP_MAPPED) &&
			block_in_file > map->m_lblk &&
			block_in_file < (map->m_lblk + map->m_len))
		goto got_it;

	/*
	 * Then do more f2fs_map_blocks() calls until we are
	 * done with this page.
	 */
	map->m_lblk = block_in_file;
	map->m_len = last_block - block_in_file;

	ret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);
	if (ret)
		goto out;
got_it:
	if ((map->m_flags & F2FS_MAP_MAPPED)) {
		block_nr = map->m_pblk + block_in_file - map->m_lblk;
		SetPageMappedToDisk(page);

		if (!PageUptodate(page) && !cleancache_get_page(page)) {
			SetPageUptodate(page);
			goto confused;
		}

		if (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,
						DATA_GENERIC_ENHANCE_READ)) {
			ret = -EFSCORRUPTED;
			goto out;
		}
	} else {
zero_out:
		zero_user_segment(page, 0, PAGE_SIZE);
		if (!PageUptodate(page))
			SetPageUptodate(page);
		unlock_page(page);
		goto out;
	}

	/*
	 * This page will go to BIO.  Do we need to send this
	 * BIO off first?
	 */
	if (bio && (*last_block_in_bio != block_nr - 1 ||
		!__same_bdev(F2FS_I_SB(inode), block_nr, bio))) {
submit_and_realloc:
		__submit_bio(F2FS_I_SB(inode), bio, DATA);
		bio = NULL;
	}
	if (bio == NULL) {
		bio = f2fs_grab_read_bio(inode, block_nr, nr_pages,
				is_readahead ? REQ_RAHEAD : 0);
		if (IS_ERR(bio)) {
			ret = PTR_ERR(bio);
			bio = NULL;
			goto out;
		}
	}

	/*
	 * If the page is under writeback, we need to wait for
	 * its completion to see the correct decrypted data.
	 */
	f2fs_wait_on_block_writeback(inode, block_nr);

	if (bio_add_page(bio, page, blocksize, 0) < blocksize)
		goto submit_and_realloc;

	inc_page_count(F2FS_I_SB(inode), F2FS_RD_DATA);
	ClearPageError(page);
	*last_block_in_bio = block_nr;
	goto out;
confused:
	if (bio) {
		__submit_bio(F2FS_I_SB(inode), bio, DATA);
		bio = NULL;
	}
	unlock_page(page);
out:
	*bio_ret = bio;
	return ret;
}
",1,8463
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static int f2fs_mpage_readpages(struct address_space *mapping,
			struct list_head *pages, struct page *page,
			unsigned nr_pages, bool is_readahead)
{
	struct bio *bio = NULL;
	sector_t last_block_in_bio = 0;
	struct inode *inode = mapping->host;
	struct f2fs_map_blocks map;
	int ret = 0;

	map.m_pblk = 0;
	map.m_lblk = 0;
	map.m_len = 0;
	map.m_flags = 0;
	map.m_next_pgofs = NULL;
	map.m_next_extent = NULL;
	map.m_seg_type = NO_CHECK_TYPE;
	map.m_may_create = false;

	for (; nr_pages; nr_pages--) {
		if (pages) {
			page = list_last_entry(pages, struct page, lru);

			prefetchw(&page->flags);
			list_del(&page->lru);
			if (add_to_page_cache_lru(page, mapping,
						  page->index,
						  readahead_gfp_mask(mapping)))
				goto next_page;
		}

		ret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,
					&last_block_in_bio, is_readahead);
		if (ret) {
			SetPageError(page);
			zero_user_segment(page, 0, PAGE_SIZE);
			unlock_page(page);
		}
next_page:
		if (pages)
			put_page(page);
	}
	BUG_ON(pages && !list_empty(pages));
	if (bio)
		__submit_bio(F2FS_I_SB(inode), bio, DATA);
	return pages ? 0 : ret;
}
",1,8464
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static int f2fs_read_data_page(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int ret = -EAGAIN;

	trace_f2fs_readpage(page, DATA);

	/* If the file has inline data, try to read it directly */
	if (f2fs_has_inline_data(inode))
		ret = f2fs_read_inline_data(inode, page);
	if (ret == -EAGAIN)
		ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);
	return ret;
}
",1,8465
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static int f2fs_set_data_page_dirty(struct page *page)
{
	struct address_space *mapping = page->mapping;
	struct inode *inode = mapping->host;

	trace_f2fs_set_page_dirty(page, DATA);

	if (!PageUptodate(page))
		SetPageUptodate(page);

	if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
		if (!IS_ATOMIC_WRITTEN_PAGE(page)) {
			f2fs_register_inmem_page(inode, page);
			return 1;
		}
		/*
		 * Previously, this page has been registered, we just
		 * return here.
		 */
		return 0;
	}

	if (!PageDirty(page)) {
		__set_page_dirty_nobuffers(page);
		f2fs_update_dirty_page(inode, page);
		return 1;
	}
	return 0;
}
",1,8466
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)
{
	return sb->s_fs_info;
}
",0,8467
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline int get_inline_xattr_addrs(struct inode *inode);
",0,8468
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline bool f2fs_is_pinned_file(struct inode *inode)
{
	return is_inode_flag_set(inode, FI_PIN_FILE);
}
",0,8469
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline int f2fs_build_stats(struct f2fs_sb_info *sbi) { return 0; }
",0,8470
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"{
	enum page_type btype = PAGE_TYPE_OF_BIO(type);
	struct f2fs_bio_info *io = sbi->write_io[btype] + temp;

	down_write(&io->io_rwsem);

	/* change META to META_FLUSH in the checkpoint procedure */
",0,8471
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static void __submit_merged_bio(struct f2fs_bio_info *io)
{
	struct f2fs_io_info *fio = &io->fio;

	if (!io->bio)
		return;

	bio_set_op_attrs(io->bio, fio->op, fio->op_flags);

	if (is_read_io(fio->op))
		trace_f2fs_prepare_read_bio(io->sbi->sb, fio->type, io->bio);
	else
		trace_f2fs_prepare_write_bio(io->sbi->sb, fio->type, io->bio);

	__submit_bio(io->sbi, io->bio, fio->type);
	io->bio = NULL;
}
",0,8472
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"		if (err == -EAGAIN) {
			fio.need_lock = LOCK_REQ;
			err = f2fs_do_write_data_page(&fio);
		}
",0,8473
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static int get_data_block_dio(struct inode *inode, sector_t iblock,
			struct buffer_head *bh_result, int create)
{
	return __get_data_block(inode, iblock, bh_result, create,
				F2FS_GET_BLOCK_DIO, NULL,
				f2fs_rw_hint_to_seg_type(inode->i_write_hint),
				false);
}
",0,8474
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"	f2fs_wait_on_page_writeback(dn->node_page, NODE, true, true);

	for (; count > 0; dn->ofs_in_node++) {
		block_t blkaddr = datablock_addr(dn->inode,
					dn->node_page, dn->ofs_in_node);
		if (blkaddr == NULL_ADDR) {
			dn->data_blkaddr = NEW_ADDR;
",0,8475
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline int f2fs_has_inline_data(struct inode *inode)
{
	return is_inode_flag_set(inode, FI_INLINE_DATA);
}
",0,8476
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)
{
	return (struct f2fs_sm_info *)(sbi->sm_info);
}
",0,8477
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline u32 __f2fs_crc32(struct f2fs_sb_info *sbi, u32 crc,
			      const void *address, unsigned int length)
{
	struct {
		struct shash_desc shash;
		char ctx[4];
	} desc;
	int err;

	BUG_ON(crypto_shash_descsize(sbi->s_chksum_driver) != sizeof(desc.ctx));

	desc.shash.tfm = sbi->s_chksum_driver;
	*(u32 *)desc.ctx = crc;

	err = crypto_shash_update(&desc.shash, address, length);
	BUG_ON(err);

	return *(u32 *)desc.ctx;
}
",0,8478
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline int update_sits_in_cursum(struct f2fs_journal *journal, int i)
{
	int before = sits_in_cursum(journal);

	journal->n_sits = cpu_to_le16(before + i);
	return before;
}
",0,8479
torvalds/linux,4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,"static inline void f2fs_i_depth_write(struct inode *inode, unsigned int depth)
{
	F2FS_I(inode)->i_current_depth = depth;
	f2fs_mark_inode_dirty_sync(inode, true);
}
",0,8480
sqlite/sqlite,54d501092d88c0cf89bec4279951f548fb0b8618,"static int zipfileUpdate(
  sqlite3_vtab *pVtab, 
  int nVal, 
  sqlite3_value **apVal, 
  sqlite_int64 *pRowid
){
  ZipfileTab *pTab = (ZipfileTab*)pVtab;
  int rc = SQLITE_OK;             /* Return Code */
  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */

  u32 mode = 0;                   /* Mode for new entry */
  u32 mTime = 0;                  /* Modification time for new entry */
  i64 sz = 0;                     /* Uncompressed size */
  const char *zPath = 0;          /* Path for new entry */
  int nPath = 0;                  /* strlen(zPath) */
  const u8 *pData = 0;            /* Pointer to buffer containing content */
  int nData = 0;                  /* Size of pData buffer in bytes */
  int iMethod = 0;                /* Compression method for new entry */
  u8 *pFree = 0;                  /* Free this */
  char *zFree = 0;                /* Also free this */
  ZipfileEntry *pOld = 0;
  ZipfileEntry *pOld2 = 0;
  int bUpdate = 0;                /* True for an update that modifies 'name' */
  int bIsDir = 0;
  u32 iCrc32 = 0;

  if( pTab->pWriteFd==0 ){
    rc = zipfileBegin(pVtab);
    if( rc!=SQLITE_OK ) return rc;
  }

  /* If this is a DELETE or UPDATE, find the archive entry to delete. */
  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){
    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);
    int nDelete = (int)strlen(zDelete);
    if( nVal>1 ){
      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);
      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){
        bUpdate = 1;
      }
    }
    for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){
      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){
        break;
      }
      assert( pOld->pNext );
    }
  }

  if( nVal>1 ){
    /* Check that 'sz' and 'rawdata' are both NULL: */
    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){
      zipfileTableErr(pTab, 'sz must be NULL');
      rc = SQLITE_CONSTRAINT;
    }
    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){
      zipfileTableErr(pTab, 'rawdata must be NULL'); 
      rc = SQLITE_CONSTRAINT;
    }

    if( rc==SQLITE_OK ){
      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){
        /* data=NULL. A directory */
        bIsDir = 1;
      }else{
        /* Value specified for 'data', and possibly 'method'. This must be
        ** a regular file or a symlink. */
        const u8 *aIn = sqlite3_value_blob(apVal[7]);
        int nIn = sqlite3_value_bytes(apVal[7]);
        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;

        iMethod = sqlite3_value_int(apVal[8]);
        sz = nIn;
        pData = aIn;
        nData = nIn;
        if( iMethod!=0 && iMethod!=8 ){
          zipfileTableErr(pTab, 'unknown compression method: %d', iMethod);
          rc = SQLITE_CONSTRAINT;
        }else{
          if( bAuto || iMethod ){
            int nCmp;
            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);
            if( rc==SQLITE_OK ){
              if( iMethod || nCmp<nIn ){
                iMethod = 8;
                pData = pFree;
                nData = nCmp;
              }
            }
          }
          iCrc32 = crc32(0, aIn, nIn);
        }
      }
    }

    if( rc==SQLITE_OK ){
      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);
    }

    if( rc==SQLITE_OK ){
      zPath = (const char*)sqlite3_value_text(apVal[2]);
      nPath = (int)strlen(zPath);
      mTime = zipfileGetTime(apVal[4]);
    }

    if( rc==SQLITE_OK && bIsDir ){
      /* For a directory, check that the last character in the path is a
      ** '/'. This appears to be required for compatibility with info-zip
      ** (the unzip command on unix). It does not create directories
      ** otherwise.  */
      if( zPath[nPath-1]!='/' ){
        zFree = sqlite3_mprintf('%s/', zPath);
        if( zFree==0 ){ rc = SQLITE_NOMEM; }
        zPath = (const char*)zFree;
        nPath++;
      }
    }

    /* Check that we're not inserting a duplicate entry -OR- updating an
    ** entry with a path, thereby making it into a duplicate. */
    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){
      ZipfileEntry *p;
      for(p=pTab->pFirstEntry; p; p=p->pNext){
        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){
          switch( sqlite3_vtab_on_conflict(pTab->db) ){
            case SQLITE_IGNORE: {
              goto zipfile_update_done;
            }
            case SQLITE_REPLACE: {
              pOld2 = p;
              break;
            }
            default: {
              zipfileTableErr(pTab, 'duplicate name: \'%s\'', zPath);
              rc = SQLITE_CONSTRAINT;
              break;
            }
          }
          break;
        }
      }
    }

    if( rc==SQLITE_OK ){
      /* Create the new CDS record. */
      pNew = zipfileNewEntry(zPath);
      if( pNew==0 ){
        rc = SQLITE_NOMEM;
      }else{
        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;
        pNew->cds.iCompression = (u16)iMethod;
        zipfileMtimeToDos(&pNew->cds, mTime);
        pNew->cds.crc32 = iCrc32;
        pNew->cds.szCompressed = nData;
        pNew->cds.szUncompressed = (u32)sz;
        pNew->cds.iExternalAttr = (mode<<16);
        pNew->cds.iOffset = (u32)pTab->szCurrent;
        pNew->cds.nFile = (u16)nPath;
        pNew->mUnixTime = (u32)mTime;
        rc = zipfileAppendEntry(pTab, pNew, pData, nData);
        zipfileAddEntry(pTab, pOld, pNew);
      }
    }
  }

  if( rc==SQLITE_OK && (pOld || pOld2) ){
    ZipfileCsr *pCsr;
    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){
      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){
        pCsr->pCurrent = pCsr->pCurrent->pNext;
        pCsr->bNoop = 1;
      }
    }

    zipfileRemoveEntryFromList(pTab, pOld);
    zipfileRemoveEntryFromList(pTab, pOld2);
  }

zipfile_update_done:
  sqlite3_free(pFree);
  sqlite3_free(zFree);
  return rc;
}
",1,8481
sqlite/sqlite,54d501092d88c0cf89bec4279951f548fb0b8618,"static int zipfileSerializeCDS(ZipfileEntry *pEntry, u8 *aBuf){
  u8 *a = aBuf;
  ZipfileCDS *pCDS = &pEntry->cds;

  if( pEntry->aExtra==0 ){
    pCDS->nExtra = 9;
  }

  zipfileWrite32(a, ZIPFILE_SIGNATURE_CDS);
  zipfileWrite16(a, pCDS->iVersionMadeBy);
  zipfileWrite16(a, pCDS->iVersionExtract);
  zipfileWrite16(a, pCDS->flags);
  zipfileWrite16(a, pCDS->iCompression);
  zipfileWrite16(a, pCDS->mTime);
  zipfileWrite16(a, pCDS->mDate);
  zipfileWrite32(a, pCDS->crc32);
  zipfileWrite32(a, pCDS->szCompressed);
  zipfileWrite32(a, pCDS->szUncompressed);
  assert( a==&aBuf[ZIPFILE_CDS_NFILE_OFF] );
  zipfileWrite16(a, pCDS->nFile);
  zipfileWrite16(a, pCDS->nExtra);
  zipfileWrite16(a, pCDS->nComment);
  zipfileWrite16(a, pCDS->iDiskStart);
  zipfileWrite16(a, pCDS->iInternalAttr);
  zipfileWrite32(a, pCDS->iExternalAttr);
  zipfileWrite32(a, pCDS->iOffset);

  memcpy(a, pCDS->zFile, pCDS->nFile);
  a += pCDS->nFile;

  if( pEntry->aExtra ){
    int n = (int)pCDS->nExtra + (int)pCDS->nComment;
    memcpy(a, pEntry->aExtra, n);
    a += n;
  }else{
    assert( pCDS->nExtra==9 );
    zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);
    zipfileWrite16(a, 5);
    *a++ = 0x01;
    zipfileWrite32(a, pEntry->mUnixTime);
  }

  return a-aBuf;
}
",0,8482
CESNET/libyang,d9feacc4a590d35dbc1af21caf9080008b4450ed,"int
yang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,
                         const char *parent_name, char *value, int parent_stmt, LY_STMT stmt)
{
    int c;
    const char **str, ***p = NULL;
    void *reallocated;
    struct lyext_substmt *info;

    c = 0;
    if (stmt == LY_STMT_PREFIX && parent_stmt == LY_STMT_BELONGSTO) {
        /* str contains no NULL value */
        str = lys_ext_complex_get_substmt(LY_STMT_BELONGSTO, ext, &info);
        if (info->cardinality < LY_STMT_CARD_SOME) {
            str++;
        } else {
           /* get the index in the array to add new item */
            p = (const char ***)str;
            for (c = 0; p[0][c + 1]; c++);
            str = p[1];
        }
        str[c] = lydict_insert_zc(module->ctx, value);
    }  else {
        str = lys_ext_complex_get_substmt(stmt, ext, &info);
        if (!str) {
            LOGVAL(module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, arg_name, parent_name);
            goto error;
        }
        if (info->cardinality < LY_STMT_CARD_SOME && *str) {
            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, arg_name, parent_name);
            goto error;
        }

        if (info->cardinality >= LY_STMT_CARD_SOME) {
            /* there can be multiple instances, str is actually const char *** */
            p = (const char ***)str;
            if (!p[0]) {
                /* allocate initial array */
                p[0] = calloc(2, sizeof(const char *));
                LY_CHECK_ERR_GOTO(!p[0], LOGMEM(module->ctx), error);
                if (stmt == LY_STMT_BELONGSTO) {
                    /* allocate another array for the belongs-to's prefixes */
                    p[1] = calloc(2, sizeof(const char *));
                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);
                } else if (stmt == LY_STMT_ARGUMENT) {
                    /* allocate another array for the yin element */
                    ((uint8_t **)p)[1] = calloc(2, sizeof(uint8_t));
                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);
                    /* default value of yin element */
                    ((uint8_t *)p[1])[0] = 2;
                }
            } else {
                /* get the index in the array to add new item */
                for (c = 0; p[0][c]; c++);
            }
            str = p[0];
        }

        str[c] = lydict_insert_zc(module->ctx, value);
        value = NULL;

        if (c) {
            /* enlarge the array(s) */
            reallocated = realloc(p[0], (c + 2) * sizeof(const char *));
            if (!reallocated) {
                LOGMEM(module->ctx);
                lydict_remove(module->ctx, p[0][c]);
                p[0][c] = NULL;
                return EXIT_FAILURE;
            }
            p[0] = reallocated;
            p[0][c + 1] = NULL;

            if (stmt == LY_STMT_BELONGSTO) {
                /* enlarge the second belongs-to's array with prefixes */
                reallocated = realloc(p[1], (c + 2) * sizeof(const char *));
                if (!reallocated) {
                    LOGMEM(module->ctx);
                    lydict_remove(module->ctx, p[1][c]);
                    p[1][c] = NULL;
                    return EXIT_FAILURE;
                }
                p[1] = reallocated;
                p[1][c + 1] = NULL;
            } else if (stmt == LY_STMT_ARGUMENT) {
                /* enlarge the second argument's array with yin element */
                reallocated = realloc(p[1], (c + 2) * sizeof(uint8_t));
                if (!reallocated) {
                    LOGMEM(module->ctx);
                    ((uint8_t *)p[1])[c] = 0;
                    return EXIT_FAILURE;
                }
                p[1] = reallocated;
                ((uint8_t *)p[1])[c + 1] = 0;
            }
        }
    }

    return EXIT_SUCCESS;

error:
    free(value);
    return EXIT_FAILURE;
}
",1,8483
CESNET/libyang,d9feacc4a590d35dbc1af21caf9080008b4450ed,"int yang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,
                             const char *parent_name, char *value, int parent_stmt, LY_STMT stmt);
",1,8484
CESNET/libyang,d9feacc4a590d35dbc1af21caf9080008b4450ed,"int
yyparse (void *scanner, struct yang_parameter *param)
{
/* The lookahead symbol.  */
int yychar;
char *s = NULL, *tmp_s = NULL, *ext_name = NULL;
struct lys_module *trg = NULL;
struct lys_node *tpdf_parent = NULL, *data_node = NULL;
struct lys_ext_instance_complex *ext_instance = NULL;
int is_ext_instance;
void *actual = NULL;
enum yytokentype backup_type, actual_type = MODULE_KEYWORD;
int64_t cnt_val = 0;
int is_value = 0;
void *yang_type = NULL;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

/* Location data for the lookahead symbol.  */
static YYLTYPE yyloc_default
# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
  = { 1, 1, 1, 1 }
# endif
;
YYLTYPE yylloc = yyloc_default;

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.
       'yyls': related to locations.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    /* The location stack.  */
    YYLTYPE yylsa[YYINITDEPTH];
    YYLTYPE *yyls;
    YYLTYPE *yylsp;

    /* The locations where the error started and ended.  */
    YYLTYPE yyerror_range[3];

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;
  YYLTYPE yyloc;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yylsp = yyls = yylsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, 'Starting parse\n'));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */

/* User initialization code.  */

{ yylloc.last_column = 0;
                  if (param->flags & EXT_INSTANCE_SUBSTMT) {
                    is_ext_instance = 1;
                    ext_instance = (struct lys_ext_instance_complex *)param->actual_node;
                    ext_name = (char *)param->data_node;
                  } else {
                    is_ext_instance = 0;
                  }
                  yylloc.last_line = is_ext_instance;     /* HACK for flex - return SUBMODULE_KEYWORD or SUBMODULE_EXT_KEYWORD */
                  param->value = &s;
                  param->data_node = (void **)&data_node;
                  param->actual_node = &actual;
                  backup_type = NODE;
                  trg = (param->submodule) ? (struct lys_module *)param->submodule : param->module;
                }


  yylsp[0] = yylloc;
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = (yytype_int16) yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = (YYSIZE_T) (yyssp - yyss + 1);

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;
        YYLTYPE *yyls1 = yyls;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_('memory exhausted'),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yyls1, yysize * sizeof (*yylsp),
                    &yystacksize);
        yyss = yyss1;
        yyvs = yyvs1;
        yyls = yyls1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        YYSTACK_RELOCATE (yyls_alloc, yyls);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;
      yylsp = yyls + yysize - 1;

      YYDPRINTF ((stderr, 'Stack size increased to %lu\n',
                  (unsigned long) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, 'Entering state %d\n', yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, 'Reading a token: '));
      yychar = yylex (&yylval, &yylloc, scanner);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, 'Now at end of input.\n'));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ('Next token is', yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ('Shifting', yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END
  *++yylsp = yylloc;
  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];

  /* Default location. */
  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
  yyerror_range[1] = yyloc;
  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 5:

    { if (yyget_text(scanner)[0] == ''') {
                      char *tmp;

                      s = malloc(yyget_leng(scanner) - 1 + 7 * yylval.i);
                      if (!s) {
                        LOGMEM(trg->ctx);
                        YYABORT;
                      }
                      if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, yyget_leng(scanner) - 2, 0, yylloc.first_column))) {
                        YYABORT;
                      }
                      s = tmp;
                    } else {
                      s = calloc(1, yyget_leng(scanner) - 1);
                      if (!s) {
                        LOGMEM(trg->ctx);
                        YYABORT;
                      }
                      memcpy(s, yyget_text(scanner) + 1, yyget_leng(scanner) - 2);
                    }
                    (yyval.p_str) = &s;
                  }

    break;

  case 8:

    { if (yyget_leng(scanner) > 2) {
                int length_s = strlen(s), length_tmp = yyget_leng(scanner);
                char *tmp;

                tmp = realloc(s, length_s + length_tmp - 1);
                if (!tmp) {
                  LOGMEM(trg->ctx);
                  YYABORT;
                }
                s = tmp;
                if (yyget_text(scanner)[0] == ''') {
                  if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, length_tmp - 2, length_s, yylloc.first_column))) {
                    YYABORT;
                  }
                  s = tmp;
                } else {
                  memcpy(s + length_s, yyget_text(scanner) + 1, length_tmp - 2);
                  s[length_s + length_tmp - 2] = '\0';
                }
              }
            }

    break;

  case 10:

    { if (param->submodule) {
                                       free(s);
                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'module');
                                       YYABORT;
                                     }
                                     trg = param->module;
                                     yang_read_common(trg,s,MODULE_KEYWORD);
                                     s = NULL;
                                     actual_type = MODULE_KEYWORD;
                                   }

    break;

  case 12:

    { if (!param->module->ns) {
                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'namespace', 'module');
                                            YYABORT;
                                          }
                                          if (!param->module->prefix) {
                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'prefix', 'module');
                                            YYABORT;
                                          }
                                        }

    break;

  case 13:

    { (yyval.i) = 0; }

    break;

  case 14:

    { if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {
                                              YYABORT;
                                            }
                                            (yyval.i) = 1;
                                            s = NULL;
                                          }

    break;

  case 15:

    { if (yang_read_common(param->module, s, NAMESPACE_KEYWORD)) {
                                           YYABORT;
                                         }
                                         s = NULL;
                                       }

    break;

  case 16:

    { if (yang_read_prefix(trg, NULL, s)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 17:

    { if (!param->submodule) {
                                          free(s);
                                          LOGVAL(trg->ctx, LYE_SUBMODULE, LY_VLOG_NONE, NULL);
                                          YYABORT;
                                        }
                                        trg = (struct lys_module *)param->submodule;
                                        yang_read_common(trg,s,MODULE_KEYWORD);
                                        s = NULL;
                                        actual_type = SUBMODULE_KEYWORD;
                                      }

    break;

  case 19:

    { if (!param->submodule->prefix) {
                                                  LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'belongs-to', 'submodule');
                                                  YYABORT;
                                                }
                                                if (!(yyvsp[0].i)) {
                                                  /* check version compatibility with the main module */
                                                  if (param->module->version > 1) {
                                                      LOGVAL(trg->ctx, LYE_INVER, LY_VLOG_NONE, NULL);
                                                      YYABORT;
                                                  }
                                                }
                                              }

    break;

  case 20:

    { (yyval.i) = 0; }

    break;

  case 21:

    { if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {
                                                 YYABORT;
                                               }
                                               (yyval.i) = 1;
                                               s = NULL;
                                             }

    break;

  case 23:

    { backup_type = actual_type;
                           actual_type = YANG_VERSION_KEYWORD;
                         }

    break;

  case 25:

    { backup_type = actual_type;
                            actual_type = NAMESPACE_KEYWORD;
                          }

    break;

  case 30:

    { actual_type = (yyvsp[-4].token);
                   backup_type = NODE;
                   actual = NULL;
                 }

    break;

  case 31:

    { YANG_ADDELEM(trg->imp, trg->imp_size, 'imports');
                                     /* HACK for unres */
                                     ((struct lys_import *)actual)->module = (struct lys_module *)s;
                                     s = NULL;
                                     (yyval.token) = actual_type;
                                     actual_type = IMPORT_KEYWORD;
                                   }

    break;

  case 32:

    { (yyval.i) = 0; }

    break;

  case 33:

    { if (yang_read_prefix(trg, actual, s)) {
                                     YYABORT;
                                   }
                                   s = NULL;
                                 }

    break;

  case 34:

    { if (trg->version != 2) {
                                          LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'description');
                                          free(s);
                                          YYABORT;
                                        }
                                        if (yang_read_description(trg, actual, s, 'import', IMPORT_KEYWORD)) {
                                          YYABORT;
                                        }
                                        s = NULL;
                                        (yyval.i) = (yyvsp[-1].i);
                                      }

    break;

  case 35:

    { if (trg->version != 2) {
                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'reference');
                                        free(s);
                                        YYABORT;
                                      }
                                      if (yang_read_reference(trg, actual, s, 'import', IMPORT_KEYWORD)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                      (yyval.i) = (yyvsp[-1].i);
                                    }

    break;

  case 36:

    { if ((yyvsp[-1].i)) {
                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'revision-date', 'import');
                                            free(s);
                                            YYABORT;
                                          }
                                          memcpy(((struct lys_import *)actual)->rev, s, LY_REV_SIZE-1);
                                          free(s);
                                          s = NULL;
                                          (yyval.i) = 1;
                                        }

    break;

  case 37:

    { YANG_ADDELEM(trg->inc, trg->inc_size, 'includes');
                                     /* HACK for unres */
                                     ((struct lys_include *)actual)->submodule = (struct lys_submodule *)s;
                                     s = NULL;
                                     (yyval.token) = actual_type;
                                     actual_type = INCLUDE_KEYWORD;
                                   }

    break;

  case 38:

    { actual_type = (yyvsp[-1].token);
                                                                backup_type = NODE;
                                                                actual = NULL;
                                                              }

    break;

  case 41:

    { (yyval.i) = 0; }

    break;

  case 42:

    { if (trg->version != 2) {
                                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'description');
                                           free(s);
                                           YYABORT;
                                         }
                                         if (yang_read_description(trg, actual, s, 'include', INCLUDE_KEYWORD)) {
                                            YYABORT;
                                         }
                                         s = NULL;
                                         (yyval.i) = (yyvsp[-1].i);
                                       }

    break;

  case 43:

    { if (trg->version != 2) {
                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'reference');
                                         free(s);
                                         YYABORT;
                                       }
                                       if (yang_read_reference(trg, actual, s, 'include', INCLUDE_KEYWORD)) {
                                         YYABORT;
                                       }
                                       s = NULL;
                                       (yyval.i) = (yyvsp[-1].i);
                                     }

    break;

  case 44:

    { if ((yyvsp[-1].i)) {
                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'revision-date', 'include');
                                             free(s);
                                             YYABORT;
                                           }
                                           memcpy(((struct lys_include *)actual)->rev, s, LY_REV_SIZE-1);
                                           free(s);
                                           s = NULL;
                                           (yyval.i) = 1;
                                         }

    break;

  case 45:

    { backup_type = actual_type;
                                  actual_type = REVISION_DATE_KEYWORD;
                                }

    break;

  case 47:

    { (yyval.token) = actual_type;
                                         if (is_ext_instance) {
                                           if (yang_read_extcomplex_str(trg, ext_instance, 'belongs-to', ext_name, s,
                                                                        0, LY_STMT_BELONGSTO)) {
                                             YYABORT;
                                           }
                                         } else {
                                           if (param->submodule->prefix) {
                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'belongs-to', 'submodule');
                                             free(s);
                                             YYABORT;
                                           }
                                           if (!ly_strequal(s, param->submodule->belongsto->name, 0)) {
                                             LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'belongs-to');
                                             free(s);
                                             YYABORT;
                                           }
                                           free(s);
                                         }
                                         s = NULL;
                                         actual_type = BELONGS_TO_KEYWORD;
                                       }

    break;

  case 48:

    { if (is_ext_instance) {
                         if (yang_read_extcomplex_str(trg, ext_instance, 'prefix', 'belongs-to', s,
                                                      LY_STMT_BELONGSTO, LY_STMT_PREFIX)) {
                           YYABORT;
                         }
                       } else {
                         if (yang_read_prefix(trg, NULL, s)) {
                           YYABORT;
                         }
                       }
                       s = NULL;
                       actual_type = (yyvsp[-4].token);
                     }

    break;

  case 49:

    { backup_type = actual_type;
                             actual_type = PREFIX_KEYWORD;
                           }

    break;

  case 52:

    { if (yang_read_common(trg, s, ORGANIZATION_KEYWORD)) {
                                      YYABORT;
                                    }
                                    s = NULL;
                                  }

    break;

  case 53:

    { if (yang_read_common(trg, s, CONTACT_KEYWORD)) {
                                 YYABORT;
                               }
                               s = NULL;
                             }

    break;

  case 54:

    { if (yang_read_description(trg, NULL, s, NULL, MODULE_KEYWORD)) {
                                     YYABORT;
                                   }
                                   s = NULL;
                                 }

    break;

  case 55:

    { if (yang_read_reference(trg, NULL, s, NULL, MODULE_KEYWORD)) {
                                   YYABORT;
                                 }
                                 s=NULL;
                               }

    break;

  case 56:

    { backup_type = actual_type;
                           actual_type = ORGANIZATION_KEYWORD;
                         }

    break;

  case 58:

    { backup_type = actual_type;
                      actual_type = CONTACT_KEYWORD;
                    }

    break;

  case 60:

    { backup_type = actual_type;
                          actual_type = DESCRIPTION_KEYWORD;
                        }

    break;

  case 62:

    { backup_type = actual_type;
                        actual_type = REFERENCE_KEYWORD;
                      }

    break;

  case 64:

    { if (trg->rev_size) {
                                      struct lys_revision *tmp;

                                      tmp = realloc(trg->rev, trg->rev_size * sizeof *trg->rev);
                                      if (!tmp) {
                                        LOGMEM(trg->ctx);
                                        YYABORT;
                                      }
                                      trg->rev = tmp;
                                    }
                                  }

    break;

  case 65:

    { (yyval.backup_token).token = actual_type;
                                  (yyval.backup_token).actual = actual;
                                  if (!is_ext_instance) {
                                    YANG_ADDELEM(trg->rev, trg->rev_size, 'revisions');
                                  }
                                  memcpy(((struct lys_revision *)actual)->date, s, LY_REV_SIZE);
                                  free(s);
                                  s = NULL;
                                  actual_type = REVISION_KEYWORD;
                                }

    break;

  case 67:

    { int i;

                                                /* check uniqueness of the revision date - not required by RFC */
                                                for (i = 0; i < (trg->rev_size - 1); i++) {
                                                  if (!strcmp(trg->rev[i].date, trg->rev[trg->rev_size - 1].date)) {
                                                    LOGWRN(trg->ctx, 'Module's revisions are not unique (%s).',
                                                           trg->rev[trg->rev_size - 1].date);
                                                    break;
                                                  }
                                                }
                                              }

    break;

  case 68:

    { actual_type = (yyvsp[-1].backup_token).token;
                                                                     actual = (yyvsp[-1].backup_token).actual;
                                                                   }

    break;

  case 72:

    { if (yang_read_description(trg, actual, s, 'revision',REVISION_KEYWORD)) {
                                            YYABORT;
                                          }
                                          s = NULL;
                                        }

    break;

  case 73:

    { if (yang_read_reference(trg, actual, s, 'revision', REVISION_KEYWORD)) {
                                          YYABORT;
                                        }
                                        s = NULL;
                                      }

    break;

  case 74:

    { s = strdup(yyget_text(scanner));
                              if (!s) {
                                LOGMEM(trg->ctx);
                                YYABORT;
                              }
                              if (lyp_check_date(trg->ctx, s)) {
                                  free(s);
                                  YYABORT;
                              }
                            }

    break;

  case 76:

    { if (lyp_check_date(trg->ctx, s)) {
                   free(s);
                   YYABORT;
               }
             }

    break;

  case 77:

    { void *tmp;

                             if (trg->tpdf_size) {
                               tmp = realloc(trg->tpdf, trg->tpdf_size * sizeof *trg->tpdf);
                               if (!tmp) {
                                 LOGMEM(trg->ctx);
                                 YYABORT;
                               }
                               trg->tpdf = tmp;
                             }

                             if (trg->features_size) {
                               tmp = realloc(trg->features, trg->features_size * sizeof *trg->features);
                               if (!tmp) {
                                 LOGMEM(trg->ctx);
                                 YYABORT;
                               }
                               trg->features = tmp;
                             }

                             if (trg->ident_size) {
                               tmp = realloc(trg->ident, trg->ident_size * sizeof *trg->ident);
                               if (!tmp) {
                                 LOGMEM(trg->ctx);
                                 YYABORT;
                               }
                               trg->ident = tmp;
                             }

                             if (trg->augment_size) {
                               tmp = realloc(trg->augment, trg->augment_size * sizeof *trg->augment);
                               if (!tmp) {
                                 LOGMEM(trg->ctx);
                                 YYABORT;
                               }
                               trg->augment = tmp;
                             }

                             if (trg->extensions_size) {
                               tmp = realloc(trg->extensions, trg->extensions_size * sizeof *trg->extensions);
                               if (!tmp) {
                                 LOGMEM(trg->ctx);
                                 YYABORT;
                               }
                               trg->extensions = tmp;
                             }
                           }

    break;

  case 78:

    { /* check the module with respect to the context now */
                         if (!param->submodule) {
                           switch (lyp_ctx_check_module(trg)) {
                           case -1:
                             YYABORT;
                           case 0:
                             break;
                           case 1:
                             /* it's already there */
                             param->flags |= YANG_EXIST_MODULE;
                             YYABORT;
                           }
                         }
                         param->flags &= (~YANG_REMOVE_IMPORT);
                         if (yang_check_imports(trg, param->unres)) {
                           YYABORT;
                         }
                         actual = NULL;
                       }

    break;

  case 79:

    { actual = NULL; }

    break;

  case 90:

    { (yyval.backup_token).token = actual_type;
                                        (yyval.backup_token).actual = actual;
                                        YANG_ADDELEM(trg->extensions, trg->extensions_size, 'extensions');
                                        trg->extensions_size--;
                                        ((struct lys_ext *)actual)->name = lydict_insert_zc(param->module->ctx, s);
                                        ((struct lys_ext *)actual)->module = trg;
                                        if (lyp_check_identifier(trg->ctx, ((struct lys_ext *)actual)->name, LY_IDENT_EXTENSION, trg, NULL)) {
                                          trg->extensions_size++;
                                          YYABORT;
                                        }
                                        trg->extensions_size++;
                                        s = NULL;
                                        actual_type = EXTENSION_KEYWORD;
                                      }

    break;

  case 91:

    { struct lys_ext *ext = actual;
                  ext->plugin = ext_get_plugin(ext->name, ext->module->name, ext->module->rev ? ext->module->rev[0].date : NULL);
                  actual_type = (yyvsp[-1].backup_token).token;
                  actual = (yyvsp[-1].backup_token).actual;
                }

    break;

  case 96:

    { if (((struct lys_ext *)actual)->flags & LYS_STATUS_MASK) {
                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'status', 'extension');
                                        YYABORT;
                                      }
                                      ((struct lys_ext *)actual)->flags |= (yyvsp[0].i);
                                    }

    break;

  case 97:

    { if (yang_read_description(trg, actual, s, 'extension', NODE)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                         }

    break;

  case 98:

    { if (yang_read_reference(trg, actual, s, 'extension', NODE)) {
                                           YYABORT;
                                         }
                                         s = NULL;
                                       }

    break;

  case 99:

    { (yyval.token) = actual_type;
                                   if (is_ext_instance) {
                                     if (yang_read_extcomplex_str(trg, ext_instance, 'argument', ext_name, s,
                                                                  0, LY_STMT_ARGUMENT)) {
                                       YYABORT;
                                     }
                                   } else {
                                     if (((struct lys_ext *)actual)->argument) {
                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'argument', 'extension');
                                        free(s);
                                        YYABORT;
                                     }
                                     ((struct lys_ext *)actual)->argument = lydict_insert_zc(param->module->ctx, s);
                                   }
                                   s = NULL;
                                   actual_type = ARGUMENT_KEYWORD;
                                 }

    break;

  case 100:

    { actual_type = (yyvsp[-1].token); }

    break;

  case 103:

    { (yyval.uint) = (yyvsp[0].uint);
                                       backup_type = actual_type;
                                       actual_type = YIN_ELEMENT_KEYWORD;
                                     }

    break;

  case 105:

    { if (is_ext_instance) {
         int c;
         const char ***p;
         uint8_t *val;
         struct lyext_substmt *info;

         c = 0;
         p = lys_ext_complex_get_substmt(LY_STMT_ARGUMENT, ext_instance, &info);
         if (info->cardinality >= LY_STMT_CARD_SOME) {
           /* get the index in the array to add new item */
           for (c = 0; p[0][c + 1]; c++);
           val = (uint8_t *)p[1];
         } else {
           val = (uint8_t *)(p + 1);
         }
         val[c] = ((yyvsp[-1].uint) == LYS_YINELEM) ? 1 : 2;
       } else {
         ((struct lys_ext *)actual)->flags |= (yyvsp[-1].uint);
       }
     }

    break;

  case 106:

    { (yyval.uint) = LYS_YINELEM; }

    break;

  case 107:

    { (yyval.uint) = 0; }

    break;

  case 108:

    { if (!strcmp(s, 'true')) {
                 (yyval.uint) = LYS_YINELEM;
               } else if (!strcmp(s, 'false')) {
                 (yyval.uint) = 0;
               } else {
                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);
                 free(s);
                 YYABORT;
               }
               free(s);
               s = NULL;
             }

    break;

  case 109:

    { (yyval.i) = (yyvsp[0].i);
                             backup_type = actual_type;
                             actual_type = STATUS_KEYWORD;
                           }

    break;

  case 110:

    { (yyval.i) = (yyvsp[-1].i); }

    break;

  case 111:

    { (yyval.i) = LYS_STATUS_CURR; }

    break;

  case 112:

    { (yyval.i) = LYS_STATUS_OBSLT; }

    break;

  case 113:

    { (yyval.i) = LYS_STATUS_DEPRC; }

    break;

  case 114:

    { if (!strcmp(s, 'current')) {
                 (yyval.i) = LYS_STATUS_CURR;
               } else if (!strcmp(s, 'obsolete')) {
                 (yyval.i) = LYS_STATUS_OBSLT;
               } else if (!strcmp(s, 'deprecated')) {
                 (yyval.i) = LYS_STATUS_DEPRC;
               } else {
                 LOGVAL(trg->ctx,LYE_INSTMT, LY_VLOG_NONE, NULL, s);
                 free(s);
                 YYABORT;
               }
               free(s);
               s = NULL;
             }

    break;

  case 115:

    { /* check uniqueness of feature's names */
                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_FEATURE, trg, NULL)) {
                                        free(s);
                                        YYABORT;
                                      }
                                      (yyval.backup_token).token = actual_type;
                                      (yyval.backup_token).actual = actual;
                                      YANG_ADDELEM(trg->features, trg->features_size, 'features');
                                      ((struct lys_feature *)actual)->name = lydict_insert_zc(trg->ctx, s);
                                      ((struct lys_feature *)actual)->module = trg;
                                      s = NULL;
                                      actual_type = FEATURE_KEYWORD;
                                    }

    break;

  case 116:

    { actual = (yyvsp[-1].backup_token).actual;
                actual_type = (yyvsp[-1].backup_token).token;
              }

    break;

  case 118:

    { struct lys_iffeature *tmp;

          if (((struct lys_feature *)actual)->iffeature_size) {
            tmp = realloc(((struct lys_feature *)actual)->iffeature,
                          ((struct lys_feature *)actual)->iffeature_size * sizeof *tmp);
            if (!tmp) {
              LOGMEM(trg->ctx);
              YYABORT;
            }
            ((struct lys_feature *)actual)->iffeature = tmp;
          }
        }

    break;

  case 121:

    { if (((struct lys_feature *)actual)->flags & LYS_STATUS_MASK) {
                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'status', 'feature');
                                      YYABORT;
                                    }
                                    ((struct lys_feature *)actual)->flags |= (yyvsp[0].i);
                                  }

    break;

  case 122:

    { if (yang_read_description(trg, actual, s, 'feature', NODE)) {
                                           YYABORT;
                                         }
                                         s = NULL;
                                       }

    break;

  case 123:

    { if (yang_read_reference(trg, actual, s, 'feature', NODE)) {
                                         YYABORT;
                                       }
                                       s = NULL;
                                     }

    break;

  case 124:

    { (yyval.backup_token).token = actual_type;
                         (yyval.backup_token).actual = actual;
                         switch (actual_type) {
                         case FEATURE_KEYWORD:
                           YANG_ADDELEM(((struct lys_feature *)actual)->iffeature,
                                        ((struct lys_feature *)actual)->iffeature_size, 'if-features');
                           break;
                         case IDENTITY_KEYWORD:
                           if (trg->version < 2) {
                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'if-feature', 'identity');
                             free(s);
                             YYABORT;
                           }
                           YANG_ADDELEM(((struct lys_ident *)actual)->iffeature,
                                        ((struct lys_ident *)actual)->iffeature_size, 'if-features');
                           break;
                         case ENUM_KEYWORD:
                           if (trg->version < 2) {
                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'if-feature');
                             free(s);
                             YYABORT;
                           }
                           YANG_ADDELEM(((struct lys_type_enum *)actual)->iffeature,
                                        ((struct lys_type_enum *)actual)->iffeature_size, 'if-features');
                           break;
                         case BIT_KEYWORD:
                           if (trg->version < 2) {
                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'if-feature', 'bit');
                             free(s);
                             YYABORT;
                           }
                           YANG_ADDELEM(((struct lys_type_bit *)actual)->iffeature,
                                        ((struct lys_type_bit *)actual)->iffeature_size, 'if-features');
                           break;
                         case REFINE_KEYWORD:
                           if (trg->version < 2) {
                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'if-feature');
                             free(s);
                             YYABORT;
                           }
                           YANG_ADDELEM(((struct lys_refine *)actual)->iffeature,
                                        ((struct lys_refine *)actual)->iffeature_size, 'if-features');
                           break;
                         case EXTENSION_INSTANCE:
                           /* nothing change */
                           break;
                         default:
                           /* lys_node_* */
                           YANG_ADDELEM(((struct lys_node *)actual)->iffeature,
                                        ((struct lys_node *)actual)->iffeature_size, 'if-features');
                           break;
                         }
                         ((struct lys_iffeature *)actual)->features = (struct lys_feature **)s;
                         s = NULL;
                         actual_type = IF_FEATURE_KEYWORD;
                       }

    break;

  case 125:

    { actual = (yyvsp[-1].backup_token).actual;
                   actual_type = (yyvsp[-1].backup_token).token;
                 }

    break;

  case 128:

    { const char *tmp;

                                       tmp = lydict_insert_zc(trg->ctx, s);
                                       s = NULL;
                                       if (dup_identities_check(tmp, trg)) {
                                         lydict_remove(trg->ctx, tmp);
                                         YYABORT;
                                       }
                                       (yyval.backup_token).token = actual_type;
                                       (yyval.backup_token).actual = actual;
                                       YANG_ADDELEM(trg->ident, trg->ident_size, 'identities');
                                       ((struct lys_ident *)actual)->name = tmp;
                                       ((struct lys_ident *)actual)->module = trg;
                                       actual_type = IDENTITY_KEYWORD;
                                     }

    break;

  case 129:

    { actual = (yyvsp[-1].backup_token).actual;
                 actual_type = (yyvsp[-1].backup_token).token;
               }

    break;

  case 131:

    { void *tmp;

           if (((struct lys_ident *)actual)->base_size) {
             tmp = realloc(((struct lys_ident *)actual)->base,
                           ((struct lys_ident *)actual)->base_size * sizeof *((struct lys_ident *)actual)->base);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             ((struct lys_ident *)actual)->base = tmp;
           }

           if (((struct lys_ident *)actual)->iffeature_size) {
             tmp = realloc(((struct lys_ident *)actual)->iffeature,
                           ((struct lys_ident *)actual)->iffeature_size * sizeof *((struct lys_ident *)actual)->iffeature);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             ((struct lys_ident *)actual)->iffeature = tmp;
           }
         }

    break;

  case 133:

    { void *identity;

                                   if ((trg->version < 2) && ((struct lys_ident *)actual)->base_size) {
                                     free(s);
                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'base', 'identity');
                                     YYABORT;
                                   }
                                   identity = actual;
                                   YANG_ADDELEM(((struct lys_ident *)actual)->base,
                                                ((struct lys_ident *)actual)->base_size, 'bases');
                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;
                                   s = NULL;
                                   actual = identity;
                                 }

    break;

  case 135:

    { if (((struct lys_ident *)actual)->flags & LYS_STATUS_MASK) {
                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'status', 'identity');
                                       YYABORT;
                                     }
                                     ((struct lys_ident *)actual)->flags |= (yyvsp[0].i);
                                   }

    break;

  case 136:

    { if (yang_read_description(trg, actual, s, 'identity', NODE)) {
                                            YYABORT;
                                          }
                                          s = NULL;
                                        }

    break;

  case 137:

    { if (yang_read_reference(trg, actual, s, 'identity', NODE)) {
                                          YYABORT;
                                        }
                                        s = NULL;
                                      }

    break;

  case 138:

    { backup_type = actual_type;
                                   actual_type = BASE_KEYWORD;
                                 }

    break;

  case 140:

    { tpdf_parent = (actual_type == EXTENSION_INSTANCE) ? ext_instance : actual;
                                      (yyval.backup_token).token = actual_type;
                                      (yyval.backup_token).actual = actual;
                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_TYPE, trg, tpdf_parent)) {
                                        free(s);
                                        YYABORT;
                                      }
                                      switch (actual_type) {
                                      case MODULE_KEYWORD:
                                      case SUBMODULE_KEYWORD:
                                        YANG_ADDELEM(trg->tpdf, trg->tpdf_size, 'typedefs');
                                        break;
                                      case GROUPING_KEYWORD:
                                        YANG_ADDELEM(((struct lys_node_grp *)tpdf_parent)->tpdf,
                                                     ((struct lys_node_grp *)tpdf_parent)->tpdf_size, 'typedefs');
                                        break;
                                      case CONTAINER_KEYWORD:
                                        YANG_ADDELEM(((struct lys_node_container *)tpdf_parent)->tpdf,
                                                     ((struct lys_node_container *)tpdf_parent)->tpdf_size, 'typedefs');
                                        break;
                                      case LIST_KEYWORD:
                                        YANG_ADDELEM(((struct lys_node_list *)tpdf_parent)->tpdf,
                                                     ((struct lys_node_list *)tpdf_parent)->tpdf_size, 'typedefs');
                                        break;
                                      case RPC_KEYWORD:
                                      case ACTION_KEYWORD:
                                        YANG_ADDELEM(((struct lys_node_rpc_action *)tpdf_parent)->tpdf,
                                                     ((struct lys_node_rpc_action *)tpdf_parent)->tpdf_size, 'typedefs');
                                        break;
                                      case INPUT_KEYWORD:
                                      case OUTPUT_KEYWORD:
                                        YANG_ADDELEM(((struct lys_node_inout *)tpdf_parent)->tpdf,
                                                     ((struct lys_node_inout *)tpdf_parent)->tpdf_size, 'typedefs');
                                        break;
                                      case NOTIFICATION_KEYWORD:
                                        YANG_ADDELEM(((struct lys_node_notif *)tpdf_parent)->tpdf,
                                                     ((struct lys_node_notif *)tpdf_parent)->tpdf_size, 'typedefs');
                                        break;
                                      case EXTENSION_INSTANCE:
                                        /* typedef is already allocated */
                                        break;
                                      default:
                                        /* another type of nodetype is error*/
                                        LOGINT(trg->ctx);
                                        free(s);
                                        YYABORT;
                                      }
                                      ((struct lys_tpdf *)actual)->name = lydict_insert_zc(param->module->ctx, s);
                                      ((struct lys_tpdf *)actual)->module = trg;
                                      s = NULL;
                                      actual_type = TYPEDEF_KEYWORD;
                                    }

    break;

  case 141:

    { if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {
                      LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'type', 'typedef');
                      YYABORT;
                    }
                    actual_type = (yyvsp[-4].backup_token).token;
                    actual = (yyvsp[-4].backup_token).actual;
                  }

    break;

  case 142:

    { (yyval.nodes).node.ptr_tpdf = actual;
                            (yyval.nodes).node.flag = 0;
                          }

    break;

  case 143:

    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;
                                       (yyval.nodes) = (yyvsp[-2].nodes);
                                     }

    break;

  case 144:

    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {
                                  YYABORT;
                                }
                                s = NULL;
                              }

    break;

  case 145:

    { if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {
                                    YYABORT;
                                  }
                                  s = NULL;
                                }

    break;

  case 146:

    { if ((yyvsp[-1].nodes).node.ptr_tpdf->flags & LYS_STATUS_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'status', 'typedef');
                                   YYABORT;
                                 }
                                 (yyvsp[-1].nodes).node.ptr_tpdf->flags |= (yyvsp[0].i);
                               }

    break;

  case 147:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, 'typedef', NODE)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 148:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, 'typedef', NODE)) {
                                      YYABORT;
                                    }
                                    s = NULL;
                                  }

    break;

  case 149:

    { actual_type = (yyvsp[-1].backup_token).token;
             actual = (yyvsp[-1].backup_token).actual;
           }

    break;

  case 150:

    { (yyval.backup_token).token = actual_type;
                                       (yyval.backup_token).actual = actual;
                                       if (!(actual = yang_read_type(trg->ctx, actual, s, actual_type))) {
                                         YYABORT;
                                       }
                                       s = NULL;
                                       actual_type = TYPE_KEYWORD;
                                     }

    break;

  case 153:

    { if (((struct yang_type *)actual)->base == LY_TYPE_STRING &&
                                         ((struct yang_type *)actual)->type->info.str.pat_count) {
                                       void *tmp;

                                       tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns,
                                                     ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns);
                                       if (!tmp) {
                                         LOGMEM(trg->ctx);
                                         YYABORT;
                                       }
                                       ((struct yang_type *)actual)->type->info.str.patterns = tmp;

#ifdef LY_ENABLED_CACHE
                                       if (!(trg->ctx->models.flags & LY_CTX_TRUSTED) && ((struct yang_type *)actual)->type->info.str.patterns_pcre) {
                                         tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns_pcre,
                                                       2 * ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns_pcre);
                                         if (!tmp) {
                                           LOGMEM(trg->ctx);
                                           YYABORT;
                                         }
                                         ((struct yang_type *)actual)->type->info.str.patterns_pcre = tmp;
                                       }
#endif
                                     }
                                     if (((struct yang_type *)actual)->base == LY_TYPE_UNION) {
                                       struct lys_type *tmp;

                                       tmp = realloc(((struct yang_type *)actual)->type->info.uni.types,
                                                     ((struct yang_type *)actual)->type->info.uni.count * sizeof *tmp);
                                       if (!tmp) {
                                         LOGMEM(trg->ctx);
                                         YYABORT;
                                       }
                                       ((struct yang_type *)actual)->type->info.uni.types = tmp;
                                     }
                                     if (((struct yang_type *)actual)->base == LY_TYPE_IDENT) {
                                       struct lys_ident **tmp;

                                       tmp = realloc(((struct yang_type *)actual)->type->info.ident.ref,
                                                     ((struct yang_type *)actual)->type->info.ident.count* sizeof *tmp);
                                       if (!tmp) {
                                         LOGMEM(trg->ctx);
                                         YYABORT;
                                       }
                                       ((struct yang_type *)actual)->type->info.ident.ref = tmp;
                                     }
                                   }

    break;

  case 157:

    { if (yang_read_require_instance(trg->ctx, actual, (yyvsp[0].i))) {
                                                 YYABORT;
                                               }
                                             }

    break;

  case 158:

    { /* leafref_specification */
                                   if (yang_read_leafref_path(trg, actual, s)) {
                                     YYABORT;
                                   }
                                   s = NULL;
                                 }

    break;

  case 159:

    { /* identityref_specification */
                                   if (((struct yang_type *)actual)->base && ((struct yang_type *)actual)->base != LY_TYPE_IDENT) {
                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'base');
                                     return EXIT_FAILURE;
                                   }
                                   ((struct yang_type *)actual)->base = LY_TYPE_IDENT;
                                   yang_type = actual;
                                   YANG_ADDELEM(((struct yang_type *)actual)->type->info.ident.ref,
                                                ((struct yang_type *)actual)->type->info.ident.count, 'identity refs');
                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;
                                   actual = yang_type;
                                   s = NULL;
                                 }

    break;

  case 162:

    { if (yang_read_fraction(trg->ctx, actual, (yyvsp[0].uint))) {
                                                YYABORT;
                                              }
                                            }

    break;

  case 165:

    { actual_type = (yyvsp[-1].backup_token).token;
                                   actual = (yyvsp[-1].backup_token).actual;
                                 }

    break;

  case 166:

    { struct yang_type *stype = (struct yang_type *)actual;

                         (yyval.backup_token).token = actual_type;
                         (yyval.backup_token).actual = actual;
                         if (stype->base != 0 && stype->base != LY_TYPE_UNION) {
                           LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Unexpected type statement.');
                           YYABORT;
                         }
                         stype->base = LY_TYPE_UNION;
                         if (strcmp(stype->name, 'union')) {
                           /* type can be a substatement only in 'union' type, not in derived types */
                           LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, 'type', 'derived type');
                           YYABORT;
                         }
                         YANG_ADDELEM(stype->type->info.uni.types, stype->type->info.uni.count, 'union types')
                         actual_type = UNION_KEYWORD;
                       }

    break;

  case 167:

    { (yyval.uint) = (yyvsp[0].uint);
                                               backup_type = actual_type;
                                               actual_type = FRACTION_DIGITS_KEYWORD;
                                             }

    break;

  case 168:

    { (yyval.uint) = (yyvsp[-1].uint); }

    break;

  case 169:

    { (yyval.uint) = (yyvsp[-1].uint); }

    break;

  case 170:

    { char *endptr = NULL;
               unsigned long val;
               errno = 0;

               val = strtoul(s, &endptr, 10);
               if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {
                 LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'fraction-digits');
                 free(s);
                 s = NULL;
                 YYABORT;
               }
               (yyval.uint) = (uint32_t) val;
               free(s);
               s =NULL;
             }

    break;

  case 171:

    { actual = (yyvsp[-1].backup_token).actual;
               actual_type = (yyvsp[-1].backup_token).token;
             }

    break;

  case 172:

    { (yyval.backup_token).token = actual_type;
                         (yyval.backup_token).actual = actual;
                         if (!(actual = yang_read_length(trg->ctx, actual, s, is_ext_instance))) {
                           YYABORT;
                         }
                         actual_type = LENGTH_KEYWORD;
                         s = NULL;
                       }

    break;

  case 175:

    { switch (actual_type) {
                               case MUST_KEYWORD:
                                 (yyval.str) = 'must';
                                 break;
                               case LENGTH_KEYWORD:
                                 (yyval.str) = 'length';
                                 break;
                               case RANGE_KEYWORD:
                                 (yyval.str) = 'range';
                                 break;
                               default:
                                 LOGINT(trg->ctx);
                                 YYABORT;
                                 break;
                               }
                             }

    break;

  case 176:

    { if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_MESSAGE_KEYWORD)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                         }

    break;

  case 177:

    { if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_APP_TAG_KEYWORD)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                         }

    break;

  case 178:

    { if (yang_read_description(trg, actual, s, (yyvsp[-1].str), NODE)) {
                                           YYABORT;
                                          }
                                          s = NULL;
                                        }

    break;

  case 179:

    { if (yang_read_reference(trg, actual, s, (yyvsp[-1].str), NODE)) {
                                         YYABORT;
                                       }
                                       s = NULL;
                                     }

    break;

  case 180:

    { (yyval.backup_token).token = actual_type;
                   (yyval.backup_token).actual = actual;
                 }

    break;

  case 181:

    {struct lys_restr *pattern = actual;
                                                                        actual = NULL;
#ifdef LY_ENABLED_CACHE
                                                                        if ((yyvsp[-2].backup_token).token != EXTENSION_INSTANCE &&
                                                                            !(data_node && data_node->nodetype != LYS_GROUPING && lys_ingrouping(data_node))) {
                                                                          unsigned int c = 2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1);
                                                                          YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, 'patterns');
                                                                          ++c;
                                                                          YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, 'patterns');
                                                                          actual = &(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1)];
                                                                        }
#endif
                                                                        if (yang_read_pattern(trg->ctx, pattern, actual, (yyvsp[-1].str), (yyvsp[0].ch))) {
                                                                          YYABORT;
                                                                        }
                                                                        actual_type = (yyvsp[-2].backup_token).token;
                                                                        actual = (yyvsp[-2].backup_token).actual;
                                                                      }

    break;

  case 182:

    { if (actual_type != EXTENSION_INSTANCE) {
                            if (((struct yang_type *)actual)->base != 0 && ((struct yang_type *)actual)->base != LY_TYPE_STRING) {
                              free(s);
                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Unexpected pattern statement.');
                              YYABORT;
                            }
                            ((struct yang_type *)actual)->base = LY_TYPE_STRING;
                            YANG_ADDELEM(((struct yang_type *)actual)->type->info.str.patterns,
                                         ((struct yang_type *)actual)->type->info.str.pat_count, 'patterns');
                          }
                          (yyval.str) = s;
                          s = NULL;
                          actual_type = PATTERN_KEYWORD;
                        }

    break;

  case 183:

    { (yyval.ch) = 0x06; }

    break;

  case 184:

    { (yyval.ch) = (yyvsp[-1].ch); }

    break;

  case 185:

    { (yyval.ch) = 0x06; /* ACK */ }

    break;

  case 186:

    { if (trg->version < 2) {
                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, 'modifier');
                                        YYABORT;
                                      }
                                      if ((yyvsp[-1].ch) != 0x06) {
                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'modifier', 'pattern');
                                        YYABORT;
                                      }
                                      (yyval.ch) = (yyvsp[0].ch);
                                    }

    break;

  case 187:

    { if (yang_read_message(trg, actual, s, 'pattern', ERROR_MESSAGE_KEYWORD)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                         }

    break;

  case 188:

    { if (yang_read_message(trg, actual, s, 'pattern', ERROR_APP_TAG_KEYWORD)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                         }

    break;

  case 189:

    { if (yang_read_description(trg, actual, s, 'pattern', NODE)) {
                                           YYABORT;
                                          }
                                          s = NULL;
                                        }

    break;

  case 190:

    { if (yang_read_reference(trg, actual, s, 'pattern', NODE)) {
                                         YYABORT;
                                       }
                                       s = NULL;
                                     }

    break;

  case 191:

    { backup_type = actual_type;
                       actual_type = MODIFIER_KEYWORD;
                     }

    break;

  case 192:

    { if (!strcmp(s, 'invert-match')) {
                                                             (yyval.ch) = 0x15;
                                                             free(s);
                                                             s = NULL;
                                                           } else {
                                                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);
                                                             free(s);
                                                             YYABORT;
                                                           }
                                                         }

    break;

  case 193:

    { struct lys_type_enum * tmp;

                                                   cnt_val = 0;
                                                   tmp = realloc(((struct yang_type *)actual)->type->info.enums.enm,
                                                                 ((struct yang_type *)actual)->type->info.enums.count * sizeof *tmp);
                                                   if (!tmp) {
                                                     LOGMEM(trg->ctx);
                                                     YYABORT;
                                                   }
                                                   ((struct yang_type *)actual)->type->info.enums.enm = tmp;
                                                 }

    break;

  case 196:

    { if (yang_check_enum(trg->ctx, yang_type, actual, &cnt_val, is_value)) {
               YYABORT;
             }
             actual = (yyvsp[-1].backup_token).actual;
             actual_type = (yyvsp[-1].backup_token).token;
           }

    break;

  case 197:

    { (yyval.backup_token).token = actual_type;
                       (yyval.backup_token).actual = yang_type = actual;
                       YANG_ADDELEM(((struct yang_type *)actual)->type->info.enums.enm, ((struct yang_type *)actual)->type->info.enums.count, 'enums');
                       if (yang_read_enum(trg->ctx, yang_type, actual, s)) {
                         YYABORT;
                       }
                       s = NULL;
                       is_value = 0;
                       actual_type = ENUM_KEYWORD;
                     }

    break;

  case 199:

    { if (((struct lys_type_enum *)actual)->iffeature_size) {
             struct lys_iffeature *tmp;

             tmp = realloc(((struct lys_type_enum *)actual)->iffeature,
                           ((struct lys_type_enum *)actual)->iffeature_size * sizeof *tmp);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             ((struct lys_type_enum *)actual)->iffeature = tmp;
           }
         }

    break;

  case 202:

    { if (is_value) {
                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'value', 'enum');
                                  YYABORT;
                                }
                                ((struct lys_type_enum *)actual)->value = (yyvsp[0].i);

                                /* keep the highest enum value for automatic increment */
                                if ((yyvsp[0].i) >= cnt_val) {
                                  cnt_val = (yyvsp[0].i) + 1;
                                }
                                is_value = 1;
                              }

    break;

  case 203:

    { if (((struct lys_type_enum *)actual)->flags & LYS_STATUS_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'status', 'enum');
                                   YYABORT;
                                 }
                                 ((struct lys_type_enum *)actual)->flags |= (yyvsp[0].i);
                               }

    break;

  case 204:

    { if (yang_read_description(trg, actual, s, 'enum', NODE)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 205:

    { if (yang_read_reference(trg, actual, s, 'enum', NODE)) {
                                      YYABORT;
                                    }
                                    s = NULL;
                                  }

    break;

  case 206:

    { (yyval.i) = (yyvsp[0].i);
                                   backup_type = actual_type;
                                   actual_type = VALUE_KEYWORD;
                                 }

    break;

  case 207:

    { (yyval.i) = (yyvsp[-1].i); }

    break;

  case 208:

    { (yyval.i) = (yyvsp[-1].i); }

    break;

  case 209:

    { /* convert it to int32_t */
                int64_t val;
                char *endptr;

                val = strtoll(s, &endptr, 10);
                if (val < INT32_MIN || val > INT32_MAX || *endptr) {
                    LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'value');
                    free(s);
                    YYABORT;
                }
                free(s);
                s = NULL;
                (yyval.i) = (int32_t) val;
             }

    break;

  case 210:

    { actual_type = (yyvsp[-1].backup_token).token;
                                                        actual = (yyvsp[-1].backup_token).actual;
                                                      }

    break;

  case 213:

    { backup_type = actual_type;
                         actual_type = PATH_KEYWORD;
                       }

    break;

  case 215:

    { (yyval.i) = (yyvsp[0].i);
                                                 backup_type = actual_type;
                                                 actual_type = REQUIRE_INSTANCE_KEYWORD;
                                               }

    break;

  case 216:

    { (yyval.i) = (yyvsp[-1].i); }

    break;

  case 217:

    { (yyval.i) = 1; }

    break;

  case 218:

    { (yyval.i) = -1; }

    break;

  case 219:

    { if (!strcmp(s,'true')) {
                  (yyval.i) = 1;
                } else if (!strcmp(s,'false')) {
                  (yyval.i) = -1;
                } else {
                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'require-instance');
                  free(s);
                  YYABORT;
                }
                free(s);
                s = NULL;
              }

    break;

  case 220:

    { struct lys_type_bit * tmp;

                                         cnt_val = 0;
                                         tmp = realloc(((struct yang_type *)actual)->type->info.bits.bit,
                                                       ((struct yang_type *)actual)->type->info.bits.count * sizeof *tmp);
                                         if (!tmp) {
                                           LOGMEM(trg->ctx);
                                           YYABORT;
                                         }
                                         ((struct yang_type *)actual)->type->info.bits.bit = tmp;
                                       }

    break;

  case 223:

    { if (yang_check_bit(trg->ctx, yang_type, actual, &cnt_val, is_value)) {
                      YYABORT;
                    }
                    actual = (yyvsp[-2].backup_token).actual;
                    actual_type = (yyvsp[-2].backup_token).token;
                  }

    break;

  case 224:

    { (yyval.backup_token).token = actual_type;
                                  (yyval.backup_token).actual = yang_type = actual;
                                  YANG_ADDELEM(((struct yang_type *)actual)->type->info.bits.bit,
                                               ((struct yang_type *)actual)->type->info.bits.count, 'bits');
                                  if (yang_read_bit(trg->ctx, yang_type, actual, s)) {
                                    YYABORT;
                                  }
                                  s = NULL;
                                  is_value = 0;
                                  actual_type = BIT_KEYWORD;
                                }

    break;

  case 226:

    { if (((struct lys_type_bit *)actual)->iffeature_size) {
             struct lys_iffeature *tmp;

             tmp = realloc(((struct lys_type_bit *)actual)->iffeature,
                           ((struct lys_type_bit *)actual)->iffeature_size * sizeof *tmp);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             ((struct lys_type_bit *)actual)->iffeature = tmp;
           }
         }

    break;

  case 229:

    { if (is_value) {
                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'position', 'bit');
                                    YYABORT;
                                  }
                                  ((struct lys_type_bit *)actual)->pos = (yyvsp[0].uint);

                                  /* keep the highest position value for automatic increment */
                                  if ((yyvsp[0].uint) >= cnt_val) {
                                    cnt_val = (yyvsp[0].uint) + 1;
                                  }
                                  is_value = 1;
                                }

    break;

  case 230:

    { if (((struct lys_type_bit *)actual)->flags & LYS_STATUS_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'status', 'bit');
                                   YYABORT;
                                 }
                                 ((struct lys_type_bit *)actual)->flags |= (yyvsp[0].i);
                              }

    break;

  case 231:

    { if (yang_read_description(trg, actual, s, 'bit', NODE)) {
                                       YYABORT;
                                     }
                                     s = NULL;
                                   }

    break;

  case 232:

    { if (yang_read_reference(trg, actual, s, 'bit', NODE)) {
                                     YYABORT;
                                   }
                                   s = NULL;
                                 }

    break;

  case 233:

    { (yyval.uint) = (yyvsp[0].uint);
                                             backup_type = actual_type;
                                             actual_type = POSITION_KEYWORD;
                                           }

    break;

  case 234:

    { (yyval.uint) = (yyvsp[-1].uint); }

    break;

  case 235:

    { (yyval.uint) = (yyvsp[-1].uint); }

    break;

  case 236:

    { /* convert it to uint32_t */
                unsigned long val;
                char *endptr = NULL;
                errno = 0;

                val = strtoul(s, &endptr, 10);
                if (s[0] == '-' || *endptr || errno || val > UINT32_MAX) {
                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'position');
                  free(s);
                  YYABORT;
                }
                free(s);
                s = NULL;
                (yyval.uint) = (uint32_t) val;
              }

    break;

  case 237:

    { backup_type = actual_type;
                            actual_type = ERROR_MESSAGE_KEYWORD;
                          }

    break;

  case 239:

    { backup_type = actual_type;
                            actual_type = ERROR_APP_TAG_KEYWORD;
                          }

    break;

  case 241:

    { backup_type = actual_type;
                    actual_type = UNITS_KEYWORD;
                  }

    break;

  case 243:

    { backup_type = actual_type;
                      actual_type = DEFAULT_KEYWORD;
                    }

    break;

  case 245:

    { (yyval.backup_token).token = actual_type;
                                       (yyval.backup_token).actual = actual;
                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_GROUPING, sizeof(struct lys_node_grp)))) {
                                         YYABORT;
                                       }
                                       s = NULL;
                                       data_node = actual;
                                       actual_type = GROUPING_KEYWORD;
                                     }

    break;

  case 246:

    { LOGDBG(LY_LDGYANG, 'finished parsing grouping statement \'%s\'', data_node->name);
                 actual_type = (yyvsp[-1].backup_token).token;
                 actual = (yyvsp[-1].backup_token).actual;
                 data_node = (yyvsp[-1].backup_token).actual;
               }

    break;

  case 249:

    { (yyval.nodes).grouping = actual; }

    break;

  case 250:

    { if ((yyvsp[-1].nodes).grouping->flags & LYS_STATUS_MASK) {
                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).grouping, 'status', 'grouping');
                                       YYABORT;
                                     }
                                     (yyvsp[-1].nodes).grouping->flags |= (yyvsp[0].i);
                                   }

    break;

  case 251:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).grouping, s, 'grouping', NODE_PRINT)) {
                                            YYABORT;
                                          }
                                          s = NULL;
                                        }

    break;

  case 252:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).grouping, s, 'grouping', NODE_PRINT)) {
                                          YYABORT;
                                        }
                                        s = NULL;
                                      }

    break;

  case 257:

    { if (trg->version < 2) {
                                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).grouping, 'notification');
                                                     YYABORT;
                                                   }
                                                 }

    break;

  case 266:

    { (yyval.backup_token).token = actual_type;
                                        (yyval.backup_token).actual = actual;
                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CONTAINER, sizeof(struct lys_node_container)))) {
                                          YYABORT;
                                        }
                                        data_node = actual;
                                        s = NULL;
                                        actual_type = CONTAINER_KEYWORD;
                                      }

    break;

  case 267:

    { LOGDBG(LY_LDGYANG, 'finished parsing container statement \'%s\'', data_node->name);
                  actual_type = (yyvsp[-1].backup_token).token;
                  actual = (yyvsp[-1].backup_token).actual;
                  data_node = (yyvsp[-1].backup_token).actual;
                }

    break;

  case 269:

    { void *tmp;

            if ((yyvsp[-1].nodes).container->iffeature_size) {
              tmp = realloc((yyvsp[-1].nodes).container->iffeature, (yyvsp[-1].nodes).container->iffeature_size * sizeof *(yyvsp[-1].nodes).container->iffeature);
              if (!tmp) {
                LOGMEM(trg->ctx);
                YYABORT;
              }
              (yyvsp[-1].nodes).container->iffeature = tmp;
            }

            if ((yyvsp[-1].nodes).container->must_size) {
              tmp = realloc((yyvsp[-1].nodes).container->must, (yyvsp[-1].nodes).container->must_size * sizeof *(yyvsp[-1].nodes).container->must);
              if (!tmp) {
                LOGMEM(trg->ctx);
                YYABORT;
              }
              (yyvsp[-1].nodes).container->must = tmp;
            }
          }

    break;

  case 270:

    { (yyval.nodes).container = actual; }

    break;

  case 274:

    { if (yang_read_presence(trg, (yyvsp[-1].nodes).container, s)) {
                                          YYABORT;
                                        }
                                        s = NULL;
                                      }

    break;

  case 275:

    { if ((yyvsp[-1].nodes).container->flags & LYS_CONFIG_MASK) {
                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, 'config', 'container');
                                        YYABORT;
                                      }
                                      (yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);
                                    }

    break;

  case 276:

    { if ((yyvsp[-1].nodes).container->flags & LYS_STATUS_MASK) {
                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, 'status', 'container');
                                        YYABORT;
                                      }
                                      (yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);
                                    }

    break;

  case 277:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).container, s, 'container', NODE_PRINT)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                         }

    break;

  case 278:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).container, s, 'container', NODE_PRINT)) {
                                           YYABORT;
                                         }
                                         s = NULL;
                                       }

    break;

  case 281:

    { if (trg->version < 2) {
                                                      LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).container, 'notification');
                                                      YYABORT;
                                                    }
                                                  }

    break;

  case 284:

    { void *tmp;

                  if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {
                    LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, 'type', 'leaf');
                    YYABORT;
                  }
                  if ((yyvsp[-1].nodes).node.ptr_leaf->dflt && ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_TRUE)) {
                    /* RFC 6020, 7.6.4 - default statement must not with mandatory true */
                    LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, 'mandatory', 'leaf');
                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, 'The \'mandatory\' statement is forbidden on leaf with \'default\'.');
                    YYABORT;
                  }

                  if ((yyvsp[-1].nodes).node.ptr_leaf->iffeature_size) {
                    tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->iffeature, (yyvsp[-1].nodes).node.ptr_leaf->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->iffeature);
                    if (!tmp) {
                      LOGMEM(trg->ctx);
                      YYABORT;
                    }
                    (yyvsp[-1].nodes).node.ptr_leaf->iffeature = tmp;
                  }

                  if ((yyvsp[-1].nodes).node.ptr_leaf->must_size) {
                    tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->must, (yyvsp[-1].nodes).node.ptr_leaf->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->must);
                    if (!tmp) {
                      LOGMEM(trg->ctx);
                      YYABORT;
                    }
                    (yyvsp[-1].nodes).node.ptr_leaf->must = tmp;
                  }

                  LOGDBG(LY_LDGYANG, 'finished parsing leaf statement \'%s\'', data_node->name);
                  actual_type = (yyvsp[-4].backup_token).token;
                  actual = (yyvsp[-4].backup_token).actual;
                  data_node = (yyvsp[-4].backup_token).actual;
                }

    break;

  case 285:

    { (yyval.backup_token).token = actual_type;
                                   (yyval.backup_token).actual = actual;
                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAF, sizeof(struct lys_node_leaf)))) {
                                     YYABORT;
                                   }
                                   data_node = actual;
                                   s = NULL;
                                   actual_type = LEAF_KEYWORD;
                                 }

    break;

  case 286:

    { (yyval.nodes).node.ptr_leaf = actual;
                            (yyval.nodes).node.flag = 0;
                          }

    break;

  case 289:

    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;
                                       (yyval.nodes) = (yyvsp[-2].nodes);
                                     }

    break;

  case 290:

    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {
                                  YYABORT;
                                }
                                s = NULL;
                              }

    break;

  case 292:

    { if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {
                                    YYABORT;
                                  }
                                  s = NULL;
                                }

    break;

  case 293:

    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_CONFIG_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, 'config', 'leaf');
                                   YYABORT;
                                 }
                                 (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);
                               }

    break;

  case 294:

    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_MASK) {
                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, 'mandatory', 'leaf');
                                      YYABORT;
                                    }
                                    (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);
                                  }

    break;

  case 295:

    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_STATUS_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, 'status', 'leaf');
                                   YYABORT;
                                 }
                                 (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);
                               }

    break;

  case 296:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, 'leaf', NODE_PRINT)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 297:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, 'leaf', NODE_PRINT)) {
                                      YYABORT;
                                    }
                                    s = NULL;
                                  }

    break;

  case 298:

    { (yyval.backup_token).token = actual_type;
                                        (yyval.backup_token).actual = actual;
                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAFLIST, sizeof(struct lys_node_leaflist)))) {
                                          YYABORT;
                                        }
                                        data_node = actual;
                                        s = NULL;
                                        actual_type = LEAF_LIST_KEYWORD;
                                      }

    break;

  case 299:

    { void *tmp;

                        if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_R) {
                          /* RFC 6020, 7.7.5 - ignore ordering when the list represents state data
                           * ignore oredering MASK - 0x7F
                           */
                          (yyvsp[-1].nodes).node.ptr_leaflist->flags &= 0x7F;
                        }
                        if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {
                          LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'type', 'leaf-list');
                          YYABORT;
                        }
                        if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size && (yyvsp[-1].nodes).node.ptr_leaflist->min) {
                          LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'min-elements', 'leaf-list');
                          LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist,
                                 'The \'min-elements\' statement with non-zero value is forbidden on leaf-lists with the \'default\' statement.');
                          YYABORT;
                        }

                        if ((yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size) {
                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->iffeature, (yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->iffeature);
                          if (!tmp) {
                            LOGMEM(trg->ctx);
                            YYABORT;
                          }
                          (yyvsp[-1].nodes).node.ptr_leaflist->iffeature = tmp;
                        }

                        if ((yyvsp[-1].nodes).node.ptr_leaflist->must_size) {
                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->must, (yyvsp[-1].nodes).node.ptr_leaflist->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->must);
                          if (!tmp) {
                            LOGMEM(trg->ctx);
                            YYABORT;
                          }
                          (yyvsp[-1].nodes).node.ptr_leaflist->must = tmp;
                        }

                        if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size) {
                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->dflt, (yyvsp[-1].nodes).node.ptr_leaflist->dflt_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->dflt);
                          if (!tmp) {
                            LOGMEM(trg->ctx);
                            YYABORT;
                          }
                          (yyvsp[-1].nodes).node.ptr_leaflist->dflt = tmp;
                        }

                        LOGDBG(LY_LDGYANG, 'finished parsing leaf-list statement \'%s\'', data_node->name);
                        actual_type = (yyvsp[-4].backup_token).token;
                        actual = (yyvsp[-4].backup_token).actual;
                        data_node = (yyvsp[-4].backup_token).actual;
                      }

    break;

  case 300:

    { (yyval.nodes).node.ptr_leaflist = actual;
                                 (yyval.nodes).node.flag = 0;
                               }

    break;

  case 303:

    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;
                                            (yyval.nodes) = (yyvsp[-2].nodes);
                                          }

    break;

  case 304:

    { if (trg->version < 2) {
                                         free(s);
                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'default');
                                         YYABORT;
                                       }
                                       YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_leaflist->dflt,
                                                    (yyvsp[-1].nodes).node.ptr_leaflist->dflt_size, 'defaults');
                                       (*(const char **)actual) = lydict_insert_zc(param->module->ctx, s);
                                       s = NULL;
                                       actual = (yyvsp[-1].nodes).node.ptr_leaflist;
                                     }

    break;

  case 305:

    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, LEAF_LIST_KEYWORD)) {
                                       YYABORT;
                                     }
                                     s = NULL;
                                   }

    break;

  case 307:

    { if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_MASK) {
                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'config', 'leaf-list');
                                        YYABORT;
                                      }
                                      (yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);
                                    }

    break;

  case 308:

    { if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {
                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'min-elements', 'leaf-list');
                                              YYABORT;
                                            }
                                            (yyvsp[-1].nodes).node.ptr_leaflist->min = (yyvsp[0].uint);
                                            (yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;
                                            (yyval.nodes) = (yyvsp[-1].nodes);
                                            if ((yyvsp[-1].nodes).node.ptr_leaflist->max && ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max)) {
                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'Invalid value \'%d\' of \'%s\'.', (yyvsp[0].uint), 'min-elements');
                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, '\'min-elements\' is bigger than \'max-elements\'.');
                                              YYABORT;
                                            }
                                          }

    break;

  case 309:

    { if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {
                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'max-elements', 'leaf-list');
                                              YYABORT;
                                            }
                                            (yyvsp[-1].nodes).node.ptr_leaflist->max = (yyvsp[0].uint);
                                            (yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;
                                            (yyval.nodes) = (yyvsp[-1].nodes);
                                            if ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max) {
                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'Invalid value \'%d\' of \'%s\'.', (yyvsp[0].uint), 'max-elements');
                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, '\'max-elements\' is smaller than \'min-elements\'.');
                                              YYABORT;
                                            }
                                          }

    break;

  case 310:

    { if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {
                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'ordered by', 'leaf-list');
                                            YYABORT;
                                          }
                                          if ((yyvsp[0].i) & LYS_USERORDERED) {
                                            (yyvsp[-1].nodes).node.ptr_leaflist->flags |= LYS_USERORDERED;
                                          }
                                          (yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);
                                          (yyval.nodes) = (yyvsp[-1].nodes);
                                        }

    break;

  case 311:

    { if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_STATUS_MASK) {
                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, 'status', 'leaf-list');
                                        YYABORT;
                                      }
                                      (yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);
                                    }

    break;

  case 312:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, 'leaf-list', NODE_PRINT)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                         }

    break;

  case 313:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, 'leaf-list', NODE_PRINT)) {
                                           YYABORT;
                                         }
                                         s = NULL;
                                       }

    break;

  case 314:

    { (yyval.backup_token).token = actual_type;
                                   (yyval.backup_token).actual = actual;
                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LIST, sizeof(struct lys_node_list)))) {
                                     YYABORT;
                                   }
                                   data_node = actual;
                                   s = NULL;
                                   actual_type = LIST_KEYWORD;
                                 }

    break;

  case 315:

    { void *tmp;

                  if ((yyvsp[-1].nodes).node.ptr_list->iffeature_size) {
                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->iffeature, (yyvsp[-1].nodes).node.ptr_list->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->iffeature);
                    if (!tmp) {
                      LOGMEM(trg->ctx);
                      YYABORT;
                    }
                    (yyvsp[-1].nodes).node.ptr_list->iffeature = tmp;
                  }

                  if ((yyvsp[-1].nodes).node.ptr_list->must_size) {
                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->must, (yyvsp[-1].nodes).node.ptr_list->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->must);
                    if (!tmp) {
                      LOGMEM(trg->ctx);
                      YYABORT;
                    }
                    (yyvsp[-1].nodes).node.ptr_list->must = tmp;
                  }

                  if ((yyvsp[-1].nodes).node.ptr_list->tpdf_size) {
                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->tpdf, (yyvsp[-1].nodes).node.ptr_list->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->tpdf);
                    if (!tmp) {
                      LOGMEM(trg->ctx);
                      YYABORT;
                    }
                    (yyvsp[-1].nodes).node.ptr_list->tpdf = tmp;
                  }

                  if ((yyvsp[-1].nodes).node.ptr_list->unique_size) {
                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->unique);
                    if (!tmp) {
                      LOGMEM(trg->ctx);
                      YYABORT;
                    }
                    (yyvsp[-1].nodes).node.ptr_list->unique = tmp;
                  }

                  LOGDBG(LY_LDGYANG, 'finished parsing list statement \'%s\'', data_node->name);
                  actual_type = (yyvsp[-4].backup_token).token;
                  actual = (yyvsp[-4].backup_token).actual;
                  data_node = (yyvsp[-4].backup_token).actual;
                }

    break;

  case 316:

    { (yyval.nodes).node.ptr_list = actual;
                            (yyval.nodes).node.flag = 0;
                          }

    break;

  case 320:

    { if ((yyvsp[-1].nodes).node.ptr_list->keys) {
                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, 'key', 'list');
                                  free(s);
                                  YYABORT;
                              }
                              (yyvsp[-1].nodes).node.ptr_list->keys = (struct lys_node_leaf **)s;
                              (yyval.nodes) = (yyvsp[-1].nodes);
                              s = NULL;
                            }

    break;

  case 321:

    { YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size, 'uniques');
                                 ((struct lys_unique *)actual)->expr = (const char **)s;
                                 (yyval.nodes) = (yyvsp[-1].nodes);
                                 s = NULL;
                                 actual = (yyvsp[-1].nodes).node.ptr_list;
                               }

    break;

  case 322:

    { if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_CONFIG_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, 'config', 'list');
                                   YYABORT;
                                 }
                                 (yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);
                               }

    break;

  case 323:

    { if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {
                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, 'min-elements', 'list');
                                         YYABORT;
                                       }
                                       (yyvsp[-1].nodes).node.ptr_list->min = (yyvsp[0].uint);
                                       (yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;
                                       (yyval.nodes) = (yyvsp[-1].nodes);
                                       if ((yyvsp[-1].nodes).node.ptr_list->max && ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max)) {
                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, 'Invalid value \'%d\' of \'%s\'.', (yyvsp[0].uint), 'min-elements');
                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, '\'min-elements\' is bigger than \'max-elements\'.');
                                         YYABORT;
                                       }
                                     }

    break;

  case 324:

    { if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {
                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, 'max-elements', 'list');
                                         YYABORT;
                                       }
                                       (yyvsp[-1].nodes).node.ptr_list->max = (yyvsp[0].uint);
                                       (yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;
                                       (yyval.nodes) = (yyvsp[-1].nodes);
                                       if ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max) {
                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, 'Invalid value \'%d\' of \'%s\'.', (yyvsp[0].uint), 'min-elements');
                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, '\'max-elements\' is smaller than \'min-elements\'.');
                                         YYABORT;
                                       }
                                     }

    break;

  case 325:

    { if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {
                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, 'ordered by', 'list');
                                       YYABORT;
                                     }
                                     if ((yyvsp[0].i) & LYS_USERORDERED) {
                                       (yyvsp[-1].nodes).node.ptr_list->flags |= LYS_USERORDERED;
                                     }
                                     (yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);
                                     (yyval.nodes) = (yyvsp[-1].nodes);
                                   }

    break;

  case 326:

    { if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_STATUS_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, 'status', 'list');
                                   YYABORT;
                                 }
                                 (yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);
                               }

    break;

  case 327:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_list, s, 'list', NODE_PRINT)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 328:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_list, s, 'list', NODE_PRINT)) {
                                      YYABORT;
                                    }
                                    s = NULL;
                                  }

    break;

  case 332:

    { if (trg->version < 2) {
                                                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_list, 'notification');
                                                 YYABORT;
                                               }
                                             }

    break;

  case 334:

    { (yyval.backup_token).token = actual_type;
                                     (yyval.backup_token).actual = actual;
                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CHOICE, sizeof(struct lys_node_choice)))) {
                                       YYABORT;
                                     }
                                     data_node = actual;
                                     s = NULL;
                                     actual_type = CHOICE_KEYWORD;
                                   }

    break;

  case 335:

    { LOGDBG(LY_LDGYANG, 'finished parsing choice statement \'%s\'', data_node->name);
               actual_type = (yyvsp[-1].backup_token).token;
               actual = (yyvsp[-1].backup_token).actual;
               data_node = (yyvsp[-1].backup_token).actual;
             }

    break;

  case 337:

    { struct lys_iffeature *tmp;

           if (((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_TRUE) && (yyvsp[-1].nodes).node.ptr_choice->dflt) {
              LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, 'default', 'choice');
              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, 'The \'default\' statement is forbidden on choices with \'mandatory\'.');
              YYABORT;
            }

           if ((yyvsp[-1].nodes).node.ptr_choice->iffeature_size) {
             tmp = realloc((yyvsp[-1].nodes).node.ptr_choice->iffeature, (yyvsp[-1].nodes).node.ptr_choice->iffeature_size * sizeof *tmp);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).node.ptr_choice->iffeature = tmp;
           }
         }

    break;

  case 338:

    { (yyval.nodes).node.ptr_choice = actual;
                              (yyval.nodes).node.flag = 0;
                            }

    break;

  case 341:

    { if ((yyvsp[-1].nodes).node.flag & LYS_CHOICE_DEFAULT) {
                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, 'default', 'choice');
                                      free(s);
                                      YYABORT;
                                    }
                                    (yyvsp[-1].nodes).node.ptr_choice->dflt = (struct lys_node *) s;
                                    s = NULL;
                                    (yyval.nodes) = (yyvsp[-1].nodes);
                                    (yyval.nodes).node.flag |= LYS_CHOICE_DEFAULT;
                                  }

    break;

  case 342:

    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_CONFIG_MASK) {
                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, 'config', 'choice');
                                     YYABORT;
                                   }
                                   (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);
                                   (yyval.nodes) = (yyvsp[-1].nodes);
                                 }

    break;

  case 343:

    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_MASK) {
                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, 'mandatory', 'choice');
                                      YYABORT;
                                    }
                                    (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);
                                    (yyval.nodes) = (yyvsp[-1].nodes);
                                  }

    break;

  case 344:

    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_STATUS_MASK) {
                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, 'status', 'choice');
                                     YYABORT;
                                   }
                                   (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);
                                   (yyval.nodes) = (yyvsp[-1].nodes);
                                 }

    break;

  case 345:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_choice, s, 'choice', NODE_PRINT)) {
                                          YYABORT;
                                        }
                                        s = NULL;
                                        (yyval.nodes) = (yyvsp[-1].nodes);
                                      }

    break;

  case 346:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_choice, s, 'choice', NODE_PRINT)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                      (yyval.nodes) = (yyvsp[-1].nodes);
                                    }

    break;

  case 356:

    { if (trg->version < 2 ) {
                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, 'choice');
                     YYABORT;
                   }
                 }

    break;

  case 357:

    { (yyval.backup_token).token = actual_type;
                                   (yyval.backup_token).actual = actual;
                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CASE, sizeof(struct lys_node_case)))) {
                                     YYABORT;
                                   }
                                   data_node = actual;
                                   s = NULL;
                                   actual_type = CASE_KEYWORD;
                                 }

    break;

  case 358:

    { LOGDBG(LY_LDGYANG, 'finished parsing case statement \'%s\'', data_node->name);
             actual_type = (yyvsp[-1].backup_token).token;
             actual = (yyvsp[-1].backup_token).actual;
             data_node = (yyvsp[-1].backup_token).actual;
           }

    break;

  case 360:

    { struct lys_iffeature *tmp;

           if ((yyvsp[-1].nodes).cs->iffeature_size) {
             tmp = realloc((yyvsp[-1].nodes).cs->iffeature, (yyvsp[-1].nodes).cs->iffeature_size * sizeof *tmp);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).cs->iffeature = tmp;
           }
          }

    break;

  case 361:

    { (yyval.nodes).cs = actual; }

    break;

  case 364:

    { if ((yyvsp[-1].nodes).cs->flags & LYS_STATUS_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).cs, 'status', 'case');
                                   YYABORT;
                                 }
                                 (yyvsp[-1].nodes).cs->flags |= (yyvsp[0].i);
                               }

    break;

  case 365:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).cs, s, 'case', NODE_PRINT)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 366:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).cs, s, 'case', NODE_PRINT)) {
                                      YYABORT;
                                    }
                                    s = NULL;
                                  }

    break;

  case 368:

    { (yyval.backup_token).token = actual_type;
                                     (yyval.backup_token).actual = actual;
                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYXML, sizeof(struct lys_node_anydata)))) {
                                       YYABORT;
                                     }
                                     data_node = actual;
                                     s = NULL;
                                     actual_type = ANYXML_KEYWORD;
                                   }

    break;

  case 369:

    { LOGDBG(LY_LDGYANG, 'finished parsing anyxml statement \'%s\'', data_node->name);
               actual_type = (yyvsp[-1].backup_token).token;
               actual = (yyvsp[-1].backup_token).actual;
               data_node = (yyvsp[-1].backup_token).actual;
             }

    break;

  case 370:

    { (yyval.backup_token).token = actual_type;
                                      (yyval.backup_token).actual = actual;
                                      if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYDATA, sizeof(struct lys_node_anydata)))) {
                                        YYABORT;
                                      }
                                      data_node = actual;
                                      s = NULL;
                                      actual_type = ANYDATA_KEYWORD;
                                    }

    break;

  case 371:

    { LOGDBG(LY_LDGYANG, 'finished parsing anydata statement \'%s\'', data_node->name);
                actual_type = (yyvsp[-1].backup_token).token;
                actual = (yyvsp[-1].backup_token).actual;
                data_node = (yyvsp[-1].backup_token).actual;
              }

    break;

  case 373:

    { void *tmp;

           if ((yyvsp[-1].nodes).node.ptr_anydata->iffeature_size) {
             tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->iffeature, (yyvsp[-1].nodes).node.ptr_anydata->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->iffeature);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).node.ptr_anydata->iffeature = tmp;
           }

           if ((yyvsp[-1].nodes).node.ptr_anydata->must_size) {
             tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->must, (yyvsp[-1].nodes).node.ptr_anydata->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->must);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).node.ptr_anydata->must = tmp;
           }
         }

    break;

  case 374:

    { (yyval.nodes).node.ptr_anydata = actual;
                              (yyval.nodes).node.flag = actual_type;
                            }

    break;

  case 378:

    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_CONFIG_MASK) {
                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, 'config',
                                            ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? 'anyxml' : 'anydata');
                                     YYABORT;
                                   }
                                   (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);
                                 }

    break;

  case 379:

    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_MAND_MASK) {
                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, 'mandatory',
                                               ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? 'anyxml' : 'anydata');
                                        YYABORT;
                                      }
                                      (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);
                                    }

    break;

  case 380:

    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_STATUS_MASK) {
                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, 'status',
                                            ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? 'anyxml' : 'anydata');
                                     YYABORT;
                                   }
                                   (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);
                                 }

    break;

  case 381:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? 'anyxml' : 'anydata', NODE_PRINT)) {
                                          YYABORT;
                                        }
                                        s = NULL;
                                      }

    break;

  case 382:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? 'anyxml' : 'anydata', NODE_PRINT)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 383:

    { (yyval.backup_token).token = actual_type;
                                       (yyval.backup_token).actual = actual;
                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_USES, sizeof(struct lys_node_uses)))) {
                                         YYABORT;
                                       }
                                       data_node = actual;
                                       s = NULL;
                                       actual_type = USES_KEYWORD;
                                     }

    break;

  case 384:

    { LOGDBG(LY_LDGYANG, 'finished parsing uses statement \'%s\'', data_node->name);
             actual_type = (yyvsp[-1].backup_token).token;
             actual = (yyvsp[-1].backup_token).actual;
             data_node = (yyvsp[-1].backup_token).actual;
           }

    break;

  case 386:

    { void *tmp;

           if ((yyvsp[-1].nodes).uses->iffeature_size) {
             tmp = realloc((yyvsp[-1].nodes).uses->iffeature, (yyvsp[-1].nodes).uses->iffeature_size * sizeof *(yyvsp[-1].nodes).uses->iffeature);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).uses->iffeature = tmp;
           }

           if ((yyvsp[-1].nodes).uses->refine_size) {
             tmp = realloc((yyvsp[-1].nodes).uses->refine, (yyvsp[-1].nodes).uses->refine_size * sizeof *(yyvsp[-1].nodes).uses->refine);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).uses->refine = tmp;
           }

           if ((yyvsp[-1].nodes).uses->augment_size) {
             tmp = realloc((yyvsp[-1].nodes).uses->augment, (yyvsp[-1].nodes).uses->augment_size * sizeof *(yyvsp[-1].nodes).uses->augment);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).uses->augment = tmp;
           }
         }

    break;

  case 387:

    { (yyval.nodes).uses = actual; }

    break;

  case 390:

    { if ((yyvsp[-1].nodes).uses->flags & LYS_STATUS_MASK) {
                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).uses, 'status', 'uses');
                                   YYABORT;
                                 }
                                 (yyvsp[-1].nodes).uses->flags |= (yyvsp[0].i);
                               }

    break;

  case 391:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).uses, s, 'uses', NODE_PRINT)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 392:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).uses, s, 'uses', NODE_PRINT)) {
                                      YYABORT;
                                    }
                                    s = NULL;
                                  }

    break;

  case 397:

    { (yyval.backup_token).token = actual_type;
                                  (yyval.backup_token).actual = actual;
                                  YANG_ADDELEM(((struct lys_node_uses *)actual)->refine,
                                               ((struct lys_node_uses *)actual)->refine_size, 'refines');
                                  ((struct lys_refine *)actual)->target_name = transform_schema2json(trg, s);
                                  free(s);
                                  s = NULL;
                                  if (!((struct lys_refine *)actual)->target_name) {
                                    YYABORT;
                                  }
                                  actual_type = REFINE_KEYWORD;
                                }

    break;

  case 398:

    { actual_type = (yyvsp[-1].backup_token).token;
               actual = (yyvsp[-1].backup_token).actual;
             }

    break;

  case 400:

    { void *tmp;

           if ((yyvsp[-1].nodes).refine->iffeature_size) {
             tmp = realloc((yyvsp[-1].nodes).refine->iffeature, (yyvsp[-1].nodes).refine->iffeature_size * sizeof *(yyvsp[-1].nodes).refine->iffeature);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).refine->iffeature = tmp;
           }

           if ((yyvsp[-1].nodes).refine->must_size) {
             tmp = realloc((yyvsp[-1].nodes).refine->must, (yyvsp[-1].nodes).refine->must_size * sizeof *(yyvsp[-1].nodes).refine->must);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).refine->must = tmp;
           }

           if ((yyvsp[-1].nodes).refine->dflt_size) {
             tmp = realloc((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size * sizeof *(yyvsp[-1].nodes).refine->dflt);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).refine->dflt = tmp;
           }
         }

    break;

  case 401:

    { (yyval.nodes).refine = actual;
                                    actual_type = REFINE_KEYWORD;
                                  }

    break;

  case 402:

    { actual = (yyvsp[-2].nodes).refine;
                                               actual_type = REFINE_KEYWORD;
                                               if ((yyvsp[-2].nodes).refine->target_type) {
                                                 if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML)) {
                                                   (yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML);
                                                 } else {
                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'must', 'refine');
                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                                                   YYABORT;
                                                 }
                                               } else {
                                                 (yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML;
                                               }
                                             }

    break;

  case 403:

    { /* leaf, leaf-list, list, container or anyxml */
               /* check possibility of statements combination */
               if ((yyvsp[-2].nodes).refine->target_type) {
                 if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA)) {
                   (yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA);
                 } else {
                   free(s);
                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'if-feature', 'refine');
                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                   YYABORT;
                 }
               } else {
                 (yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA;
               }
             }

    break;

  case 404:

    { if ((yyvsp[-1].nodes).refine->target_type) {
                                             if ((yyvsp[-1].nodes).refine->target_type & LYS_CONTAINER) {
                                               if ((yyvsp[-1].nodes).refine->mod.presence) {
                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'presence', 'refine');
                                                 free(s);
                                                 YYABORT;
                                               }
                                               (yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;
                                               (yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);
                                             } else {
                                               free(s);
                                               LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'presence', 'refine');
                                               LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                                               YYABORT;
                                             }
                                           } else {
                                             (yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;
                                             (yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);
                                           }
                                           s = NULL;
                                           (yyval.nodes) = (yyvsp[-1].nodes);
                                         }

    break;

  case 405:

    { int i;

                                          if ((yyvsp[-1].nodes).refine->dflt_size) {
                                            if (trg->version < 2) {
                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'default', 'refine');
                                              YYABORT;
                                            }
                                            if ((yyvsp[-1].nodes).refine->target_type & LYS_LEAFLIST) {
                                              (yyvsp[-1].nodes).refine->target_type = LYS_LEAFLIST;
                                            } else {
                                              free(s);
                                              LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'default', 'refine');
                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                                              YYABORT;
                                            }
                                          } else {
                                            if ((yyvsp[-1].nodes).refine->target_type) {
                                              if (trg->version < 2 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE))) {
                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE);
                                              } if (trg->version > 1 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {
                                                /* YANG 1.1 */
                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE);
                                              } else {
                                                free(s);
                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'default', 'refine');
                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                                                YYABORT;
                                              }
                                            } else {
                                              if (trg->version < 2) {
                                                (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE;
                                              } else {
                                                /* YANG 1.1 */
                                                (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE;
                                              }
                                            }
                                          }
                                          /* check for duplicity */
                                          for (i = 0; i < (yyvsp[-1].nodes).refine->dflt_size; ++i) {
                                              if (ly_strequal((yyvsp[-1].nodes).refine->dflt[i], s, 0)) {
                                                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'default');
                                                  LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Duplicated default value \'%s\'.', s);
                                                  YYABORT;
                                              }
                                          }
                                          YANG_ADDELEM((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size, 'defaults');
                                          *((const char **)actual) = lydict_insert_zc(trg->ctx, s);
                                          actual = (yyvsp[-1].nodes).refine;
                                          s = NULL;
                                          (yyval.nodes) = (yyvsp[-1].nodes);
                                        }

    break;

  case 406:

    { if ((yyvsp[-1].nodes).refine->target_type) {
                                           if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST)) {
                                             (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST);
                                             if ((yyvsp[-1].nodes).refine->flags & LYS_CONFIG_MASK) {
                                               LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'config', 'refine');
                                               YYABORT;
                                             }
                                             (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);
                                           } else {
                                             LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'config', 'refine');
                                             LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                                             YYABORT;
                                           }
                                         } else {
                                           (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST;
                                           (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);
                                         }
                                         (yyval.nodes) = (yyvsp[-1].nodes);
                                       }

    break;

  case 407:

    { if ((yyvsp[-1].nodes).refine->target_type) {
                                              if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_ANYXML)) {
                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_ANYXML);
                                                if ((yyvsp[-1].nodes).refine->flags & LYS_MAND_MASK) {
                                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'mandatory', 'refine');
                                                  YYABORT;
                                                }
                                                (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);
                                              } else {
                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'mandatory', 'refine');
                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                                                YYABORT;
                                              }
                                            } else {
                                              (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_ANYXML;
                                              (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);
                                            }
                                            (yyval.nodes) = (yyvsp[-1].nodes);
                                          }

    break;

  case 408:

    { if ((yyvsp[-1].nodes).refine->target_type) {
                                                 if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {
                                                   (yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);
                                                   if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MINSET) {
                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'min-elements', 'refine');
                                                     YYABORT;
                                                   }
                                                   (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;
                                                   (yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);
                                                 } else {
                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'min-elements', 'refine');
                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                                                   YYABORT;
                                                 }
                                               } else {
                                                 (yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;
                                                 (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;
                                                 (yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);
                                               }
                                               (yyval.nodes) = (yyvsp[-1].nodes);
                                             }

    break;

  case 409:

    { if ((yyvsp[-1].nodes).refine->target_type) {
                                                 if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {
                                                   (yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);
                                                   if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MAXSET) {
                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'max-elements', 'refine');
                                                     YYABORT;
                                                   }
                                                   (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;
                                                   (yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);
                                                 } else {
                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'max-elements', 'refine');
                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid refine target nodetype for the substatements.');
                                                   YYABORT;
                                                 }
                                               } else {
                                                 (yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;
                                                 (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;
                                                 (yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);
                                               }
                                               (yyval.nodes) = (yyvsp[-1].nodes);
                                             }

    break;

  case 410:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).refine, s, 'refine', NODE)) {
                                                YYABORT;
                                              }
                                              s = NULL;
                                            }

    break;

  case 411:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).refine, s, 'refine', NODE)) {
                                              YYABORT;
                                            }
                                            s = NULL;
                                          }

    break;

  case 414:

    { void *parent;

                                         (yyval.backup_token).token = actual_type;
                                         (yyval.backup_token).actual = actual;
                                         parent = actual;
                                         YANG_ADDELEM(((struct lys_node_uses *)actual)->augment,
                                                      ((struct lys_node_uses *)actual)->augment_size, 'augments');
                                         if (yang_read_augment(trg, parent, actual, s)) {
                                           YYABORT;
                                         }
                                         data_node = actual;
                                         s = NULL;
                                         actual_type = AUGMENT_KEYWORD;
                                       }

    break;

  case 415:

    { LOGDBG(LY_LDGYANG, 'finished parsing augment statement \'%s\'', data_node->name);
                         actual_type = (yyvsp[-4].backup_token).token;
                         actual = (yyvsp[-4].backup_token).actual;
                         data_node = (yyvsp[-4].backup_token).actual;
                       }

    break;

  case 418:

    { (yyval.backup_token).token = actual_type;
                               (yyval.backup_token).actual = actual;
                               YANG_ADDELEM(trg->augment, trg->augment_size, 'augments');
                               if (yang_read_augment(trg, NULL, actual, s)) {
                                 YYABORT;
                               }
                               data_node = actual;
                               s = NULL;
                               actual_type = AUGMENT_KEYWORD;
                             }

    break;

  case 419:

    { LOGDBG(LY_LDGYANG, 'finished parsing augment statement \'%s\'', data_node->name);
                    actual_type = (yyvsp[-4].backup_token).token;
                    actual = (yyvsp[-4].backup_token).actual;
                    data_node = (yyvsp[-4].backup_token).actual;
                  }

    break;

  case 420:

    { (yyval.nodes).augment = actual; }

    break;

  case 423:

    { if ((yyvsp[-1].nodes).augment->flags & LYS_STATUS_MASK) {
                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).augment, 'status', 'augment');
                                      YYABORT;
                                    }
                                    (yyvsp[-1].nodes).augment->flags |= (yyvsp[0].i);
                                  }

    break;

  case 424:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).augment, s, 'augment', NODE_PRINT)) {
                                           YYABORT;
                                         }
                                         s = NULL;
                                       }

    break;

  case 425:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).augment, s, 'augment', NODE_PRINT)) {
                                         YYABORT;
                                       }
                                       s = NULL;
                                     }

    break;

  case 428:

    { if (trg->version < 2) {
                                                    LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).augment, 'notification');
                                                    YYABORT;
                                                  }
                                                }

    break;

  case 430:

    { if (param->module->version != 2) {
                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, 'action');
                                       free(s);
                                       YYABORT;
                                     }
                                     (yyval.backup_token).token = actual_type;
                                     (yyval.backup_token).actual = actual;
                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ACTION, sizeof(struct lys_node_rpc_action)))) {
                                       YYABORT;
                                     }
                                     data_node = actual;
                                     s = NULL;
                                     actual_type = ACTION_KEYWORD;
                                   }

    break;

  case 431:

    { LOGDBG(LY_LDGYANG, 'finished parsing action statement \'%s\'', data_node->name);
               actual_type = (yyvsp[-1].backup_token).token;
               actual = (yyvsp[-1].backup_token).actual;
               data_node = (yyvsp[-1].backup_token).actual;
             }

    break;

  case 432:

    { (yyval.backup_token).token = actual_type;
                                  (yyval.backup_token).actual = actual;
                                  if (!(actual = yang_read_node(trg, NULL, param->node, s, LYS_RPC, sizeof(struct lys_node_rpc_action)))) {
                                    YYABORT;
                                  }
                                  data_node = actual;
                                  s = NULL;
                                  actual_type = RPC_KEYWORD;
                                }

    break;

  case 433:

    { LOGDBG(LY_LDGYANG, 'finished parsing rpc statement \'%s\'', data_node->name);
            actual_type = (yyvsp[-1].backup_token).token;
            actual = (yyvsp[-1].backup_token).actual;
            data_node = (yyvsp[-1].backup_token).actual;
          }

    break;

  case 435:

    { void *tmp;

            if ((yyvsp[-1].nodes).node.ptr_rpc->iffeature_size) {
              tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->iffeature, (yyvsp[-1].nodes).node.ptr_rpc->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->iffeature);
              if (!tmp) {
                LOGMEM(trg->ctx);
                YYABORT;
              }
              (yyvsp[-1].nodes).node.ptr_rpc->iffeature = tmp;
            }

            if ((yyvsp[-1].nodes).node.ptr_rpc->tpdf_size) {
              tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->tpdf, (yyvsp[-1].nodes).node.ptr_rpc->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->tpdf);
              if (!tmp) {
                LOGMEM(trg->ctx);
                YYABORT;
              }
              (yyvsp[-1].nodes).node.ptr_rpc->tpdf = tmp;
            }
          }

    break;

  case 436:

    { (yyval.nodes).node.ptr_rpc = actual;
                           (yyval.nodes).node.flag = 0;
                         }

    break;

  case 438:

    { if ((yyvsp[-1].nodes).node.ptr_rpc->flags & LYS_STATUS_MASK) {
                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_rpc, 'status', 'rpc');
                                  YYABORT;
                                }
                                (yyvsp[-1].nodes).node.ptr_rpc->flags |= (yyvsp[0].i);
                             }

    break;

  case 439:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, 'rpc', NODE_PRINT)) {
                                       YYABORT;
                                     }
                                     s = NULL;
                                   }

    break;

  case 440:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, 'rpc', NODE_PRINT)) {
                                     YYABORT;
                                   }
                                   s = NULL;
                                 }

    break;

  case 443:

    { if ((yyvsp[-2].nodes).node.flag & LYS_RPC_INPUT) {
                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, 'input', 'rpc');
                                         YYABORT;
                                       }
                                       (yyvsp[-2].nodes).node.flag |= LYS_RPC_INPUT;
                                       (yyval.nodes) = (yyvsp[-2].nodes);
                                     }

    break;

  case 444:

    { if ((yyvsp[-2].nodes).node.flag & LYS_RPC_OUTPUT) {
                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, 'output', 'rpc');
                                          YYABORT;
                                        }
                                        (yyvsp[-2].nodes).node.flag |= LYS_RPC_OUTPUT;
                                        (yyval.nodes) = (yyvsp[-2].nodes);
                                      }

    break;

  case 445:

    { (yyval.backup_token).token = actual_type;
                                  (yyval.backup_token).actual = actual;
                                  s = strdup('input');
                                  if (!s) {
                                    LOGMEM(trg->ctx);
                                    YYABORT;
                                  }
                                  if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_INPUT, sizeof(struct lys_node_inout)))) {
                                    YYABORT;
                                  }
                                  data_node = actual;
                                  s = NULL;
                                  actual_type = INPUT_KEYWORD;
                                }

    break;

  case 446:

    { void *tmp;
                  struct lys_node_inout *input = actual;

                  if (input->must_size) {
                    tmp = realloc(input->must, input->must_size * sizeof *input->must);
                    if (!tmp) {
                      LOGMEM(trg->ctx);
                      YYABORT;
                    }
                    input->must = tmp;
                  }

                  if (input->tpdf_size) {
                    tmp = realloc(input->tpdf, input->tpdf_size * sizeof *input->tpdf);
                    if (!tmp) {
                      LOGMEM(trg->ctx);
                      YYABORT;
                    }
                    input->tpdf = tmp;
                  }

                  LOGDBG(LY_LDGYANG, 'finished parsing input statement \'%s\'', data_node->name);
                  actual_type = (yyvsp[-4].backup_token).token;
                  actual = (yyvsp[-4].backup_token).actual;
                  data_node = (yyvsp[-4].backup_token).actual;
                }

    break;

  case 452:

    { (yyval.backup_token).token = actual_type;
                                    (yyval.backup_token).actual = actual;
                                    s = strdup('output');
                                    if (!s) {
                                      LOGMEM(trg->ctx);
                                      YYABORT;
                                    }
                                    if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_OUTPUT, sizeof(struct lys_node_inout)))) {
                                      YYABORT;
                                    }
                                    data_node = actual;
                                    s = NULL;
                                    actual_type = OUTPUT_KEYWORD;
                                  }

    break;

  case 453:

    { void *tmp;
                   struct lys_node_inout *output = actual;

                   if (output->must_size) {
                     tmp = realloc(output->must, output->must_size * sizeof *output->must);
                     if (!tmp) {
                       LOGMEM(trg->ctx);
                       YYABORT;
                     }
                     output->must = tmp;
                   }

                   if (output->tpdf_size) {
                     tmp = realloc(output->tpdf, output->tpdf_size * sizeof *output->tpdf);
                     if (!tmp) {
                       LOGMEM(trg->ctx);
                       YYABORT;
                     }
                     output->tpdf = tmp;
                   }

                   LOGDBG(LY_LDGYANG, 'finished parsing output statement \'%s\'', data_node->name);
                   actual_type = (yyvsp[-4].backup_token).token;
                   actual = (yyvsp[-4].backup_token).actual;
                   data_node = (yyvsp[-4].backup_token).actual;
                 }

    break;

  case 454:

    { (yyval.backup_token).token = actual_type;
                                           (yyval.backup_token).actual = actual;
                                           if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_NOTIF, sizeof(struct lys_node_notif)))) {
                                             YYABORT;
                                           }
                                           data_node = actual;
                                           actual_type = NOTIFICATION_KEYWORD;
                                         }

    break;

  case 455:

    { LOGDBG(LY_LDGYANG, 'finished parsing notification statement \'%s\'', data_node->name);
                     actual_type = (yyvsp[-1].backup_token).token;
                     actual = (yyvsp[-1].backup_token).actual;
                     data_node = (yyvsp[-1].backup_token).actual;
                   }

    break;

  case 457:

    { void *tmp;

            if ((yyvsp[-1].nodes).notif->must_size) {
              tmp = realloc((yyvsp[-1].nodes).notif->must, (yyvsp[-1].nodes).notif->must_size * sizeof *(yyvsp[-1].nodes).notif->must);
              if (!tmp) {
                LOGMEM(trg->ctx);
                YYABORT;
              }
              (yyvsp[-1].nodes).notif->must = tmp;
            }

           if ((yyvsp[-1].nodes).notif->iffeature_size) {
             tmp = realloc((yyvsp[-1].nodes).notif->iffeature, (yyvsp[-1].nodes).notif->iffeature_size * sizeof *(yyvsp[-1].nodes).notif->iffeature);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).notif->iffeature = tmp;
           }

           if ((yyvsp[-1].nodes).notif->tpdf_size) {
             tmp = realloc((yyvsp[-1].nodes).notif->tpdf, (yyvsp[-1].nodes).notif->tpdf_size * sizeof *(yyvsp[-1].nodes).notif->tpdf);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].nodes).notif->tpdf = tmp;
           }
          }

    break;

  case 458:

    { (yyval.nodes).notif = actual; }

    break;

  case 461:

    { if ((yyvsp[-1].nodes).notif->flags & LYS_STATUS_MASK) {
                                           LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).notif, 'status', 'notification');
                                           YYABORT;
                                         }
                                         (yyvsp[-1].nodes).notif->flags |= (yyvsp[0].i);
                                       }

    break;

  case 462:

    { if (yang_read_description(trg, (yyvsp[-1].nodes).notif, s, 'notification', NODE_PRINT)) {
                                                YYABORT;
                                              }
                                              s = NULL;
                                            }

    break;

  case 463:

    { if (yang_read_reference(trg, (yyvsp[-1].nodes).notif, s, 'notification', NODE_PRINT)) {
                                              YYABORT;
                                            }
                                            s = NULL;
                                          }

    break;

  case 467:

    { (yyval.backup_token).token = actual_type;
                                   (yyval.backup_token).actual = actual;
                                   YANG_ADDELEM(trg->deviation, trg->deviation_size, 'deviations');
                                   ((struct lys_deviation *)actual)->target_name = transform_schema2json(trg, s);
                                   free(s);
                                   if (!((struct lys_deviation *)actual)->target_name) {
                                     YYABORT;
                                   }
                                   s = NULL;
                                   actual_type = DEVIATION_KEYWORD;
                                 }

    break;

  case 468:

    { void *tmp;

                      if ((yyvsp[-1].dev)->deviate_size) {
                        tmp = realloc((yyvsp[-1].dev)->deviate, (yyvsp[-1].dev)->deviate_size * sizeof *(yyvsp[-1].dev)->deviate);
                        if (!tmp) {
                          LOGINT(trg->ctx);
                          YYABORT;
                        }
                        (yyvsp[-1].dev)->deviate = tmp;
                      } else {
                        LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, 'deviate', 'deviation');
                        YYABORT;
                      }
                      actual_type = (yyvsp[-4].backup_token).token;
                      actual = (yyvsp[-4].backup_token).actual;
                    }

    break;

  case 469:

    { (yyval.dev) = actual; }

    break;

  case 470:

    { if (yang_read_description(trg, (yyvsp[-1].dev), s, 'deviation', NODE)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                           (yyval.dev) = (yyvsp[-1].dev);
                                         }

    break;

  case 471:

    { if (yang_read_reference(trg, (yyvsp[-1].dev), s, 'deviation', NODE)) {
                                           YYABORT;
                                         }
                                         s = NULL;
                                         (yyval.dev) = (yyvsp[-1].dev);
                                       }

    break;

  case 477:

    { (yyval.backup_token).token = actual_type;
                                               (yyval.backup_token).actual = actual;
                                               if (!(actual = yang_read_deviate_unsupported(trg->ctx, actual))) {
                                                 YYABORT;
                                               }
                                               actual_type = NOT_SUPPORTED_KEYWORD;
                                             }

    break;

  case 478:

    { actual_type = (yyvsp[-2].backup_token).token;
                              actual = (yyvsp[-2].backup_token).actual;
                            }

    break;

  case 484:

    { (yyval.backup_token).token = actual_type;
                           (yyval.backup_token).actual = actual;
                           if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_ADD))) {
                             YYABORT;
                           }
                           actual_type = ADD_KEYWORD;
                         }

    break;

  case 485:

    { actual_type = (yyvsp[-2].backup_token).token;
                    actual = (yyvsp[-2].backup_token).actual;
                  }

    break;

  case 487:

    { void *tmp;

           if ((yyvsp[-1].deviate)->must_size) {
             tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].deviate)->must = tmp;
           }

           if ((yyvsp[-1].deviate)->unique_size) {
             tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].deviate)->unique = tmp;
           }

           if ((yyvsp[-1].deviate)->dflt_size) {
             tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].deviate)->dflt = tmp;
           }
         }

    break;

  case 488:

    { (yyval.deviate) = actual; }

    break;

  case 489:

    { if (yang_read_units(trg, actual, s, ADD_KEYWORD)) {
                                         YYABORT;
                                       }
                                       s = NULL;
                                       (yyval.deviate) = (yyvsp[-1].deviate);
                                     }

    break;

  case 491:

    { YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, 'uniques');
                                        ((struct lys_unique *)actual)->expr = (const char **)s;
                                        s = NULL;
                                        actual = (yyvsp[-1].deviate);
                                        (yyval.deviate)= (yyvsp[-1].deviate);
                                      }

    break;

  case 492:

    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, 'defaults');
                                         *((const char **)actual) = lydict_insert_zc(trg->ctx, s);
                                         s = NULL;
                                         actual = (yyvsp[-1].deviate);
                                         (yyval.deviate) = (yyvsp[-1].deviate);
                                       }

    break;

  case 493:

    { if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {
                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'config', 'deviate');
                                          YYABORT;
                                        }
                                        (yyvsp[-1].deviate)->flags = (yyvsp[0].i);
                                        (yyval.deviate) = (yyvsp[-1].deviate);
                                      }

    break;

  case 494:

    { if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {
                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'mandatory', 'deviate');
                                             YYABORT;
                                           }
                                           (yyvsp[-1].deviate)->flags = (yyvsp[0].i);
                                           (yyval.deviate) = (yyvsp[-1].deviate);
                                         }

    break;

  case 495:

    { if ((yyvsp[-1].deviate)->min_set) {
                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'min-elements', 'deviation');
                                                YYABORT;
                                              }
                                              (yyvsp[-1].deviate)->min = (yyvsp[0].uint);
                                              (yyvsp[-1].deviate)->min_set = 1;
                                              (yyval.deviate) =  (yyvsp[-1].deviate);
                                            }

    break;

  case 496:

    { if ((yyvsp[-1].deviate)->max_set) {
                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'max-elements', 'deviation');
                                                YYABORT;
                                              }
                                              (yyvsp[-1].deviate)->max = (yyvsp[0].uint);
                                              (yyvsp[-1].deviate)->max_set = 1;
                                              (yyval.deviate) =  (yyvsp[-1].deviate);
                                            }

    break;

  case 497:

    { (yyval.backup_token).token = actual_type;
                                 (yyval.backup_token).actual = actual;
                                 if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_DEL))) {
                                   YYABORT;
                                 }
                                 actual_type = DELETE_KEYWORD;
                               }

    break;

  case 498:

    { actual_type = (yyvsp[-2].backup_token).token;
                       actual = (yyvsp[-2].backup_token).actual;
                     }

    break;

  case 500:

    { void *tmp;

            if ((yyvsp[-1].deviate)->must_size) {
              tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);
              if (!tmp) {
                LOGMEM(trg->ctx);
                YYABORT;
              }
              (yyvsp[-1].deviate)->must = tmp;
            }

            if ((yyvsp[-1].deviate)->unique_size) {
              tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);
              if (!tmp) {
                LOGMEM(trg->ctx);
                YYABORT;
              }
              (yyvsp[-1].deviate)->unique = tmp;
            }

            if ((yyvsp[-1].deviate)->dflt_size) {
              tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);
              if (!tmp) {
                LOGMEM(trg->ctx);
                YYABORT;
              }
              (yyvsp[-1].deviate)->dflt = tmp;
            }
          }

    break;

  case 501:

    { (yyval.deviate) = actual; }

    break;

  case 502:

    { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {
                                            YYABORT;
                                          }
                                          s = NULL;
                                          (yyval.deviate) = (yyvsp[-1].deviate);
                                        }

    break;

  case 504:

    { YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, 'uniques');
                                           ((struct lys_unique *)actual)->expr = (const char **)s;
                                           s = NULL;
                                           actual = (yyvsp[-1].deviate);
                                           (yyval.deviate) = (yyvsp[-1].deviate);
                                         }

    break;

  case 505:

    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, 'defaults');
                                            *((const char **)actual) = lydict_insert_zc(trg->ctx, s);
                                            s = NULL;
                                            actual = (yyvsp[-1].deviate);
                                            (yyval.deviate) = (yyvsp[-1].deviate);
                                          }

    break;

  case 506:

    { (yyval.backup_token).token = actual_type;
                                   (yyval.backup_token).actual = actual;
                                   if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_RPL))) {
                                     YYABORT;
                                   }
                                   actual_type = REPLACE_KEYWORD;
                                 }

    break;

  case 507:

    { actual_type = (yyvsp[-2].backup_token).token;
                        actual = (yyvsp[-2].backup_token).actual;
                      }

    break;

  case 509:

    { void *tmp;

           if ((yyvsp[-1].deviate)->dflt_size) {
             tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);
             if (!tmp) {
               LOGMEM(trg->ctx);
               YYABORT;
             }
             (yyvsp[-1].deviate)->dflt = tmp;
           }
         }

    break;

  case 510:

    { (yyval.deviate) = actual; }

    break;

  case 512:

    { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {
                                             YYABORT;
                                           }
                                           s = NULL;
                                           (yyval.deviate) = (yyvsp[-1].deviate);
                                         }

    break;

  case 513:

    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, 'defaults');
                                             *((const char **)actual) = lydict_insert_zc(trg->ctx, s);
                                             s = NULL;
                                             actual = (yyvsp[-1].deviate);
                                             (yyval.deviate) = (yyvsp[-1].deviate);
                                           }

    break;

  case 514:

    { if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {
                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'config', 'deviate');
                                              YYABORT;
                                            }
                                            (yyvsp[-1].deviate)->flags = (yyvsp[0].i);
                                            (yyval.deviate) = (yyvsp[-1].deviate);
                                          }

    break;

  case 515:

    { if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {
                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'mandatory', 'deviate');
                                                 YYABORT;
                                               }
                                               (yyvsp[-1].deviate)->flags = (yyvsp[0].i);
                                               (yyval.deviate) = (yyvsp[-1].deviate);
                                             }

    break;

  case 516:

    { if ((yyvsp[-1].deviate)->min_set) {
                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'min-elements', 'deviation');
                                                    YYABORT;
                                                  }
                                                  (yyvsp[-1].deviate)->min = (yyvsp[0].uint);
                                                  (yyvsp[-1].deviate)->min_set = 1;
                                                  (yyval.deviate) =  (yyvsp[-1].deviate);
                                                }

    break;

  case 517:

    { if ((yyvsp[-1].deviate)->max_set) {
                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'max-elements', 'deviation');
                                                    YYABORT;
                                                  }
                                                  (yyvsp[-1].deviate)->max = (yyvsp[0].uint);
                                                  (yyvsp[-1].deviate)->max_set = 1;
                                                  (yyval.deviate) =  (yyvsp[-1].deviate);
                                                }

    break;

  case 518:

    { (yyval.backup_token).token = actual_type;
                        (yyval.backup_token).actual = actual;
                        if (!(actual = yang_read_when(trg, actual, actual_type, s))) {
                          YYABORT;
                        }
                        s = NULL;
                        actual_type = WHEN_KEYWORD;
                      }

    break;

  case 519:

    { actual_type = (yyvsp[-1].backup_token).token;
             actual = (yyvsp[-1].backup_token).actual;
           }

    break;

  case 523:

    { if (yang_read_description(trg, actual, s, 'when', NODE)) {
                                        YYABORT;
                                      }
                                      s = NULL;
                                    }

    break;

  case 524:

    { if (yang_read_reference(trg, actual, s, 'when', NODE)) {
                                      YYABORT;
                                    }
                                    s = NULL;
                                  }

    break;

  case 525:

    { (yyval.i) = (yyvsp[0].i);
                             backup_type = actual_type;
                             actual_type = CONFIG_KEYWORD;
                           }

    break;

  case 526:

    { (yyval.i) = (yyvsp[-1].i); }

    break;

  case 527:

    { (yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET; }

    break;

  case 528:

    { (yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET; }

    break;

  case 529:

    { if (!strcmp(s, 'true')) {
                  (yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET;
                } else if (!strcmp(s, 'false')) {
                  (yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET;
                } else {
                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'config');
                  free(s);
                  YYABORT;
                }
                free(s);
                s = NULL;
              }

    break;

  case 530:

    { (yyval.i) = (yyvsp[0].i);
                                   backup_type = actual_type;
                                   actual_type = MANDATORY_KEYWORD;
                                 }

    break;

  case 531:

    { (yyval.i) = (yyvsp[-1].i); }

    break;

  case 532:

    { (yyval.i) = LYS_MAND_TRUE; }

    break;

  case 533:

    { (yyval.i) = LYS_MAND_FALSE; }

    break;

  case 534:

    { if (!strcmp(s, 'true')) {
                  (yyval.i) = LYS_MAND_TRUE;
                } else if (!strcmp(s, 'false')) {
                  (yyval.i) = LYS_MAND_FALSE;
                } else {
                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'mandatory');
                  free(s);
                  YYABORT;
                }
                free(s);
                s = NULL;
              }

    break;

  case 535:

    { backup_type = actual_type;
                       actual_type = PRESENCE_KEYWORD;
                     }

    break;

  case 537:

    { (yyval.uint) = (yyvsp[0].uint);
                                   backup_type = actual_type;
                                   actual_type = MIN_ELEMENTS_KEYWORD;
                                 }

    break;

  case 538:

    { (yyval.uint) = (yyvsp[-1].uint); }

    break;

  case 539:

    { (yyval.uint) = (yyvsp[-1].uint); }

    break;

  case 540:

    { if (strlen(s) == 1 && s[0] == '0') {
                  (yyval.uint) = 0;
                } else {
                  /* convert it to uint32_t */
                  uint64_t val;
                  char *endptr = NULL;
                  errno = 0;

                  val = strtoul(s, &endptr, 10);
                  if (*endptr || s[0] == '-' || errno || val > UINT32_MAX) {
                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'min-elements');
                      free(s);
                      YYABORT;
                  }
                  (yyval.uint) = (uint32_t) val;
                }
                free(s);
                s = NULL;
              }

    break;

  case 541:

    { (yyval.uint) = (yyvsp[0].uint);
                                   backup_type = actual_type;
                                   actual_type = MAX_ELEMENTS_KEYWORD;
                                 }

    break;

  case 542:

    { (yyval.uint) = (yyvsp[-1].uint); }

    break;

  case 543:

    { (yyval.uint) = 0; }

    break;

  case 544:

    { (yyval.uint) = (yyvsp[-1].uint); }

    break;

  case 545:

    { if (!strcmp(s, 'unbounded')) {
                  (yyval.uint) = 0;
                } else {
                  /* convert it to uint32_t */
                  uint64_t val;
                  char *endptr = NULL;
                  errno = 0;

                  val = strtoul(s, &endptr, 10);
                  if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {
                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, 'max-elements');
                      free(s);
                      YYABORT;
                  }
                  (yyval.uint) = (uint32_t) val;
                }
                free(s);
                s = NULL;
              }

    break;

  case 546:

    { (yyval.i) = (yyvsp[0].i);
                                     backup_type = actual_type;
                                     actual_type = ORDERED_BY_KEYWORD;
                                   }

    break;

  case 547:

    { (yyval.i) = (yyvsp[-1].i); }

    break;

  case 548:

    { (yyval.i) = LYS_USERORDERED; }

    break;

  case 549:

    { (yyval.i) = LYS_SYSTEMORDERED; }

    break;

  case 550:

    { if (!strcmp(s, 'user')) {
                  (yyval.i) = LYS_USERORDERED;
                } else if (!strcmp(s, 'system')) {
                  (yyval.i) = LYS_SYSTEMORDERED;
                } else {
                  free(s);
                  YYABORT;
                }
                free(s);
                s=NULL;
              }

    break;

  case 551:

    { (yyval.backup_token).token = actual_type;
                       (yyval.backup_token).actual = actual;
                       switch (actual_type) {
                       case CONTAINER_KEYWORD:
                         YANG_ADDELEM(((struct lys_node_container *)actual)->must,
                                     ((struct lys_node_container *)actual)->must_size, 'musts');
                         break;
                       case ANYDATA_KEYWORD:
                       case ANYXML_KEYWORD:
                         YANG_ADDELEM(((struct lys_node_anydata *)actual)->must,
                                     ((struct lys_node_anydata *)actual)->must_size, 'musts');
                         break;
                       case LEAF_KEYWORD:
                         YANG_ADDELEM(((struct lys_node_leaf *)actual)->must,
                                     ((struct lys_node_leaf *)actual)->must_size, 'musts');
                         break;
                       case LEAF_LIST_KEYWORD:
                         YANG_ADDELEM(((struct lys_node_leaflist *)actual)->must,
                                     ((struct lys_node_leaflist *)actual)->must_size, 'musts');
                         break;
                       case LIST_KEYWORD:
                         YANG_ADDELEM(((struct lys_node_list *)actual)->must,
                                     ((struct lys_node_list *)actual)->must_size, 'musts');
                         break;
                       case REFINE_KEYWORD:
                         YANG_ADDELEM(((struct lys_refine *)actual)->must,
                                     ((struct lys_refine *)actual)->must_size, 'musts');
                         break;
                       case ADD_KEYWORD:
                       case DELETE_KEYWORD:
                         YANG_ADDELEM(((struct lys_deviate *)actual)->must,
                                      ((struct lys_deviate *)actual)->must_size, 'musts');
                         break;
                       case NOTIFICATION_KEYWORD:
                         if (trg->version < 2) {
                           free(s);
                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, 'must');
                           YYABORT;
                         }
                         YANG_ADDELEM(((struct lys_node_notif *)actual)->must,
                                     ((struct lys_node_notif *)actual)->must_size, 'musts');
                         break;
                       case INPUT_KEYWORD:
                       case OUTPUT_KEYWORD:
                         if (trg->version < 2) {
                           free(s);
                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, 'must');
                           YYABORT;
                         }
                         YANG_ADDELEM(((struct lys_node_inout *)actual)->must,
                                     ((struct lys_node_inout *)actual)->must_size, 'musts');
                         break;
                       case EXTENSION_INSTANCE:
                         /* must is already allocated */
                         break;
                       default:
                         free(s);
                         LOGINT(trg->ctx);
                         YYABORT;
                       }
                       ((struct lys_restr *)actual)->expr = transform_schema2json(trg, s);
                       free(s);
                       if (!((struct lys_restr *)actual)->expr) {
                         YYABORT;
                       }
                       s = NULL;
                       actual_type = MUST_KEYWORD;
                     }

    break;

  case 552:

    { actual_type = (yyvsp[-1].backup_token).token;
             actual = (yyvsp[-1].backup_token).actual;
           }

    break;

  case 555:

    { backup_type = actual_type;
                             actual_type = UNIQUE_KEYWORD;
                           }

    break;

  case 559:

    { backup_type = actual_type;
                       actual_type = KEY_KEYWORD;
                     }

    break;

  case 561:

    { s = strdup(yyget_text(scanner));
                               if (!s) {
                                 LOGMEM(trg->ctx);
                                 YYABORT;
                               }
                             }

    break;

  case 564:

    { (yyval.backup_token).token = actual_type;
                        (yyval.backup_token).actual = actual;
                        if (!(actual = yang_read_range(trg->ctx, actual, s, is_ext_instance))) {
                          YYABORT;
                        }
                        actual_type = RANGE_KEYWORD;
                        s = NULL;
                      }

    break;

  case 565:

    { if (s) {
                                                s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 2);
                                                if (!s) {
                                                  LOGMEM(trg->ctx);
                                                  YYABORT;
                                                }
                                                strcat(s,'/');
                                                strcat(s, yyget_text(scanner));
                                              } else {
                                                s = malloc(yyget_leng(scanner) + 2);
                                                if (!s) {
                                                  LOGMEM(trg->ctx);
                                                  YYABORT;
                                                }
                                                s[0]='/';
                                                memcpy(s + 1, yyget_text(scanner), yyget_leng(scanner) + 1);
                                              }
                                            }

    break;

  case 569:

    { if (s) {
                                              s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 1);
                                              if (!s) {
                                                LOGMEM(trg->ctx);
                                                YYABORT;
                                              }
                                              strcat(s, yyget_text(scanner));
                                            } else {
                                              s = strdup(yyget_text(scanner));
                                              if (!s) {
                                                LOGMEM(trg->ctx);
                                                YYABORT;
                                              }
                                            }
                                          }

    break;

  case 571:

    { tmp_s = yyget_text(scanner); }

    break;

  case 572:

    { s = strdup(tmp_s);
                                                                if (!s) {
                                                                  LOGMEM(trg->ctx);
                                                                  YYABORT;
                                                                }
                                                                s[strlen(s) - 1] = '\0';
                                                             }

    break;

  case 573:

    { tmp_s = yyget_text(scanner); }

    break;

  case 574:

    { s = strdup(tmp_s);
                                                      if (!s) {
                                                        LOGMEM(trg->ctx);
                                                        YYABORT;
                                                      }
                                                      s[strlen(s) - 1] = '\0';
                                                    }

    break;

  case 598:

    { /* convert it to uint32_t */
                                                unsigned long val;

                                                val = strtoul(yyget_text(scanner), NULL, 10);
                                                if (val > UINT32_MAX) {
                                                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Converted number is very long.');
                                                    YYABORT;
                                                }
                                                (yyval.uint) = (uint32_t) val;
                                             }

    break;

  case 599:

    { (yyval.uint) = 0; }

    break;

  case 600:

    { (yyval.uint) = (yyvsp[0].uint); }

    break;

  case 601:

    { (yyval.i) = 0; }

    break;

  case 602:

    { /* convert it to int32_t */
                             int64_t val;

                             val = strtoll(yyget_text(scanner), NULL, 10);
                             if (val < INT32_MIN || val > INT32_MAX) {
                                 LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,
                                        'The number is not in the correct range (INT32_MIN..INT32_MAX): \'%d\'',val);
                                 YYABORT;
                             }
                             (yyval.i) = (int32_t) val;
                           }

    break;

  case 608:

    { if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {
                    free(s);
                    YYABORT;
                }
              }

    break;

  case 613:

    { char *tmp;

               if ((tmp = strchr(s, ':'))) {
                 *tmp = '\0';
                 /* check prefix */
                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {
                   free(s);
                   YYABORT;
                 }
                 /* check identifier */
                 if (lyp_check_identifier(trg->ctx, tmp + 1, LY_IDENT_SIMPLE, trg, NULL)) {
                   free(s);
                   YYABORT;
                 }
                 *tmp = ':';
               } else {
                 /* check identifier */
                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {
                   free(s);
                   YYABORT;
                 }
               }
             }

    break;

  case 614:

    { s = (yyvsp[-1].str); }

    break;

  case 615:

    { s = (yyvsp[-3].str); }

    break;

  case 616:

    { actual_type = backup_type;
                 backup_type = NODE;
                 (yyval.str) = s;
                 s = NULL;
               }

    break;

  case 617:

    { actual_type = backup_type;
                           backup_type = NODE;
                         }

    break;

  case 618:

    { (yyval.str) = s;
                          s = NULL;
                        }

    break;

  case 622:

    { actual_type = (yyvsp[-1].backup_token).token;
                     actual = (yyvsp[-1].backup_token).actual;
                   }

    break;

  case 623:

    { (yyval.backup_token).token = actual_type;
                                                (yyval.backup_token).actual = actual;
                                                if (!(actual = yang_read_ext(trg, (actual) ? actual : trg, (yyvsp[-1].str), s,
                                                                             actual_type, backup_type, is_ext_instance))) {
                                                  YYABORT;
                                                }
                                                s = NULL;
                                                actual_type = EXTENSION_INSTANCE;
                                              }

    break;

  case 624:

    { (yyval.str) = s; s = NULL; }

    break;

  case 639:

    {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;
        int32_t length = 0, old_length = 0;
        char *tmp_value;

        if (!substmt) {
          substmt = calloc(1, sizeof *substmt);
          if (!substmt) {
            LOGMEM(trg->ctx);
            YYABORT;
          }
          ((struct lys_ext_instance *)actual)->parent = substmt;
        }
        length = strlen((yyvsp[-2].str));
        old_length = (substmt->ext_substmt) ? strlen(substmt->ext_substmt) + 2 : 2;
        tmp_value = realloc(substmt->ext_substmt, old_length + length + 1);
        if (!tmp_value) {
          LOGMEM(trg->ctx);
          YYABORT;
        }
        substmt->ext_substmt = tmp_value;
        tmp_value += old_length - 2;
        memcpy(tmp_value, (yyvsp[-2].str), length);
        tmp_value[length] = ' ';
        tmp_value[length + 1] = '\0';
        tmp_value[length + 2] = '\0';
      }

    break;

  case 640:

    {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;
        int32_t length;
        char *tmp_value, **array;
        int i = 0;

        if (!substmt) {
          substmt = calloc(1, sizeof *substmt);
          if (!substmt) {
            LOGMEM(trg->ctx);
            YYABORT;
          }
          ((struct lys_ext_instance *)actual)->parent = substmt;
        }
        length = strlen((yyvsp[-2].str));
        if (!substmt->ext_modules) {
          array = malloc(2 * sizeof *substmt->ext_modules);
        } else {
          for (i = 0; substmt->ext_modules[i]; ++i);
          array = realloc(substmt->ext_modules, (i + 2) * sizeof *substmt->ext_modules);
        }
        if (!array) {
          LOGMEM(trg->ctx);
          YYABORT;
        }
        substmt->ext_modules = array;
        array[i + 1] = NULL;
        tmp_value = malloc(length + 2);
        if (!tmp_value) {
          LOGMEM(trg->ctx);
          YYABORT;
        }
        array[i] = tmp_value;
        memcpy(tmp_value, (yyvsp[-2].str), length);
        tmp_value[length] = '\0';
        tmp_value[length + 1] = '\0';
      }

    break;

  case 643:

    { (yyval.str) = yyget_text(scanner); }

    break;

  case 644:

    { (yyval.str) = yyget_text(scanner); }

    break;

  case 656:

    { s = strdup(yyget_text(scanner));
                  if (!s) {
                    LOGMEM(trg->ctx);
                    YYABORT;
                  }
                }

    break;

  case 749:

    { s = strdup(yyget_text(scanner));
                          if (!s) {
                            LOGMEM(trg->ctx);
                            YYABORT;
                          }
                        }

    break;

  case 750:

    { s = strdup(yyget_text(scanner));
                                    if (!s) {
                                      LOGMEM(trg->ctx);
                                      YYABORT;
                                    }
                                  }

    break;

  case 751:

    { struct lys_type **type;

                             type = (struct lys_type **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
                                                                                            'type', LY_STMT_TYPE);
                             if (!type) {
                               YYABORT;
                             }
                             /* allocate type structure */
                             (*type) = calloc(1, sizeof **type);
                             if (!*type) {
                               LOGMEM(trg->ctx);
                               YYABORT;
                             }

                             /* HACK for unres */
                             (*type)->parent = (struct lys_tpdf *)ext_instance;
                             (yyval.v) = actual = *type;
                             is_ext_instance = 0;
                            }

    break;

  case 752:

    { struct lys_tpdf **tpdf;

                                tpdf = (struct lys_tpdf **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
                                                                                               'typedef', LY_STMT_TYPEDEF);
                                if (!tpdf) {
                                  YYABORT;
                                }
                                /* allocate typedef structure */
                                (*tpdf) = calloc(1, sizeof **tpdf);
                                if (!*tpdf) {
                                  LOGMEM(trg->ctx);
                                  YYABORT;
                                }

                                (yyval.v) = actual = *tpdf;
                                is_ext_instance = 0;
                              }

    break;

  case 753:

    { struct lys_iffeature **iffeature;

                                 iffeature = (struct lys_iffeature **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
                                                                                                          'if-feature', LY_STMT_IFFEATURE);
                                 if (!iffeature) {
                                   YYABORT;
                                 }
                                 /* allocate typedef structure */
                                 (*iffeature) = calloc(1, sizeof **iffeature);
                                 if (!*iffeature) {
                                   LOGMEM(trg->ctx);
                                   YYABORT;
                                 }
                                 (yyval.v) = actual = *iffeature;
                               }

    break;

  case 754:

    { struct lys_restr **restr;
                                    LY_STMT stmt;

                                    s = yyget_text(scanner);
                                    if (!strcmp(s, 'must')) {
                                      stmt = LY_STMT_MUST;
                                    } else if (!strcmp(s, 'pattern')) {
                                      stmt = LY_STMT_PATTERN;
                                    } else if (!strcmp(s, 'range')) {
                                      stmt = LY_STMT_RANGE;
                                    } else {
                                      stmt = LY_STMT_LENGTH;
                                    }
                                    restr = (struct lys_restr **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, s, stmt);
                                    if (!restr) {
                                      YYABORT;
                                    }
                                    /* allocate structure for must */
                                    (*restr) = calloc(1, sizeof(struct lys_restr));
                                    if (!*restr) {
                                      LOGMEM(trg->ctx);
                                      YYABORT;
                                    }
                                    (yyval.v) = actual = *restr;
                                    s = NULL;
                                  }

    break;

  case 755:

    { actual = yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, 'when', LY_STMT_WHEN);
                             if (!actual) {
                               YYABORT;
                             }
                             (yyval.v) = actual;
                           }

    break;

  case 756:

    { struct lys_revision **rev;
                                 int i;

                                 rev = (struct lys_revision **)yang_getplace_for_extcomplex_struct(ext_instance, &i, ext_name,
                                                                                                   'revision', LY_STMT_REVISION);
                                 if (!rev) {
                                   YYABORT;
                                 }
                                 rev[i] = calloc(1, sizeof **rev);
                                 if (!rev[i]) {
                                   LOGMEM(trg->ctx);
                                   YYABORT;
                                 }
                                 actual = rev[i];
                                 (yyval.revisions).revision = rev;
                                 (yyval.revisions).index = i;
                               }

    break;

  case 757:

    { LY_STMT stmt;

                                s = yyget_text(scanner);
                                if (!strcmp(s, 'action')) {
                                  stmt = LY_STMT_ACTION;
                                } else if (!strcmp(s, 'anydata')) {
                                  stmt = LY_STMT_ANYDATA;
                                } else if (!strcmp(s, 'anyxml')) {
                                  stmt = LY_STMT_ANYXML;
                                } else if (!strcmp(s, 'case')) {
                                  stmt = LY_STMT_CASE;
                                } else if (!strcmp(s, 'choice')) {
                                  stmt = LY_STMT_CHOICE;
                                } else if (!strcmp(s, 'container')) {
                                  stmt = LY_STMT_CONTAINER;
                                } else if (!strcmp(s, 'grouping')) {
                                  stmt = LY_STMT_GROUPING;
                                } else if (!strcmp(s, 'input')) {
                                  stmt = LY_STMT_INPUT;
                                } else if (!strcmp(s, 'leaf')) {
                                  stmt = LY_STMT_LEAF;
                                } else if (!strcmp(s, 'leaf-list')) {
                                  stmt = LY_STMT_LEAFLIST;
                                } else if (!strcmp(s, 'list')) {
                                  stmt = LY_STMT_LIST;
                                } else if (!strcmp(s, 'notification')) {
                                  stmt = LY_STMT_NOTIFICATION;
                                } else if (!strcmp(s, 'output')) {
                                  stmt = LY_STMT_OUTPUT;
                                } else {
                                  stmt = LY_STMT_USES;
                                }
                                if (yang_extcomplex_node(ext_instance, ext_name, s, *param->node, stmt)) {
                                  YYABORT;
                                }
                                actual = NULL;
                                s = NULL;
                                is_ext_instance = 0;
                              }

    break;

  case 758:

    { LOGERR(trg->ctx, ly_errno, 'Extension's substatement \'%s\' not supported.', yyget_text(scanner)); }

    break;

  case 790:

    { actual_type = EXTENSION_INSTANCE;
                                actual = ext_instance;
                                if (!is_ext_instance) {
                                  LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));
                                  YYABORT;
                                }
                                (yyval.i) = 0;
                              }

    break;

  case 792:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'prefix', ext_name, s,
                                                                  0, LY_STMT_PREFIX)) {
                                       YYABORT;
                                     }
                                   }

    break;

  case 793:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'description', ext_name, s,
                                                                       0, LY_STMT_DESCRIPTION)) {
                                            YYABORT;
                                          }
                                        }

    break;

  case 794:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'reference', ext_name, s,
                                                                     0, LY_STMT_REFERENCE)) {
                                          YYABORT;
                                        }
                                      }

    break;

  case 795:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'units', ext_name, s,
                                                                     0, LY_STMT_UNITS)) {
                                      YYABORT;
                                    }
                                  }

    break;

  case 796:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'base', ext_name, s,
                                                                0, LY_STMT_BASE)) {
                                     YYABORT;
                                   }
                                 }

    break;

  case 797:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'contact', ext_name, s,
                                                                     0, LY_STMT_CONTACT)) {
                                        YYABORT;
                                      }
                                    }

    break;

  case 798:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'default', ext_name, s,
                                                                     0, LY_STMT_DEFAULT)) {
                                        YYABORT;
                                      }
                                    }

    break;

  case 799:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'error-message', ext_name, s,
                                                                         0, LY_STMT_ERRMSG)) {
                                              YYABORT;
                                            }
                                          }

    break;

  case 800:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'error-app-tag', ext_name, s,
                                                                         0, LY_STMT_ERRTAG)) {
                                              YYABORT;
                                            }
                                          }

    break;

  case 801:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'key', ext_name, s,
                                                               0, LY_STMT_KEY)) {
                                    YYABORT;
                                  }
                                }

    break;

  case 802:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'namespace', ext_name, s,
                                                                     0, LY_STMT_NAMESPACE)) {
                                          YYABORT;
                                        }
                                      }

    break;

  case 803:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'organization', ext_name, s,
                                                                        0, LY_STMT_ORGANIZATION)) {
                                             YYABORT;
                                           }
                                         }

    break;

  case 804:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'path', ext_name, s,
                                                                0, LY_STMT_PATH)) {
                                     YYABORT;
                                   }
                                 }

    break;

  case 805:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'presence', ext_name, s,
                                                                    0, LY_STMT_PRESENCE)) {
                                         YYABORT;
                                       }
                                     }

    break;

  case 806:

    { if (yang_read_extcomplex_str(trg, ext_instance, 'revision-date', ext_name, s,
                                                                         0, LY_STMT_REVISIONDATE)) {
                                              YYABORT;
                                            }
                                          }

    break;

  case 807:

    { struct lys_type *type = (yyvsp[-2].v);

       if (yang_fill_type(trg, type, (struct yang_type *)type->der, ext_instance, param->unres)) {
         yang_type_free(trg->ctx, type);
         YYABORT;
       }
       if (unres_schema_add_node(trg, param->unres, type, UNRES_TYPE_DER_EXT, NULL) == -1) {
         yang_type_free(trg->ctx, type);
         YYABORT;
       }
       actual = ext_instance;
       is_ext_instance = 1;
     }

    break;

  case 808:

    { struct lys_tpdf *tpdf = (yyvsp[-2].v);

       if (yang_fill_type(trg, &tpdf->type, (struct yang_type *)tpdf->type.der, tpdf, param->unres)) {
         yang_type_free(trg->ctx, &tpdf->type);
       }
       if (yang_check_ext_instance(trg, &tpdf->ext, tpdf->ext_size, tpdf, param->unres)) {
         YYABORT;
       }
       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DER_TPDF, (struct lys_node *)ext_instance) == -1) {
         yang_type_free(trg->ctx, &tpdf->type);
         YYABORT;
       }
       /* check default value*/
       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&tpdf->dflt)) == -1)  {
         YYABORT;
       }
       actual = ext_instance;
       is_ext_instance = 1;
     }

    break;

  case 809:

    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, 'status', LY_STMT_STATUS,
                                                                    (yyvsp[0].i), LYS_STATUS_MASK)) {
                                       YYABORT;
                                     }
                                   }

    break;

  case 810:

    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, 'config', LY_STMT_CONFIG,
                                                                    (yyvsp[0].i), LYS_CONFIG_MASK)) {
                                       YYABORT;
                                     }
                                   }

    break;

  case 811:

    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, 'mandatory', LY_STMT_MANDATORY,
                                                                       (yyvsp[0].i), LYS_MAND_MASK)) {
                                          YYABORT;
                                        }
                                      }

    break;

  case 812:

    { if ((yyvsp[-1].i) & LYS_ORDERED_MASK) {
                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, 'ordered by', ext_name);
                                            YYABORT;
                                         }
                                         if ((yyvsp[0].i) & LYS_USERORDERED) {
                                           if (yang_fill_extcomplex_flags(ext_instance, ext_name, 'ordered-by', LY_STMT_ORDEREDBY,
                                                                          (yyvsp[0].i), LYS_USERORDERED)) {
                                             YYABORT;
                                           }
                                         }
                                         (yyvsp[-1].i) |= (yyvsp[0].i);
                                         (yyval.i) = (yyvsp[-1].i);
                                       }

    break;

  case 813:

    { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, 'require-instance',
                                                                              LY_STMT_REQINSTANCE, (yyvsp[0].i))) {
                                                 YYABORT;
                                               }
                                             }

    break;

  case 814:

    { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, 'modifier', LY_STMT_MODIFIER, 0)) {
                                         YYABORT;
                                       }
                                     }

    break;

  case 815:

    { /* range check */
       if ((yyvsp[0].uint) < 1 || (yyvsp[0].uint) > 18) {
         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, 'Invalid value \'%d\' of \'%s\'.', (yyvsp[0].uint), 'fraction-digits');
         YYABORT;
       }
       if (yang_fill_extcomplex_uint8(ext_instance, ext_name, 'fraction-digits', LY_STMT_DIGITS, (yyvsp[0].uint))) {
         YYABORT;
       }
     }

    break;

  case 816:

    { uint32_t **val;

                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
                                                                                                  'min-elements', LY_STMT_MIN);
                                           if (!val) {
                                             YYABORT;
                                           }
                                           /* store the value */
                                           *val = malloc(sizeof(uint32_t));
                                           if (!*val) {
                                             LOGMEM(trg->ctx);
                                             YYABORT;
                                           }
                                           **val = (yyvsp[0].uint);
                                         }

    break;

  case 817:

    { uint32_t **val;

                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
                                                                                                  'max-elements', LY_STMT_MAX);
                                           if (!val) {
                                             YYABORT;
                                           }
                                           /* store the value */
                                           *val = malloc(sizeof(uint32_t));
                                           if (!*val) {
                                             LOGMEM(trg->ctx);
                                             YYABORT;
                                           }
                                           **val = (yyvsp[0].uint);
                                         }

    break;

  case 818:

    { uint32_t **val;

                                       val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
                                                                                              'position', LY_STMT_POSITION);
                                       if (!val) {
                                         YYABORT;
                                       }
                                       /* store the value */
                                       *val = malloc(sizeof(uint32_t));
                                       if (!*val) {
                                         LOGMEM(trg->ctx);
                                         YYABORT;
                                       }
                                       **val = (yyvsp[0].uint);
                                     }

    break;

  case 819:

    { int32_t **val;

                                    val = (int32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
                                                                                          'value', LY_STMT_VALUE);
                                    if (!val) {
                                      YYABORT;
                                    }
                                    /* store the value */
                                    *val = malloc(sizeof(int32_t));
                                    if (!*val) {
                                      LOGMEM(trg->ctx);
                                      YYABORT;
                                    }
                                    **val = (yyvsp[0].i);
                                  }

    break;

  case 820:

    { struct lys_unique **unique;
                                     int rc;

                                     unique = (struct lys_unique **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
                                                                                                        'unique', LY_STMT_UNIQUE);
                                     if (!unique) {
                                       YYABORT;
                                     }
                                     *unique = calloc(1, sizeof(struct lys_unique));
                                     if (!*unique) {
                                       LOGMEM(trg->ctx);
                                       YYABORT;
                                     }
                                     rc = yang_fill_unique(trg, (struct lys_node_list *)ext_instance, *unique, s, param->unres);
                                     free(s);
                                     s = NULL;
                                     if (rc) {
                                       YYABORT;
                                     }
                                   }

    break;

  case 821:

    { struct lys_iffeature *iffeature;

       iffeature = (yyvsp[-2].v);
       s = (char *)iffeature->features;
       iffeature->features = NULL;
       if (yang_fill_iffeature(trg, iffeature, ext_instance, s, param->unres, 0)) {
         YYABORT;
       }
       if (yang_check_ext_instance(trg, &iffeature->ext, iffeature->ext_size, iffeature, param->unres)) {
         YYABORT;
       }
       s = NULL;
       actual = ext_instance;
     }

    break;

  case 823:

    { if (yang_check_ext_instance(trg, &((struct lys_restr *)(yyvsp[-2].v))->ext, ((struct lys_restr *)(yyvsp[-2].v))->ext_size, (yyvsp[-2].v), param->unres)) {
         YYABORT;
       }
       actual = ext_instance;
     }

    break;

  case 824:

    { if (yang_check_ext_instance(trg, &(*(struct lys_when **)(yyvsp[-2].v))->ext, (*(struct lys_when **)(yyvsp[-2].v))->ext_size,
                                   *(struct lys_when **)(yyvsp[-2].v), param->unres)) {
         YYABORT;
       }
       actual = ext_instance;
     }

    break;

  case 825:

    { int i;

       for (i = 0; i < (yyvsp[-2].revisions).index; ++i) {
         if (!strcmp((yyvsp[-2].revisions).revision[i]->date, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->date)) {
           LOGWRN(trg->ctx, 'Module's revisions are not unique (%s).', (yyvsp[-2].revisions).revision[i]->date);
           break;
         }
       }
       if (yang_check_ext_instance(trg, &(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext_size,
                                   &(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index], param->unres)) {
         YYABORT;
       }
       actual = ext_instance;
     }

    break;

  case 826:

    { actual = ext_instance;
                                                                    is_ext_instance = 1;
                                                                  }

    break;



      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ('-> $$ =', yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;
  *++yylsp = yyloc;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */
  {
    const int yylhs = yyr1[yyn] - YYNTOKENS;
    const int yyi = yypgoto[yylhs] + *yyssp;
    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
               ? yytable[yyi]
               : yydefgoto[yylhs]);
  }

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (&yylloc, scanner, param, YY_('syntax error'));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_('syntax error');
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (&yylloc, scanner, param, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }

  yyerror_range[1] = yylloc;

  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct ('Error: discarding',
                      yytoken, &yylval, &yylloc, scanner, param);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;

      yyerror_range[1] = *yylsp;
      yydestruct ('Error: popping',
                  yystos[yystate], yyvsp, yylsp, scanner, param);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  yyerror_range[2] = yylloc;
  /* Using YYLLOC is tempting, but would change the location of
     the lookahead.  YYLOC is available though.  */
  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
  *++yylsp = yyloc;

  /* Shift the error token.  */
  YY_SYMBOL_PRINT ('Shifting', yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (&yylloc, scanner, param, YY_('memory exhausted'));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ('Cleanup: discarding lookahead',
                  yytoken, &yylval, &yylloc, scanner, param);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ('Cleanup: popping',
                  yystos[*yyssp], yyvsp, yylsp, scanner, param);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  return yyresult;
}
",1,8485
CESNET/libyang,d9feacc4a590d35dbc1af21caf9080008b4450ed,"                 }
",0,8486
CESNET/libyang,d9feacc4a590d35dbc1af21caf9080008b4450ed,"int
yang_read_message(struct lys_module *module,struct lys_restr *save,char *value, char *what, int message)
{
    int ret;

    if (message == ERROR_APP_TAG_KEYWORD) {
        ret = yang_check_string(module, &save->eapptag, 'error_app_tag', what, value, NULL);
    } else {
        ret = yang_check_string(module, &save->emsg, 'error_message', what, value, NULL);
    }
    return ret;
}
",0,8487
CESNET/libyang,d9feacc4a590d35dbc1af21caf9080008b4450ed,"    STATUS_KEYWORD = 328,
    SUBMODULE_KEYWORD = 329,
    TYPE_KEYWORD = 330,
",0,8488
LibreDWG/libredwg,c6f6668b82bfe595899cc820279ac37bb9ef16f5,"void
dwg_free_object (Dwg_Object *obj)
{
  int error = 0;
  long unsigned int j;
  Dwg_Data *dwg;
  Bit_Chain *dat = &pdat;

  if (obj && obj->parent)
    {
      dwg = obj->parent;
      dat->version = dwg->header.version;
    }
  else
    return;
  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)
    return;
  dat->from_version = dat->version;
  if (obj->supertype == DWG_SUPERTYPE_UNKNOWN)
    goto unhandled;

  switch (obj->type)
    {
    case DWG_TYPE_TEXT:
      dwg_free_TEXT (dat, obj);
      break;
    case DWG_TYPE_ATTRIB:
      dwg_free_ATTRIB (dat, obj);
      break;
    case DWG_TYPE_ATTDEF:
      dwg_free_ATTDEF (dat, obj);
      break;
    case DWG_TYPE_BLOCK:
      dwg_free_BLOCK (dat, obj);
      break;
    case DWG_TYPE_ENDBLK:
      dwg_free_ENDBLK (dat, obj);
      break;
    case DWG_TYPE_SEQEND:
      dwg_free_SEQEND (dat, obj);
      break;
    case DWG_TYPE_INSERT:
      dwg_free_INSERT (dat, obj);
      break;
    case DWG_TYPE_MINSERT:
      dwg_free_MINSERT (dat, obj);
      break;
    case DWG_TYPE_VERTEX_2D:
      dwg_free_VERTEX_2D (dat, obj);
      break;
    case DWG_TYPE_VERTEX_3D:
      dwg_free_VERTEX_3D (dat, obj);
      break;
    case DWG_TYPE_VERTEX_MESH:
      dwg_free_VERTEX_MESH (dat, obj);
      break;
    case DWG_TYPE_VERTEX_PFACE:
      dwg_free_VERTEX_PFACE (dat, obj);
      break;
    case DWG_TYPE_VERTEX_PFACE_FACE:
      dwg_free_VERTEX_PFACE_FACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_2D:
      dwg_free_POLYLINE_2D (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_3D:
      dwg_free_POLYLINE_3D (dat, obj);
      break;
    case DWG_TYPE_ARC:
      dwg_free_ARC (dat, obj);
      break;
    case DWG_TYPE_CIRCLE:
      dwg_free_CIRCLE (dat, obj);
      break;
    case DWG_TYPE_LINE:
      dwg_free_LINE (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ORDINATE:
      dwg_free_DIMENSION_ORDINATE (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_LINEAR:
      dwg_free_DIMENSION_LINEAR (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ALIGNED:
      dwg_free_DIMENSION_ALIGNED (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ANG3PT:
      dwg_free_DIMENSION_ANG3PT (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ANG2LN:
      dwg_free_DIMENSION_ANG2LN (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_RADIUS:
      dwg_free_DIMENSION_RADIUS (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_DIAMETER:
      dwg_free_DIMENSION_DIAMETER (dat, obj);
      break;
    case DWG_TYPE_POINT:
      dwg_free_POINT (dat, obj);
      break;
    case DWG_TYPE__3DFACE:
      dwg_free__3DFACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_PFACE:
      dwg_free_POLYLINE_PFACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_MESH:
      dwg_free_POLYLINE_MESH (dat, obj);
      break;
    case DWG_TYPE_SOLID:
      dwg_free_SOLID (dat, obj);
      break;
    case DWG_TYPE_TRACE:
      dwg_free_TRACE (dat, obj);
      break;
    case DWG_TYPE_SHAPE:
      dwg_free_SHAPE (dat, obj);
      break;
    case DWG_TYPE_VIEWPORT:
      dwg_free_VIEWPORT (dat, obj);
      break;
    case DWG_TYPE_ELLIPSE:
      dwg_free_ELLIPSE (dat, obj);
      break;
    case DWG_TYPE_SPLINE:
      dwg_free_SPLINE (dat, obj);
      break;
    case DWG_TYPE_REGION:
      dwg_free_REGION (dat, obj);
      break;
    case DWG_TYPE__3DSOLID:
      dwg_free__3DSOLID (dat, obj);
      break; /* Check the type of the object */
    case DWG_TYPE_BODY:
      dwg_free_BODY (dat, obj);
      break;
    case DWG_TYPE_RAY:
      dwg_free_RAY (dat, obj);
      break;
    case DWG_TYPE_XLINE:
      dwg_free_XLINE (dat, obj);
      break;
    case DWG_TYPE_DICTIONARY:
      dwg_free_DICTIONARY (dat, obj);
      break;
    case DWG_TYPE_MTEXT:
      dwg_free_MTEXT (dat, obj);
      break;
    case DWG_TYPE_LEADER:
      dwg_free_LEADER (dat, obj);
      break;
    case DWG_TYPE_TOLERANCE:
      dwg_free_TOLERANCE (dat, obj);
      break;
    case DWG_TYPE_MLINE:
      dwg_free_MLINE (dat, obj);
      break;
    case DWG_TYPE_BLOCK_CONTROL:
      dwg_free_BLOCK_CONTROL (dat, obj);
      break;
    case DWG_TYPE_BLOCK_HEADER:
      dwg_free_BLOCK_HEADER (dat, obj);
      break;
    case DWG_TYPE_LAYER_CONTROL:
      dwg_free_LAYER_CONTROL (dat, obj);
      break;
    case DWG_TYPE_LAYER:
      dwg_free_LAYER (dat, obj);
      break;
    case DWG_TYPE_STYLE_CONTROL:
      dwg_free_STYLE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_STYLE:
      dwg_free_STYLE (dat, obj);
      break;
    case DWG_TYPE_LTYPE_CONTROL:
      dwg_free_LTYPE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_LTYPE:
      dwg_free_LTYPE (dat, obj);
      break;
    case DWG_TYPE_VIEW_CONTROL:
      dwg_free_VIEW_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VIEW:
      dwg_free_VIEW (dat, obj);
      break;
    case DWG_TYPE_UCS_CONTROL:
      dwg_free_UCS_CONTROL (dat, obj);
      break;
    case DWG_TYPE_UCS:
      dwg_free_UCS (dat, obj);
      break;
    case DWG_TYPE_VPORT_CONTROL:
      dwg_free_VPORT_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VPORT:
      dwg_free_VPORT (dat, obj);
      break;
    case DWG_TYPE_APPID_CONTROL:
      dwg_free_APPID_CONTROL (dat, obj);
      break;
    case DWG_TYPE_APPID:
      dwg_free_APPID (dat, obj);
      break;
    case DWG_TYPE_DIMSTYLE_CONTROL:
      dwg_free_DIMSTYLE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_DIMSTYLE:
      dwg_free_DIMSTYLE (dat, obj);
      break;
    case DWG_TYPE_VPORT_ENTITY_CONTROL:
      dwg_free_VPORT_ENTITY_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VPORT_ENTITY_HEADER:
      dwg_free_VPORT_ENTITY_HEADER (dat, obj);
      break;
    case DWG_TYPE_GROUP:
      dwg_free_GROUP (dat, obj);
      break;
    case DWG_TYPE_MLINESTYLE:
      dwg_free_MLINESTYLE (dat, obj);
      break;
    case DWG_TYPE_OLE2FRAME:
      dwg_free_OLE2FRAME (dat, obj);
      break;
    case DWG_TYPE_DUMMY:
      dwg_free_DUMMY (dat, obj);
      break;
    case DWG_TYPE_LONG_TRANSACTION:
      dwg_free_LONG_TRANSACTION (dat, obj);
      break;
    case DWG_TYPE_LWPOLYLINE:
      dwg_free_LWPOLYLINE (dat, obj);
      break;
    case DWG_TYPE_HATCH:
      dwg_free_HATCH (dat, obj);
      break;
    case DWG_TYPE_XRECORD:
      dwg_free_XRECORD (dat, obj);
      break;
    case DWG_TYPE_PLACEHOLDER:
      dwg_free_PLACEHOLDER (dat, obj);
      break;
    case DWG_TYPE_OLEFRAME:
      dwg_free_OLEFRAME (dat, obj);
      break;
#ifdef DEBUG_VBA_PROJECT
    case DWG_TYPE_VBA_PROJECT:
      dwg_free_VBA_PROJECT (dat, obj);
      break;
#endif
    case DWG_TYPE_LAYOUT:
      dwg_free_LAYOUT (dat, obj);
      break;
    case DWG_TYPE_PROXY_ENTITY:
      dwg_free_PROXY_ENTITY (dat, obj);
      break;
    case DWG_TYPE_PROXY_OBJECT:
      dwg_free_PROXY_OBJECT (dat, obj);
      break;
    default:
      if (obj->type == obj->parent->layout_type)
        {
          SINCE (R_13)
          {
            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed
          }
        }

      else if ((error = dwg_free_variable_type (obj->parent, obj))
               & DWG_ERR_UNHANDLEDCLASS)
        {
          int is_entity;
          int i;
          Dwg_Class *klass;

        unhandled:
          is_entity = 0;
          i = obj->type - 500;
          klass = NULL;

          dwg = obj->parent;
          if (dwg->dwg_class && i >= 0 && i < (int)dwg->num_classes)
            {
              klass = &dwg->dwg_class[i];
              is_entity = klass ? dwg_class_is_entity (klass) : 0;
            }
          // indxf (and later injson) already creates some DEBUGGING classes
          if (obj->fixedtype == DWG_TYPE_TABLE)
            {
              // just the preview, i.e. common. plus some colors: leak
              dwg_free_UNKNOWN_ENT (dat, obj);
            }
          else if (obj->fixedtype == DWG_TYPE_DATATABLE)
            {
              dwg_free_UNKNOWN_OBJ (dat, obj);
            }
          else if (klass && !is_entity)
            {
              dwg_free_UNKNOWN_OBJ (dat, obj);
            }
          else if (klass && is_entity)
            {
              dwg_free_UNKNOWN_ENT (dat, obj);
            }
          else // not a class
            {
              FREE_IF (obj->tio.unknown);
            }
        }
    }
  /* With this importer the dxfname is dynamic, just the name is const */
  if (dwg->opts & DWG_OPTS_INDXF)
    FREE_IF (obj->dxfname);
  obj->type = DWG_TYPE_FREED;
}
",1,8489
LibreDWG/libredwg,c6f6668b82bfe595899cc820279ac37bb9ef16f5,"int
dwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,
                       unsigned long address)
{
  int error = 0;
  unsigned long oldpos;
  unsigned long end_address = address + obj->size;

  oldpos = bit_position (dat);
  assert (address);
  dat->byte = address;
  dat->bit = 0;

  LOG_INFO ('Object number: %lu', (unsigned long)obj->index);
  if (obj->size > 0x100000)
    {
      LOG_ERROR ('Object size %u overflow', obj->size);
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  while (dat->byte + obj->size >= dat->size)
    bit_chain_alloc (dat);

  // TODO: calculate size from the fields. either <0x7fff or more
  // patch it afterwards and check old<>new size if enough space allocated.
  bit_write_MS (dat, obj->size);
  obj->address = dat->byte;
  PRE (R_2010) {
    bit_write_BS (dat, obj->type);
    LOG_INFO (', Size: %d [MS], Type: %d [BS]\n', obj->size, obj->type)
  }
  LATER_VERSIONS
  {
    if (!obj->handlestream_size && obj->bitsize)
      obj->handlestream_size = obj->size * 8 - obj->bitsize;
    bit_write_UMC (dat, obj->handlestream_size);
    obj->address = dat->byte;
    bit_write_BOT (dat, obj->type);
    LOG_INFO (', Size: %d [MS], Hdlsize: %lu [UMC], Type: %d [BOT]\n',
              obj->size, (unsigned long)obj->handlestream_size, obj->type)
  }

  /* Write the specific type to dat */
  switch (obj->type)
    {
    case DWG_TYPE_TEXT:
      error = dwg_encode_TEXT (dat, obj);
      break;
    case DWG_TYPE_ATTRIB:
      error = dwg_encode_ATTRIB (dat, obj);
      break;
    case DWG_TYPE_ATTDEF:
      error = dwg_encode_ATTDEF (dat, obj);
      break;
    case DWG_TYPE_BLOCK:
      error = dwg_encode_BLOCK (dat, obj);
      break;
    case DWG_TYPE_ENDBLK:
      error = dwg_encode_ENDBLK (dat, obj);
      break;
    case DWG_TYPE_SEQEND:
      error = dwg_encode_SEQEND (dat, obj);
      break;
    case DWG_TYPE_INSERT:
      error = dwg_encode_INSERT (dat, obj);
      break;
    case DWG_TYPE_MINSERT:
      error = dwg_encode_MINSERT (dat, obj);
      break;
    case DWG_TYPE_VERTEX_2D:
      error = dwg_encode_VERTEX_2D (dat, obj);
      break;
    case DWG_TYPE_VERTEX_3D:
      error = dwg_encode_VERTEX_3D (dat, obj);
      break;
    case DWG_TYPE_VERTEX_MESH:
      error = dwg_encode_VERTEX_MESH (dat, obj);
      break;
    case DWG_TYPE_VERTEX_PFACE:
      error = dwg_encode_VERTEX_PFACE (dat, obj);
      break;
    case DWG_TYPE_VERTEX_PFACE_FACE:
      error = dwg_encode_VERTEX_PFACE_FACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_2D:
      error = dwg_encode_POLYLINE_2D (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_3D:
      error = dwg_encode_POLYLINE_3D (dat, obj);
      break;
    case DWG_TYPE_ARC:
      error = dwg_encode_ARC (dat, obj);
      break;
    case DWG_TYPE_CIRCLE:
      error = dwg_encode_CIRCLE (dat, obj);
      break;
    case DWG_TYPE_LINE:
      error = dwg_encode_LINE (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ORDINATE:
      error = dwg_encode_DIMENSION_ORDINATE (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_LINEAR:
      error = dwg_encode_DIMENSION_LINEAR (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ALIGNED:
      error = dwg_encode_DIMENSION_ALIGNED (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ANG3PT:
      error = dwg_encode_DIMENSION_ANG3PT (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ANG2LN:
      error = dwg_encode_DIMENSION_ANG2LN (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_RADIUS:
      error = dwg_encode_DIMENSION_RADIUS (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_DIAMETER:
      error = dwg_encode_DIMENSION_DIAMETER (dat, obj);
      break;
    case DWG_TYPE_POINT:
      error = dwg_encode_POINT (dat, obj);
      break;
    case DWG_TYPE__3DFACE:
      error = dwg_encode__3DFACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_PFACE:
      error = dwg_encode_POLYLINE_PFACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_MESH:
      error = dwg_encode_POLYLINE_MESH (dat, obj);
      break;
    case DWG_TYPE_SOLID:
      error = dwg_encode_SOLID (dat, obj);
      break;
    case DWG_TYPE_TRACE:
      error = dwg_encode_TRACE (dat, obj);
      break;
    case DWG_TYPE_SHAPE:
      error = dwg_encode_SHAPE (dat, obj);
      break;
    case DWG_TYPE_VIEWPORT:
      error = dwg_encode_VIEWPORT (dat, obj);
      break;
    case DWG_TYPE_ELLIPSE:
      error = dwg_encode_ELLIPSE (dat, obj);
      break;
    case DWG_TYPE_SPLINE:
      error = dwg_encode_SPLINE (dat, obj);
      break;
    case DWG_TYPE_REGION:
      error = dwg_encode_REGION (dat, obj);
      break;
    case DWG_TYPE__3DSOLID:
      error = dwg_encode__3DSOLID (dat, obj);
      break;
    case DWG_TYPE_BODY:
      error = dwg_encode_BODY (dat, obj);
      break;
    case DWG_TYPE_RAY:
      error = dwg_encode_RAY (dat, obj);
      break;
    case DWG_TYPE_XLINE:
      error = dwg_encode_XLINE (dat, obj);
      break;
    case DWG_TYPE_DICTIONARY:
      error = dwg_encode_DICTIONARY (dat, obj);
      break;
    case DWG_TYPE_MTEXT:
      error = dwg_encode_MTEXT (dat, obj);
      break;
    case DWG_TYPE_LEADER:
      error = dwg_encode_LEADER (dat, obj);
      break;
    case DWG_TYPE_TOLERANCE:
      error = dwg_encode_TOLERANCE (dat, obj);
      break;
    case DWG_TYPE_MLINE:
      error = dwg_encode_MLINE (dat, obj);
      break;
    case DWG_TYPE_BLOCK_CONTROL:
      error = dwg_encode_BLOCK_CONTROL (dat, obj);
      break;
    case DWG_TYPE_BLOCK_HEADER:
      error = dwg_encode_BLOCK_HEADER (dat, obj);
      break;
    case DWG_TYPE_LAYER_CONTROL:
      error = dwg_encode_LAYER_CONTROL (dat, obj);
      break;
    case DWG_TYPE_LAYER:
      error = dwg_encode_LAYER (dat, obj);
      break;
    case DWG_TYPE_STYLE_CONTROL:
      error = dwg_encode_STYLE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_STYLE:
      error = dwg_encode_STYLE (dat, obj);
      break;
    case DWG_TYPE_LTYPE_CONTROL:
      error = dwg_encode_LTYPE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_LTYPE:
      error = dwg_encode_LTYPE (dat, obj);
      break;
    case DWG_TYPE_VIEW_CONTROL:
      error = dwg_encode_VIEW_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VIEW:
      error = dwg_encode_VIEW (dat, obj);
      break;
    case DWG_TYPE_UCS_CONTROL:
      error = dwg_encode_UCS_CONTROL (dat, obj);
      break;
    case DWG_TYPE_UCS:
      error = dwg_encode_UCS (dat, obj);
      break;
    case DWG_TYPE_VPORT_CONTROL:
      error = dwg_encode_VPORT_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VPORT:
      error = dwg_encode_VPORT (dat, obj);
      break;
    case DWG_TYPE_APPID_CONTROL:
      error = dwg_encode_APPID_CONTROL (dat, obj);
      break;
    case DWG_TYPE_APPID:
      error = dwg_encode_APPID (dat, obj);
      break;
    case DWG_TYPE_DIMSTYLE_CONTROL:
      error = dwg_encode_DIMSTYLE_CONTROL (dat, obj);
      break;
    case DWG_TYPE_DIMSTYLE:
      error = dwg_encode_DIMSTYLE (dat, obj);
      break;
    case DWG_TYPE_VPORT_ENTITY_CONTROL:
      error = dwg_encode_VPORT_ENTITY_CONTROL (dat, obj);
      break;
    case DWG_TYPE_VPORT_ENTITY_HEADER:
      error = dwg_encode_VPORT_ENTITY_HEADER (dat, obj);
      break;
    case DWG_TYPE_GROUP:
      error = dwg_encode_GROUP (dat, obj);
      break;
    case DWG_TYPE_MLINESTYLE:
      error = dwg_encode_MLINESTYLE (dat, obj);
      (void)dwg_encode_get_class (obj->parent, obj);
      break;
    case DWG_TYPE_OLE2FRAME:
      error = dwg_encode_OLE2FRAME (dat, obj);
      (void)dwg_encode_get_class (obj->parent, obj);
      break;
    case DWG_TYPE_DUMMY:
      error = dwg_encode_DUMMY (dat, obj);
      break;
    case DWG_TYPE_LONG_TRANSACTION:
      error = dwg_encode_LONG_TRANSACTION (dat, obj);
      break;
    case DWG_TYPE_LWPOLYLINE:
      error = dwg_encode_LWPOLYLINE (dat, obj);
      (void)dwg_encode_get_class (obj->parent, obj);
      break;
    case DWG_TYPE_HATCH:
      error = dwg_encode_HATCH (dat, obj);
      (void)dwg_encode_get_class (obj->parent, obj);
      break;
    case DWG_TYPE_XRECORD:
      error = dwg_encode_XRECORD (dat, obj);
      (void)dwg_encode_get_class (obj->parent, obj);
      break;
    case DWG_TYPE_PLACEHOLDER:
      error = dwg_encode_PLACEHOLDER (dat, obj);
      (void)dwg_encode_get_class (obj->parent, obj);
      break;
    case DWG_TYPE_OLEFRAME:
      error = dwg_encode_OLEFRAME (dat, obj);
      (void)dwg_encode_get_class (obj->parent, obj);
      break;
    case DWG_TYPE_VBA_PROJECT:
      LOG_ERROR ('Unhandled Object VBA_PROJECT. Has its own section');
      // dwg_encode_VBA_PROJECT(dat, obj);
      break;
    case DWG_TYPE_LAYOUT:
      error |= dwg_encode_LAYOUT (dat, obj);
      (void)dwg_encode_get_class (obj->parent, obj);
      break;
    case DWG_TYPE_PROXY_ENTITY:
      error = dwg_encode_PROXY_ENTITY (dat, obj);
      break;
    case DWG_TYPE_PROXY_OBJECT:
      error = dwg_encode_PROXY_OBJECT (dat, obj);
      break;
    default:
      if (obj->type == obj->parent->layout_type
          && obj->fixedtype == DWG_TYPE_LAYOUT)
        {
          error = dwg_encode_LAYOUT (dat, obj);
          (void)dwg_encode_get_class (obj->parent, obj);
        }
      else if ((error = dwg_encode_variable_type (obj->parent, dat, obj))
               & DWG_ERR_UNHANDLEDCLASS)
        {
          Dwg_Data *dwg = obj->parent;
          int is_entity;
          int i = obj->type - 500;
          Dwg_Class *klass = dwg_encode_get_class (dwg, obj);

          assert (address);
          dat->byte = address; // restart and write into the UNKNOWN_OBJ object
          dat->bit = 0;
          bit_write_MS (dat, obj->size); // unknown blobs have a known size
          if (dat->version >= R_2010)
            {
              bit_write_UMC (dat, obj->handlestream_size);
              bit_write_BOT (dat, obj->type);
            }
          else
            bit_write_BS (dat, obj->type);

          if (klass && obj->supertype == DWG_SUPERTYPE_UNKNOWN)
            is_entity = dwg_class_is_entity (klass);
          else
            is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;
          // properly dwg_decode_object/_entity for eed, reactors, xdic
          if (klass && !is_entity)
            error = dwg_encode_UNKNOWN_OBJ (dat, obj);
          else if (klass)
            error = dwg_encode_UNKNOWN_ENT (dat, obj);
          else // not a class
            {
              LOG_WARN ('Unknown object, skipping eed/reactors/xdic');
              error = DWG_ERR_UNHANDLEDCLASS;
              SINCE (R_2000)
              {
                bit_write_RL (dat, obj->bitsize);
                LOG_INFO ('bitsize: ' FORMAT_RL ' [RL] (@%lu.%u)\n', obj->bitsize,
                          dat->byte - 4, dat->bit);
              }
              bit_write_H (dat, &obj->handle);
              LOG_INFO ('handle: ' FORMAT_H ' [H 5]\n', ARGS_H (obj->handle));
              // write obj->size bytes, excl. bitsize and handle.
              // overshoot the bitsize and handle size.
              bit_write_TF (dat, obj->tio.unknown, obj->size);
            }
        }
    }

  /* DXF: patchup size and bitsize */
  if (!obj->size)
    {
      BITCODE_BL pos = bit_position (dat);
      assert (address);
      obj->size = dat->byte - address - 2; // excludes the CRC
      if (dat->bit)
        obj->size++;
      //assert (obj->bitsize); // on errors
      if (!obj->bitsize)
        {
          LOG_TRACE ('-bitsize calc from address (no handle) @%lu.%u\n',
                     dat->byte, dat->bit);
          obj->bitsize = pos - (obj->address * 8);
        }
      bit_set_position (dat, address * 8);
      if (obj->size > 0x7fff)
        // TODO: with overlarge sizes >0x7fff memmove dat
        LOG_ERROR ('Unhandled size %u > 0x7fff', (unsigned)obj->size);
      bit_write_MS (dat, obj->size);
      LOG_TRACE ('-size: %u [MS] @%lu\n', obj->size, address);
      SINCE (R_2013)
      {
        if (!obj->handlestream_size && obj->bitsize)
          obj->handlestream_size = obj->size * 8 - obj->bitsize;
        bit_write_UMC (dat, obj->handlestream_size);
        LOG_TRACE ('-handlestream_size: %lu [UMC]\n', obj->handlestream_size);
      }
      SINCE (R_2000)
      {
        if (obj->bitsize_pos && obj->bitsize)
          {
            bit_set_position (dat, obj->bitsize_pos);
            bit_write_RL (dat, obj->bitsize);
            LOG_TRACE ('-bitsize: %u [RL] @%lu.%lu\n', obj->bitsize,
                       obj->bitsize_pos / 8, obj->bitsize_pos % 8);
          }
      }
      bit_set_position (dat, pos);
    }

  /*
   if (obj->supertype != DWG_SUPERTYPE_UNKNOWN)
   {
     fprintf (stderr, 'Begin address:\t%10lu\n', address);
     fprintf (stderr, 'Last address:\t%10lu\tSize: %10lu\n', dat->byte,
   obj->size); fprintf (stderr, 'End address:\t%10lu (calculated)\n', address +
   2 + obj->size);
   }
   */

  /* Now 1 padding bits until next byte, and then a RS CRC */
  if (dat->bit)
    LOG_TRACE ('padding: +%d [*B]\n', 8 - dat->bit)
  while (dat->bit)
    bit_write_B (dat, 1);
  end_address = obj->address + obj->size;
  if (end_address != dat->byte)
    {
      if (obj->size)
        LOG_WARN ('Wrong object size: %lu + %u = %lu != %lu: %ld off', obj->address,
                  obj->size, end_address, dat->byte, (long)(end_address - dat->byte));
      dat->byte = end_address;
    }
  assert (!dat->bit);
  bit_write_CRC (dat, address, 0xC0C1);
  return error;
}
",1,8490
LibreDWG/libredwg,c6f6668b82bfe595899cc820279ac37bb9ef16f5," * Private functions
 */

static int resolve_objectref_vector (Bit_Chain *restrict dat,
                                     Dwg_Data *restrict dwg);

static void decode_preR13_section_ptr (const char *restrict name,
                                       Dwg_Section_Type_r11 id,
                                       Bit_Chain *restrict dat,
",0,8491
LibreDWG/libredwg,c6f6668b82bfe595899cc820279ac37bb9ef16f5,"static BITCODE_RL
encode_patch_RLsize (Bit_Chain *dat, long unsigned int pvzadr)
{
  unsigned long pos;
  BITCODE_RL size;
  if (dat->bit) // padding
    {
      dat->bit = 0;
      dat->byte++;
    }
  size = dat->byte - pvzadr - 4; // minus the RL size
  pos = bit_position (dat);
  assert (pvzadr);
  bit_set_position (dat, pvzadr * 8);
  bit_write_RL (dat, size);
  LOG_TRACE ('size: ' FORMAT_RL ' [RL] @%lu\n', size, pvzadr);
  bit_set_position (dat, pos);
  return size;
}
",0,8492
greenbone/gsa,19b541e18d503ff594936d0a7ac803a1b0aa4fd1,"http_response_t *
create_not_found_response (const gchar *url, cmd_response_data_t *response_data)
{
  http_response_t *response;
  int len;

  cmd_response_data_set_status_code (response_data, MHD_HTTP_NOT_FOUND);

  gchar *msg =
    '<!DOCTYPE html>'
    '<html>'
    '<head>'
    '<meta http-equiv=\'Content-Type\' content=\'text/html; charset=UTF-8\' />'
    '<link rel=\'icon\' href=\'/img/favicon.gif\' type=\'image/gif\'></link>'
    '<title>Greenbone Security Assistant</title>'
    '</head>'
    '<body>'
    '<h1>URL not found</h1>'
    '<p>'
    'The requested URL is not available'
    '</p>'
    '</body>'
    '</html>';

  cmd_response_data_set_content_type (response_data,
                                      GSAD_CONTENT_TYPE_TEXT_HTML);

  cmd_response_data_set_content_length (response_data, strlen (msg));

  len = cmd_response_data_get_content_length (response_data);
  response = MHD_create_response_from_buffer (len, msg, MHD_RESPMEM_MUST_COPY);
  return response;
}
",1,8493
greenbone/gsa,19b541e18d503ff594936d0a7ac803a1b0aa4fd1,"  if (!ret)
    {
",0,8494
facebook/fbthrift,3f156207e8a6583d88999487e954320dc18955e6,"  [[noreturn]] static void throwInvalidFieldData();

 protected:
",1,8495
facebook/fbthrift,3f156207e8a6583d88999487e954320dc18955e6,"            protocol, map_size, {rpt_key_type, rpt_mapped_type});
      } else {
        auto const kreader = [&protocol](auto& key) {
          key_methods::read(protocol, key);
        };
",1,8496
facebook/fbthrift,3f156207e8a6583d88999487e954320dc18955e6,"      prot.readI64(i64);
      return;
    }
",0,8497
WebAssembly/binaryen,85e95e315a8023c46eb804fe80ebc244bcfdae3e,"Name WasmBinaryBuilder::getFunctionIndexName(Index i) {
  return wasm.functions[i]->name;
}

void WasmBinaryBuilder::getResizableLimits(Address& initial, Address& max, bool &shared, Address defaultIfNoMax) {
  auto flags = getU32LEB();
",1,8498
WebAssembly/binaryen,85e95e315a8023c46eb804fe80ebc244bcfdae3e,"    auto curr = make_unique<FunctionType>();
    auto form = getS32LEB();
    if (form != BinaryConsts::EncodedType::Func) {
      throwError('bad signature form ' + std::to_string(form));
    }
    size_t numParams = getU32LEB();
",0,8499
eclipse/wakaama,01ce63fdcf86eb0d4765fb9326d7e6df36846f09,"coap_status_t __attribute__((optimize('O0')))
#else
coap_status_t
#endif
coap_parse_message(void *packet, uint8_t *data, uint16_t data_len)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  uint8_t *current_option;
  unsigned int option_number = 0;
  unsigned int option_delta = 0;
  size_t option_length = 0;

  /* Initialize packet */
  memset(coap_pkt, 0, sizeof(coap_packet_t));

  /* pointer to packet bytes */
  coap_pkt->buffer = data;

  /* parse header fields */
  coap_pkt->version = (COAP_HEADER_VERSION_MASK & coap_pkt->buffer[0])>>COAP_HEADER_VERSION_POSITION;
  coap_pkt->type = (coap_message_type_t)((COAP_HEADER_TYPE_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TYPE_POSITION);
  coap_pkt->token_len = MIN(COAP_TOKEN_LEN, (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION);
  coap_pkt->code = coap_pkt->buffer[1];
  coap_pkt->mid = coap_pkt->buffer[2]<<8 | coap_pkt->buffer[3];

  if (coap_pkt->version != 1)
  {
    coap_error_message = 'CoAP version must be 1';
    return BAD_REQUEST_4_00;
  }

  current_option = data + COAP_HEADER_LEN;

  if (coap_pkt->token_len != 0)
  {
      memcpy(coap_pkt->token, current_option, coap_pkt->token_len);
      SET_OPTION(coap_pkt, COAP_OPTION_TOKEN);

      PRINTF('Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n', coap_pkt->token_len,
        coap_pkt->token[0],
        coap_pkt->token[1],
        coap_pkt->token[2],
        coap_pkt->token[3],
        coap_pkt->token[4],
        coap_pkt->token[5],
        coap_pkt->token[6],
        coap_pkt->token[7]
      ); /*FIXME always prints 8 bytes */
  }

  /* parse options */
  current_option += coap_pkt->token_len;

  while (current_option < data+data_len)
  {
    /* Payload marker 0xFF, currently only checking for 0xF* because rest is reserved */
    if ((current_option[0] & 0xF0)==0xF0)
    {
      coap_pkt->payload = ++current_option;
      coap_pkt->payload_len = data_len - (coap_pkt->payload - data);

      break;
    }

    option_delta = current_option[0]>>4;
    option_length = current_option[0] & 0x0F;
    ++current_option;

    if (option_delta == 13) {
      option_delta += current_option[0];
      ++current_option;
    } else if (option_delta == 14) {
      option_delta += 255;
      option_delta += current_option[0] << 8;
      ++current_option;
      option_delta += current_option[0];
      ++current_option;
    }

    if (option_length == 13) {
      option_length += current_option[0];
      ++current_option;
    } else if (option_length == 14) {
      option_length += 255;
      option_length += current_option[0] << 8;
      ++current_option;
      option_length += current_option[0];
      ++current_option;
    }

    option_number += option_delta;

    if (current_option + option_length > data + data_len)
    {
        PRINTF('OPTION %u (delta %u, len %u) has invalid length.\n', option_number, option_delta, option_length);
        coap_free_header(coap_pkt);
        return BAD_REQUEST_4_00;
    }
    else
    {
        PRINTF('OPTION %u (delta %u, len %u): ', option_number, option_delta, option_length);
    }

    SET_OPTION(coap_pkt, option_number);

    switch (option_number)
    {
      case COAP_OPTION_CONTENT_TYPE:
        coap_pkt->content_type = (coap_content_type_t)coap_parse_int_option(current_option, option_length);
        PRINTF('Content-Format [%u]\n', coap_pkt->content_type);
        break;
      case COAP_OPTION_MAX_AGE:
        coap_pkt->max_age = coap_parse_int_option(current_option, option_length);
        PRINTF('Max-Age [%lu]\n', coap_pkt->max_age);
        break;
      case COAP_OPTION_ETAG:
        coap_pkt->etag_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));
        memcpy(coap_pkt->etag, current_option, coap_pkt->etag_len);
        PRINTF('ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n', coap_pkt->etag_len,
          coap_pkt->etag[0],
          coap_pkt->etag[1],
          coap_pkt->etag[2],
          coap_pkt->etag[3],
          coap_pkt->etag[4],
          coap_pkt->etag[5],
          coap_pkt->etag[6],
          coap_pkt->etag[7]
        ); /*FIXME always prints 8 bytes */
        break;
      case COAP_OPTION_ACCEPT:
        if (coap_pkt->accept_num < COAP_MAX_ACCEPT_NUM)
        {
          coap_pkt->accept[coap_pkt->accept_num] = coap_parse_int_option(current_option, option_length);
          coap_pkt->accept_num += 1;
          PRINTF('Accept [%u]\n', coap_pkt->content_type);
        }
        break;
      case COAP_OPTION_IF_MATCH:
        /*FIXME support multiple ETags */
        coap_pkt->if_match_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));
        memcpy(coap_pkt->if_match, current_option, coap_pkt->if_match_len);
        PRINTF('If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n', coap_pkt->if_match_len,
          coap_pkt->if_match[0],
          coap_pkt->if_match[1],
          coap_pkt->if_match[2],
          coap_pkt->if_match[3],
          coap_pkt->if_match[4],
          coap_pkt->if_match[5],
          coap_pkt->if_match[6],
          coap_pkt->if_match[7]
        ); /*FIXME always prints 8 bytes */
        break;
      case COAP_OPTION_IF_NONE_MATCH:
        coap_pkt->if_none_match = 1;
        PRINTF('If-None-Match\n');
        break;

      case COAP_OPTION_URI_HOST:
        coap_pkt->uri_host = current_option;
        coap_pkt->uri_host_len = option_length;
        PRINTF('Uri-Host [%.*s]\n', coap_pkt->uri_host_len, coap_pkt->uri_host);
        break;
      case COAP_OPTION_URI_PORT:
        coap_pkt->uri_port = coap_parse_int_option(current_option, option_length);
        PRINTF('Uri-Port [%u]\n', coap_pkt->uri_port);
        break;
      case COAP_OPTION_URI_PATH:
        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */
        // coap_merge_multi_option( (char **) &(coap_pkt->uri_path), &(coap_pkt->uri_path_len), current_option, option_length, 0);
        coap_add_multi_option( &(coap_pkt->uri_path), current_option, option_length, 1);
        PRINTF('Uri-Path [%.*s]\n', option_length, current_option);
        break;
      case COAP_OPTION_URI_QUERY:
        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */
        // coap_merge_multi_option( (char **) &(coap_pkt->uri_query), &(coap_pkt->uri_query_len), current_option, option_length, '&');
        coap_add_multi_option( &(coap_pkt->uri_query), current_option, option_length, 1);
        PRINTF('Uri-Query [%.*s]\n', option_length, current_option);
        break;

      case COAP_OPTION_LOCATION_PATH:
        coap_add_multi_option( &(coap_pkt->location_path), current_option, option_length, 1);
        break;
      case COAP_OPTION_LOCATION_QUERY:
        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */
        coap_merge_multi_option( &(coap_pkt->location_query), &(coap_pkt->location_query_len), current_option, option_length, '&');
        PRINTF('Location-Query [%.*s]\n', option_length, current_option);
        break;

      case COAP_OPTION_PROXY_URI:
        /*FIXME check for own end-point */
        coap_pkt->proxy_uri = current_option;
        coap_pkt->proxy_uri_len = option_length;
        /*TODO length > 270 not implemented (actually not required) */
        PRINTF('Proxy-Uri NOT IMPLEMENTED [%.*s]\n', coap_pkt->proxy_uri_len, coap_pkt->proxy_uri);
        coap_error_message = 'This is a constrained server (Contiki)';
        coap_free_header(coap_pkt);
        return PROXYING_NOT_SUPPORTED_5_05;

      case COAP_OPTION_OBSERVE:
        coap_pkt->observe = coap_parse_int_option(current_option, option_length);
        PRINTF('Observe [%lu]\n', coap_pkt->observe);
        break;
      case COAP_OPTION_BLOCK2:
        coap_pkt->block2_num = coap_parse_int_option(current_option, option_length);
        coap_pkt->block2_more = (coap_pkt->block2_num & 0x08)>>3;
        coap_pkt->block2_size = 16 << (coap_pkt->block2_num & 0x07);
        coap_pkt->block2_offset = (coap_pkt->block2_num & ~0x0000000F)<<(coap_pkt->block2_num & 0x07);
        coap_pkt->block2_num >>= 4;
        PRINTF('Block2 [%lu%s (%u B/blk)]\n', coap_pkt->block2_num, coap_pkt->block2_more ? '+' : '', coap_pkt->block2_size);
        break;
      case COAP_OPTION_BLOCK1:
        coap_pkt->block1_num = coap_parse_int_option(current_option, option_length);
        coap_pkt->block1_more = (coap_pkt->block1_num & 0x08)>>3;
        coap_pkt->block1_size = 16 << (coap_pkt->block1_num & 0x07);
        coap_pkt->block1_offset = (coap_pkt->block1_num & ~0x0000000F)<<(coap_pkt->block1_num & 0x07);
        coap_pkt->block1_num >>= 4;
        PRINTF('Block1 [%lu%s (%u B/blk)]\n', coap_pkt->block1_num, coap_pkt->block1_more ? '+' : '', coap_pkt->block1_size);
        break;
      case COAP_OPTION_SIZE:
        coap_pkt->size = coap_parse_int_option(current_option, option_length);
        PRINTF('Size [%lu]\n', coap_pkt->size);
        break;
      default:
        PRINTF('unknown (%u)\n', option_number);
        /* Check if critical (odd) */
        if (option_number & 1)
        {
          coap_error_message = 'Unsupported critical option';
          return BAD_OPTION_4_02;
        }
    }

    current_option += option_length;
  } /* for */
  PRINTF('-Done parsing-------\n');



  return NO_ERROR;
}
",1,8500
eclipse/wakaama,01ce63fdcf86eb0d4765fb9326d7e6df36846f09,"int
coap_get_header_uri_host(void *packet, const char **host)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;

  if (!IS_OPTION(coap_pkt, COAP_OPTION_URI_HOST)) return 0;

  *host = (char *)coap_pkt->uri_host;
  return coap_pkt->uri_host_len;
}
",0,8501
zephyrproject-rtos/zephyr,2ba886a1c44a9a8e09ed37b95eb9fd46370efe7e,"static void memoryWrite(u8_t *buf, u16_t size)
{
	if ((addr + size) > memory_size) {
		size = memory_size - addr;
		stage = MSC_ERROR;
		usb_ep_set_stall(mass_ep_data[MSD_OUT_EP_IDX].ep_addr);
		LOG_WRN('Stall OUT endpoint');
	}

	/* we fill an array in RAM of 1 block before writing it in memory */
	for (int i = 0; i < size; i++) {
		page[addr % BLOCK_SIZE + i] = buf[i];
	}

	/* if the array is filled, write it in memory */
	if (!((addr + size) % BLOCK_SIZE)) {
		if (!(disk_access_status(disk_pdrv) &
					DISK_STATUS_WR_PROTECT)) {
			LOG_DBG('Disk WRITE Qd %d', (addr/BLOCK_SIZE));
			thread_op = THREAD_OP_WRITE_QUEUED;  /* write_queued */
			defered_wr_sz = size;
			k_sem_give(&disk_wait_sem);
			return;
		}
	}

	addr += size;
	length -= size;
	csw.DataResidue -= size;

	if ((!length) || (stage != MSC_PROCESS_CBW)) {
		csw.Status = (stage == MSC_ERROR) ? CSW_FAILED : CSW_PASSED;
		sendCSW();
	}
}
",1,8502
zephyrproject-rtos/zephyr,2ba886a1c44a9a8e09ed37b95eb9fd46370efe7e,"static void thread_memory_write_done(void)
{
	u32_t size = defered_wr_sz;

	addr += size;
	length -= size;
	csw.DataResidue -= size;


	if ((!length) || (stage != MSC_PROCESS_CBW)) {
		csw.Status = (stage == MSC_ERROR) ? CSW_FAILED : CSW_PASSED;
		sendCSW();
	}

	thread_op = THREAD_OP_WRITE_DONE;

	usb_ep_read_continue(mass_ep_data[MSD_OUT_EP_IDX].ep_addr);
}
",1,8503
zephyrproject-rtos/zephyr,2ba886a1c44a9a8e09ed37b95eb9fd46370efe7e,"static void fail(void)
{
	csw.Status = CSW_FAILED;
	sendCSW();
}
",0,8504
zephyrproject-rtos/zephyr,2ba886a1c44a9a8e09ed37b95eb9fd46370efe7e,"static void mass_storage_bulk_in(u8_t ep,
				 enum usb_dc_ep_cb_status_code ep_status)
{
	ARG_UNUSED(ep_status);
	ARG_UNUSED(ep);

	switch (stage) {
	/*the device has to send data to the host*/
	case MSC_PROCESS_CBW:
		switch (cbw.CB[0]) {
		case READ10:
		case READ12:
			/* LOG_DBG('< BI - PROC_CBW  READ'); */
			memoryRead();
			break;
		default:
			LOG_ERR('< BI-PROC_CBW default <<ERROR!!>>');
			break;
		}
		break;

	/*the device has to send a CSW*/
	case MSC_SEND_CSW:
		LOG_DBG('< BI - MSC_SEND_CSW');
		sendCSW();
		break;

	/*the host has received the CSW -> we wait a CBW*/
	case MSC_WAIT_CSW:
		LOG_DBG('< BI - MSC_WAIT_CSW');
		stage = MSC_READ_CBW;
		break;

	/*an error has occurred*/
	default:
		LOG_WRN('Stall IN endpoint, stage: %d', stage);
		usb_ep_set_stall(mass_ep_data[MSD_IN_EP_IDX].ep_addr);
		sendCSW();
		break;
	}
}
",0,8505
zephyrproject-rtos/zephyr,204cceaf643e51c3a15a40dde7cba4dd618f4f22,"static void install_update_cb(void)
{
	struct coap_packet response_packet;
	u8_t *data = k_malloc(MAX_DOWNLOAD_DATA);
	int rcvd = -1;

	if (data == NULL) {
		LOG_ERR('Could not alloc data memory');
		ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
		goto cleanup;
	}

	wait_fds();

	rcvd = recv(ctx.sock, data, MAX_DOWNLOAD_DATA, MSG_DONTWAIT);
	if (rcvd <= 0) {
		ctx.code_status = UPDATEHUB_NETWORKING_ERROR;
		LOG_ERR('Could not receive data');
		goto cleanup;
	}

	if (coap_packet_parse(&response_packet, data, rcvd, NULL, 0) < 0) {
		LOG_ERR('Invalid data received');
		ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
		goto cleanup;
	}

	ctx.downloaded_size = ctx.downloaded_size +
			      (response_packet.max_len - response_packet.offset);

	if (tc_sha256_update(&ctx.sha256sum,
			     response_packet.data + response_packet.offset,
			     response_packet.max_len - response_packet.offset) < 1) {
		LOG_ERR('Could not update sha256sum');
		ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
		goto cleanup;
	}

	if (flash_img_buffered_write(&ctx.flash_ctx,
				     response_packet.data + response_packet.offset,
				     response_packet.max_len - response_packet.offset,
				     ctx.downloaded_size == ctx.block.total_size) < 0) {
		LOG_ERR('Error to write on the flash');
		ctx.code_status = UPDATEHUB_INSTALL_ERROR;
		goto cleanup;
	}

	if (coap_update_from_block(&response_packet, &ctx.block) < 0) {
		ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
		goto cleanup;
	}

	if (coap_next_block(&response_packet, &ctx.block) == 0) {
		LOG_ERR('Could not get the next');
		ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
		goto cleanup;
	}

	if (ctx.downloaded_size == ctx.block.total_size) {
		if (!install_update_cb_sha256())
			ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
			goto cleanup;
		}
	}
",1,8506
zephyrproject-rtos/zephyr,204cceaf643e51c3a15a40dde7cba4dd618f4f22,"static bool install_update_cb_sha256(void)
{
	u8_t image_hash[TC_SHA256_DIGEST_SIZE];
	char buffer[3], sha256_image_dowloaded[TC_SHA256_BLOCK_SIZE + 1];
	int i, buffer_len = 0;

	if (tc_sha256_final(image_hash, &ctx.sha256sum) < 1) {
		LOG_ERR('Could not finish sha256sum');
		return false;
	}

	memset(&sha256_image_dowloaded, 0, TC_SHA256_BLOCK_SIZE + 1);
	for (i = 0; i < TC_SHA256_DIGEST_SIZE; i++) {
		snprintk(buffer, sizeof(buffer), '%02x', image_hash[i]);
		buffer_len = buffer_len + strlen(buffer);
		strncat(&sha256_image_dowloaded[i], buffer,
			MIN(TC_SHA256_BLOCK_SIZE, buffer_len));
	}

	if (strncmp(sha256_image_dowloaded,
		update_info.sha256sum_image,
		strlen(update_info.sha256sum_image)) != 0) {
		LOG_ERR('SHA256SUM of image are not the same');
		ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
		return false;
	}

	return true;
}
",0,8507
zephyrproject-rtos/zephyr,34a4bbef8536db599e2d57b8a8dd34e104e28fdb,"static enum updatehub_response install_update(void)
{
	int verification_download = 0;
	int attempts_download = 0;

	if (boot_erase_img_bank(DT_FLASH_AREA_IMAGE_1_ID) != 0) {
		LOG_ERR('Failed to init flash and erase second slot');
		ctx.code_status = UPDATEHUB_FLASH_INIT_ERROR;
		goto error;
	}

	if (tc_sha256_init(&ctx.sha256sum) < 1) {
		LOG_ERR('Could not start sha256sum');
		ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
		goto error;
	}

	if (!start_coap_client()) {
		ctx.code_status = UPDATEHUB_NETWORKING_ERROR;
		goto error;
	}

	if (coap_block_transfer_init(&ctx.block, COAP_BLOCK_1024,
				     update_info.image_size) < 0) {
		LOG_ERR('Unable init block transfer');
		ctx.code_status = UPDATEHUB_NETWORKING_ERROR;
		goto cleanup;
	}

	flash_img_init(&ctx.flash_ctx);

	ctx.downloaded_size = 0;

	while (ctx.downloaded_size != ctx.block.total_size) {
		verification_download = ctx.downloaded_size;

		if (send_request(COAP_TYPE_CON, COAP_METHOD_GET,
				 UPDATEHUB_DOWNLOAD) < 0) {
			ctx.code_status = UPDATEHUB_NETWORKING_ERROR;
			goto cleanup;
		}

		install_update_cb();

		if (ctx.code_status != UPDATEHUB_OK) {
			goto cleanup;
		}

		if (verification_download == ctx.downloaded_size) {
			if (attempts_download ==
			    CONFIG_UPDATEHUB_COAP_MAX_RETRY) {
				LOG_ERR('Could not get the packet');
				ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
				goto cleanup;
			}
			attempts_download++;
		}
	}

cleanup:
	cleanup_connection();

error:
	ctx.downloaded_size = 0;

	return ctx.code_status;
}
",1,8508
zephyrproject-rtos/zephyr,34a4bbef8536db599e2d57b8a8dd34e104e28fdb,"static void probe_cb(char *metadata, size_t metadata_size)
{
	struct coap_packet reply;
	char tmp[MAX_DOWNLOAD_DATA];
	size_t tmp_len;
	int rcvd = -1;

	wait_fds();

	rcvd = recv(ctx.sock, tmp, MAX_DOWNLOAD_DATA, MSG_DONTWAIT);
	if (rcvd <= 0) {
		LOG_ERR('Could not receive data');
		ctx.code_status = UPDATEHUB_NETWORKING_ERROR;
		return;
	}

	if (coap_packet_parse(&reply, tmp, rcvd, NULL, 0) < 0) {
		LOG_ERR('Invalid data received');
		ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;
		return;
	}

	if (COAP_RESPONSE_CODE_NOT_FOUND == coap_header_get_code(&reply)) {
		LOG_INF('No update available');
		ctx.code_status = UPDATEHUB_NO_UPDATE;
		return;
	}

	/* check if we have buffer space to receive payload */
	if (metadata_size < (reply.max_len - reply.offset)) {
		LOG_ERR('There is no buffer available');
		ctx.code_status = UPDATEHUB_METADATA_ERROR;
		return;
	}

	memset(metadata, 0, metadata_size);
	memcpy(metadata, reply.data + reply.offset,
	       reply.max_len - reply.offset);

	/* ensures payload have a valid string with size lower
	 * than metadata_size
	 */
	tmp_len = strlen(metadata);
	if (tmp_len >= metadata_size) {
		LOG_ERR('Invalid metadata data received');
		ctx.code_status = UPDATEHUB_METADATA_ERROR;
		return;
	}

	ctx.code_status = UPDATEHUB_OK;

	LOG_INF('Probe metadata received');
}
",0,8509
zephyrproject-rtos/zephyr,c0e8deb8e848ca45a316377b6fe0a35e94cfbef4,"void mayfly_enable(u8_t caller_id, u8_t callee_id, u8_t enable)
{
	if (enable) {
		if (mft[callee_id][caller_id].enable_req ==
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
		}

		mayfly_enable_cb(caller_id, callee_id, enable);
	} else {
		if (mft[callee_id][caller_id].disable_req ==
		    mft[callee_id][caller_id].disable_ack) {
			mft[callee_id][caller_id].disable_req++;

			mayfly_pend(caller_id, callee_id);
		}
	}
}
",1,8510
zephyrproject-rtos/zephyr,c0e8deb8e848ca45a316377b6fe0a35e94cfbef4,"void mayfly_run(u8_t callee_id)
{
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
		return;
	}
	mfp[callee_id] = 1U;

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
		memq_link_t *link;
		struct mayfly *m = 0;

		/* fetch mayfly in callee queue, if any */
		link = memq_peek(mft[callee_id][caller_id].head,
				 mft[callee_id][caller_id].tail,
				 (void **)&m);
		while (link) {
			u8_t state;

#if defined(MAYFLY_UT)
			_state = 0U;
#endif /* MAYFLY_UT */

			/* execute work if ready */
			state = (m->_req - m->_ack) & 0x03;
			if (state == 1U) {
#if defined(MAYFLY_UT)
				_state = 1U;
#endif /* MAYFLY_UT */

				/* mark mayfly as ran */
				m->_ack--;

				/* call the mayfly function */
				m->fp(m->param);
			}

			/* dequeue if not re-pended */
			dequeue(callee_id, caller_id, link, m);

			/* fetch next mayfly in callee queue, if any */
			link = memq_peek(mft[callee_id][caller_id].head,
					 mft[callee_id][caller_id].tail,
					 (void **)&m);

			/* yield out of mayfly_run if a mayfly function was
			 * called.
			 */
			if (state == 1U) {
				/* pend callee (tailchain) if mayfly queue is
				 * not empty or all caller queues are not
				 * processed.
				 */
				if (caller_id || link) {
					mayfly_pend(callee_id, callee_id);

					return;
				}
			}
		}

		if (mft[callee_id][caller_id].disable_req !=
		    mft[callee_id][caller_id].disable_ack) {
			disable = 1U;

			mft[callee_id][caller_id].disable_ack =
				mft[callee_id][caller_id].disable_req;
		}

		if (mft[callee_id][caller_id].enable_req !=
		    mft[callee_id][caller_id].enable_ack) {
			enable = 1U;

			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
		mayfly_enable_cb(callee_id, callee_id, 0);
	}
}
",1,8511
zephyrproject-rtos/zephyr,c0e8deb8e848ca45a316377b6fe0a35e94cfbef4,"static void dequeue(u8_t callee_id, u8_t caller_id, memq_link_t *link,
		    struct mayfly *m)
{
	u8_t req;

	req = m->_req;
	if (((req - m->_ack) & 0x03) != 1U) {
		u8_t ack;

#if defined(MAYFLY_UT)
		u32_t mayfly_ut_run_test(void);
		void mayfly_ut_mfy(void *param);

		if (_state && m->fp == mayfly_ut_mfy) {
			static u8_t single;

			if (!single) {
				single = 1U;
				mayfly_ut_run_test();
			}
		}
#endif /* MAYFLY_UT */

		/* dequeue mayfly struct */
		memq_dequeue(mft[callee_id][caller_id].tail,
			     &mft[callee_id][caller_id].head,
			     0);

		/* release link into dequeued mayfly struct */
		m->_link = link;

		/* reset mayfly state to idle */
		ack = m->_ack;
		m->_ack = req;

		/* re-insert, if re-pended by interrupt */
		if (((m->_req - ack) & 0x03) == 1U) {
#if defined(MAYFLY_UT)
			printk('%s: RACE\n', __func__);
#endif /* MAYFLY_UT */

			m->_ack = ack;
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
		}
	}
}
",0,8512
FreeRDP/FreeRDP,ed53cd148f43cbab905eaa0f5308c2bf3c48cc37,"static void update_read_synchronize(rdpUpdate* update, wStream* s)
{
	WINPR_UNUSED(update);
	Stream_Seek_UINT16(s); /* pad2Octets (2 bytes) */
	                       /**
	                        * The Synchronize Update is an artifact from the
	                        * T.128 protocol and should be ignored.
	                        */
}
",1,8514
FreeRDP/FreeRDP,ed53cd148f43cbab905eaa0f5308c2bf3c48cc37,"BOOL update_recv(rdpUpdate* update, wStream* s)
{
	BOOL rc = FALSE;
	UINT16 updateType;
	rdpContext* context = update->context;

	if (Stream_GetRemainingLength(s) < 2)
	{
		WLog_ERR(TAG, 'Stream_GetRemainingLength(s) < 2');
		return FALSE;
	}

	Stream_Read_UINT16(s, updateType); /* updateType (2 bytes) */
	WLog_Print(update->log, WLOG_TRACE, '%s Update Data PDU', UPDATE_TYPE_STRINGS[updateType]);

	if (!update_begin_paint(update))
		goto fail;

	switch (updateType)
	{
		case UPDATE_TYPE_ORDERS:
			rc = update_recv_orders(update, s);
			break;

		case UPDATE_TYPE_BITMAP:
		{
			BITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);

			if (!bitmap_update)
			{
				WLog_ERR(TAG, 'UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed');
				goto fail;
			}

			rc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);
			free_bitmap_update(update->context, bitmap_update);
		}
		break;

		case UPDATE_TYPE_PALETTE:
		{
			PALETTE_UPDATE* palette_update = update_read_palette(update, s);

			if (!palette_update)
			{
				WLog_ERR(TAG, 'UPDATE_TYPE_PALETTE - update_read_palette() failed');
				goto fail;
			}

			rc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);
			free_palette_update(context, palette_update);
		}
		break;

		case UPDATE_TYPE_SYNCHRONIZE:
			update_read_synchronize(update, s);
			rc = IFCALLRESULT(TRUE, update->Synchronize, context);
			break;

		default:
			break;
	}

fail:

	if (!update_end_paint(update))
		rc = FALSE;

	if (!rc)
	{
		WLog_ERR(TAG, 'UPDATE_TYPE %s [%' PRIu16 '] failed', update_type_to_string(updateType),
		         updateType);
		return FALSE;
	}

	return TRUE;
}
",1,8515
FreeRDP/FreeRDP,ed53cd148f43cbab905eaa0f5308c2bf3c48cc37,"static BOOL update_send_window_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,
                                      const WINDOW_STATE_ORDER* stateOrder)
{
	return update_send_new_or_existing_window(context, orderInfo, stateOrder);
}
",0,8516
FreeRDP/FreeRDP,ed53cd148f43cbab905eaa0f5308c2bf3c48cc37,"static int update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)
{
	int length = 0;
	rdpUpdate* update = context->update;
	orderInfo->boundsFlags = 0;

	if (update_bounds_is_null(&update->currentBounds))
		return 0;

	orderInfo->controlFlags |= ORDER_BOUNDS;

	if (update_bounds_equals(&update->previousBounds, &update->currentBounds))
	{
		orderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;
		return 0;
	}
	else
	{
		length += 1;

		if (update->previousBounds.left != update->currentBounds.left)
		{
			orderInfo->bounds.left = update->currentBounds.left;
			orderInfo->boundsFlags |= BOUND_LEFT;
			length += 2;
		}

		if (update->previousBounds.top != update->currentBounds.top)
		{
			orderInfo->bounds.top = update->currentBounds.top;
			orderInfo->boundsFlags |= BOUND_TOP;
			length += 2;
		}

		if (update->previousBounds.right != update->currentBounds.right)
		{
			orderInfo->bounds.right = update->currentBounds.right;
			orderInfo->boundsFlags |= BOUND_RIGHT;
			length += 2;
		}

		if (update->previousBounds.bottom != update->currentBounds.bottom)
		{
			orderInfo->bounds.bottom = update->currentBounds.bottom;
			orderInfo->boundsFlags |= BOUND_BOTTOM;
			length += 2;
		}
	}

	return length;
}
",0,8517
FreeRDP/FreeRDP,c0fd449ec0870b050d350d6d844b1ea6dad4bc7d,"BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)
{
	rdpGlyph* prevGlyph;

	if (id > 9)
	{
		WLog_ERR(TAG, 'invalid glyph cache id: %' PRIu32 '', id);
		return FALSE;
	}

	if (index > glyphCache->glyphCache[id].number)
	{
		WLog_ERR(TAG, 'invalid glyph cache index: %' PRIu32 ' in cache id: %' PRIu32 '', index, id);
		return FALSE;
	}

	WLog_Print(glyphCache->log, WLOG_DEBUG, 'GlyphCachePut: id: %' PRIu32 ' index: %' PRIu32 '', id,
	           index);
	prevGlyph = glyphCache->glyphCache[id].entries[index];

	if (prevGlyph)
		prevGlyph->Free(glyphCache->context, prevGlyph);

	glyphCache->glyphCache[id].entries[index] = glyph;
	return TRUE;
}
",1,8518
FreeRDP/FreeRDP,c0fd449ec0870b050d350d6d844b1ea6dad4bc7d,"static BOOL update_gdi_fast_glyph(rdpContext* context, const FAST_GLYPH_ORDER* fastGlyph)
{
	INT32 x, y;
	BYTE text_data[4] = { 0 };
	INT32 opLeft, opTop;
	INT32 opRight, opBottom;
	INT32 opWidth = 0, opHeight = 0;
	INT32 bkWidth = 0, bkHeight = 0;
	rdpCache* cache;

	if (!context || !fastGlyph || !context->cache)
		return FALSE;

	cache = context->cache;
	opLeft = fastGlyph->opLeft;
	opTop = fastGlyph->opTop;
	opRight = fastGlyph->opRight;
	opBottom = fastGlyph->opBottom;
	x = fastGlyph->x;
	y = fastGlyph->y;

	if (opBottom == -32768)
	{
		BYTE flags = (BYTE)(opTop & 0x0F);

		if (flags & 0x01)
			opBottom = fastGlyph->bkBottom;

		if (flags & 0x02)
			opRight = fastGlyph->bkRight;

		if (flags & 0x04)
			opTop = fastGlyph->bkTop;

		if (flags & 0x08)
			opLeft = fastGlyph->bkLeft;
	}

	if (opLeft == 0)
		opLeft = fastGlyph->bkLeft;

	if (opRight == 0)
		opRight = fastGlyph->bkRight;

	/* See update_gdi_fast_index opRight comment. */
	if (opRight > (INT64)context->instance->settings->DesktopWidth)
		opRight = (int)context->instance->settings->DesktopWidth;

	if (x == -32768)
		x = fastGlyph->bkLeft;

	if (y == -32768)
		y = fastGlyph->bkTop;

	if ((fastGlyph->cbData > 1) && (fastGlyph->glyphData.aj))
	{
		/* got option font that needs to go into cache */
		rdpGlyph* glyph;
		const GLYPH_DATA_V2* glyphData = &fastGlyph->glyphData;

		glyph = Glyph_Alloc(context, glyphData->x, glyphData->y, glyphData->cx, glyphData->cy,
		                    glyphData->cb, glyphData->aj);

		if (!glyph)
			return FALSE;

		if (!glyph_cache_put(cache->glyph, fastGlyph->cacheId, fastGlyph->data[0], glyph))
		{
			glyph->Free(context, glyph);
			return FALSE;
		}
	}

	text_data[0] = fastGlyph->data[0];
	text_data[1] = 0;

	if (fastGlyph->bkRight > fastGlyph->bkLeft)
		bkWidth = fastGlyph->bkRight - fastGlyph->bkLeft + 1;

	if (fastGlyph->bkBottom > fastGlyph->bkTop)
		bkHeight = fastGlyph->bkBottom - fastGlyph->bkTop + 1;

	if (opRight > opLeft)
		opWidth = opRight - opLeft + 1;

	if (opBottom > opTop)
		opHeight = opBottom - opTop + 1;

	return update_process_glyph_fragments(
	    context, text_data, sizeof(text_data), fastGlyph->cacheId, fastGlyph->ulCharInc,
	    fastGlyph->flAccel, fastGlyph->backColor, fastGlyph->foreColor, x, y, fastGlyph->bkLeft,
	    fastGlyph->bkTop, bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);
}
",0,8519
wolfSSL/wolfssl,df1b7f34f173cfc2968ce12e8fcd2fd8bcc61a59,"int ProcessReply(WOLFSSL* ssl)
{
    int    ret = 0, type, readSz;
    int    atomicUser = 0;
    word32 startIdx = 0;
#if defined(WOLFSSL_DTLS)
    int    used;
#endif

#ifdef ATOMIC_USER
    if (ssl->ctx->DecryptVerifyCb)
        atomicUser = 1;
#endif

    if (ssl->error != 0 && ssl->error != WANT_READ && ssl->error != WANT_WRITE
    #ifdef WOLFSSL_ASYNC_CRYPT
        && ssl->error != WC_PENDING_E
    #endif
    #ifdef WOLFSSL_NONBLOCK_OCSP
        && ssl->error != OCSP_WANT_READ
    #endif
    ) {
        WOLFSSL_MSG('ProcessReply retry in error state, not allowed');
        return ssl->error;
    }

    for (;;) {
        switch (ssl->options.processReply) {

        /* in the WOLFSSL_SERVER case, get the first byte for detecting
         * old client hello */
        case doProcessInit:

            readSz = RECORD_HEADER_SZ;

        #ifdef WOLFSSL_DTLS
            if (ssl->options.dtls)
                readSz = DTLS_RECORD_HEADER_SZ;
        #endif

            /* get header or return error */
            if (!ssl->options.dtls) {
                if ((ret = GetInputData(ssl, readSz)) < 0)
                    return ret;
            } else {
            #ifdef WOLFSSL_DTLS
                /* read ahead may already have header */
                used = ssl->buffers.inputBuffer.length -
                       ssl->buffers.inputBuffer.idx;
                if (used < readSz) {
                    if ((ret = GetInputData(ssl, readSz)) < 0)
                        return ret;
                }
            #endif
            }

#ifdef OLD_HELLO_ALLOWED

            /* see if sending SSLv2 client hello */
            if ( ssl->options.side == WOLFSSL_SERVER_END &&
                 ssl->options.clientState == NULL_STATE &&
                 ssl->buffers.inputBuffer.buffer[ssl->buffers.inputBuffer.idx]
                         != handshake) {
                byte b0, b1;

                ssl->options.processReply = runProcessOldClientHello;

                /* sanity checks before getting size at front */
                if (ssl->buffers.inputBuffer.buffer[
                          ssl->buffers.inputBuffer.idx + OPAQUE16_LEN] != OLD_HELLO_ID) {
                    WOLFSSL_MSG('Not a valid old client hello');
                    return PARSE_ERROR;
                }

                if (ssl->buffers.inputBuffer.buffer[
                          ssl->buffers.inputBuffer.idx + OPAQUE24_LEN] != SSLv3_MAJOR &&
                    ssl->buffers.inputBuffer.buffer[
                          ssl->buffers.inputBuffer.idx + OPAQUE24_LEN] != DTLS_MAJOR) {
                    WOLFSSL_MSG('Not a valid version in old client hello');
                    return PARSE_ERROR;
                }

                /* how many bytes need ProcessOldClientHello */
                b0 =
                ssl->buffers.inputBuffer.buffer[ssl->buffers.inputBuffer.idx++];
                b1 =
                ssl->buffers.inputBuffer.buffer[ssl->buffers.inputBuffer.idx++];
                ssl->curSize = (word16)(((b0 & 0x7f) << 8) | b1);
            }
            else {
                ssl->options.processReply = getRecordLayerHeader;
                continue;
            }
            FALL_THROUGH;

        /* in the WOLFSSL_SERVER case, run the old client hello */
        case runProcessOldClientHello:

            /* get sz bytes or return error */
            if (!ssl->options.dtls) {
                if ((ret = GetInputData(ssl, ssl->curSize)) < 0)
                    return ret;
            } else {
            #ifdef WOLFSSL_DTLS
                /* read ahead may already have */
                used = ssl->buffers.inputBuffer.length -
                       ssl->buffers.inputBuffer.idx;
                if (used < ssl->curSize)
                    if ((ret = GetInputData(ssl, ssl->curSize)) < 0)
                        return ret;
            #endif  /* WOLFSSL_DTLS */
            }

            ret = ProcessOldClientHello(ssl, ssl->buffers.inputBuffer.buffer,
                                        &ssl->buffers.inputBuffer.idx,
                                        ssl->buffers.inputBuffer.length -
                                        ssl->buffers.inputBuffer.idx,
                                        ssl->curSize);
            if (ret < 0)
                return ret;

            else if (ssl->buffers.inputBuffer.idx ==
                     ssl->buffers.inputBuffer.length) {
                ssl->options.processReply = doProcessInit;
                return 0;
            }

#endif  /* OLD_HELLO_ALLOWED */
            FALL_THROUGH;

        /* get the record layer header */
        case getRecordLayerHeader:

            ret = GetRecordHeader(ssl, ssl->buffers.inputBuffer.buffer,
                                       &ssl->buffers.inputBuffer.idx,
                                       &ssl->curRL, &ssl->curSize);
#ifdef WOLFSSL_DTLS
            if (ssl->options.dtls && ret == SEQUENCE_ERROR) {
                WOLFSSL_MSG('Silently dropping out of order DTLS message');
                ssl->options.processReply = doProcessInit;
                ssl->buffers.inputBuffer.length = 0;
                ssl->buffers.inputBuffer.idx = 0;
#ifdef WOLFSSL_DTLS_DROP_STATS
                ssl->replayDropCount++;
#endif /* WOLFSSL_DTLS_DROP_STATS */

                if (IsDtlsNotSctpMode(ssl) && ssl->options.dtlsHsRetain) {
                    ret = DtlsMsgPoolSend(ssl, 0);
                    if (ret != 0)
                        return ret;
                }

                continue;
            }
#endif
            if (ret != 0)
                return ret;

#ifdef WOLFSSL_TLS13
            if (IsAtLeastTLSv1_3(ssl->version) && IsEncryptionOn(ssl, 0) &&
                                        ssl->curRL.type != application_data &&
                                        ssl->curRL.type != change_cipher_spec) {
                SendAlert(ssl, alert_fatal, unexpected_message);
                return PARSE_ERROR;
            }
#endif

            ssl->options.processReply = getData;
            FALL_THROUGH;

        /* retrieve record layer data */
        case getData:

            /* get sz bytes or return error */
            if (!ssl->options.dtls) {
                if ((ret = GetInputData(ssl, ssl->curSize)) < 0) {
#ifdef WOLFSSL_EXTRA_ALERTS
                    if (ret != WANT_READ)
                        SendAlert(ssl, alert_fatal, bad_record_mac);
#endif
                    return ret;
                }
            }
            else {
#ifdef WOLFSSL_DTLS
                /* read ahead may already have */
                used = ssl->buffers.inputBuffer.length -
                       ssl->buffers.inputBuffer.idx;
                if (used < ssl->curSize)
                    if ((ret = GetInputData(ssl, ssl->curSize)) < 0)
                        return ret;
#endif
            }

            if (IsEncryptionOn(ssl, 0)) {
                int tooLong = 0;

#ifdef WOLFSSL_TLS13
                if (IsAtLeastTLSv1_3(ssl->version)) {
                    tooLong  = ssl->curSize > MAX_TLS13_ENC_SZ;
                    tooLong |= ssl->curSize - ssl->specs.aead_mac_size >
                                                             MAX_TLS13_PLAIN_SZ;
                }
#endif
#ifdef WOLFSSL_EXTRA_ALERTS
                if (!IsAtLeastTLSv1_3(ssl->version))
                    tooLong = ssl->curSize > MAX_TLS_CIPHER_SZ;
#endif
                if (tooLong) {
                    WOLFSSL_MSG('Encrypted data too long');
#if defined(WOLFSSL_TLS13) || defined(WOLFSSL_EXTRA_ALERTS)
                    SendAlert(ssl, alert_fatal, record_overflow);
#endif
                    return BUFFER_ERROR;
                }
            }
            ssl->keys.padSz = 0;

            ssl->options.processReply = verifyEncryptedMessage;
            startIdx = ssl->buffers.inputBuffer.idx;  /* in case > 1 msg per */
            FALL_THROUGH;

        /* verify digest of encrypted message */
        case verifyEncryptedMessage:
#if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
                                   !atomicUser && ssl->options.startedETMRead) {
                ret = VerifyMacEnc(ssl, ssl->buffers.inputBuffer.buffer +
                                   ssl->buffers.inputBuffer.idx,
                                   ssl->curSize, ssl->curRL.type);
            #ifdef WOLFSSL_ASYNC_CRYPT
                if (ret == WC_PENDING_E)
                    return ret;
            #endif
                if (ret < 0) {
                    WOLFSSL_MSG('VerifyMacEnc failed');
                    WOLFSSL_ERROR(ret);
                #ifdef WOLFSSL_DTLS
                    /* If in DTLS mode, if the decrypt fails for any
                     * reason, pretend the datagram never happened. */
                    if (ssl->options.dtls) {
                        ssl->options.processReply = doProcessInit;
                        ssl->buffers.inputBuffer.idx =
                                        ssl->buffers.inputBuffer.length;
                        #ifdef WOLFSSL_DTLS_DROP_STATS
                            ssl->macDropCount++;
                        #endif /* WOLFSSL_DTLS_DROP_STATS */
                    }
                #endif /* WOLFSSL_DTLS */
                #ifdef WOLFSSL_EXTRA_ALERTS
                    if (!ssl->options.dtls)
                        SendAlert(ssl, alert_fatal, bad_record_mac);
                #endif
                    return DECRYPT_ERROR;
                }
                ssl->keys.encryptSz    = ssl->curSize;
            }
#endif
            ssl->options.processReply = decryptMessage;
            FALL_THROUGH;

        /* decrypt message */
        case decryptMessage:

#if !defined(WOLFSSL_TLS13) || defined(WOLFSSL_TLS13_DRAFT_18)
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0)
#else
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
                                        (!IsAtLeastTLSv1_3(ssl->version) ||
                                         ssl->curRL.type != change_cipher_spec))
#endif
            {
                bufferStatic* in = &ssl->buffers.inputBuffer;

                ret = SanityCheckCipherText(ssl, ssl->curSize);
                if (ret < 0) {
                #ifdef WOLFSSL_EXTRA_ALERTS
                    SendAlert(ssl, alert_fatal, bad_record_mac);
                #endif
                    return ret;
                }

                if (atomicUser) {
        #ifdef ATOMIC_USER
            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                    if (ssl->options.startedETMRead) {
                        ret = ssl->ctx->VerifyDecryptCb(ssl,
                                     in->buffer + in->idx, in->buffer + in->idx,
                                     ssl->curSize - MacSize(ssl),
                                     ssl->curRL.type, 1, &ssl->keys.padSz,
                                     ssl->DecryptVerifyCtx);
                    }
                    else
            #endif
                    {
                        ret = ssl->ctx->DecryptVerifyCb(ssl,
                                      in->buffer + in->idx,
                                      in->buffer + in->idx,
                                      ssl->curSize, ssl->curRL.type, 1,
                                      &ssl->keys.padSz, ssl->DecryptVerifyCtx);
                    }
        #endif /* ATOMIC_USER */
                }
                else {
                    if (!ssl->options.tls1_3) {
        #ifndef WOLFSSL_NO_TLS12
            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                    if (ssl->options.startedETMRead) {
                        word32 digestSz = MacSize(ssl);
                        ret = Decrypt(ssl,
                                      in->buffer + in->idx,
                                      in->buffer + in->idx,
                                      ssl->curSize - digestSz);
                         ssl->keys.padSz =
                              in->buffer[in->idx + ssl->curSize - digestSz - 1];
                         ssl->keys.padSz += 1;
                         ssl->keys.decryptedCur = 1;
                    }
                    else
            #endif
                    {
                        ret = Decrypt(ssl,
                                      in->buffer + in->idx,
                                      in->buffer + in->idx,
                                      ssl->curSize);
                    }
        #else
                        ret = DECRYPT_ERROR;
        #endif
                    }
                    else
                    {
                #ifdef WOLFSSL_TLS13
                    #if defined(WOLFSSL_TLS13_DRAFT_18) || \
                        defined(WOLFSSL_TLS13_DRAFT_22) || \
                        defined(WOLFSSL_TLS13_DRAFT_23)
                        ret = DecryptTls13(ssl,
                                           in->buffer + in->idx,
                                           in->buffer + in->idx,
                                           ssl->curSize, NULL, 0);
                    #else
                        ret = DecryptTls13(ssl,
                                        in->buffer + in->idx,
                                        in->buffer + in->idx,
                                        ssl->curSize,
                                        (byte*)&ssl->curRL, RECORD_HEADER_SZ);
                    #endif
                #else
                        ret = DECRYPT_ERROR;
                #endif /* WOLFSSL_TLS13 */
                    }
                }

            #ifdef WOLFSSL_ASYNC_CRYPT
                if (ret == WC_PENDING_E)
                    return ret;
            #endif

                if (ret >= 0) {
            #ifndef WOLFSSL_NO_TLS12
                    /* handle success */
                #ifndef WOLFSSL_AEAD_ONLY
                    if (ssl->options.tls1_1 && ssl->specs.cipher_type == block)
                        ssl->buffers.inputBuffer.idx += ssl->specs.block_size;
                #endif
                        /* go past TLSv1.1 IV */
                    if (CipherHasExpIV(ssl))
                        ssl->buffers.inputBuffer.idx += AESGCM_EXP_IV_SZ;
            #endif
                }
                else {
                    WOLFSSL_MSG('Decrypt failed');
                    WOLFSSL_ERROR(ret);
                #ifdef WOLFSSL_EARLY_DATA
                    if (ssl->options.tls1_3) {
                         if (ssl->options.side == WOLFSSL_SERVER_END &&
                                 ssl->earlyData != no_early_data &&
                                 ssl->options.clientState <
                                                     CLIENT_FINISHED_COMPLETE) {
                            ssl->earlyDataSz += ssl->curSize;
                            if (ssl->earlyDataSz <=
                                                  ssl->options.maxEarlyDataSz) {
                                WOLFSSL_MSG('Ignoring EarlyData!');
                                if (ssl->keys.peer_sequence_number_lo-- == 0)
                                    ssl->keys.peer_sequence_number_hi--;
                                ssl->options.processReply = doProcessInit;
                                ssl->buffers.inputBuffer.idx =
                                                ssl->buffers.inputBuffer.length;
                                return 0;
                            }
                            WOLFSSL_MSG('Too much EarlyData!');
                        }
                        SendAlert(ssl, alert_fatal, bad_record_mac);
                    }
                #endif
                #ifdef WOLFSSL_DTLS
                    /* If in DTLS mode, if the decrypt fails for any
                     * reason, pretend the datagram never happened. */
                    if (ssl->options.dtls) {
                        ssl->options.processReply = doProcessInit;
                        ssl->buffers.inputBuffer.idx =
                                        ssl->buffers.inputBuffer.length;
                        #ifdef WOLFSSL_DTLS_DROP_STATS
                            ssl->macDropCount++;
                        #endif /* WOLFSSL_DTLS_DROP_STATS */
                    }
                #endif /* WOLFSSL_DTLS */
                    return DECRYPT_ERROR;
                }
            }

            ssl->options.processReply = verifyMessage;
            FALL_THROUGH;

        /* verify digest of message */
        case verifyMessage:

#if !defined(WOLFSSL_TLS13) || defined(WOLFSSL_TLS13_DRAFT_18)
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0)
#else
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
                                        (!IsAtLeastTLSv1_3(ssl->version) ||
                                         ssl->curRL.type != change_cipher_spec))
#endif
            {
                if (!atomicUser
#if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                                && !ssl->options.startedETMRead
#endif
                    ) {
                    ret = VerifyMac(ssl, ssl->buffers.inputBuffer.buffer +
                                    ssl->buffers.inputBuffer.idx,
                                    ssl->curSize, ssl->curRL.type,
                                    &ssl->keys.padSz);
                #ifdef WOLFSSL_ASYNC_CRYPT
                    if (ret == WC_PENDING_E)
                        return ret;
                #endif
                    if (ret < 0) {
                        WOLFSSL_MSG('VerifyMac failed');
                        WOLFSSL_ERROR(ret);
                    #ifdef WOLFSSL_DTLS
                        /* If in DTLS mode, if the decrypt fails for any
                         * reason, pretend the datagram never happened. */
                        if (ssl->options.dtls) {
                            ssl->options.processReply = doProcessInit;
                            ssl->buffers.inputBuffer.idx =
                                            ssl->buffers.inputBuffer.length;
                            #ifdef WOLFSSL_DTLS_DROP_STATS
                                ssl->macDropCount++;
                            #endif /* WOLFSSL_DTLS_DROP_STATS */
                        }
                    #endif /* WOLFSSL_DTLS */
                    #ifdef WOLFSSL_EXTRA_ALERTS
                        if (!ssl->options.dtls)
                            SendAlert(ssl, alert_fatal, bad_record_mac);
                    #endif
                        return DECRYPT_ERROR;
                    }
                }

                ssl->keys.encryptSz    = ssl->curSize;
                ssl->keys.decryptedCur = 1;
#ifdef WOLFSSL_TLS13
                if (ssl->options.tls1_3) {
                    word16 i = (word16)(ssl->buffers.inputBuffer.length -
                                        ssl->keys.padSz);
                    /* Remove padding from end of plain text. */
                    for (--i; i > ssl->buffers.inputBuffer.idx; i--) {
                        if (ssl->buffers.inputBuffer.buffer[i] != 0)
                            break;
                    }
                    /* Get the real content type from the end of the data. */
                    ssl->curRL.type = ssl->buffers.inputBuffer.buffer[i];
                    ssl->keys.padSz = ssl->buffers.inputBuffer.length - i;
                }
#endif
            }

            ssl->options.processReply = runProcessingOneMessage;
            FALL_THROUGH;

        /* the record layer is here */
        case runProcessingOneMessage:

       #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
            if (IsEncryptionOn(ssl, 0) && ssl->options.startedETMRead) {
                if (ssl->buffers.inputBuffer.length - ssl->keys.padSz -
                                              ssl->buffers.inputBuffer.idx -
                                              MacSize(ssl) > MAX_PLAINTEXT_SZ) {
                    WOLFSSL_MSG('Plaintext too long - Encrypt-Then-MAC');
            #if defined(WOLFSSL_EXTRA_ALERTS)
                    SendAlert(ssl, alert_fatal, record_overflow);
            #endif
                    return BUFFER_ERROR;
                }
            }
            else
       #endif
            if (ssl->buffers.inputBuffer.length - ssl->keys.padSz -
                              ssl->buffers.inputBuffer.idx > MAX_PLAINTEXT_SZ) {
                WOLFSSL_MSG('Plaintext too long');
#if defined(WOLFSSL_TLS13) || defined(WOLFSSL_EXTRA_ALERTS)
                SendAlert(ssl, alert_fatal, record_overflow);
#endif
                return BUFFER_ERROR;
            }

        #ifdef WOLFSSL_DTLS
            if (IsDtlsNotSctpMode(ssl)) {
                DtlsUpdateWindow(ssl);
            }
        #endif /* WOLFSSL_DTLS */

            WOLFSSL_MSG('received record layer msg');

            switch (ssl->curRL.type) {
                case handshake :
                    /* debugging in DoHandShakeMsg */
                    if (ssl->options.dtls) {
#ifdef WOLFSSL_DTLS
                        ret = DoDtlsHandShakeMsg(ssl,
                                            ssl->buffers.inputBuffer.buffer,
                                            &ssl->buffers.inputBuffer.idx,
                                            ssl->buffers.inputBuffer.length);
#endif
                    }
                    else if (!IsAtLeastTLSv1_3(ssl->version)) {
#ifndef WOLFSSL_NO_TLS12
                        ret = DoHandShakeMsg(ssl,
                                            ssl->buffers.inputBuffer.buffer,
                                            &ssl->buffers.inputBuffer.idx,
                                            ssl->buffers.inputBuffer.length);
#else
                        ret = BUFFER_ERROR;
#endif
                    }
                    else {
#ifdef WOLFSSL_TLS13
                        ret = DoTls13HandShakeMsg(ssl,
                                            ssl->buffers.inputBuffer.buffer,
                                            &ssl->buffers.inputBuffer.idx,
                                            ssl->buffers.inputBuffer.length);
    #ifdef WOLFSSL_EARLY_DATA
                        if (ret != 0)
                            return ret;
                        if (ssl->options.side == WOLFSSL_SERVER_END &&
                                ssl->earlyData > early_data_ext &&
                                ssl->options.handShakeState == HANDSHAKE_DONE) {
                            ssl->earlyData = no_early_data;
                            ssl->options.processReply = doProcessInit;
                            return ZERO_RETURN;
                        }
    #endif
#else
                        ret = BUFFER_ERROR;
#endif
                    }
                    if (ret != 0) {
                        WOLFSSL_ERROR(ret);
                        return ret;
                    }
                    break;

                case change_cipher_spec:
                    WOLFSSL_MSG('got CHANGE CIPHER SPEC');
                    #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
                        if (ssl->hsInfoOn)
                            AddPacketName(ssl, 'ChangeCipher');
                        /* add record header back on info */
                        if (ssl->toInfoOn) {
                            AddPacketInfo(ssl, 'ChangeCipher',
                                change_cipher_spec,
                                ssl->buffers.inputBuffer.buffer +
                                ssl->buffers.inputBuffer.idx - RECORD_HEADER_SZ,
                                1 + RECORD_HEADER_SZ, READ_PROTO, ssl->heap);
                            #ifdef WOLFSSL_CALLBACKS
                            AddLateRecordHeader(&ssl->curRL, &ssl->timeoutInfo);
                            #endif
                        }
                    #endif

#ifdef WOLFSSL_TLS13
    #ifdef WOLFSSL_TLS13_DRAFT_18
                    if (IsAtLeastTLSv1_3(ssl->version)) {
                        SendAlert(ssl, alert_fatal, illegal_parameter);
                        return UNKNOWN_RECORD_TYPE;
                    }
    #else
                    if (IsAtLeastTLSv1_3(ssl->version)) {
                        word32 i = ssl->buffers.inputBuffer.idx;
                        if (ssl->options.handShakeState == HANDSHAKE_DONE) {
                            SendAlert(ssl, alert_fatal, unexpected_message);
                            return UNKNOWN_RECORD_TYPE;
                        }
                        if (ssl->curSize != 1 ||
                                      ssl->buffers.inputBuffer.buffer[i] != 1) {
                            SendAlert(ssl, alert_fatal, illegal_parameter);
                            return UNKNOWN_RECORD_TYPE;
                        }
                        ssl->buffers.inputBuffer.idx++;
                        break;
                    }
    #endif
#endif

#ifndef WOLFSSL_NO_TLS12
                    ret = SanityCheckMsgReceived(ssl, change_cipher_hs);
                    if (ret != 0) {
                        if (!ssl->options.dtls) {
                            return ret;
                        }
                        else {
                        #ifdef WOLFSSL_DTLS
                        /* Check for duplicate CCS message in DTLS mode.
                         * DTLS allows for duplicate messages, and it should be
                         * skipped. Also skip if out of order. */
                            if (ret != DUPLICATE_MSG_E && ret != OUT_OF_ORDER_E)
                                return ret;

                            if (IsDtlsNotSctpMode(ssl)) {
                                ret = DtlsMsgPoolSend(ssl, 1);
                                if (ret != 0)
                                    return ret;
                            }

                            if (ssl->curSize != 1) {
                                WOLFSSL_MSG('Malicious or corrupted'
                                            ' duplicate ChangeCipher msg');
                                return LENGTH_ERROR;
                            }
                            ssl->buffers.inputBuffer.idx++;
                            break;
                        #endif /* WOLFSSL_DTLS */
                        }
                    }

                    if (IsEncryptionOn(ssl, 0) && ssl->options.handShakeDone) {
                        ssl->buffers.inputBuffer.idx += ssl->keys.padSz;
                        ssl->curSize -= (word16) ssl->buffers.inputBuffer.idx;
            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                        if (ssl->options.startedETMRead) {
                            word32 digestSz = MacSize(ssl);
                            ssl->buffers.inputBuffer.idx += digestSz;
                            ssl->curSize -= digestSz;
                        }
            #endif
                    }

                    if (ssl->curSize != 1) {
                        WOLFSSL_MSG('Malicious or corrupted ChangeCipher msg');
                        return LENGTH_ERROR;
                    }

                    ssl->buffers.inputBuffer.idx++;
                    ssl->keys.encryptionOn = 1;

                    /* setup decrypt keys for following messages */
                    /* XXX This might not be what we want to do when
                     * receiving a CCS with multicast. We update the
                     * key when the application updates them. */
                    if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)
                        return ret;

            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                    ssl->options.startedETMRead = ssl->options.encThenMac;
            #endif

                    #ifdef WOLFSSL_DTLS
                        if (ssl->options.dtls) {
                            WOLFSSL_DTLS_PEERSEQ* peerSeq = ssl->keys.peerSeq;
#ifdef WOLFSSL_MULTICAST
                            if (ssl->options.haveMcast) {
                                peerSeq += ssl->keys.curPeerId;
                                peerSeq->highwaterMark = UpdateHighwaterMark(0,
                                        ssl->ctx->mcastFirstSeq,
                                        ssl->ctx->mcastSecondSeq,
                                        ssl->ctx->mcastMaxSeq);
                            }
#endif
                            peerSeq->nextEpoch++;
                            peerSeq->prevSeq_lo = peerSeq->nextSeq_lo;
                            peerSeq->prevSeq_hi = peerSeq->nextSeq_hi;
                            peerSeq->nextSeq_lo = 0;
                            peerSeq->nextSeq_hi = 0;
                            XMEMCPY(peerSeq->prevWindow, peerSeq->window,
                                    DTLS_SEQ_SZ);
                            XMEMSET(peerSeq->window, 0, DTLS_SEQ_SZ);
                        }
                    #endif

                    #ifdef HAVE_LIBZ
                        if (ssl->options.usingCompression)
                            if ( (ret = InitStreams(ssl)) != 0)
                                return ret;
                    #endif
                    ret = BuildFinished(ssl, &ssl->hsHashes->verifyHashes,
                                       ssl->options.side == WOLFSSL_CLIENT_END ?
                                       server : client);
                    if (ret != 0)
                        return ret;
#endif /* !WOLFSSL_NO_TLS12 */
                    break;

                case application_data:
                    WOLFSSL_MSG('got app DATA');
                    #ifdef WOLFSSL_DTLS
                        if (ssl->options.dtls && ssl->options.dtlsHsRetain) {
                            FreeHandshakeResources(ssl);
                            ssl->options.dtlsHsRetain = 0;
                        }
                    #endif
                    #ifdef WOLFSSL_TLS13
                        if (ssl->keys.keyUpdateRespond) {
                            WOLFSSL_MSG('No KeyUpdate from peer seen');
                            return SANITY_MSG_E;
                        }
                    #endif
                    if ((ret = DoApplicationData(ssl,
                                                ssl->buffers.inputBuffer.buffer,
                                                &ssl->buffers.inputBuffer.idx))
                                                                         != 0) {
                        WOLFSSL_ERROR(ret);
                        return ret;
                    }
                    break;

                case alert:
                    WOLFSSL_MSG('got ALERT!');
                    ret = DoAlert(ssl, ssl->buffers.inputBuffer.buffer,
                                  &ssl->buffers.inputBuffer.idx, &type,
                                   ssl->buffers.inputBuffer.length);
                    if (ret == alert_fatal)
                        return FATAL_ERROR;
                    else if (ret < 0)
                        return ret;

                    /* catch warnings that are handled as errors */
                    if (type == close_notify)
                        return ssl->error = ZERO_RETURN;

                    if (type == decrypt_error)
                        return FATAL_ERROR;
                    break;

                default:
                    WOLFSSL_ERROR(UNKNOWN_RECORD_TYPE);
                    return UNKNOWN_RECORD_TYPE;
            }

            ssl->options.processReply = doProcessInit;

            /* input exhausted? */
            if (ssl->buffers.inputBuffer.idx >= ssl->buffers.inputBuffer.length)
                return 0;

            /* more messages per record */
            else if ((ssl->buffers.inputBuffer.idx - startIdx) < ssl->curSize) {
                WOLFSSL_MSG('More messages in record');

                ssl->options.processReply = runProcessingOneMessage;

                if (IsEncryptionOn(ssl, 0)) {
                    WOLFSSL_MSG('Bundled encrypted messages, remove middle pad');
            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                    if (ssl->options.startedETMRead) {
                        word32 digestSz = MacSize(ssl);
                        if (ssl->buffers.inputBuffer.idx >=
                                                   ssl->keys.padSz + digestSz) {
                            ssl->buffers.inputBuffer.idx -=
                                                     ssl->keys.padSz + digestSz;
                        }
                        else {
                            WOLFSSL_MSG('\tmiddle padding error');
                            return FATAL_ERROR;
                        }
                    }
                    else
             #endif
                    {
                        if (ssl->buffers.inputBuffer.idx >= ssl->keys.padSz) {
                            ssl->buffers.inputBuffer.idx -= ssl->keys.padSz;
                        }
                        else {
                            WOLFSSL_MSG('\tmiddle padding error');
                            return FATAL_ERROR;
                        }
                    }
                }

                continue;
            }
            /* more records */
            else {
                WOLFSSL_MSG('More records in input');
                ssl->options.processReply = doProcessInit;
                continue;
            }

        default:
            WOLFSSL_MSG('Bad process input state, programming error');
            return INPUT_CASE_ERROR;
        }
    }
}
",1,8520
wolfSSL/wolfssl,df1b7f34f173cfc2968ce12e8fcd2fd8bcc61a59,"void InitSuitesHashSigAlgo(Suites* suites, int haveECDSAsig, int haveRSAsig,
                           int haveAnon, int tls1_2, int keySz)
{
    word16 idx = 0;

    (void)tls1_2;
    (void)keySz;

#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    if (haveECDSAsig) {
#ifdef HAVE_ECC
    #ifdef WOLFSSL_SHA512
        AddSuiteHashSigAlgo(suites, sha512_mac, ecc_dsa_sa_algo, keySz, &idx);
    #endif
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(suites, sha384_mac, ecc_dsa_sa_algo, keySz, &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(suites, sha256_mac, ecc_dsa_sa_algo, keySz, &idx);
    #endif
    #if !defined(NO_SHA) && (!defined(NO_OLD_TLS) || \
                                            defined(WOLFSSL_ALLOW_TLS_SHA1))
        AddSuiteHashSigAlgo(suites, sha_mac, ecc_dsa_sa_algo, keySz, &idx);
    #endif
#endif
    #ifdef HAVE_ED25519
        AddSuiteHashSigAlgo(suites, ED25519_SA_MAJOR, ED25519_SA_MINOR, keySz,
                                                                          &idx);
    #endif
    #ifdef HAVE_ED448
        AddSuiteHashSigAlgo(suites, ED448_SA_MAJOR, ED448_SA_MINOR, keySz,
                                                                          &idx);
    #endif
    }
#endif /* HAVE_ECC || HAVE_ED25519 || defined(HAVE_ED448 */

    if (haveRSAsig) {
    #ifdef WC_RSA_PSS
        if (tls1_2) {
        #ifdef WOLFSSL_SHA512
            AddSuiteHashSigAlgo(suites, sha512_mac, rsa_pss_sa_algo, keySz,
                                                                          &idx);
        #endif
        #ifdef WOLFSSL_SHA384
            AddSuiteHashSigAlgo(suites, sha384_mac, rsa_pss_sa_algo, keySz,
                                                                          &idx);
        #endif
        #ifndef NO_SHA256
            AddSuiteHashSigAlgo(suites, sha256_mac, rsa_pss_sa_algo, keySz,
                                                                          &idx);
        #endif
        }
    #endif
    #ifdef WOLFSSL_SHA512
        AddSuiteHashSigAlgo(suites, sha512_mac, rsa_sa_algo, keySz, &idx);
    #endif
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(suites, sha384_mac, rsa_sa_algo, keySz, &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(suites, sha256_mac, rsa_sa_algo, keySz, &idx);
    #endif
    #ifdef WOLFSSL_SHA224
        AddSuiteHashSigAlgo(suites, sha224_mac, rsa_sa_algo, keySz, &idx);
    #endif
    #if !defined(NO_SHA) && (!defined(NO_OLD_TLS) || \
                                            defined(WOLFSSL_ALLOW_TLS_SHA1))
        AddSuiteHashSigAlgo(suites, sha_mac, rsa_sa_algo, keySz, &idx);
    #endif
    }

#ifdef HAVE_ANON
    if (haveAnon) {
        AddSuiteHashSigAlgo(suites, sha_mac, anonymous_sa_algo, keySz, &idx);
    }
#endif

    (void)haveAnon;
    (void)haveECDSAsig;
    suites->hashSigAlgoSz = idx;
}
",0,8521
torvalds/linux,99e3a236dd43d06c65af0a2ef9cb44306aef6e02,"static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)
{
	bool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;
	u32 chunk_size = mr->chunk_size, headroom = mr->headroom;
	unsigned int chunks, chunks_per_page;
	u64 addr = mr->addr, size = mr->len;
	int size_chk, err;

	if (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {
		/* Strictly speaking we could support this, if:
		 * - huge pages, or*
		 * - using an IOMMU, or
		 * - making sure the memory area is consecutive
		 * but for now, we simply say 'computer says no'.
		 */
		return -EINVAL;
	}

	if (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |
			XDP_UMEM_USES_NEED_WAKEUP))
		return -EINVAL;

	if (!unaligned_chunks && !is_power_of_2(chunk_size))
		return -EINVAL;

	if (!PAGE_ALIGNED(addr)) {
		/* Memory area has to be page size aligned. For
		 * simplicity, this might change.
		 */
		return -EINVAL;
	}

	if ((addr + size) < addr)
		return -EINVAL;

	chunks = (unsigned int)div_u64(size, chunk_size);
	if (chunks == 0)
		return -EINVAL;

	if (!unaligned_chunks) {
		chunks_per_page = PAGE_SIZE / chunk_size;
		if (chunks < chunks_per_page || chunks % chunks_per_page)
			return -EINVAL;
	}

	size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM;
	if (size_chk < 0)
		return -EINVAL;

	umem->address = (unsigned long)addr;
	umem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK
					    : ~((u64)chunk_size - 1);
	umem->size = size;
	umem->headroom = headroom;
	umem->chunk_size_nohr = chunk_size - headroom;
	umem->npgs = size / PAGE_SIZE;
	umem->pgs = NULL;
	umem->user = NULL;
	umem->flags = mr->flags;
	INIT_LIST_HEAD(&umem->xsk_list);
	spin_lock_init(&umem->xsk_list_lock);

	refcount_set(&umem->users, 1);

	err = xdp_umem_account_pages(umem);
	if (err)
		return err;

	err = xdp_umem_pin_pages(umem);
	if (err)
		goto out_account;

	umem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),
			       GFP_KERNEL_ACCOUNT);
	if (!umem->pages) {
		err = -ENOMEM;
		goto out_pin;
	}

	err = xdp_umem_map_pages(umem);
	if (!err)
		return 0;

	kvfree(umem->pages);

out_pin:
	xdp_umem_unpin_pages(umem);
out_account:
	xdp_umem_unaccount_pages(umem);
	return err;
}
",1,8522
torvalds/linux,99e3a236dd43d06c65af0a2ef9cb44306aef6e02,"void xdp_put_umem(struct xdp_umem *umem)
{
	if (!umem)
		return;

	if (refcount_dec_and_test(&umem->users)) {
		INIT_WORK(&umem->work, xdp_umem_release_deferred);
		schedule_work(&umem->work);
	}
}
",0,8523
meetecho/janus-gateway,f46f27fb129fd1b3744830b4fc6e75ab78794636,"int janus_process_incoming_request(janus_request *request) {
	int ret = -1;
	if(request == NULL) {
		JANUS_LOG(LOG_ERR, 'Missing request or payload to process, giving up...\n');
		return ret;
	}
	int error_code = 0;
	char error_cause[100];
	json_t *root = request->message;
	/* Ok, let's start with the ids */
	guint64 session_id = 0, handle_id = 0;
	json_t *s = json_object_get(root, 'session_id');
	if(s && json_is_integer(s))
		session_id = json_integer_value(s);
	json_t *h = json_object_get(root, 'handle_id');
	if(h && json_is_integer(h))
		handle_id = json_integer_value(h);

	janus_session *session = NULL;
	janus_ice_handle *handle = NULL;

	/* Get transaction and message request */
	JANUS_VALIDATE_JSON_OBJECT(root, incoming_request_parameters,
		error_code, error_cause, FALSE,
		JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
	if(error_code != 0) {
		ret = janus_process_error_string(request, session_id, NULL, error_code, error_cause);
		goto jsondone;
	}
	json_t *transaction = json_object_get(root, 'transaction');
	const gchar *transaction_text = json_string_value(transaction);
	json_t *message = json_object_get(root, 'janus');
	const gchar *message_text = json_string_value(message);

	if(session_id == 0 && handle_id == 0) {
		/* Can only be a 'Create new session', a 'Get info' or a 'Ping/Pong' request */
		if(!strcasecmp(message_text, 'info')) {
			ret = janus_process_success(request, janus_info(transaction_text));
			goto jsondone;
		}
		if(!strcasecmp(message_text, 'ping')) {
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('pong', 0, transaction_text);
			ret = janus_process_success(request, reply);
			goto jsondone;
		}
		if(strcasecmp(message_text, 'create')) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		/* Make sure we're accepting new sessions */
		if(!accept_new_sessions) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_NOT_ACCEPTING_SESSIONS, NULL);
			goto jsondone;
		}
		/* Any secret/token to check? */
		ret = janus_request_check_secret(request, session_id, transaction_text);
		if(ret != 0) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);
			goto jsondone;
		}
		session_id = 0;
		json_t *id = json_object_get(root, 'id');
		if(id != NULL) {
			/* The application provided the session ID to use */
			session_id = json_integer_value(id);
			if(session_id > 0 && (session = janus_session_find(session_id)) != NULL) {
				/* Session ID already taken */
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_CONFLICT, 'Session ID already in use');
				goto jsondone;
			}
		}
		/* Handle it */
		session = janus_session_create(session_id);
		if(session == NULL) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, 'Memory error');
			goto jsondone;
		}
		session_id = session->session_id;
		/* We increase the counter as this request is using the session */
		janus_refcount_increase(&session->ref);
		/* Take note of the request source that originated this session (HTTP, WebSockets, RabbitMQ?) */
		session->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);
		/* Notify the source that a new session has been created */
		request->transport->session_created(request->instance, session->session_id);
		/* Notify event handlers */
		if(janus_events_is_enabled()) {
			/* Session created, add info on the transport that originated it */
			json_t *transport = json_object();
			json_object_set_new(transport, 'transport', json_string(session->source->transport->get_package()));
			char id[32];
			memset(id, 0, sizeof(id));
			g_snprintf(id, sizeof(id), '%p', session->source->instance);
			json_object_set_new(transport, 'id', json_string(id));
			janus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,
				session_id, 'created', transport);
		}
		/* Prepare JSON reply */
		json_t *reply = janus_create_message('success', 0, transaction_text);
		json_t *data = json_object();
		json_object_set_new(data, 'id', json_integer(session_id));
		json_object_set_new(reply, 'data', data);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
		goto jsondone;
	}
	if(session_id < 1) {
		JANUS_LOG(LOG_ERR, 'Invalid session\n');
		ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);
		goto jsondone;
	}
	if(h && handle_id < 1) {
		JANUS_LOG(LOG_ERR, 'Invalid handle\n');
		ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);
		goto jsondone;
	}

	/* Go on with the processing */
	ret = janus_request_check_secret(request, session_id, transaction_text);
	if(ret != 0) {
		ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);
		goto jsondone;
	}

	/* If we got here, make sure we have a session (and/or a handle) */
	session = janus_session_find(session_id);
	if(!session) {
		JANUS_LOG(LOG_ERR, 'Couldn't find any session %'SCNu64'...\n', session_id);
		ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, 'No such session %'SCNu64'', session_id);
		goto jsondone;
	}
	/* Update the last activity timer */
	session->last_activity = janus_get_monotonic_time();
	handle = NULL;
	if(handle_id > 0) {
		handle = janus_session_handles_find(session, handle_id);
		if(!handle) {
			JANUS_LOG(LOG_ERR, 'Couldn't find any handle %'SCNu64' in session %'SCNu64'...\n', handle_id, session_id);
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_HANDLE_NOT_FOUND, 'No such handle %'SCNu64' in session %'SCNu64'', handle_id, session_id);
			goto jsondone;
		}
	}

	/* What is this? */
	if(!strcasecmp(message_text, 'keepalive')) {
		/* Just a keep-alive message, reply with an ack */
		JANUS_LOG(LOG_VERB, 'Got a keep-alive on session %'SCNu64'\n', session_id);
		json_t *reply = janus_create_message('ack', session_id, transaction_text);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
	} else if(!strcasecmp(message_text, 'attach')) {
		if(handle != NULL) {
			/* Attach is a session-level command */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		JANUS_VALIDATE_JSON_OBJECT(root, attach_parameters,
			error_code, error_cause, FALSE,
			JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
		if(error_code != 0) {
			ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
			goto jsondone;
		}
		json_t *plugin = json_object_get(root, 'plugin');
		const gchar *plugin_text = json_string_value(plugin);
		janus_plugin *plugin_t = janus_plugin_find(plugin_text);
		if(plugin_t == NULL) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, 'No such plugin '%s'', plugin_text);
			goto jsondone;
		}
		/* If the auth token mechanism is enabled, we should check if this token can access this plugin */
		const char *token_value = NULL;
		if(janus_auth_is_enabled()) {
			json_t *token = json_object_get(root, 'token');
			if(token != NULL) {
				token_value = json_string_value(token);
				if(token_value && !janus_auth_check_plugin(token_value, plugin_t)) {
					JANUS_LOG(LOG_ERR, 'Token '%s' can't access plugin '%s'\n', token_value, plugin_text);
					ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED_PLUGIN, 'Provided token can't access plugin '%s'', plugin_text);
					goto jsondone;
				}
			}
		}
		json_t *opaque = json_object_get(root, 'opaque_id');
		const char *opaque_id = opaque ? json_string_value(opaque) : NULL;
		/* Create handle */
		handle = janus_ice_handle_create(session, opaque_id, token_value);
		if(handle == NULL) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, 'Memory error');
			goto jsondone;
		}
		handle_id = handle->handle_id;
		/* We increase the counter as this request is using the handle */
		janus_refcount_increase(&handle->ref);
		/* Attach to the plugin */
		int error = 0;
		if((error = janus_ice_handle_attach_plugin(session, handle, plugin_t)) != 0) {
			/* TODO Make error struct to pass verbose information */
			janus_session_handles_remove(session, handle);
			JANUS_LOG(LOG_ERR, 'Couldn't attach to plugin '%s', error '%d'\n', plugin_text, error);
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_ATTACH, 'Couldn't attach to plugin: error '%d'', error);
			goto jsondone;
		}
		/* Prepare JSON reply */
		json_t *reply = janus_create_message('success', session_id, transaction_text);
		json_t *data = json_object();
		json_object_set_new(data, 'id', json_integer(handle_id));
		json_object_set_new(reply, 'data', data);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
	} else if(!strcasecmp(message_text, 'destroy')) {
		if(handle != NULL) {
			/* Query is a session-level command */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		janus_mutex_lock(&sessions_mutex);
		g_hash_table_remove(sessions, &session->session_id);
		janus_mutex_unlock(&sessions_mutex);
		/* Notify the source that the session has been destroyed */
		janus_request *source = janus_session_get_request(session);
		if(source && source->transport)
			source->transport->session_over(source->instance, session->session_id, FALSE, FALSE);
		janus_request_unref(source);

		/* Schedule the session for deletion */
		janus_session_destroy(session);

		/* Prepare JSON reply */
		json_t *reply = janus_create_message('success', session_id, transaction_text);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
		/* Notify event handlers as well */
		if(janus_events_is_enabled())
			janus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,
				session_id, 'destroyed', NULL);
	} else if(!strcasecmp(message_text, 'detach')) {
		if(handle == NULL) {
			/* Query is an handle-level command */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		if(handle->app == NULL || handle->app_handle == NULL) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, 'No plugin to detach from');
			goto jsondone;
		}
		int error = janus_session_handles_remove(session, handle);
		if(error != 0) {
			/* TODO Make error struct to pass verbose information */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, 'Couldn't detach from plugin: error '%d'', error);
			/* TODO Delete handle instance */
			goto jsondone;
		}
		/* Prepare JSON reply */
		json_t *reply = janus_create_message('success', session_id, transaction_text);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
	} else if(!strcasecmp(message_text, 'hangup')) {
		if(handle == NULL) {
			/* Query is an handle-level command */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		if(handle->app == NULL || handle->app_handle == NULL) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, 'No plugin attached');
			goto jsondone;
		}
		janus_ice_webrtc_hangup(handle, 'Janus API');
		/* Prepare JSON reply */
		json_t *reply = janus_create_message('success', session_id, transaction_text);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
	} else if(!strcasecmp(message_text, 'claim')) {
		janus_mutex_lock(&session->mutex);
		if(session->source != NULL) {
			/* If we're claiming from the same transport, ignore */
			if(session->source->instance == request->instance) {
				janus_mutex_unlock(&session->mutex);
				/* Prepare JSON reply */
				json_t *reply = json_object();
				json_object_set_new(reply, 'janus', json_string('success'));
				json_object_set_new(reply, 'session_id', json_integer(session_id));
				json_object_set_new(reply, 'transaction', json_string(transaction_text));
				/* Send the success reply */
				ret = janus_process_success(request, reply);
				goto jsondone;
			}
			/* Notify the old transport that this session is over for them, but has been reclaimed */
			session->source->transport->session_over(session->source->instance, session->session_id, FALSE, TRUE);
			janus_request_destroy(session->source);
			session->source = NULL;
		}
		session->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);
		/* Notify the new transport that it has claimed a session */
		session->source->transport->session_claimed(session->source->instance, session->session_id);
		/* Previous transport may be gone, clear flag */
		g_atomic_int_set(&session->transport_gone, 0);
		janus_mutex_unlock(&session->mutex);
		/* Prepare JSON reply */
		json_t *reply = json_object();
		json_object_set_new(reply, 'janus', json_string('success'));
		json_object_set_new(reply, 'session_id', json_integer(session_id));
		json_object_set_new(reply, 'transaction', json_string(transaction_text));
		/* Send the success reply */
		ret = janus_process_success(request, reply);
	} else if(!strcasecmp(message_text, 'message')) {
		if(handle == NULL) {
			/* Query is an handle-level command */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		if(handle->app == NULL || handle->app_handle == NULL) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, 'No plugin to handle this message');
			goto jsondone;
		}
		janus_plugin *plugin_t = (janus_plugin *)handle->app;
		JANUS_LOG(LOG_VERB, '[%'SCNu64'] There's a message for %s\n', handle->handle_id, plugin_t->get_name());
		JANUS_VALIDATE_JSON_OBJECT(root, body_parameters,
			error_code, error_cause, FALSE,
			JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
		if(error_code != 0) {
			ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
			goto jsondone;
		}
		json_t *body = json_object_get(root, 'body');
		/* Is there an SDP attached? */
		json_t *jsep = json_object_get(root, 'jsep');
		char *jsep_type = NULL;
		char *jsep_sdp = NULL, *jsep_sdp_stripped = NULL;
		gboolean renegotiation = FALSE;
		if(jsep != NULL) {
			if(!json_is_object(jsep)) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON_OBJECT, 'Invalid jsep object');
				goto jsondone;
			}
			JANUS_VALIDATE_JSON_OBJECT_FORMAT('JSEP error: missing mandatory element (%s)',
				'JSEP error: invalid element type (%s should be %s)',
				jsep, jsep_parameters, error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *type = json_object_get(jsep, 'type');
			jsep_type = g_strdup(json_string_value(type));
			type = NULL;
			json_t *jsep_trickle = json_object_get(jsep, 'trickle');
			gboolean do_trickle = jsep_trickle ? json_is_true(jsep_trickle) : TRUE;
			json_t *jsep_e2ee = json_object_get(jsep, 'e2ee');
			gboolean e2ee = jsep_e2ee ? json_is_true(jsep_e2ee) : FALSE;
			/* Are we still cleaning up from a previous media session? */
			if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {
				JANUS_LOG(LOG_VERB, '[%'SCNu64'] Still cleaning up from a previous media session, let's wait a bit...\n', handle->handle_id);
				gint64 waited = 0;
				while(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {
					g_usleep(100000);
					waited += 100000;
					if(waited >= 3*G_USEC_PER_SEC) {
						JANUS_LOG(LOG_VERB, '[%'SCNu64']   -- Waited 3 seconds, that's enough!\n', handle->handle_id);
						ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, 'Still cleaning a previous session');
						goto jsondone;
					}
				}
			}
			/* Check if we're renegotiating (if we have an answer, we did an offer/answer round already) */
			renegotiation = janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);
			/* Check the JSEP type */
			janus_mutex_lock(&handle->mutex);
			int offer = 0;
			if(!strcasecmp(jsep_type, 'offer')) {
				offer = 1;
				janus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
				janus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER);
				janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);
			} else if(!strcasecmp(jsep_type, 'answer')) {
				janus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);
				if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))
					janus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);
				offer = 0;
			} else {
				/* TODO Handle other message types as well */
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_UNKNOWN_TYPE, 'JSEP error: unknown message type '%s'', jsep_type);
				g_free(jsep_type);
				janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
				janus_mutex_unlock(&handle->mutex);
				goto jsondone;
			}
			json_t *sdp = json_object_get(jsep, 'sdp');
			jsep_sdp = (char *)json_string_value(sdp);
			JANUS_LOG(LOG_VERB, '[%'SCNu64'] Remote SDP:\n%s', handle->handle_id, jsep_sdp);
			/* Is this valid SDP? */
			char error_str[512];
			int audio = 0, video = 0, data = 0;
			janus_sdp *parsed_sdp = janus_sdp_preparse(handle, jsep_sdp, error_str, sizeof(error_str), &audio, &video, &data);
			if(parsed_sdp == NULL) {
				/* Invalid SDP */
				ret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, error_str);
				g_free(jsep_type);
				janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
				janus_mutex_unlock(&handle->mutex);
				goto jsondone;
			}
			/* Notify event handlers */
			if(janus_events_is_enabled()) {
				janus_events_notify_handlers(JANUS_EVENT_TYPE_JSEP, JANUS_EVENT_SUBTYPE_NONE,
					session_id, handle_id, handle->opaque_id, 'remote', jsep_type, jsep_sdp);
			}
			/* FIXME We're only handling single audio/video lines for now... */
			JANUS_LOG(LOG_VERB, '[%'SCNu64'] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\n',
			                    handle->handle_id,
			                    audio ? 'has' : 'has NOT',
			                    video ? 'has' : 'has NOT',
			                    data ? 'have' : 'have NOT');
			if(audio > 1) {
				JANUS_LOG(LOG_WARN, '[%'SCNu64'] More than one audio line? only going to negotiate one...\n', handle->handle_id);
			}
			if(video > 1) {
				JANUS_LOG(LOG_WARN, '[%'SCNu64'] More than one video line? only going to negotiate one...\n', handle->handle_id);
			}
			if(data > 1) {
				JANUS_LOG(LOG_WARN, '[%'SCNu64'] More than one data line? only going to negotiate one...\n', handle->handle_id);
			}
#ifndef HAVE_SCTP
			if(data) {
				JANUS_LOG(LOG_WARN, '[%'SCNu64']   -- DataChannels have been negotiated, but support for them has not been compiled...\n', handle->handle_id);
			}
#endif
			/* We behave differently if it's a new session or an update... */
			if(!renegotiation) {
				/* New session */
				if(offer) {
					/* Setup ICE locally (we received an offer) */
					if(janus_ice_setup_local(handle, offer, audio, video, data, do_trickle) < 0) {
						JANUS_LOG(LOG_ERR, 'Error setting ICE locally\n');
						janus_sdp_destroy(parsed_sdp);
						g_free(jsep_type);
						janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
						ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, 'Error setting ICE locally');
						janus_mutex_unlock(&handle->mutex);
						goto jsondone;
					}
				} else {
					/* Make sure we're waiting for an ANSWER in the first place */
					if(!handle->agent) {
						JANUS_LOG(LOG_ERR, 'Unexpected ANSWER (did we offer?)\n');
						janus_sdp_destroy(parsed_sdp);
						g_free(jsep_type);
						janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
						ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, 'Unexpected ANSWER (did we offer?)');
						janus_mutex_unlock(&handle->mutex);
						goto jsondone;
					}
				}
				if(janus_sdp_process(handle, parsed_sdp, FALSE) < 0) {
					JANUS_LOG(LOG_ERR, 'Error processing SDP\n');
					janus_sdp_destroy(parsed_sdp);
					g_free(jsep_type);
					janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
					ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, 'Error processing SDP');
					janus_mutex_unlock(&handle->mutex);
					goto jsondone;
				}
				if(!offer) {
					/* Set remote candidates now (we received an answer) */
					if(do_trickle) {
						janus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);
					} else {
						janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);
					}
					janus_request_ice_handle_answer(handle, audio, video, data, jsep_sdp);
				} else {
					/* Check if the mid RTP extension is being negotiated */
					handle->stream->mid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_MID);
					/* Check if the RTP Stream ID extension is being negotiated */
					handle->stream->rid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_RID);
					handle->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_REPAIRED_RID);
					/* Check if the audio level ID extension is being negotiated */
					handle->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_AUDIO_LEVEL);
					/* Check if the video orientation ID extension is being negotiated */
					handle->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION);
					/* Check if the frame marking ID extension is being negotiated */
					handle->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_FRAME_MARKING);
					/* Check if transport wide CC is supported */
					int transport_wide_cc_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC);
					handle->stream->do_transport_wide_cc = transport_wide_cc_ext_id > 0 ? TRUE : FALSE;
					handle->stream->transport_wide_cc_ext_id = transport_wide_cc_ext_id;
				}
			} else {
				/* FIXME This is a renegotiation: we can currently only handle simple changes in media
				 * direction and ICE restarts: anything more complex than that will result in an error */
				JANUS_LOG(LOG_INFO, '[%'SCNu64'] Negotiation update, checking what changed...\n', handle->handle_id);
				if(janus_sdp_process(handle, parsed_sdp, TRUE) < 0) {
					JANUS_LOG(LOG_ERR, 'Error processing SDP\n');
					janus_sdp_destroy(parsed_sdp);
					g_free(jsep_type);
					janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
					ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, 'Error processing SDP');
					janus_mutex_unlock(&handle->mutex);
					goto jsondone;
				}
				if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART)) {
					JANUS_LOG(LOG_INFO, '[%'SCNu64'] Restarting ICE...\n', handle->handle_id);
					/* Update remote credentials for ICE */
					if(handle->stream) {
						nice_agent_set_remote_credentials(handle->agent, handle->stream->stream_id,
							handle->stream->ruser, handle->stream->rpass);
					}
					/* FIXME We only need to do that for offers: if it's an answer, we did that already */
					if(offer) {
						janus_ice_restart(handle);
					} else {
						janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART);
					}
					/* If we're full-trickling, we'll need to resend the candidates later */
					if(janus_ice_is_full_trickle_enabled()) {
						janus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RESEND_TRICKLES);
					}
				}
#ifdef HAVE_SCTP
				if(!offer) {
					/* Were datachannels just added? */
					if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS)) {
						janus_ice_stream *stream = handle->stream;
						if(stream != NULL && stream->component != NULL
								&& stream->component->dtls != NULL && stream->component->dtls->sctp == NULL) {
							/* Create SCTP association as well */
							JANUS_LOG(LOG_WARN, '[%'SCNu64'] Creating datachannels...\n', handle->handle_id);
							janus_dtls_srtp_create_sctp(stream->component->dtls);
						}
					}
				}
#endif
			}
			char *tmp = handle->remote_sdp;
			handle->remote_sdp = g_strdup(jsep_sdp);
			g_free(tmp);
			janus_mutex_unlock(&handle->mutex);
			/* Anonymize SDP */
			if(janus_sdp_anonymize(parsed_sdp) < 0) {
				/* Invalid SDP */
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, 'JSEP error: invalid SDP');
				janus_sdp_destroy(parsed_sdp);
				g_free(jsep_type);
				janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
				goto jsondone;
			}
			jsep_sdp_stripped = janus_sdp_write(parsed_sdp);
			janus_sdp_destroy(parsed_sdp);
			sdp = NULL;
			if(e2ee)
				janus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_E2EE);
			janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
		}

		/* Make sure the app handle is still valid */
		if(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, 'No plugin to handle this message');
			g_free(jsep_type);
			g_free(jsep_sdp_stripped);
			janus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
			goto jsondone;
		}

		/* Send the message to the plugin (which must eventually free transaction_text and unref the two objects, body and jsep) */
		json_incref(body);
		json_t *body_jsep = NULL;
		if(jsep_sdp_stripped) {
			body_jsep = json_pack('{ssss}', 'type', jsep_type, 'sdp', jsep_sdp_stripped);
			/* Check if simulcasting is enabled */
			if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO)) {
				if(handle->stream && (handle->stream->rid[0] || handle->stream->video_ssrc_peer[1])) {
					json_t *simulcast = json_object();
					/* If we have rids, pass those, otherwise pass the SSRCs */
					if(handle->stream->rid[0]) {
						json_t *rids = json_array();
						json_array_append_new(rids, json_string(handle->stream->rid[0]));
						if(handle->stream->rid[1])
							json_array_append_new(rids, json_string(handle->stream->rid[1]));
						if(handle->stream->rid[2])
							json_array_append_new(rids, json_string(handle->stream->rid[2]));
						json_object_set_new(simulcast, 'rids', rids);
						json_object_set_new(simulcast, 'rid-ext', json_integer(handle->stream->rid_ext_id));
					} else {
						json_t *ssrcs = json_array();
						json_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[0]));
						if(handle->stream->video_ssrc_peer[1])
							json_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[1]));
						if(handle->stream->video_ssrc_peer[2])
							json_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[2]));
						json_object_set_new(simulcast, 'ssrcs', ssrcs);
					}
					if(handle->stream->framemarking_ext_id > 0)
						json_object_set_new(simulcast, 'framemarking-ext', json_integer(handle->stream->framemarking_ext_id));
					json_object_set_new(body_jsep, 'simulcast', simulcast);
				}
			}
			/* Check if this is a renegotiation or update */
			if(renegotiation)
				json_object_set_new(body_jsep, 'update', json_true());
			/* If media is encrypted end-to-end, the plugin may need to know */
			if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_E2EE))
				json_object_set_new(body_jsep, 'e2ee', json_true());
		}
		janus_plugin_result *result = plugin_t->handle_message(handle->app_handle,
			g_strdup((char *)transaction_text), body, body_jsep);
		g_free(jsep_type);
		g_free(jsep_sdp_stripped);
		if(result == NULL) {
			/* Something went horribly wrong! */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, 'Plugin didn't give a result');
			goto jsondone;
		}
		if(result->type == JANUS_PLUGIN_OK) {
			/* The plugin gave a result already (synchronous request/response) */
			if(result->content == NULL || !json_is_object(result->content)) {
				/* Missing content, or not a JSON object */
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,
					result->content == NULL ?
						'Plugin didn't provide any content for this synchronous response' :
						'Plugin returned an invalid JSON response');
				janus_plugin_result_destroy(result);
				goto jsondone;
			}
			/* Reference the content, as destroying the result instance will decref it */
			json_incref(result->content);
			/* Prepare JSON response */
			json_t *reply = janus_create_message('success', session->session_id, transaction_text);
			json_object_set_new(reply, 'sender', json_integer(handle->handle_id));
			if(janus_is_opaqueid_in_api_enabled() && handle->opaque_id != NULL)
				json_object_set_new(reply, 'opaque_id', json_string(handle->opaque_id));
			json_t *plugin_data = json_object();
			json_object_set_new(plugin_data, 'plugin', json_string(plugin_t->get_package()));
			json_object_set_new(plugin_data, 'data', result->content);
			json_object_set_new(reply, 'plugindata', plugin_data);
			/* Send the success reply */
			ret = janus_process_success(request, reply);
		} else if(result->type == JANUS_PLUGIN_OK_WAIT) {
			/* The plugin received the request but didn't process it yet, send an ack (asynchronous notifications may follow) */
			json_t *reply = janus_create_message('ack', session_id, transaction_text);
			if(result->text)
				json_object_set_new(reply, 'hint', json_string(result->text));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
		} else {
			/* Something went horribly wrong! */
			ret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,
				(char *)(result->text ? result->text : 'Plugin returned a severe (unknown) error'));
			janus_plugin_result_destroy(result);
			goto jsondone;
		}
		janus_plugin_result_destroy(result);
	} else if(!strcasecmp(message_text, 'trickle')) {
		if(handle == NULL) {
			/* Trickle is an handle-level command */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		if(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, 'No plugin to handle this trickle candidate');
			goto jsondone;
		}
		json_t *candidate = json_object_get(root, 'candidate');
		json_t *candidates = json_object_get(root, 'candidates');
		if(candidate == NULL && candidates == NULL) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_MISSING_MANDATORY_ELEMENT, 'Missing mandatory element (candidate|candidates)');
			goto jsondone;
		}
		if(candidate != NULL && candidates != NULL) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON, 'Can't have both candidate and candidates');
			goto jsondone;
		}
		if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {
			JANUS_LOG(LOG_ERR, '[%'SCNu64'] Received a trickle, but still cleaning a previous session\n', handle->handle_id);
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, 'Still cleaning a previous session');
			goto jsondone;
		}
		janus_mutex_lock(&handle->mutex);
		if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE)) {
			/* It looks like this peer supports Trickle, after all */
			JANUS_LOG(LOG_VERB, 'Handle %'SCNu64' supports trickle even if it didn't negotiate it...\n', handle->handle_id);
			janus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);
		}
		/* Is there any stream ready? this trickle may get here before the SDP it relates to */
		if(handle->stream == NULL) {
			JANUS_LOG(LOG_WARN, '[%'SCNu64'] No stream, queueing this trickle as it got here before the SDP...\n', handle->handle_id);
			/* Enqueue this trickle candidate(s), we'll process this later */
			janus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);
			handle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);
			/* Send the ack right away, an event will tell the application if the candidate(s) failed */
			goto trickledone;
		}
		/* Is the ICE stack ready already? */
		if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER) ||
				!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER) ||
				!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER)) {
			const char *cause = NULL;
			if(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER))
				cause = 'processing the offer';
			else if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER))
				cause = 'waiting for the answer';
			else if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))
				cause = 'waiting for the offer';
			JANUS_LOG(LOG_VERB, '[%'SCNu64'] Still %s, queueing this trickle to wait until we're done there...\n',
				handle->handle_id, cause);
			/* Enqueue this trickle candidate(s), we'll process this later */
			janus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);
			handle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);
			/* Send the ack right away, an event will tell the application if the candidate(s) failed */
			goto trickledone;
		}
		if(candidate != NULL) {
			/* We got a single candidate */
			int error = 0;
			const char *error_string = NULL;
			if((error = janus_ice_trickle_parse(handle, candidate, &error_string)) != 0) {
				ret = janus_process_error(request, session_id, transaction_text, error, '%s', error_string);
				janus_mutex_unlock(&handle->mutex);
				goto jsondone;
			}
		} else {
			/* We got multiple candidates in an array */
			if(!json_is_array(candidates)) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, 'candidates is not an array');
				janus_mutex_unlock(&handle->mutex);
				goto jsondone;
			}
			JANUS_LOG(LOG_VERB, 'Got multiple candidates (%zu)\n', json_array_size(candidates));
			if(json_array_size(candidates) > 0) {
				/* Handle remote candidates */
				size_t i = 0;
				for(i=0; i<json_array_size(candidates); i++) {
					json_t *c = json_array_get(candidates, i);
					/* FIXME We don't care if any trickle fails to parse */
					janus_ice_trickle_parse(handle, c, NULL);
				}
			}
		}

trickledone:
		janus_mutex_unlock(&handle->mutex);
		/* We reply right away, not to block the web server... */
		json_t *reply = janus_create_message('ack', session_id, transaction_text);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
	} else {
		ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN_REQUEST, 'Unknown request '%s'', message_text);
	}

jsondone:
	/* Done processing */
	if(handle != NULL)
		janus_refcount_decrease(&handle->ref);
	if(session != NULL)
		janus_refcount_decrease(&session->ref);
	return ret;
}
",1,8524
meetecho/janus-gateway,f46f27fb129fd1b3744830b4fc6e75ab78794636,"json_t *janus_plugin_handle_sdp(janus_plugin_session *plugin_session, janus_plugin *plugin, const char *sdp_type, const char *sdp, gboolean restart) {
	if(!janus_plugin_session_is_alive(plugin_session) ||
			plugin == NULL || sdp_type == NULL || sdp == NULL) {
		JANUS_LOG(LOG_ERR, 'Invalid arguments\n');
		return NULL;
	}
	janus_ice_handle *ice_handle = (janus_ice_handle *)plugin_session->gateway_handle;
	//~ if(ice_handle == NULL || janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_READY)) {
	if(ice_handle == NULL) {
		JANUS_LOG(LOG_ERR, 'Invalid ICE handle\n');
		return NULL;
	}
	int offer = 0;
	if(!strcasecmp(sdp_type, 'offer')) {
		/* This is an offer from a plugin */
		offer = 1;
		janus_flags_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER);
		janus_flags_clear(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);
	} else if(!strcasecmp(sdp_type, 'answer')) {
		/* This is an answer from a plugin */
		janus_flags_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);
		if(janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))
			janus_flags_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);
	} else {
		/* TODO Handle other messages */
		JANUS_LOG(LOG_ERR, 'Unknown type '%s'\n', sdp_type);
		return NULL;
	}
	/* Is this valid SDP? */
	char error_str[512];
	int audio = 0, video = 0, data = 0;
	janus_sdp *parsed_sdp = janus_sdp_preparse(ice_handle, sdp, error_str, sizeof(error_str), &audio, &video, &data);
	if(parsed_sdp == NULL) {
		JANUS_LOG(LOG_ERR, '[%'SCNu64'] Couldn't parse SDP... %s\n', ice_handle->handle_id, error_str);
		return NULL;
	}
	gboolean updating = FALSE;
	if(offer) {
		/* We may still not have a local ICE setup */
		JANUS_LOG(LOG_VERB, '[%'SCNu64'] Audio %s been negotiated\n', ice_handle->handle_id, audio ? 'has' : 'has NOT');
		if(audio > 1) {
			JANUS_LOG(LOG_ERR, '[%'SCNu64'] More than one audio line? only going to negotiate one...\n', ice_handle->handle_id);
		}
		JANUS_LOG(LOG_VERB, '[%'SCNu64'] Video %s been negotiated\n', ice_handle->handle_id, video ? 'has' : 'has NOT');
		if(video > 1) {
			JANUS_LOG(LOG_ERR, '[%'SCNu64'] More than one video line? only going to negotiate one...\n', ice_handle->handle_id);
		}
		JANUS_LOG(LOG_VERB, '[%'SCNu64'] SCTP/DataChannels %s been negotiated\n', ice_handle->handle_id, data ? 'have' : 'have NOT');
		if(data > 1) {
			JANUS_LOG(LOG_ERR, '[%'SCNu64'] More than one data line? only going to negotiate one...\n', ice_handle->handle_id);
		}
#ifndef HAVE_SCTP
		if(data) {
			JANUS_LOG(LOG_WARN, '[%'SCNu64']   -- DataChannels have been negotiated, but support for them has not been compiled...\n', ice_handle->handle_id);
		}
#endif
		/* Are we still cleaning up from a previous media session? */
		if(janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {
			JANUS_LOG(LOG_VERB, '[%'SCNu64'] Still cleaning up from a previous media session, let's wait a bit...\n', ice_handle->handle_id);
			gint64 waited = 0;
			while(janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {
				JANUS_LOG(LOG_VERB, '[%'SCNu64'] Still cleaning up from a previous media session, let's wait a bit...\n', ice_handle->handle_id);
				g_usleep(100000);
				waited += 100000;
				if(waited >= 3*G_USEC_PER_SEC) {
					JANUS_LOG(LOG_VERB, '[%'SCNu64']   -- Waited 3 seconds, that's enough!\n', ice_handle->handle_id);
					JANUS_LOG(LOG_ERR, '[%'SCNu64'] Still cleaning a previous session\n', ice_handle->handle_id);
					janus_sdp_destroy(parsed_sdp);
					return NULL;
				}
			}
		}
		if(ice_handle->agent == NULL) {
			/* We still need to configure the WebRTC stuff: negotiate RFC4588 by default */
			janus_flags_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RFC4588_RTX);
			/* Process SDP in order to setup ICE locally (this is going to result in an answer from the browser) */
			janus_mutex_lock(&ice_handle->mutex);
			if(janus_ice_setup_local(ice_handle, 0, audio, video, data, 1) < 0) {
				JANUS_LOG(LOG_ERR, '[%'SCNu64'] Error setting ICE locally\n', ice_handle->handle_id);
				janus_sdp_destroy(parsed_sdp);
				janus_mutex_unlock(&ice_handle->mutex);
				return NULL;
			}
			janus_mutex_unlock(&ice_handle->mutex);
		} else {
			updating = TRUE;
			JANUS_LOG(LOG_INFO, '[%'SCNu64'] Updating existing session\n', ice_handle->handle_id);
			if(offer && ice_handle->stream) {
				/* We might need some new properties set as well */
				janus_ice_stream *stream = ice_handle->stream;
				if(audio) {
					if(!janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_AUDIO)) {
						janus_flags_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_AUDIO);
						stream->audio_ssrc = janus_random_uint32();	/* FIXME Should we look for conflicts? */
						if(stream->audio_rtcp_ctx == NULL) {
							stream->audio_rtcp_ctx = g_malloc0(sizeof(rtcp_context));
							stream->audio_rtcp_ctx->tb = 48000;	/* May change later */
						}
					}
					if(ice_handle->audio_mid == NULL)
						ice_handle->audio_mid = g_strdup('audio');
				}
				if(video) {
					if(!janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO)) {
						janus_flags_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO);
						stream->video_ssrc = janus_random_uint32();	/* FIXME Should we look for conflicts? */
						if(stream->video_rtcp_ctx[0] == NULL) {
							stream->video_rtcp_ctx[0] = g_malloc0(sizeof(rtcp_context));
							stream->video_rtcp_ctx[0]->tb = 90000;	/* May change later */
						}
					}
					if(ice_handle->video_mid == NULL)
						ice_handle->video_mid = g_strdup('video');
				}
				if(data) {
					if(ice_handle->data_mid == NULL)
						ice_handle->data_mid = g_strdup('data');
				}
			}
		}
		/* Make sure we don't send the rid/repaired-rid attributes when offering ourselves */
		int mid_ext_id = 0, transport_wide_cc_ext_id = 0, audiolevel_ext_id = 0, videoorientation_ext_id = 0;
		GList *temp = parsed_sdp->m_lines;
		while(temp) {
			janus_sdp_mline *m = (janus_sdp_mline *)temp->data;
			GList *tempA = m->attributes;
			while(tempA) {
				janus_sdp_attribute *a = (janus_sdp_attribute *)tempA->data;
				if(a->name && a->value) {
					if(strstr(a->value, JANUS_RTP_EXTMAP_MID))
						mid_ext_id = atoi(a->value);
					else if(strstr(a->value, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC))
						transport_wide_cc_ext_id = atoi(a->value);
					else if(strstr(a->value, JANUS_RTP_EXTMAP_AUDIO_LEVEL))
						audiolevel_ext_id = atoi(a->value);
					else if(strstr(a->value, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION))
						videoorientation_ext_id = atoi(a->value);
					else if(strstr(a->value, JANUS_RTP_EXTMAP_RID) ||
							strstr(a->value, JANUS_RTP_EXTMAP_REPAIRED_RID)) {
						m->attributes = g_list_remove(m->attributes, a);
						tempA = m->attributes;
						janus_sdp_attribute_destroy(a);
						continue;
					}
				}
				tempA = tempA->next;
			}
			temp = temp->next;
		}
		if(ice_handle->stream && ice_handle->stream->mid_ext_id != mid_ext_id)
			ice_handle->stream->mid_ext_id = mid_ext_id;
		if(ice_handle->stream && ice_handle->stream->transport_wide_cc_ext_id != transport_wide_cc_ext_id) {
			ice_handle->stream->do_transport_wide_cc = transport_wide_cc_ext_id > 0 ? TRUE : FALSE;
			ice_handle->stream->transport_wide_cc_ext_id = transport_wide_cc_ext_id;
		}
		if(ice_handle->stream && ice_handle->stream->audiolevel_ext_id != audiolevel_ext_id)
			ice_handle->stream->audiolevel_ext_id = audiolevel_ext_id;
		if(ice_handle->stream && ice_handle->stream->videoorientation_ext_id != videoorientation_ext_id)
			ice_handle->stream->videoorientation_ext_id = videoorientation_ext_id;
	} else {
		/* Check if the answer does contain the mid/rid/repaired-rid attributes */
		gboolean do_mid = FALSE, do_rid = FALSE, do_repaired_rid = FALSE;
		GList *temp = parsed_sdp->m_lines;
		while(temp) {
			janus_sdp_mline *m = (janus_sdp_mline *)temp->data;
			GList *tempA = m->attributes;
			while(tempA) {
				janus_sdp_attribute *a = (janus_sdp_attribute *)tempA->data;
				if(a->name && a->value) {
					if(strstr(a->value, JANUS_RTP_EXTMAP_MID))
						do_mid = TRUE;
					else if(strstr(a->value, JANUS_RTP_EXTMAP_RID))
						do_rid = TRUE;
					else if(strstr(a->value, JANUS_RTP_EXTMAP_REPAIRED_RID))
						do_repaired_rid = TRUE;
				}
				tempA = tempA->next;
			}
			temp = temp->next;
		}
		if(!do_mid && ice_handle->stream)
			ice_handle->stream->mid_ext_id = 0;
		if(!do_rid && ice_handle->stream) {
			ice_handle->stream->rid_ext_id = 0;
			ice_handle->stream->ridrtx_ext_id = 0;
			g_free(ice_handle->stream->rid[0]);
			ice_handle->stream->rid[0] = NULL;
			g_free(ice_handle->stream->rid[1]);
			ice_handle->stream->rid[1] = NULL;
			g_free(ice_handle->stream->rid[2]);
			ice_handle->stream->rid[2] = NULL;
			if(ice_handle->stream->video_ssrc_peer_temp > 0) {
				ice_handle->stream->video_ssrc_peer[0] = ice_handle->stream->video_ssrc_peer_temp;
				ice_handle->stream->video_ssrc_peer_temp = 0;
			}
		}
		if(!do_repaired_rid && ice_handle->stream)
			ice_handle->stream->ridrtx_ext_id = 0;
	}
	if(!updating && !janus_ice_is_full_trickle_enabled()) {
		/* Wait for candidates-done callback */
		int waiting = 0;
		while(ice_handle->cdone < 1) {
			if(ice_handle == NULL || janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_STOP)
					|| janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ALERT)) {
				JANUS_LOG(LOG_WARN, '[%'SCNu64'] Handle detached or PC closed, giving up...!\n', ice_handle ? ice_handle->handle_id : 0);
				janus_sdp_destroy(parsed_sdp);
				return NULL;
			}
			if(ice_handle->cdone < 0) {
				JANUS_LOG(LOG_ERR, '[%'SCNu64'] Error gathering candidates!\n', ice_handle->handle_id);
				janus_sdp_destroy(parsed_sdp);
				return NULL;
			}
			if(waiting && (waiting % 5000) == 0) {
				JANUS_LOG(LOG_WARN, '[%'SCNu64'] Waited 5s for candidates, that's way too much... going on with what we have (WebRTC setup might fail)\n', ice_handle->handle_id);
				break;
			}
			if(waiting && (waiting % 1000) == 0) {
				JANUS_LOG(LOG_WARN, '[%'SCNu64'] %s for candidates-done callback... (slow gathering, are you using STUN or TURN for Janus too, instead of just for users? Consider enabling full-trickle instead)\n',
					ice_handle->handle_id, (waiting == 1000 ? 'Waiting' : 'Still waiting'));
			}
			waiting++;
			g_usleep(1000);
		}
	}
	/* Anonymize SDP */
	if(janus_sdp_anonymize(parsed_sdp) < 0) {
		/* Invalid SDP */
		JANUS_LOG(LOG_ERR, '[%'SCNu64'] Invalid SDP\n', ice_handle->handle_id);
		janus_sdp_destroy(parsed_sdp);
		return NULL;
	}

	/* Check if this is a renegotiation and we need an ICE restart */
	if(offer && restart)
		janus_ice_restart(ice_handle);
	/* Add our details */
	janus_mutex_lock(&ice_handle->mutex);
	janus_ice_stream *stream = ice_handle->stream;
	if (stream == NULL) {
		JANUS_LOG(LOG_ERR, '[%'SCNu64'] Error stream not found\n', ice_handle->handle_id);
		janus_mutex_unlock(&ice_handle->mutex);
		return NULL;
	}
	if(janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RFC4588_RTX) &&
			stream->rtx_payload_types == NULL) {
		/* Make sure we have a list of rtx payload types to generate, if needed */
		janus_sdp_mline *m = janus_sdp_mline_find(parsed_sdp, JANUS_SDP_VIDEO);
		if(m && m->ptypes) {
			stream->rtx_payload_types = g_hash_table_new(NULL, NULL);
			GList *ptypes = g_list_copy(m->ptypes), *tempP = ptypes;
			GList *rtx_ptypes = g_hash_table_get_values(stream->rtx_payload_types);
			while(tempP) {
				int ptype = GPOINTER_TO_INT(tempP->data);
				int rtx_ptype = ptype+1;
				if(rtx_ptype > 127)
					rtx_ptype = 96;
				while(g_list_find(m->ptypes, GINT_TO_POINTER(rtx_ptype))
						|| g_list_find(rtx_ptypes, GINT_TO_POINTER(rtx_ptype))) {
					rtx_ptype++;
					if(rtx_ptype > 127)
						rtx_ptype = 96;
					if(rtx_ptype == ptype) {
						/* We did a whole round? should never happen... */
						rtx_ptype = -1;
						break;
					}
				}
				if(rtx_ptype > 0)
					g_hash_table_insert(stream->rtx_payload_types, GINT_TO_POINTER(ptype), GINT_TO_POINTER(rtx_ptype));
				g_list_free(rtx_ptypes);
				rtx_ptypes = g_hash_table_get_values(stream->rtx_payload_types);
				tempP = tempP->next;
			}
			g_list_free(ptypes);
			g_list_free(rtx_ptypes);
		}
	}
	/* Enrich the SDP the plugin gave us with all the WebRTC related stuff */
	char *sdp_merged = janus_sdp_merge(ice_handle, parsed_sdp, offer ? TRUE : FALSE);
	if(sdp_merged == NULL) {
		/* Couldn't merge SDP */
		JANUS_LOG(LOG_ERR, '[%'SCNu64'] Error merging SDP\n', ice_handle->handle_id);
		janus_sdp_destroy(parsed_sdp);
		janus_mutex_unlock(&ice_handle->mutex);
		return NULL;
	}
	janus_sdp_destroy(parsed_sdp);

	if(!updating) {
		if(offer) {
			/* We set the flag to wait for an answer before handling trickle candidates */
			janus_flags_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);
		} else {
			JANUS_LOG(LOG_VERB, '[%'SCNu64'] Sending answer, ready to setup remote candidates and send connectivity checks...\n', ice_handle->handle_id);
			janus_request_ice_handle_answer(ice_handle, audio, video, data, NULL);
		}
	}
#ifdef HAVE_SCTP
	if(!offer && janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_READY)) {
		/* Renegotiation: check if datachannels were just added on an existing PeerConnection */
		if(janus_flags_is_set(&ice_handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS)) {
			janus_ice_stream *stream = ice_handle->stream;
			if(stream != NULL && stream->component != NULL &&
					stream->component->dtls != NULL && stream->component->dtls->sctp == NULL) {
				/* Create SCTP association as well */
				JANUS_LOG(LOG_WARN, '[%'SCNu64'] Creating datachannels...\n', ice_handle->handle_id);
				janus_dtls_srtp_create_sctp(stream->component->dtls);
			}
		}
	}
#endif

	/* Prepare JSON event */
	json_t *jsep = json_object();
	json_object_set_new(jsep, 'type', json_string(sdp_type));
	json_object_set_new(jsep, 'sdp', json_string(sdp_merged));
	char *tmp = ice_handle->local_sdp;
	ice_handle->local_sdp = sdp_merged;
	janus_mutex_unlock(&ice_handle->mutex);
	g_free(tmp);
	return jsep;
}
",1,8525
meetecho/janus-gateway,f46f27fb129fd1b3744830b4fc6e75ab78794636,"							handle->audio_mid = g_strdup(a->value);
						if(handle->stream_mid == NULL)
							handle->stream_mid = handle->audio_mid;
					} else if(m->type == JANUS_SDP_VIDEO && m->port > 0) {
						JANUS_LOG(LOG_VERB, '[%'SCNu64'] Video mid: %s\n', handle->handle_id, a->value);
						if(strlen(a->value) > 16) {
							JANUS_LOG(LOG_ERR, '[%'SCNu64'] Video mid too large: (%zu > 16)\n', handle->handle_id, strlen(a->value));
							return NULL;
						}
",1,8526
meetecho/janus-gateway,f46f27fb129fd1b3744830b4fc6e75ab78794636,"janus_sdp *janus_sdp_preparse(void *ice_handle, const char *jsep_sdp, char *error_str, size_t errlen,
		int *audio, int *video, int *data) {
	if(!ice_handle || !jsep_sdp || !audio || !video || !data) {
		JANUS_LOG(LOG_ERR, '  Can't preparse, invalid arguments\n');
		return NULL;
	}
	janus_ice_handle *handle = (janus_ice_handle *)ice_handle;
	janus_sdp *parsed_sdp = janus_sdp_parse(jsep_sdp, error_str, errlen);
	if(!parsed_sdp) {
		JANUS_LOG(LOG_ERR, '  Error parsing SDP? %s\n', error_str ? error_str : '(unknown reason)');
		/* Invalid SDP */
		return NULL;
	}
	/* Look for m-lines */
	GList *temp = parsed_sdp->m_lines;
	while(temp) {
		janus_sdp_mline *m = (janus_sdp_mline *)temp->data;
		if(m->type == JANUS_SDP_AUDIO && m->port > 0) {
			*audio = *audio + 1;
		} else if(m->type == JANUS_SDP_VIDEO && m->port > 0) {
			*video = *video + 1;
		}
		/* Preparse the mid as well */
		GList *tempA = m->attributes;
		while(tempA) {
			janus_sdp_attribute *a = (janus_sdp_attribute *)tempA->data;
			if(a->name) {
				if(!strcasecmp(a->name, 'mid')) {
					/* Found mid attribute */
					if(m->type == JANUS_SDP_AUDIO && m->port > 0) {
						JANUS_LOG(LOG_VERB, '[%'SCNu64'] Audio mid: %s\n', handle->handle_id, a->value);
						if(strlen(a->value) > 16) {
							JANUS_LOG(LOG_ERR, '[%'SCNu64'] Audio mid too large: (%zu > 16)\n', handle->handle_id, strlen(a->value));
							return NULL;
						}
						if(handle->audio_mid == NULL)
							handle->audio_mid = g_strdup(a->value);
						if(handle->stream_mid == NULL)
							handle->stream_mid = handle->audio_mid;
					} else if(m->type == JANUS_SDP_VIDEO && m->port > 0) {
						JANUS_LOG(LOG_VERB, '[%'SCNu64'] Video mid: %s\n', handle->handle_id, a->value);
						if(strlen(a->value) > 16) {
							JANUS_LOG(LOG_ERR, '[%'SCNu64'] Video mid too large: (%zu > 16)\n', handle->handle_id, strlen(a->value));
							return NULL;
						}
						if(handle->video_mid == NULL)
							handle->video_mid = g_strdup(a->value);
						if(handle->stream_mid == NULL)
							handle->stream_mid = handle->video_mid;
					}
				}
			}
			tempA = tempA->next;
		}
		temp = temp->next;
	}
#ifdef HAVE_SCTP
	*data = (strstr(jsep_sdp, 'DTLS/SCTP') && !strstr(jsep_sdp, ' 0 DTLS/SCTP') &&
		!strstr(jsep_sdp, ' 0 UDP/DTLS/SCTP')) ? 1 : 0;	/* FIXME This is a really hacky way of checking... */
#else
	*data = 0;
#endif

	return parsed_sdp;
}
",1,8527
meetecho/janus-gateway,f46f27fb129fd1b3744830b4fc6e75ab78794636,"static void janus_handle_signal(int signum) {
	stop_signal = signum;
	switch(g_atomic_int_get(&stop)) {
		case 0:
			JANUS_PRINT('Stopping server, please wait...\n');
			break;
		case 1:
			JANUS_PRINT('In a hurry? I'm trying to free resources cleanly, here!\n');
			break;
		default:
			JANUS_PRINT('Ok, leaving immediately...\n');
			break;
	}
	g_atomic_int_inc(&stop);
	if(g_atomic_int_get(&stop) > 2)
		exit(1);
	if(mainloop && g_main_loop_is_running(mainloop))
		g_main_loop_quit(mainloop);
}
",0,8528
meetecho/janus-gateway,f46f27fb129fd1b3744830b4fc6e75ab78794636,"void janus_plugin_send_remb(janus_plugin_session *plugin_session, uint32_t bitrate) {
	if((plugin_session < (janus_plugin_session *)0x1000) || g_atomic_int_get(&plugin_session->stopped))
		return;
	janus_ice_handle *handle = (janus_ice_handle *)plugin_session->gateway_handle;
	if(!handle || janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_STOP)
			|| janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ALERT))
		return;
	janus_ice_send_remb(handle, bitrate);
}
",0,8529
meetecho/janus-gateway,f46f27fb129fd1b3744830b4fc6e75ab78794636,"void janus_plugin_relay_rtp(janus_plugin_session *plugin_session, janus_plugin_rtp *packet) {
	if((plugin_session < (janus_plugin_session *)0x1000) || g_atomic_int_get(&plugin_session->stopped) ||
			packet == NULL || packet->buffer == NULL || packet->length < 1)
		return;
	janus_ice_handle *handle = (janus_ice_handle *)plugin_session->gateway_handle;
	if(!handle || janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_STOP)
			|| janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ALERT))
		return;
	janus_ice_relay_rtp(handle, packet);
}
",0,8530
meetecho/janus-gateway,f46f27fb129fd1b3744830b4fc6e75ab78794636,"int janus_process_incoming_admin_request(janus_request *request) {
	int ret = -1;
	int error_code = 0;
	char error_cause[100];
	if(request == NULL) {
		JANUS_LOG(LOG_ERR, 'Missing request or payload to process, giving up...\n');
		return ret;
	}
	json_t *root = request->message;
	/* Ok, let's start with the ids */
	guint64 session_id = 0, handle_id = 0;
	json_t *s = json_object_get(root, 'session_id');
	if(s && json_is_integer(s))
		session_id = json_integer_value(s);
	json_t *h = json_object_get(root, 'handle_id');
	if(h && json_is_integer(h))
		handle_id = json_integer_value(h);

	janus_session *session = NULL;
	janus_ice_handle *handle = NULL;

	/* Get transaction and message request */
	JANUS_VALIDATE_JSON_OBJECT(root, admin_parameters,
		error_code, error_cause, FALSE,
		JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
	if(error_code != 0) {
		ret = janus_process_error_string(request, session_id, NULL, error_code, error_cause);
		goto jsondone;
	}
	json_t *transaction = json_object_get(root, 'transaction');
	const gchar *transaction_text = json_string_value(transaction);
	json_t *message = json_object_get(root, 'janus');
	const gchar *message_text = json_string_value(message);

	if(session_id == 0 && handle_id == 0) {
		/* Can only be a 'Get all sessions' or some general setting manipulation request */
		if(!strcasecmp(message_text, 'info')) {
			/* The generic info request */
			ret = janus_process_success(request, janus_info(transaction_text));
			goto jsondone;
		}
		if(!strcasecmp(message_text, 'ping')) {
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('pong', 0, transaction_text);
			ret = janus_process_success(request, reply);
			goto jsondone;
		}
		if(admin_api_secret != NULL) {
			/* There's an admin/monitor secret, check that the client provided it */
			json_t *secret = json_object_get(root, 'admin_secret');
			if(!secret || !json_is_string(secret) || !janus_strcmp_const_time(json_string_value(secret), admin_api_secret)) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);
				goto jsondone;
			}
		}
		if(!strcasecmp(message_text, 'get_status')) {
			/* Return some info on the settings (mostly debug-related, at the moment) */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_t *status = json_object();
			json_object_set_new(status, 'token_auth', janus_auth_is_enabled() ? json_true() : json_false());
			json_object_set_new(status, 'session_timeout', json_integer(session_timeout));
			json_object_set_new(status, 'reclaim_session_timeout', json_integer(reclaim_session_timeout));
			json_object_set_new(status, 'candidates_timeout', json_integer(candidates_timeout));
			json_object_set_new(status, 'log_level', json_integer(janus_log_level));
			json_object_set_new(status, 'log_timestamps', janus_log_timestamps ? json_true() : json_false());
			json_object_set_new(status, 'log_colors', janus_log_colors ? json_true() : json_false());
			json_object_set_new(status, 'locking_debug', lock_debug ? json_true() : json_false());
			json_object_set_new(status, 'refcount_debug', refcount_debug ? json_true() : json_false());
			json_object_set_new(status, 'libnice_debug', janus_ice_is_ice_debugging_enabled() ? json_true() : json_false());
			json_object_set_new(status, 'min_nack_queue', json_integer(janus_get_min_nack_queue()));
			json_object_set_new(status, 'no_media_timer', json_integer(janus_get_no_media_timer()));
			json_object_set_new(status, 'slowlink_threshold', json_integer(janus_get_slowlink_threshold()));
			json_object_set_new(reply, 'status', status);
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_session_timeout')) {
			/* Change the session timeout value */
			JANUS_VALIDATE_JSON_OBJECT(root, timeout_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *timeout = json_object_get(root, 'timeout');
			int timeout_num = json_integer_value(timeout);
			if(timeout_num < 0) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, 'Invalid element type (timeout should be a positive integer)');
				goto jsondone;
			}
			session_timeout = timeout_num;
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			json_object_set_new(reply, 'timeout', json_integer(session_timeout));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_log_level')) {
			/* Change the debug logging level */
			JANUS_VALIDATE_JSON_OBJECT(root, level_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *level = json_object_get(root, 'level');
			int level_num = json_integer_value(level);
			if(level_num < LOG_NONE || level_num > LOG_MAX) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, 'Invalid element type (level should be between %d and %d)', LOG_NONE, LOG_MAX);
				goto jsondone;
			}
			janus_log_level = level_num;
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'level', json_integer(janus_log_level));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_locking_debug')) {
			/* Enable/disable the locking debug (would show a message on the console for every lock attempt) */
			JANUS_VALIDATE_JSON_OBJECT(root, debug_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *debug = json_object_get(root, 'debug');
			lock_debug = json_is_true(debug);
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'locking_debug', lock_debug ? json_true() : json_false());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_refcount_debug')) {
			/* Enable/disable the reference counter debug (would show a message on the console for every increase/decrease) */
			JANUS_VALIDATE_JSON_OBJECT(root, debug_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *debug = json_object_get(root, 'debug');
			if(json_is_true(debug)) {
				refcount_debug = TRUE;
			} else {
				refcount_debug = FALSE;
			}
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'refcount_debug', refcount_debug ? json_true() : json_false());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_log_timestamps')) {
			/* Enable/disable the log timestamps */
			JANUS_VALIDATE_JSON_OBJECT(root, timestamps_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *timestamps = json_object_get(root, 'timestamps');
			janus_log_timestamps = json_is_true(timestamps);
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'log_timestamps', janus_log_timestamps ? json_true() : json_false());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_log_colors')) {
			/* Enable/disable the log colors */
			JANUS_VALIDATE_JSON_OBJECT(root, colors_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *colors = json_object_get(root, 'colors');
			janus_log_colors = json_is_true(colors);
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'log_colors', janus_log_colors ? json_true() : json_false());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_libnice_debug')) {
			/* Enable/disable the libnice debugging (http://nice.freedesktop.org/libnice/libnice-Debug-messages.html) */
			JANUS_VALIDATE_JSON_OBJECT(root, debug_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *debug = json_object_get(root, 'debug');
			if(json_is_true(debug)) {
				janus_ice_debugging_enable();
			} else {
				janus_ice_debugging_disable();
			}
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'libnice_debug', janus_ice_is_ice_debugging_enabled() ? json_true() : json_false());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_min_nack_queue')) {
			/* Change the current value for the min NACK queue */
			JANUS_VALIDATE_JSON_OBJECT(root, mnq_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *mnq = json_object_get(root, 'min_nack_queue');
			int mnq_num = json_integer_value(mnq);
			janus_set_min_nack_queue(mnq_num);
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'min_nack_queue', json_integer(janus_get_min_nack_queue()));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_no_media_timer')) {
			/* Change the current value for the no-media timer */
			JANUS_VALIDATE_JSON_OBJECT(root, nmt_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *nmt = json_object_get(root, 'no_media_timer');
			int nmt_num = json_integer_value(nmt);
			janus_set_no_media_timer(nmt_num);
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			json_object_set_new(reply, 'no_media_timer', json_integer(janus_get_no_media_timer()));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'set_slowlink_threshold')) {
			/* Change the current value for the slowlink-threshold value */
			JANUS_VALIDATE_JSON_OBJECT(root, st_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *nmt = json_object_get(root, 'slowlink_threshold');
			int nmt_num = json_integer_value(nmt);
			janus_set_slowlink_threshold(nmt_num);
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			json_object_set_new(reply, 'slowlink_threshold', json_integer(janus_get_slowlink_threshold()));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'accept_new_sessions')) {
			/* Configure whether we should accept new incoming sessions or not:
			 * this can be particularly useful whenever, e.g., we want to stop
			 * accepting new sessions because we're draining this server */
			JANUS_VALIDATE_JSON_OBJECT(root, ans_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *accept = json_object_get(root, 'accept');
			accept_new_sessions = json_is_true(accept);
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'accept', accept_new_sessions ? json_true() : json_false());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'message_plugin')) {
			/* Contact a plugin and expect a response */
			JANUS_VALIDATE_JSON_OBJECT(root, messageplugin_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *plugin = json_object_get(root, 'plugin');
			const char *plugin_value = json_string_value(plugin);
			janus_plugin *p = janus_plugin_find(plugin_value);
			if(p == NULL) {
				/* No such handler... */
				g_snprintf(error_cause, sizeof(error_cause), '%s', 'Invalid plugin');
				ret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, error_cause);
				goto jsondone;
			}
			if(p->handle_admin_message == NULL) {
				/* Handler doesn't implement the hook... */
				g_snprintf(error_cause, sizeof(error_cause), '%s', 'Plugin doesn't support Admin API messages');
				ret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, error_cause);
				goto jsondone;
			}
			json_t *query = json_object_get(root, 'request');
			json_t *response = p->handle_admin_message(query);
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			json_object_set_new(reply, 'response', response ? response : json_object());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'query_eventhandler')) {
			/* Contact an event handler and expect a response */
			JANUS_VALIDATE_JSON_OBJECT(root, queryhandler_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *handler = json_object_get(root, 'handler');
			const char *handler_value = json_string_value(handler);
			janus_eventhandler *evh = g_hash_table_lookup(eventhandlers, handler_value);
			if(evh == NULL) {
				/* No such handler... */
				g_snprintf(error_cause, sizeof(error_cause), '%s', 'Invalid event handler');
				ret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, error_cause);
				goto jsondone;
			}
			if(evh->handle_request == NULL) {
				/* Handler doesn't implement the hook... */
				g_snprintf(error_cause, sizeof(error_cause), '%s', 'Event handler doesn't support queries');
				ret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, error_cause);
				goto jsondone;
			}
			json_t *query = json_object_get(root, 'request');
			json_t *response = evh->handle_request(query);
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			json_object_set_new(reply, 'response', response ? response : json_object());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'query_logger')) {
			/* Contact a logger and expect a response */
			JANUS_VALIDATE_JSON_OBJECT(root, querylogger_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *logger = json_object_get(root, 'logger');
			const char *logger_value = json_string_value(logger);
			janus_logger *l = g_hash_table_lookup(loggers, logger_value);
			if(l == NULL) {
				/* No such handler... */
				g_snprintf(error_cause, sizeof(error_cause), '%s', 'Invalid logger');
				ret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, error_cause);
				goto jsondone;
			}
			if(l->handle_request == NULL) {
				/* Handler doesn't implement the hook... */
				g_snprintf(error_cause, sizeof(error_cause), '%s', 'Logger doesn't support queries');
				ret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, error_cause);
				goto jsondone;
			}
			json_t *query = json_object_get(root, 'request');
			json_t *response = l->handle_request(query);
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			json_object_set_new(reply, 'response', response ? response : json_object());
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'custom_event')) {
			/* Enqueue a custom 'external' event to notify via event handlers */
			JANUS_VALIDATE_JSON_OBJECT(root, customevent_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *schema = json_object_get(root, 'schema');
			const char *schema_value = json_string_value(schema);
			json_t *data = json_object_get(root, 'data');
			if(janus_events_is_enabled()) {
				json_incref(data);
				janus_events_notify_handlers(JANUS_EVENT_TYPE_EXTERNAL, JANUS_EVENT_SUBTYPE_NONE,
					0, schema_value, data);
			}
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'custom_logline')) {
			/* Print something custom on the logs, using the specified debug level */
			JANUS_VALIDATE_JSON_OBJECT(root, customlogline_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *line = json_object_get(root, 'line');
			const char *log_line = json_string_value(line);
			json_t *level = json_object_get(root, 'level');
			int log_level = LOG_INFO;
			if(level) {
				log_level = json_integer_value(level);
				if(log_level < LOG_NONE || log_level > LOG_MAX)
					log_level = LOG_INFO;
			}
			/* Print the log line on the log */
			JANUS_LOG(log_level, '%s\n', log_line);
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'list_sessions')) {
			/* List sessions */
			session_id = 0;
			json_t *list = json_array();
			if(sessions != NULL && g_hash_table_size(sessions) > 0) {
				janus_mutex_lock(&sessions_mutex);
				GHashTableIter iter;
				gpointer value;
				g_hash_table_iter_init(&iter, sessions);
				while (g_hash_table_iter_next(&iter, NULL, &value)) {
					janus_session *session = value;
					if(session == NULL) {
						continue;
					}
					json_array_append_new(list, json_integer(session->session_id));
				}
				janus_mutex_unlock(&sessions_mutex);
			}
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'sessions', list);
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'add_token')) {
			/* Add a token valid for authentication */
			ret = janus_request_allow_token(request, session_id, transaction_text, TRUE, TRUE);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'list_tokens')) {
			/* List all the valid tokens */
			if(!janus_auth_is_stored_mode()) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, 'Stored-Token based authentication disabled');
				goto jsondone;
			}
			json_t *tokens_list = json_array();
			GList *list = janus_auth_list_tokens();
			if(list != NULL) {
				GList *tmp = list;
				while(tmp) {
					char *token = (char *)tmp->data;
					if(token != NULL) {
						json_t *plugins_list = janus_json_token_plugin_array(token);
						if(json_array_size(plugins_list) > 0) {
							json_t *t = json_object();
							json_object_set_new(t, 'token', json_string(token));
							json_object_set_new(t, 'allowed_plugins', plugins_list);
							json_array_append_new(tokens_list, t);
						}
						else
							json_decref(plugins_list);
						tmp->data = NULL;
						g_free(token);
					}
					tmp = tmp->next;
				}
				g_list_free(list);
			}
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_t *data = json_object();
			json_object_set_new(data, 'tokens', tokens_list);
			json_object_set_new(reply, 'data', data);
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'allow_token')) {
			/* Allow a valid token valid to access a plugin */
			ret = janus_request_allow_token(request, session_id, transaction_text, TRUE, FALSE);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'disallow_token')) {
			/* Disallow a valid token valid from accessing a plugin */
			ret = janus_request_allow_token(request, session_id, transaction_text, FALSE, FALSE);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'remove_token')) {
			/* Invalidate a token for authentication purposes */
			if(!janus_auth_is_stored_mode()) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, 'Stored-Token based authentication disabled');
				goto jsondone;
			}
			JANUS_VALIDATE_JSON_OBJECT(root, token_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			json_t *token = json_object_get(root, 'token');
			const char *token_value = json_string_value(token);
			if(!janus_auth_remove_token(token_value)) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, 'Error removing token');
				goto jsondone;
			}
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'resolve_address')) {
			/* Helper method to evaluate whether this instance can resolve an address, and how soon */
			JANUS_VALIDATE_JSON_OBJECT(root, resaddr_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			const char *address = json_string_value(json_object_get(root, 'address'));
			/* Resolve the address */
			gint64 start = janus_get_monotonic_time();
			struct addrinfo *res = NULL;
			janus_network_address addr;
			janus_network_address_string_buffer addr_buf;
			if(getaddrinfo(address, NULL, NULL, &res) != 0 ||
					janus_network_address_from_sockaddr(res->ai_addr, &addr) != 0 ||
					janus_network_address_to_string_buffer(&addr, &addr_buf) != 0) {
				JANUS_LOG(LOG_ERR, 'Could not resolve %s...\n', address);
				if(res)
					freeaddrinfo(res);
				ret = janus_process_error_string(request, session_id, transaction_text,
					JANUS_ERROR_UNKNOWN, (char *)'Could not resolve address');
				goto jsondone;
			}
			gint64 end = janus_get_monotonic_time();
			freeaddrinfo(res);
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'ip', json_string(janus_network_address_string_from_buffer(&addr_buf)));
			json_object_set_new(reply, 'elapsed', json_integer(end-start));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'test_stun')) {
			/* Helper method to evaluate whether this instance can use STUN with a specific server */
			JANUS_VALIDATE_JSON_OBJECT(root, teststun_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			const char *address = json_string_value(json_object_get(root, 'address'));
			uint16_t port = json_integer_value(json_object_get(root, 'port'));
			uint16_t local_port = json_integer_value(json_object_get(root, 'localport'));
			/* Resolve the address */
			gint64 start = janus_get_monotonic_time();
			struct addrinfo *res = NULL;
			janus_network_address addr;
			janus_network_address_string_buffer addr_buf;
			if(getaddrinfo(address, NULL, NULL, &res) != 0 ||
					janus_network_address_from_sockaddr(res->ai_addr, &addr) != 0 ||
					janus_network_address_to_string_buffer(&addr, &addr_buf) != 0) {
				JANUS_LOG(LOG_ERR, 'Could not resolve %s...\n', address);
				if(res)
					freeaddrinfo(res);
				ret = janus_process_error_string(request, session_id, transaction_text,
					JANUS_ERROR_UNKNOWN, (char *)'Could not resolve address');
				goto jsondone;
			}
			freeaddrinfo(res);
			/* Test the STUN server */
			janus_network_address public_addr = { 0 };
			uint16_t public_port = 0;
			if(janus_ice_test_stun_server(&addr, port, local_port, &public_addr, &public_port) < 0) {
				ret = janus_process_error_string(request, session_id, transaction_text,
					JANUS_ERROR_UNKNOWN, (char *)'STUN request failed');
				goto jsondone;
			}
			if(janus_network_address_to_string_buffer(&public_addr, &addr_buf) != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text,
					JANUS_ERROR_UNKNOWN, (char *)'Could not resolve public address');
				goto jsondone;
			}
			const char *public_ip_addr = janus_network_address_string_from_buffer(&addr_buf);
			gint64 end = janus_get_monotonic_time();
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', 0, transaction_text);
			json_object_set_new(reply, 'public_ip', json_string(public_ip_addr));
			json_object_set_new(reply, 'public_port', json_integer(public_port));
			json_object_set_new(reply, 'elapsed', json_integer(end-start));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else {
			/* No message we know of */
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
	}
	if(session_id < 1) {
		JANUS_LOG(LOG_ERR, 'Invalid session\n');
		ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);
		goto jsondone;
	}
	if(h && handle_id < 1) {
		JANUS_LOG(LOG_ERR, 'Invalid handle\n');
		ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);
		goto jsondone;
	}

	/* Go on with the processing */
	if(admin_api_secret != NULL) {
		/* There's an API secret, check that the client provided it */
		json_t *secret = json_object_get(root, 'admin_secret');
		if(!secret || !json_is_string(secret) || !janus_strcmp_const_time(json_string_value(secret), admin_api_secret)) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);
			goto jsondone;
		}
	}

	/* If we got here, make sure we have a session (and/or a handle) */
	session = janus_session_find(session_id);
	if(!session) {
		JANUS_LOG(LOG_ERR, 'Couldn't find any session %'SCNu64'...\n', session_id);
		ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, 'No such session %'SCNu64'', session_id);
		goto jsondone;
	}
	handle = NULL;
	if(handle_id > 0) {
		handle = janus_session_handles_find(session, handle_id);
		if(!handle) {
			JANUS_LOG(LOG_ERR, 'Couldn't find any handle %'SCNu64' in session %'SCNu64'...\n', handle_id, session_id);
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_HANDLE_NOT_FOUND, 'No such handle %'SCNu64' in session %'SCNu64'', handle_id, session_id);
			goto jsondone;
		}
	}

	/* What is this? */
	if(handle == NULL) {
		/* Session-related */
		if(!strcasecmp(message_text, 'destroy_session')) {
			janus_mutex_lock(&sessions_mutex);
			g_hash_table_remove(sessions, &session->session_id);
			janus_mutex_unlock(&sessions_mutex);
			/* Notify the source that the session has been destroyed */
			janus_request *source = janus_session_get_request(session);
			if(source && source->transport)
				source->transport->session_over(source->instance, session->session_id, FALSE, FALSE);
			janus_request_unref(source);
			/* Schedule the session for deletion */
			janus_session_destroy(session);

			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', session_id, transaction_text);
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			/* Notify event handlers as well */
			if(janus_events_is_enabled())
				janus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,
					session_id, 'destroyed', NULL);
			goto jsondone;
		}
		/* If this is not a request to destroy a session, it must be a request to list the handles */
		if(strcasecmp(message_text, 'list_handles')) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		/* List handles */
		json_t *list = janus_session_handles_list_json(session);
		/* Prepare JSON reply */
		json_t *reply = janus_create_message('success', session_id, transaction_text);
		json_object_set_new(reply, 'handles', list);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
		goto jsondone;
	} else {
		/* Handle-related */
		if(!strcasecmp(message_text, 'detach_handle')) {
			if(handle->app == NULL || handle->app_handle == NULL) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, 'No plugin to detach from');
				goto jsondone;
			}
			int error = janus_session_handles_remove(session, handle);
			if(error != 0) {
				/* TODO Make error struct to pass verbose information */
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, 'Couldn't detach from plugin: error '%d'', error);
				/* TODO Delete handle instance */
				goto jsondone;
			}
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', session_id, transaction_text);
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'hangup_webrtc')) {
			if(handle->app == NULL || handle->app_handle == NULL) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, 'No plugin attached');
				goto jsondone;
			}
			janus_ice_webrtc_hangup(handle, 'Admin API');
			/* Prepare JSON reply */
			json_t *reply = janus_create_message('success', session_id, transaction_text);
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'start_pcap') || !strcasecmp(message_text, 'start_text2pcap')) {
			/* Start dumping RTP and RTCP packets to a pcap or text2pcap file */
			JANUS_VALIDATE_JSON_OBJECT(root, text2pcap_parameters,
				error_code, error_cause, FALSE,
				JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
			if(error_code != 0) {
				ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
				goto jsondone;
			}
			gboolean text = !strcasecmp(message_text, 'start_text2pcap');
			const char *folder = json_string_value(json_object_get(root, 'folder'));
			const char *filename = json_string_value(json_object_get(root, 'filename'));
			int truncate = json_integer_value(json_object_get(root, 'truncate'));
			if(handle->text2pcap != NULL) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN,
					text ? 'text2pcap already started' : 'pcap already started');
				goto jsondone;
			}
			handle->text2pcap = janus_text2pcap_create(folder, filename, truncate, text);
			if(handle->text2pcap == NULL) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN,
					text ? 'Error starting text2pcap dump' : 'Error starting pcap dump');
				goto jsondone;
			}
			g_atomic_int_set(&handle->dump_packets, 1);
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		} else if(!strcasecmp(message_text, 'stop_pcap') || !strcasecmp(message_text, 'stop_text2pcap')) {
			/* Stop dumping RTP and RTCP packets to a pcap or text2pcap file */
			if(handle->text2pcap == NULL) {
				ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN,
					'Capture not started');
				goto jsondone;
			}
			if(g_atomic_int_compare_and_exchange(&handle->dump_packets, 1, 0)) {
				janus_text2pcap_close(handle->text2pcap);
				g_clear_pointer(&handle->text2pcap, janus_text2pcap_free);
			}
			/* Prepare JSON reply */
			json_t *reply = json_object();
			json_object_set_new(reply, 'janus', json_string('success'));
			json_object_set_new(reply, 'transaction', json_string(transaction_text));
			/* Send the success reply */
			ret = janus_process_success(request, reply);
			goto jsondone;
		}
		/* If this is not a request to start/stop debugging to text2pcap, it must be a handle_info */
		if(strcasecmp(message_text, 'handle_info')) {
			ret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, 'Unhandled request '%s' at this path', message_text);
			goto jsondone;
		}
		JANUS_VALIDATE_JSON_OBJECT(root, handleinfo_parameters,
			error_code, error_cause, FALSE,
			JANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);
		if(error_code != 0) {
			ret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);
			goto jsondone;
		}
		/* Check if we should limit the response to the plugin-specific info */
		gboolean plugin_only = json_is_true(json_object_get(root, 'plugin_only'));
		/* Prepare info */
		json_t *info = json_object();
		json_object_set_new(info, 'session_id', json_integer(session_id));
		json_object_set_new(info, 'session_last_activity', json_integer(session->last_activity));
		janus_mutex_lock(&session->mutex);
		if(session->source && session->source->transport)
			json_object_set_new(info, 'session_transport', json_string(session->source->transport->get_package()));
		janus_mutex_unlock(&session->mutex);
		janus_mutex_lock(&handle->mutex);
		json_object_set_new(info, 'handle_id', json_integer(handle_id));
		if(handle->opaque_id)
			json_object_set_new(info, 'opaque_id', json_string(handle->opaque_id));
		if(handle->token)
			json_object_set_new(info, 'token', json_string(handle->token));
		json_object_set_new(info, 'loop-running', (handle->mainloop != NULL &&
			g_main_loop_is_running(handle->mainloop)) ? json_true() : json_false());
		json_object_set_new(info, 'created', json_integer(handle->created));
		json_object_set_new(info, 'current_time', json_integer(janus_get_monotonic_time()));
		if(handle->app && janus_plugin_session_is_alive(handle->app_handle)) {
			janus_plugin *plugin = (janus_plugin *)handle->app;
			json_object_set_new(info, 'plugin', json_string(plugin->get_package()));
			if(plugin->query_session) {
				/* FIXME This check will NOT work with legacy plugins that were compiled BEFORE the method was specified in plugin.h */
				json_t *query = plugin->query_session(handle->app_handle);
				if(query != NULL) {
					/* Make sure this is a JSON object */
					if(!json_is_object(query)) {
						JANUS_LOG(LOG_WARN, 'Ignoring invalid query response from the plugin (not an object)\n');
						json_decref(query);
					} else {
						json_object_set_new(info, 'plugin_specific', query);
					}
					query = NULL;
				}
			}
		}
		if(plugin_only)
			goto info_done;
		json_t *flags = json_object();
		json_object_set_new(flags, 'got-offer', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER) ? json_true() : json_false());
		json_object_set_new(flags, 'got-answer', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER) ? json_true() : json_false());
		json_object_set_new(flags, 'negotiated', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED) ? json_true() : json_false());
		json_object_set_new(flags, 'processing-offer', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER) ? json_true() : json_false());
		json_object_set_new(flags, 'starting', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_START) ? json_true() : json_false());
		json_object_set_new(flags, 'ice-restart', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART) ? json_true() : json_false());
		json_object_set_new(flags, 'ready', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_READY) ? json_true() : json_false());
		json_object_set_new(flags, 'stopped', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_STOP) ? json_true() : json_false());
		json_object_set_new(flags, 'alert', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ALERT) ? json_true() : json_false());
		json_object_set_new(flags, 'trickle', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE) ? json_true() : json_false());
		json_object_set_new(flags, 'all-trickles', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ALL_TRICKLES) ? json_true() : json_false());
		json_object_set_new(flags, 'resend-trickles', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RESEND_TRICKLES) ? json_true() : json_false());
		json_object_set_new(flags, 'trickle-synced', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE_SYNCED) ? json_true() : json_false());
		json_object_set_new(flags, 'data-channels', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS) ? json_true() : json_false());
		json_object_set_new(flags, 'has-audio', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_AUDIO) ? json_true() : json_false());
		json_object_set_new(flags, 'has-video', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO) ? json_true() : json_false());
		json_object_set_new(flags, 'new-datachan-sdp', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEW_DATACHAN_SDP) ? json_true() : json_false());
		json_object_set_new(flags, 'rfc4588-rtx', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RFC4588_RTX) ? json_true() : json_false());
		json_object_set_new(flags, 'cleaning', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING) ? json_true() : json_false());
		json_object_set_new(flags, 'e2ee', janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_E2EE) ? json_true() : json_false());
		json_object_set_new(info, 'flags', flags);
		if(handle->agent) {
			json_object_set_new(info, 'agent-created', json_integer(handle->agent_created));
			json_object_set_new(info, 'ice-mode', json_string(janus_ice_is_ice_lite_enabled() ? 'lite' : 'full'));
			json_object_set_new(info, 'ice-role', json_string(handle->controlling ? 'controlling' : 'controlled'));
		}
		json_t *sdps = json_object();
		if(handle->rtp_profile)
			json_object_set_new(sdps, 'profile', json_string(handle->rtp_profile));
		if(handle->local_sdp)
			json_object_set_new(sdps, 'local', json_string(handle->local_sdp));
		if(handle->remote_sdp)
			json_object_set_new(sdps, 'remote', json_string(handle->remote_sdp));
		json_object_set_new(info, 'sdps', sdps);
		if(handle->pending_trickles)
			json_object_set_new(info, 'pending-trickles', json_integer(g_list_length(handle->pending_trickles)));
		if(handle->queued_packets)
			json_object_set_new(info, 'queued-packets', json_integer(g_async_queue_length(handle->queued_packets)));
		if(g_atomic_int_get(&handle->dump_packets) && handle->text2pcap) {
			if(handle->text2pcap->text) {
				json_object_set_new(info, 'dump-to-text2pcap', json_true());
				json_object_set_new(info, 'text2pcap-file', json_string(handle->text2pcap->filename));
			} else {
				json_object_set_new(info, 'dump-to-pcap', json_true());
				json_object_set_new(info, 'pcap-file', json_string(handle->text2pcap->filename));
			}
		}
		json_t *streams = json_array();
		if(handle->stream) {
			json_t *s = janus_admin_stream_summary(handle->stream);
			if(s)
				json_array_append_new(streams, s);
		}
		json_object_set_new(info, 'streams', streams);
info_done:
		janus_mutex_unlock(&handle->mutex);
		/* Prepare JSON reply */
		json_t *reply = janus_create_message('success', session_id, transaction_text);
		json_object_set_new(reply, 'handle_id', json_integer(handle_id));
		json_object_set_new(reply, 'info', info);
		/* Send the success reply */
		ret = janus_process_success(request, reply);
		goto jsondone;
	}

jsondone:
	/* Done processing */
	if(handle != NULL)
		janus_refcount_decrease(&handle->ref);
	if(session != NULL)
		janus_refcount_decrease(&session->ref);
	return ret;
}
",0,8531
FreeRDP/FreeRDP,8526965eef5182ad8131a2d8ebabce046666f259,"BOOL tpdu_read_header(wStream* s, BYTE* code, BYTE* li, UINT16 tpktlength)
{
	if (Stream_GetRemainingLength(s) < 3)
		return FALSE;

	Stream_Read_UINT8(s, *li);   /* LI */
	Stream_Read_UINT8(s, *code); /* Code */

	if (*li + 4 > tpktlength)
	{
		WLog_ERR(TAG, 'tpdu length %' PRIu16 ' > tpkt header length %' PRIu16, li, tpktlength);
		return FALSE;
	}

	if (*code == X224_TPDU_DATA)
	{
		/* EOT (1 byte) */
		Stream_Seek(s, 1);
	}
	else
	{
		/* DST-REF (2 bytes) */
		/* SRC-REF (2 bytes) */
		/* Class 0 (1 byte) */
		return Stream_SafeSeek(s, 5);
	}

	return TRUE;
}
",1,8532
FreeRDP/FreeRDP,8526965eef5182ad8131a2d8ebabce046666f259,"void tpdu_write_data(wStream* s)
{
	tpdu_write_header(s, 2, X224_TPDU_DATA);
}
",0,8533
openenclave/openenclave,bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,"static ssize_t _hostfs_read(oe_fd_t* desc, void* buf, size_t count)
{
    ssize_t ret = -1;
    file_t* file = _cast_file(desc);

    if (!file)
        OE_RAISE_ERRNO(OE_EINVAL);

    /* Call the host to perform the read(). */
    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)
        OE_RAISE_ERRNO(OE_EINVAL);

done:
    return ret;
}
",1,8534
openenclave/openenclave,bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,"static ssize_t _hostfs_write(oe_fd_t* desc, const void* buf, size_t count)
{
    ssize_t ret = -1;
    file_t* file = _cast_file(desc);

    /* Check parameters. */
    if (!file || (count && !buf))
        OE_RAISE_ERRNO(OE_EINVAL);

    /* Call the host. */
    if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK)
        OE_RAISE_ERRNO(OE_EINVAL);

done:
    return ret;
}
",1,8535
openenclave/openenclave,bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,"static ssize_t _hostfs_readv(
    oe_fd_t* desc,
    const struct oe_iovec* iov,
    int iovcnt)
{
    ssize_t ret = -1;
    file_t* file = _cast_file(desc);
    void* buf = NULL;
    size_t buf_size = 0;

    if (!file || (!iov && iovcnt) || iovcnt < 0 || iovcnt > OE_IOV_MAX)
        OE_RAISE_ERRNO(OE_EINVAL);

    /* Flatten the IO vector into contiguous heap memory. */
    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)
        OE_RAISE_ERRNO(OE_ENOMEM);

    /* Call the host. */
    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=
        OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }

    /* Synchronize data read with IO vector. */
    if (ret > 0)
    {
        if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)
            OE_RAISE_ERRNO(OE_EINVAL);
    }

done:

    if (buf)
        oe_free(buf);

    return ret;
}
",1,8536
openenclave/openenclave,bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,"static ssize_t _hostfs_writev(
    oe_fd_t* desc,
    const struct oe_iovec* iov,
    int iovcnt)
{
    ssize_t ret = -1;
    file_t* file = _cast_file(desc);
    void* buf = NULL;
    size_t buf_size = 0;

    if (!file || !iov || iovcnt < 0 || iovcnt > OE_IOV_MAX)
        OE_RAISE_ERRNO(OE_EINVAL);

    /* Flatten the IO vector into contiguous heap memory. */
    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)
        OE_RAISE_ERRNO(OE_ENOMEM);

    /* Call the host. */
    if (oe_syscall_writev_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=
        OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }

done:

    if (buf)
        oe_free(buf);

    return ret;
}
",1,8537
openenclave/openenclave,bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,"static ssize_t _hostfs_pread(
    oe_fd_t* desc,
    void* buf,
    size_t count,
    oe_off_t offset)
{
    ssize_t ret = -1;
    file_t* file = _cast_file(desc);

    if (!file)
        OE_RAISE_ERRNO(OE_EINVAL);

    if (oe_syscall_pread_ocall(&ret, file->host_fd, buf, count, offset) !=
        OE_OK)
        OE_RAISE_ERRNO(OE_EINVAL);

done:
    return ret;
}
",1,8538
