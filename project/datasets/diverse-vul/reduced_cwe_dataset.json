[
    {
        "func": "static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n{\n    int sx, sy;\n    int dx, dy;\n    int width, height;\n    int depth;\n    int notify = 0;\n\n    depth = s->get_bpp((VGAState *)s) / 8;\n    s->get_resolution((VGAState *)s, &width, &height);\n\n    /* extra x, y */\n    sx = (src % (width * depth)) / depth;\n    sy = (src / (width * depth));\n    dx = (dst % (width *depth)) / depth;\n    dy = (dst / (width * depth));\n\n    /* normalize width */\n    w /= depth;\n\n    /* if we're doing a backward copy, we have to adjust\n       our x/y to be the upper left corner (instead of the lower\n       right corner) */\n    if (s->cirrus_blt_dstpitch < 0) {\n\tsx -= (s->cirrus_blt_width / depth) - 1;\n\tdx -= (s->cirrus_blt_width / depth) - 1;\n\tsy -= s->cirrus_blt_height - 1;\n\tdy -= s->cirrus_blt_height - 1;\n    }\n\n    /* are we in the visible portion of memory? */\n    if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\t(sx + w) <= width && (sy + h) <= height &&\n\t(dx + w) <= width && (dy + h) <= height) {\n\tnotify = 1;\n    }\n\n    /* make to sure only copy if it's a plain copy ROP */\n    if (*s->cirrus_rop != cirrus_bitblt_rop_fwd_src &&\n\t*s->cirrus_rop != cirrus_bitblt_rop_bkwd_src)\n\tnotify = 0;\n\n    /* we have to flush all pending changes so that the copy\n       is generated at the appropriate moment in time */\n    if (notify)\n\tvga_hw_update();\n\n    (*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t      s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    if (notify)\n\ts->ds->dpy_copy(s->ds,\n\t\t\tsx, sy, dx, dy,\n\t\t\ts->cirrus_blt_width / depth,\n\t\t\ts->cirrus_blt_height);\n\n    /* we don't have to notify the display that this portion has\n       changed since dpy_copy implies this */\n\n    if (!notify)\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 135590882627853658533498335902319684573,
        "size": 66,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,\n                             uint8_t *dst,const uint8_t *src,\n                             int dstpitch,int srcpitch,\n                             int bltwidth,int bltheight)\n{\n    int x,y;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x++) {\n            ROP_OP(*dst, *src);\n            dst++;\n            src++;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 27696392987383562433164405181263025184,
        "size": 18,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\t(*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t\t  s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 331046290845234389374470092408344022350,
        "size": 19,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,\n\t\t\t\t\t     unsigned mode,\n\t\t\t\t\t     unsigned offset,\n\t\t\t\t\t     uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t}\n\tval <<= 1;\n\tdst++;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 50418188797463436407734640880675508745,
        "size": 22,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\t\t\t\t\t    const uint8_t * src)\n{\n    uint8_t *dst;\n\n    dst = s->vram_ptr + s->cirrus_blt_dstaddr;\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 176630228639235556421341667256894067184,
        "size": 14,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 335738960224286063332470333845363880021,
        "size": 19,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vram_ptr +\n                                            (s->cirrus_blt_srcaddr & ~7));\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 58384268221957848687614989550830035306,
        "size": 6,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n{\n    cirrus_fill_t rop_func;\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n    rop_func(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n             s->cirrus_blt_dstpitch,\n             s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t     s->cirrus_blt_height);\n    cirrus_bitblt_reset(s);\n    return 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 149842811940934737817714037905575936616,
        "size": 14,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static void cirrus_bitblt_cputovideo_next(CirrusVGAState * s)\n{\n    int copy_count;\n    uint8_t *end_ptr;\n\n    if (s->cirrus_srccounter > 0) {\n        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n            cirrus_bitblt_common_patterncopy(s, s->cirrus_bltbuf);\n        the_end:\n            s->cirrus_srccounter = 0;\n            cirrus_bitblt_reset(s);\n        } else {\n            /* at least one scan line */\n            do {\n                (*s->cirrus_rop)(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n                                 s->cirrus_bltbuf, 0, 0, s->cirrus_blt_width, 1);\n                cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,\n                                         s->cirrus_blt_width, 1);\n                s->cirrus_blt_dstaddr += s->cirrus_blt_dstpitch;\n                s->cirrus_srccounter -= s->cirrus_blt_srcpitch;\n                if (s->cirrus_srccounter <= 0)\n                    goto the_end;\n                /* more bytes than needed can be transfered because of\n                   word alignment, so we keep them for the next line */\n                /* XXX: keep alignment to speed up transfer */\n                end_ptr = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n                copy_count = s->cirrus_srcptr_end - end_ptr;\n                memmove(s->cirrus_bltbuf, end_ptr, copy_count);\n                s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;\n                s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n            } while (s->cirrus_srcptr >= s->cirrus_srcptr_end);\n        }\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 246597330759913647803692062244246778621,
        "size": 34,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s,\n\t\t\t\t\t      unsigned mode,\n\t\t\t\t\t      unsigned offset,\n\t\t\t\t\t      uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t    *(dst + 1) = s->gr[0x11];\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t    *(dst + 1) = s->gr[0x10];\n\t}\n\tval <<= 1;\n\tdst += 2;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 15);\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef",
        "hash": 241662835431977252361369897799666577695,
        "size": 24,
        "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\n    if (BLTUNSAFE(s))\n        return 0;\n\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "65d35a09979e63541afc5bfc595b9f1b1b4ae069",
        "hash": 128516004862549772575527502984330639841,
        "size": 25,
        "message": "CVE-2008-4539: fix a heap overflow in Cirrus emulation\n\nThe code in hw/cirrus_vga.c has changed a lot between CVE-2007-1320 has\nbeen announced and the patch has been applied. As a consequence it has\nwrongly applied and QEMU is still vulnerable to this bug if using VNC.\n\n(noticed by Jan Niehusmann)\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@5587 c046a42c-6fe2-441c-8c8c-71466251a162"
    },
    {
        "func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-119",
            "CWE-787"
        ],
        "project": "nbd",
        "commit_id": "3ef52043861ab16352d49af89e048ba6339d6df8",
        "hash": 168268959423393978625601902172027564201,
        "size": 93,
        "message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh."
    },
    {
        "func": "read_channel_data (FILE       *f,\n                   PSPimage   *ia,\n                   guchar    **pixels,\n                   guint       bytespp,\n                   guint       offset,\n                   GimpDrawable  *drawable,\n                   guint32     compressed_len)\n{\n  gint i, y, width = drawable->width, height = drawable->height;\n  gint npixels = width * height;\n  guchar *buf, *p, *q, *endq;\n  guchar *buf2 = NULL;  /* please the compiler */\n  guchar runcount, byte;\n  z_stream zstream;\n\n  switch (ia->compression)\n    {\n    case PSP_COMP_NONE:\n      if (bytespp == 1)\n        {\n          if ((width % 4) == 0)\n            fread (pixels[0], height * width, 1, f);\n          else\n            {\n              for (y = 0; y < height; y++)\n                {\n                  fread (pixels[y], width, 1, f);\n                  fseek (f, 4 - (width % 4), SEEK_CUR);\n                }\n            }\n        }\n      else\n        {\n          buf = g_malloc (width);\n          for (y = 0; y < height; y++)\n            {\n              fread (buf, width, 1, f);\n              if (width % 4)\n                fseek (f, 4 - (width % 4), SEEK_CUR);\n              p = buf;\n              q = pixels[y] + offset;\n              for (i = 0; i < width; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n          g_free (buf);\n        }\n      break;\n\n    case PSP_COMP_RLE:\n      q = pixels[0] + offset;\n      endq = q + npixels * bytespp;\n      buf = g_malloc (127);\n      while (q < endq)\n        {\n          p = buf;\n          fread (&runcount, 1, 1, f);\n          if (runcount > 128)\n            {\n              runcount -= 128;\n              fread (&byte, 1, 1, f);\n              memset (buf, byte, runcount);\n            }\n          else\n            fread (buf, runcount, 1, f);\n          if (bytespp == 1)\n            {\n              memmove (q, buf, runcount);\n              q += runcount;\n            }\n          else\n            {\n              p = buf;\n              for (i = 0; i < runcount; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n        }\n      g_free (buf);\n      break;\n\n    case PSP_COMP_LZ77:\n      buf = g_malloc (compressed_len);\n      fread (buf, compressed_len, 1, f);\n      zstream.next_in = buf;\n      zstream.avail_in = compressed_len;\n      zstream.zalloc = psp_zalloc;\n      zstream.zfree = psp_zfree;\n      zstream.opaque = f;\n      if (inflateInit (&zstream) != Z_OK)\n        {\n          g_message (\"zlib error\");\n          return -1;\n        }\n      if (bytespp == 1)\n        zstream.next_out = pixels[0];\n      else\n        {\n          buf2 = g_malloc (npixels);\n          zstream.next_out = buf2;\n        }\n      zstream.avail_out = npixels;\n      if (inflate (&zstream, Z_FINISH) != Z_STREAM_END)\n        {\n          g_message (\"zlib error\");\n          inflateEnd (&zstream);\n          return -1;\n        }\n      inflateEnd (&zstream);\n      g_free (buf);\n\n      if (bytespp > 1)\n        {\n          p = buf2;\n          q = pixels[0] + offset;\n          for (i = 0; i < npixels; i++)\n            {\n              *q = *p++;\n              q += bytespp;\n            }\n          g_free (buf2);\n        }\n      break;\n    }\n\n  return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "gimp",
        "commit_id": "48ec15890e1751dede061f6d1f469b6508c13439",
        "hash": 268527682097671800466654253912840631017,
        "size": 131,
        "message": "file-psp: fix for bogus input data. Fixes bug #639203"
    },
    {
        "func": "LZWReadByte (FILE *fd,\n             gint  just_reset_LZW,\n             gint  input_code_size)\n{\n  static gint fresh = FALSE;\n  gint        code, incode;\n  static gint code_size, set_code_size;\n  static gint max_code, max_code_size;\n  static gint firstcode, oldcode;\n  static gint clear_code, end_code;\n  static gint table[2][(1 << MAX_LZW_BITS)];\n  static gint stack[(1 << (MAX_LZW_BITS)) * 2], *sp;\n  gint        i;\n\n  if (just_reset_LZW)\n    {\n      if (input_code_size > MAX_LZW_BITS)\n        {\n          g_message (\"Value out of range for code size (corrupted file?)\");\n          return -1;\n        }\n\n      set_code_size = input_code_size;\n      code_size     = set_code_size + 1;\n      clear_code    = 1 << set_code_size;\n      end_code      = clear_code + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      GetCode (fd, 0, TRUE);\n\n      fresh = TRUE;\n\n      sp = stack;\n\n      for (i = 0; i < clear_code; ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = i;\n        }\n      for (; i < (1 << MAX_LZW_BITS); ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = 0;\n        }\n\n      return 0;\n    }\n  else if (fresh)\n    {\n      fresh = FALSE;\n      do\n        {\n          firstcode = oldcode = GetCode (fd, code_size, FALSE);\n        }\n      while (firstcode == clear_code);\n\n      return firstcode & 255;\n    }\n\n  if (sp > stack)\n    return (*--sp) & 255;\n\n  while ((code = GetCode (fd, code_size, FALSE)) >= 0)\n    {\n      if (code == clear_code)\n        {\n          for (i = 0; i < clear_code; ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = i;\n            }\n          for (; i < (1 << MAX_LZW_BITS); ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = 0;\n            }\n\n          code_size     = set_code_size + 1;\n          max_code_size = 2 * clear_code;\n          max_code      = clear_code + 2;\n          sp            = stack;\n          firstcode     = oldcode = GetCode (fd, code_size, FALSE);\n\n          return firstcode & 255;\n        }\n      else if (code == end_code)\n        {\n          gint   count;\n          guchar buf[260];\n\n          if (ZeroDataBlock)\n            return -2;\n\n          while ((count = GetDataBlock (fd, buf)) > 0)\n            ;\n\n          if (count != 0)\n            g_print (\"GIF: missing EOD in data stream (common occurence)\");\n\n          return -2;\n        }\n\n      incode = code;\n\n      if (code >= max_code)\n        {\n          *sp++ = firstcode;\n          code = oldcode;\n        }\n\n      while (code >= clear_code)\n        {\n          *sp++ = table[1][code];\n          if (code == table[0][code])\n            {\n              g_message (\"Circular table entry.  Corrupt file.\");\n              gimp_quit ();\n            }\n          code = table[0][code];\n        }\n\n      *sp++ = firstcode = table[1][code];\n\n      if ((code = max_code) < (1 << MAX_LZW_BITS))\n        {\n          table[0][code] = oldcode;\n          table[1][code] = firstcode;\n          ++max_code;\n          if ((max_code >= max_code_size) &&\n              (max_code_size < (1 << MAX_LZW_BITS)))\n            {\n              max_code_size *= 2;\n              ++code_size;\n            }\n        }\n\n      oldcode = incode;\n\n      if (sp > stack)\n        return (*--sp) & 255;\n    }\n\n  return code & 255;\n}",
        "target": 1,
        "cwe": [
            "CWE-787"
        ],
        "project": "gimp",
        "commit_id": "376ad788c1a1c31d40f18494889c383f6909ebfc",
        "hash": 262460488929992643848907634827404054084,
        "size": 145,
        "message": "file-gif-load: fix heap corruption and buffer overflow (CVE-2011-2896)"
    },
    {
        "func": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->sector_count;\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    r->iov.iov_len = n * 512;\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-119",
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "hash": 213245298169248322012872751185147846432,
        "size": 45,
        "message": "scsi-disk: commonize iovec creation between reads and writes\n\nAlso, consistently use qiov.size instead of iov.iov_len.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"
    },
    {
        "func": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-119",
            "CWE-787"
        ],
        "project": "qemu",
        "commit_id": "103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "hash": 62207758564897816562478888853378352571,
        "size": 33,
        "message": "scsi-disk: commonize iovec creation between reads and writes\n\nAlso, consistently use qiov.size instead of iov.iov_len.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"
    },
    {
        "func": "theme_adium_append_message (EmpathyChatView *view,\n\t\t\t    EmpathyMessage  *msg)\n{\n\tEmpathyThemeAdium     *theme = EMPATHY_THEME_ADIUM (view);\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tEmpathyContact        *sender;\n\tTpMessage             *tp_msg;\n\tTpAccount             *account;\n\tgchar                 *body_escaped;\n\tconst gchar           *name;\n\tconst gchar           *contact_id;\n\tEmpathyAvatar         *avatar;\n\tconst gchar           *avatar_filename = NULL;\n\tgint64                 timestamp;\n\tconst gchar           *html = NULL;\n\tconst gchar           *func;\n\tconst gchar           *service_name;\n\tGString               *message_classes = NULL;\n\tgboolean               is_backlog;\n\tgboolean               consecutive;\n\tgboolean               action;\n\n\tif (priv->pages_loading != 0) {\n\t\tqueue_item (&priv->message_queue, QUEUED_MESSAGE, msg, NULL);\n\t\treturn;\n\t}\n\n\t/* Get information */\n\tsender = empathy_message_get_sender (msg);\n\taccount = empathy_contact_get_account (sender);\n\tservice_name = empathy_protocol_name_to_display_name\n\t\t(tp_account_get_protocol (account));\n\tif (service_name == NULL)\n\t\tservice_name = tp_account_get_protocol (account);\n\ttimestamp = empathy_message_get_timestamp (msg);\n\tbody_escaped = theme_adium_parse_body (theme,\n\t\tempathy_message_get_body (msg),\n\t\tempathy_message_get_token (msg));\n\tname = empathy_contact_get_logged_alias (sender);\n\tcontact_id = empathy_contact_get_id (sender);\n\taction = (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION);\n\n\t/* If this is a /me probably */\n\tif (action) {\n\t\tgchar *str;\n\n\t\tif (priv->data->version >= 4 || !priv->data->custom_template) {\n\t\t\tstr = g_strdup_printf (\"<span class='actionMessageUserName'>%s</span>\"\n\t\t\t\t\t       \"<span class='actionMessageBody'>%s</span>\",\n\t\t\t\t\t       name, body_escaped);\n\t\t} else {\n\t\t\tstr = g_strdup_printf (\"*%s*\", body_escaped);\n\t\t}\n\t\tg_free (body_escaped);\n\t\tbody_escaped = str;\n\t}\n\n\t/* Get the avatar filename, or a fallback */\n\tavatar = empathy_contact_get_avatar (sender);\n\tif (avatar) {\n\t\tavatar_filename = avatar->filename;\n\t}\n\tif (!avatar_filename) {\n\t\tif (empathy_contact_is_user (sender)) {\n\t\t\tavatar_filename = priv->data->default_outgoing_avatar_filename;\n\t\t} else {\n\t\t\tavatar_filename = priv->data->default_incoming_avatar_filename;\n\t\t}\n\t\tif (!avatar_filename) {\n\t\t\tif (!priv->data->default_avatar_filename) {\n\t\t\t\tpriv->data->default_avatar_filename =\n\t\t\t\t\tempathy_filename_from_icon_name (EMPATHY_IMAGE_AVATAR_DEFAULT,\n\t\t\t\t\t\t\t\t\t GTK_ICON_SIZE_DIALOG);\n\t\t\t}\n\t\t\tavatar_filename = priv->data->default_avatar_filename;\n\t\t}\n\t}\n\n\t/* We want to join this message with the last one if\n\t * - senders are the same contact,\n\t * - last message was recieved recently,\n\t * - last message and this message both are/aren't backlog, and\n\t * - DisableCombineConsecutive is not set in theme's settings */\n\tis_backlog = empathy_message_is_backlog (msg);\n\tconsecutive = empathy_contact_equal (priv->last_contact, sender) &&\n\t\t(timestamp - priv->last_timestamp < MESSAGE_JOIN_PERIOD) &&\n\t\t(is_backlog == priv->last_is_backlog) &&\n\t\t!tp_asv_get_boolean (priv->data->info,\n\t\t\t\t     \"DisableCombineConsecutive\", NULL);\n\n\t/* Define message classes */\n\tmessage_classes = g_string_new (\"message\");\n\tif (!priv->has_focus && !is_backlog) {\n\t\tif (!priv->has_unread_message) {\n\t\t\tg_string_append (message_classes, \" firstFocus\");\n\t\t\tpriv->has_unread_message = TRUE;\n\t\t}\n\t\tg_string_append (message_classes, \" focus\");\n\t}\n\tif (is_backlog) {\n\t\tg_string_append (message_classes, \" history\");\n\t}\n\tif (consecutive) {\n\t\tg_string_append (message_classes, \" consecutive\");\n\t}\n\tif (empathy_contact_is_user (sender)) {\n\t\tg_string_append (message_classes, \" outgoing\");\n\t} else {\n\t\tg_string_append (message_classes, \" incoming\");\n\t}\n\tif (empathy_message_should_highlight (msg)) {\n\t\tg_string_append (message_classes, \" mention\");\n\t}\n\tif (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY) {\n\t\tg_string_append (message_classes, \" autoreply\");\n\t}\n\tif (action) {\n\t\tg_string_append (message_classes, \" action\");\n\t}\n\t/* FIXME: other classes:\n\t * status - the message is a status change\n\t * event - the message is a notification of something happening\n\t *         (for example, encryption being turned on)\n\t * %status% - See %status% in theme_adium_append_html ()\n\t */\n\n\t/* This is slightly a hack, but it's the only way to add\n\t * arbitrary data to messages in the HTML. We add another\n\t * class called \"x-empathy-message-id-*\" to the message. This\n\t * way, we can remove the unread marker for this specific\n\t * message later. */\n\ttp_msg = empathy_message_get_tp_message (msg);\n\tif (tp_msg != NULL) {\n\t\tguint32 id;\n\t\tgboolean valid;\n\n\t\tid = tp_message_get_pending_message_id (tp_msg, &valid);\n\t\tif (valid) {\n\t\t\tg_string_append_printf (message_classes,\n\t\t\t    \" x-empathy-message-id-%u\", id);\n\t\t}\n\t}\n\n\t/* Define javascript function to use */\n\tif (consecutive) {\n\t\tfunc = priv->allow_scrolling ? \"appendNextMessage\" : \"appendNextMessageNoScroll\";\n\t} else {\n\t\tfunc = priv->allow_scrolling ? \"appendMessage\" : \"appendMessageNoScroll\";\n\t}\n\n\tif (empathy_contact_is_user (sender)) {\n\t\t/* out */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->out_nextcontext_html : priv->data->out_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->out_nextcontent_html : priv->data->out_content_html;\n\t\t}\n\n\t\t/* remove all the unread marks when we are sending a message */\n\t\ttheme_adium_remove_all_focus_marks (theme);\n\t} else {\n\t\t/* in */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->in_nextcontext_html : priv->data->in_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->in_nextcontent_html : priv->data->in_content_html;\n\t\t}\n\t}\n\n\ttheme_adium_append_html (theme, func, html, body_escaped,\n\t\t\t\t avatar_filename, name, contact_id,\n\t\t\t\t service_name, message_classes->str,\n\t\t\t\t timestamp, is_backlog, empathy_contact_is_user (sender));\n\n\t/* Keep the sender of the last displayed message */\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t}\n\tpriv->last_contact = g_object_ref (sender);\n\tpriv->last_timestamp = timestamp;\n\tpriv->last_is_backlog = is_backlog;\n\n\tg_free (body_escaped);\n\tg_string_free (message_classes, TRUE);\n}",
        "target": 1,
        "cwe": [
            "CWE-79"
        ],
        "project": "empathy",
        "commit_id": "739aca418457de752be13721218aaebc74bd9d36",
        "hash": 254126956197139691281133098433587437850,
        "size": 189,
        "message": "theme_adium_append_message: escape alias before displaying it\n\nNot doing so can lead to nasty HTML injection from hostile users.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=662035"
    },
    {
        "func": "theme_adium_append_message (EmpathyChatView *view,\n\t\t\t    EmpathyMessage  *msg)\n{\n\tEmpathyThemeAdium     *theme = EMPATHY_THEME_ADIUM (view);\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tEmpathyContact        *sender;\n\tTpMessage             *tp_msg;\n\tTpAccount             *account;\n\tgchar                 *body_escaped, *name_escaped;\n\tconst gchar           *name;\n\tconst gchar           *contact_id;\n\tEmpathyAvatar         *avatar;\n\tconst gchar           *avatar_filename = NULL;\n\tgint64                 timestamp;\n\tconst gchar           *html = NULL;\n\tconst gchar           *func;\n\tconst gchar           *service_name;\n\tGString               *message_classes = NULL;\n\tgboolean               is_backlog;\n\tgboolean               consecutive;\n\tgboolean               action;\n\n\tif (priv->pages_loading != 0) {\n\t\tqueue_item (&priv->message_queue, QUEUED_MESSAGE, msg, NULL);\n\t\treturn;\n\t}\n\n\t/* Get information */\n\tsender = empathy_message_get_sender (msg);\n\taccount = empathy_contact_get_account (sender);\n\tservice_name = empathy_protocol_name_to_display_name\n\t\t(tp_account_get_protocol (account));\n\tif (service_name == NULL)\n\t\tservice_name = tp_account_get_protocol (account);\n\ttimestamp = empathy_message_get_timestamp (msg);\n\tbody_escaped = theme_adium_parse_body (theme,\n\t\tempathy_message_get_body (msg),\n\t\tempathy_message_get_token (msg));\n\tname = empathy_contact_get_logged_alias (sender);\n\tcontact_id = empathy_contact_get_id (sender);\n\taction = (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION);\n\n\t/* If this is a /me probably */\n\tif (action) {\n\t\tgchar *str;\n\n\t\tif (priv->data->version >= 4 || !priv->data->custom_template) {\n\t\t\tstr = g_strdup_printf (\"<span class='actionMessageUserName'>%s</span>\"\n\t\t\t\t\t       \"<span class='actionMessageBody'>%s</span>\",\n\t\t\t\t\t       name, body_escaped);\n\t\t} else {\n\t\t\tstr = g_strdup_printf (\"*%s*\", body_escaped);\n\t\t}\n\t\tg_free (body_escaped);\n\t\tbody_escaped = str;\n\t}\n\n\t/* Get the avatar filename, or a fallback */\n\tavatar = empathy_contact_get_avatar (sender);\n\tif (avatar) {\n\t\tavatar_filename = avatar->filename;\n\t}\n\tif (!avatar_filename) {\n\t\tif (empathy_contact_is_user (sender)) {\n\t\t\tavatar_filename = priv->data->default_outgoing_avatar_filename;\n\t\t} else {\n\t\t\tavatar_filename = priv->data->default_incoming_avatar_filename;\n\t\t}\n\t\tif (!avatar_filename) {\n\t\t\tif (!priv->data->default_avatar_filename) {\n\t\t\t\tpriv->data->default_avatar_filename =\n\t\t\t\t\tempathy_filename_from_icon_name (EMPATHY_IMAGE_AVATAR_DEFAULT,\n\t\t\t\t\t\t\t\t\t GTK_ICON_SIZE_DIALOG);\n\t\t\t}\n\t\t\tavatar_filename = priv->data->default_avatar_filename;\n\t\t}\n\t}\n\n\t/* We want to join this message with the last one if\n\t * - senders are the same contact,\n\t * - last message was recieved recently,\n\t * - last message and this message both are/aren't backlog, and\n\t * - DisableCombineConsecutive is not set in theme's settings */\n\tis_backlog = empathy_message_is_backlog (msg);\n\tconsecutive = empathy_contact_equal (priv->last_contact, sender) &&\n\t\t(timestamp - priv->last_timestamp < MESSAGE_JOIN_PERIOD) &&\n\t\t(is_backlog == priv->last_is_backlog) &&\n\t\t!tp_asv_get_boolean (priv->data->info,\n\t\t\t\t     \"DisableCombineConsecutive\", NULL);\n\n\t/* Define message classes */\n\tmessage_classes = g_string_new (\"message\");\n\tif (!priv->has_focus && !is_backlog) {\n\t\tif (!priv->has_unread_message) {\n\t\t\tg_string_append (message_classes, \" firstFocus\");\n\t\t\tpriv->has_unread_message = TRUE;\n\t\t}\n\t\tg_string_append (message_classes, \" focus\");\n\t}\n\tif (is_backlog) {\n\t\tg_string_append (message_classes, \" history\");\n\t}\n\tif (consecutive) {\n\t\tg_string_append (message_classes, \" consecutive\");\n\t}\n\tif (empathy_contact_is_user (sender)) {\n\t\tg_string_append (message_classes, \" outgoing\");\n\t} else {\n\t\tg_string_append (message_classes, \" incoming\");\n\t}\n\tif (empathy_message_should_highlight (msg)) {\n\t\tg_string_append (message_classes, \" mention\");\n\t}\n\tif (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY) {\n\t\tg_string_append (message_classes, \" autoreply\");\n\t}\n\tif (action) {\n\t\tg_string_append (message_classes, \" action\");\n\t}\n\t/* FIXME: other classes:\n\t * status - the message is a status change\n\t * event - the message is a notification of something happening\n\t *         (for example, encryption being turned on)\n\t * %status% - See %status% in theme_adium_append_html ()\n\t */\n\n\t/* This is slightly a hack, but it's the only way to add\n\t * arbitrary data to messages in the HTML. We add another\n\t * class called \"x-empathy-message-id-*\" to the message. This\n\t * way, we can remove the unread marker for this specific\n\t * message later. */\n\ttp_msg = empathy_message_get_tp_message (msg);\n\tif (tp_msg != NULL) {\n\t\tguint32 id;\n\t\tgboolean valid;\n\n\t\tid = tp_message_get_pending_message_id (tp_msg, &valid);\n\t\tif (valid) {\n\t\t\tg_string_append_printf (message_classes,\n\t\t\t    \" x-empathy-message-id-%u\", id);\n\t\t}\n\t}\n\n\t/* Define javascript function to use */\n\tif (consecutive) {\n\t\tfunc = priv->allow_scrolling ? \"appendNextMessage\" : \"appendNextMessageNoScroll\";\n\t} else {\n\t\tfunc = priv->allow_scrolling ? \"appendMessage\" : \"appendMessageNoScroll\";\n\t}\n\n\tif (empathy_contact_is_user (sender)) {\n\t\t/* out */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->out_nextcontext_html : priv->data->out_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->out_nextcontent_html : priv->data->out_content_html;\n\t\t}\n\n\t\t/* remove all the unread marks when we are sending a message */\n\t\ttheme_adium_remove_all_focus_marks (theme);\n\t} else {\n\t\t/* in */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->in_nextcontext_html : priv->data->in_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->in_nextcontent_html : priv->data->in_content_html;\n\t\t}\n\t}\n\n\tname_escaped = g_markup_escape_text (name, -1);\n\n\ttheme_adium_append_html (theme, func, html, body_escaped,\n\t\t\t\t avatar_filename, name_escaped, contact_id,\n\t\t\t\t service_name, message_classes->str,\n\t\t\t\t timestamp, is_backlog, empathy_contact_is_user (sender));\n\n\t/* Keep the sender of the last displayed message */\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t}\n\tpriv->last_contact = g_object_ref (sender);\n\tpriv->last_timestamp = timestamp;\n\tpriv->last_is_backlog = is_backlog;\n\n\tg_free (body_escaped);\n\tg_free (name_escaped);\n\tg_string_free (message_classes, TRUE);\n}",
        "target": 1,
        "cwe": [
            "CWE-79"
        ],
        "project": "empathy",
        "commit_id": "15a4eec2f156c4f60398a9d842279203f475ed89",
        "hash": 173823105561549440192741583855967113472,
        "size": 192,
        "message": "theme-adium: escape the name in actions as well"
    },
    {
        "func": "static void pdfobj_flag(struct pdf_struct *pdf, struct pdf_obj *obj, enum pdf_flag flag)\n{\n    const char *s= \"\";\n    pdf->flags |= 1 << flag;\n    if (!cli_debug_flag)\n\treturn;\n    switch (flag) {\n\tcase UNTERMINATED_OBJ_DICT:\n\t    s = \"dictionary not terminated\";\n\t    break;\n\tcase ESCAPED_COMMON_PDFNAME:\n\t    /* like /JavaScript */\n\t    s = \"escaped common pdfname\";\n\t    break;\n\tcase BAD_STREAM_FILTERS:\n\t    s = \"duplicate stream filters\";\n\t    break;\n\tcase BAD_PDF_VERSION:\n\t    s = \"bad pdf version\";\n\t    break;\n\tcase BAD_PDF_HEADERPOS:\n\t    s = \"bad pdf header position\";\n\t    break;\n\tcase BAD_PDF_TRAILER:\n\t    s = \"bad pdf trailer\";\n\t    break;\n\tcase BAD_PDF_TOOMANYOBJS:\n\t    s = \"too many pdf objs\";\n\t    break;\n\tcase BAD_FLATE:\n\t    s = \"bad deflate stream\";\n\t    break;\n\tcase BAD_FLATESTART:\n\t    s = \"bad deflate stream start\";\n\t    break;\n\tcase BAD_STREAMSTART:\n\t    s = \"bad stream start\";\n\t    break;\n\tcase UNKNOWN_FILTER:\n\t    s = \"unknown filter used\";\n\t    break;\n\tcase BAD_ASCIIDECODE:\n\t    s = \"bad ASCII decode\";\n\t    break;\n\tcase HEX_JAVASCRIPT:\n\t    s = \"hex javascript\";\n\t    break;\n\tcase BAD_INDOBJ:\n\t    s = \"referencing nonexistent obj\";\n\t    break;\n\tcase HAS_OPENACTION:\n\t    s = \"has /OpenAction\";\n\t    break;\n\tcase HAS_LAUNCHACTION:\n\t    s = \"has /LaunchAction\";\n\t    break;\n\tcase BAD_STREAMLEN:\n\t    s = \"bad /Length, too small\";\n\t    break;\n\tcase ENCRYPTED_PDF:\n\t    s = \"PDF is encrypted\";\n\t    break;\n\tcase LINEARIZED_PDF:\n\t    s = \"linearized PDF\";\n\t    break;\n\tcase MANY_FILTERS:\n\t    s = \"more than 2 filters per obj\";\n\t    break;\n    }\n    cli_dbgmsg(\"cli_pdf: %s flagged in object %u %u\\n\", s, obj->id>>8, obj->id&0xff);\n}",
        "target": 1,
        "cwe": [
            "CWE-119",
            "CWE-189",
            "CWE-79"
        ],
        "project": "clamav-devel",
        "commit_id": "24ff855c82d3f5c62bc5788a5776cefbffce2971",
        "hash": 57739306186896487130282252690250888554,
        "size": 71,
        "message": "pdf: bb #7053"
    },
    {
        "func": "static void pdf_parseobj(struct pdf_struct *pdf, struct pdf_obj *obj)\n{\n    /* enough to hold common pdf names, we don't need all the names */\n    char pdfname[64];\n    const char *q2, *q3;\n    const char *q = obj->start + pdf->map;\n    const char *dict, *start;\n    off_t dict_length;\n    off_t bytesleft = obj_size(pdf, obj, 1);\n    unsigned i, filters=0;\n    enum objstate objstate = STATE_NONE;\n\n    if (bytesleft < 0)\n\treturn;\n    start = q;\n    /* find start of dictionary */\n    do {\n\tq2 = pdf_nextobject(q, bytesleft);\n\tbytesleft -= q2 -q;\n\tif (!q2 || bytesleft < 0) {\n\t    return;\n\t}\n\tq3 = memchr(q-1, '<', q2-q+1);\n\tq2++;\n\tbytesleft--;\n\tq = q2;\n    } while (!q3 || q3[1] != '<');\n    dict = q3+2;\n    q = dict;\n    bytesleft = obj_size(pdf, obj, 1) - (q - start);\n    /* find end of dictionary */\n    do {\n\tq2 = pdf_nextobject(q, bytesleft);\n\tbytesleft -= q2 -q;\n\tif (!q2 || bytesleft < 0) {\n\t    return;\n\t}\n\tq3 = memchr(q-1, '>', q2-q+1);\n\tq2++;\n\tbytesleft--;\n\tq = q2;\n    } while (!q3 || q3[1] != '>');\n    obj->flags |= 1 << OBJ_DICT;\n    dict_length = q3 - dict;\n\n    /*  process pdf names */\n    for (q = dict;dict_length > 0;) {\n\tint escapes = 0;\n\tq2 = memchr(q, '/', dict_length);\n\tif (!q2)\n\t    break;\n\tdict_length -= q2 - q;\n\tq = q2;\n\t/* normalize PDF names */\n\tfor (i = 0;dict_length > 0 && (i < sizeof(pdfname)-1); i++) {\n\t    q++;\n\t    dict_length--;\n\t    if (*q == '#') {\n\t\tif (cli_hex2str_to(q+1, pdfname+i, 2) == -1)\n\t\t    break;\n\t\tq += 2;\n\t\tdict_length -= 2;\n\t\tescapes = 1;\n\t\tcontinue;\n\t    }\n\t    if (*q == ' ' || *q == '\\t' || *q == '\\r' || *q == '\\n' ||\n\t\t*q == '/' || *q == '>' || *q == ']' || *q == '[' || *q == '<'\n\t\t|| *q == '(')\n\t\tbreak;\n\t    pdfname[i] = *q;\n\t}\n\tpdfname[i] = '\\0';\n\n\thandle_pdfname(pdf, obj, pdfname, escapes, &objstate);\n\tif (objstate == STATE_LINEARIZED) {\n\t    long trailer_end, trailer;\n\t    pdfobj_flag(pdf, obj, LINEARIZED_PDF);\n\t    objstate = STATE_NONE;\n\t    trailer_end = pdf_readint(q, dict_length, \"/H\");\n\t    if (trailer_end > 0 && trailer_end < pdf->size) {\n\t\ttrailer = trailer_end - 1024;\n\t\tif (trailer < 0) trailer = 0;\n\t\tq2 = pdf->map + trailer;\n\t\tcli_dbgmsg(\"cli_pdf: looking for trailer in linearized pdf: %ld - %ld\\n\", trailer, trailer_end);\n\t\tpdf_parse_trailer(pdf, q2, trailer_end - trailer);\n\t\tif (pdf->fileID)\n\t\t    cli_dbgmsg(\"cli_pdf: found fileID\\n\");\n\t    }\n\t}\n\tif (objstate == STATE_LAUNCHACTION)\n\t    pdfobj_flag(pdf, obj, HAS_LAUNCHACTION);\n\tif (dict_length > 0 && (objstate == STATE_JAVASCRIPT ||\n\t    objstate == STATE_OPENACTION)) {\n\t    if (objstate == STATE_OPENACTION)\n\t\tpdfobj_flag(pdf, obj, HAS_OPENACTION);\n\t    q2 = pdf_nextobject(q, dict_length);\n\t    if (q2 && isdigit(*q2)) {\n\t\tuint32_t objid = atoi(q2) << 8;\n\t\twhile (isdigit(*q2)) q2++;\n\t\tq2 = pdf_nextobject(q2, dict_length);\n\t\tif (q2 && isdigit(*q2)) {\n\t\t    objid |= atoi(q2) & 0xff;\n\t\t    q2 = pdf_nextobject(q2, dict_length);\n\t\t    if (q2 && *q2 == 'R') {\n\t\t\tstruct pdf_obj *obj2;\n\t\t\tcli_dbgmsg(\"cli_pdf: found %s stored in indirect object %u %u\\n\",\n\t\t\t\t   pdfname,\n\t\t\t\t   objid >> 8, objid&0xff);\n\t\t\tobj2 = find_obj(pdf, obj, objid);\n\t\t\tif (obj2) {\n\t\t\t    enum pdf_objflags flag = objstate == STATE_JAVASCRIPT ?\n\t\t\t\tOBJ_JAVASCRIPT : OBJ_OPENACTION;\n\t\t\t    obj2->flags |= 1 << flag;\n\t\t\t    obj->flags &= ~(1 << flag);\n\t\t\t} else {\n\t\t\t    pdfobj_flag(pdf, obj, BAD_INDOBJ);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    objstate = STATE_NONE;\n\t}\n    }\n    for (i=0;i<sizeof(pdfname_actions)/sizeof(pdfname_actions[0]);i++) {\n\tconst struct pdfname_action *act = &pdfname_actions[i];\n\tif ((obj->flags & (1 << act->set_objflag)) &&\n\t    act->from_state == STATE_FILTER &&\n\t    act->to_state == STATE_FILTER &&\n\t    act->set_objflag != OBJ_FILTER_CRYPT &&\n\t    act->set_objflag != OBJ_FILTER_STANDARD) {\n\t    filters++;\n\t}\n    }\n    if (filters > 2) { /* more than 2 non-crypt filters */\n\tpdfobj_flag(pdf, obj, MANY_FILTERS);\n    }\n    if (obj->flags & ((1 << OBJ_SIGNED) | KNOWN_FILTERS))\n\tobj->flags &= ~(1 << OBJ_FILTER_UNKNOWN);\n    if (obj->flags & (1 << OBJ_FILTER_UNKNOWN))\n\tpdfobj_flag(pdf, obj, UNKNOWN_FILTER);\n    cli_dbgmsg(\"cli_pdf: %u %u obj flags: %02x\\n\", obj->id>>8, obj->id&0xff, obj->flags);\n}",
        "target": 1,
        "cwe": [
            "CWE-119",
            "CWE-189",
            "CWE-79"
        ],
        "project": "clamav-devel",
        "commit_id": "24ff855c82d3f5c62bc5788a5776cefbffce2971",
        "hash": 269085714966241484363378878310531989314,
        "size": 142,
        "message": "pdf: bb #7053"
    },
    {
        "func": "static int pdf_extract_obj(struct pdf_struct *pdf, struct pdf_obj *obj)\n{\n    char fullname[NAME_MAX + 1];\n    int fout;\n    off_t sum = 0;\n    int rc = CL_SUCCESS;\n    char *ascii_decoded = NULL;\n    int dump = 1;\n\n    /* TODO: call bytecode hook here, allow override dumpability */\n    if ((!(obj->flags & (1 << OBJ_STREAM)) ||\n\t(obj->flags & (1 << OBJ_HASFILTERS)))\n\t&& !(obj->flags & DUMP_MASK)) {\n\t/* don't dump all streams */\n\tdump = 0;\n    }\n    if ((obj->flags & (1 << OBJ_IMAGE)) &&\n\t!(obj->flags & (1 << OBJ_FILTER_DCT))) {\n\t/* don't dump / scan non-JPG images */\n\tdump = 0;\n    }\n    if (obj->flags & (1 << OBJ_FORCEDUMP)) {\n\t/* bytecode can force dump by setting this flag */\n\tdump = 1;\n    }\n    if (!dump)\n\treturn CL_CLEAN;\n    cli_dbgmsg(\"cli_pdf: dumping obj %u %u\\n\", obj->id>>8, obj->id);\n    snprintf(fullname, sizeof(fullname), \"%s\"PATHSEP\"pdf%02u\", pdf->dir, pdf->files++);\n    fout = open(fullname,O_RDWR|O_CREAT|O_EXCL|O_TRUNC|O_BINARY, 0600);\n    if (fout < 0) {\n\tchar err[128];\n\tcli_errmsg(\"cli_pdf: can't create temporary file %s: %s\\n\", fullname, cli_strerror(errno, err, sizeof(err)));\n\tfree(ascii_decoded);\n\treturn CL_ETMPFILE;\n    }\n\n    do {\n    if (obj->flags & (1 << OBJ_STREAM)) {\n\tconst char *start = pdf->map + obj->start;\n\toff_t p_stream = 0, p_endstream = 0;\n\toff_t length;\n\tfind_stream_bounds(start, pdf->size - obj->start,\n\t\t\t   pdf->size - obj->start,\n\t\t\t   &p_stream, &p_endstream);\n\tif (p_stream && p_endstream) {\n\t    const char *flate_in;\n\t    long ascii_decoded_size = 0;\n\t    size_t size = p_endstream - p_stream;\n\t    off_t orig_length;\n\n\t    length = find_length(pdf, obj, start, p_stream);\n\t    if (length < 0)\n\t\tlength = 0;\n\t    orig_length = length;\n\t    if (length > pdf->size || obj->start + p_stream + length > pdf->size) {\n\t\tcli_dbgmsg(\"cli_pdf: length out of file: %ld + %ld > %ld\\n\",\n\t\t\t   p_stream, length, pdf->size);\n\t\tlength = pdf->size - (obj->start + p_stream);\n\t    }\n\t    if (!(obj->flags & (1 << OBJ_FILTER_FLATE)) && length <= 0) {\n\t\tconst char *q = start + p_endstream;\n\t\tlength = size;\n\t\tq--;\n\t\tif (*q == '\\n') {\n\t\t    q--;\n\t\t    length--;\n\t\t    if (*q == '\\r')\n\t\t\tlength--;\n\t\t} else if (*q == '\\r') {\n\t\t    length--;\n\t\t}\n\t\tif (length < 0)\n\t\t    length = 0;\n\t\tcli_dbgmsg(\"cli_pdf: calculated length %ld\\n\", length);\n\t    } else {\n\t\tif (size > length+2) {\n\t\t    cli_dbgmsg(\"cli_pdf: calculated length %ld < %ld\\n\",\n\t\t\t       length, size);\n\t\t    length = size;\n\t\t}\n\t    }\n\t    if (orig_length && size > orig_length + 20) {\n\t\tcli_dbgmsg(\"cli_pdf: orig length: %ld, length: %ld, size: %ld\\n\",\n\t\t\t   orig_length, length, size);\n\t\tpdfobj_flag(pdf, obj, BAD_STREAMLEN);\n\t    }\n\t    if (!length)\n\t\tlength = size;\n\n\t    if (obj->flags & (1 << OBJ_FILTER_AH)) {\n\t\tascii_decoded = cli_malloc(length/2 + 1);\n\t\tif (!ascii_decoded) {\n\t\t    cli_errmsg(\"Cannot allocate memory for asciidecode\\n\");\n\t\t    rc = CL_EMEM;\n\t\t    break;\n\t\t}\n\t\tascii_decoded_size = asciihexdecode(start + p_stream,\n\t\t\t\t\t\t    length,\n\t\t\t\t\t\t    ascii_decoded);\n\t    } else if (obj->flags & (1 << OBJ_FILTER_A85)) {\n\t\tascii_decoded = cli_malloc(length*5);\n\t\tif (!ascii_decoded) {\n\t\t    cli_errmsg(\"Cannot allocate memory for asciidecode\\n\");\n\t\t    rc = CL_EMEM;\n\t\t    break;\n\t\t}\n\t\tascii_decoded_size = ascii85decode(start+p_stream,\n\t\t\t\t\t\t   length,\n\t\t\t\t\t\t   (unsigned char*)ascii_decoded);\n\t    }\n\t    if (ascii_decoded_size < 0) {\n\t\t/* don't flag for images or truncated objs*/\n\t\tif (!(obj->flags &\n\t\t      ((1 << OBJ_IMAGE) | (1 << OBJ_TRUNCATED))))\n\t\t    pdfobj_flag(pdf, obj, BAD_ASCIIDECODE);\n\t\tcli_dbgmsg(\"cli_pdf: failed to asciidecode in %u %u obj\\n\", obj->id>>8,obj->id&0xff);\n\t\tfree(ascii_decoded);\n\t\tascii_decoded = NULL;\n\t\t/* attempt to directly flatedecode it */\n\t    }\n\t    /* either direct or ascii-decoded input */\n\t    if (!ascii_decoded)\n\t\tascii_decoded_size = length;\n\t    flate_in = ascii_decoded ? ascii_decoded : start+p_stream;\n\n\t    if (obj->flags & (1 << OBJ_FILTER_FLATE)) {\n\t\tcli_dbgmsg(\"cli_pdf: deflate len %ld (orig %ld)\\n\", ascii_decoded_size, (long)orig_length);\n\t\trc = filter_flatedecode(pdf, obj, flate_in, ascii_decoded_size, fout, &sum);\n\t    } else {\n\t\tif (filter_writen(pdf, obj, fout, flate_in, ascii_decoded_size, &sum) != ascii_decoded_size)\n\t\t    rc = CL_EWRITE;\n\t    }\n\t}\n    } else if (obj->flags & (1 << OBJ_JAVASCRIPT)) {\n\tconst char *q2;\n\tconst char *q = pdf->map+obj->start;\n\t/* TODO: get obj-endobj size */\n\toff_t bytesleft = obj_size(pdf, obj, 0);\n\tif (bytesleft < 0)\n\t    break;\n\n\tq2 = cli_memstr(q, bytesleft, \"/JavaScript\", 11);\n\tif (!q2)\n\t    break;\n\tbytesleft -= q2 - q;\n\tdo {\n\tq2++;\n\tbytesleft--;\n\tq = pdf_nextobject(q2, bytesleft);\n\tif (!q)\n\t    break;\n\tbytesleft -= q - q2;\n\tq2 = q;\n\t} while (*q == '/');\n\tif (!q)\n\t    break;\n\tif (*q == '(') {\n\t    if (filter_writen(pdf, obj, fout, q+1, bytesleft-1, &sum) != (bytesleft-1)) {\n\t\trc = CL_EWRITE;\n\t\tbreak;\n\t    }\n\t} else if (*q == '<') {\n\t    char *decoded;\n\t    q2 = memchr(q+1, '>', bytesleft);\n\t    if (!q2) q2 = q + bytesleft;\n\t    decoded = cli_malloc(q2 - q);\n\t    if (!decoded) {\n\t\trc = CL_EMEM;\n\t\tbreak;\n\t    }\n\t    cli_hex2str_to(q2, decoded, q2-q-1);\n\t    decoded[q2-q-1] = '\\0';\n\t    cli_dbgmsg(\"cli_pdf: found hexadecimal encoded javascript in %u %u obj\\n\",\n\t\t       obj->id>>8, obj->id&0xff);\n\t    pdfobj_flag(pdf, obj, HEX_JAVASCRIPT);\n\t    filter_writen(pdf, obj, fout, decoded, q2-q-1, &sum);\n\t    free(decoded);\n\t}\n    } else {\n\toff_t bytesleft = obj_size(pdf, obj, 0);\n\tif (filter_writen(pdf, obj, fout , pdf->map + obj->start, bytesleft,&sum) != bytesleft)\n\t    rc = CL_EWRITE;\n    }\n    } while (0);\n    cli_dbgmsg(\"cli_pdf: extracted %ld bytes %u %u obj to %s\\n\", sum, obj->id>>8, obj->id&0xff, fullname);\n    if (sum) {\n\tint rc2;\n\tcli_updatelimits(pdf->ctx, sum);\n\t/* TODO: invoke bytecode on this pdf obj with metainformation associated\n\t * */\n\tlseek(fout, 0, SEEK_SET);\n\trc2 = cli_magic_scandesc(fout, pdf->ctx);\n\tif (rc2 == CL_VIRUS || rc == CL_SUCCESS)\n\t    rc = rc2;\n\tif (rc == CL_CLEAN) {\n\t    rc2 = run_pdf_hooks(pdf, PDF_PHASE_POSTDUMP, fout, obj - pdf->objs);\n\t    if (rc2 == CL_VIRUS)\n\t\trc = rc2;\n\t}\n    }\n    close(fout);\n    free(ascii_decoded);\n    if (!pdf->ctx->engine->keeptmp)\n\tif (cli_unlink(fullname) && rc != CL_VIRUS)\n\t    rc = CL_EUNLINK;\n    return rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-119",
            "CWE-189",
            "CWE-79"
        ],
        "project": "clamav-devel",
        "commit_id": "24ff855c82d3f5c62bc5788a5776cefbffce2971",
        "hash": 281142343032271992969451234162272681873,
        "size": 208,
        "message": "pdf: bb #7053"
    },
    {
        "func": "static void check_user_password(struct pdf_struct *pdf, int R, const char *O,\n\t\t\t\tconst char *U, int32_t P, int EM,\n\t\t\t\tunsigned length, unsigned oulen)\n{\n    unsigned i;\n    uint8_t result[16];\n    char data[32];\n    cli_md5_ctx md5;\n    struct arc4_state arc4;\n    unsigned password_empty = 0;\n\n    dbg_printhex(\"U: \", U, 32);\n    dbg_printhex(\"O: \", O, 32);\n    if (R == 5) {\n\tuint8_t result2[32];\n\tSHA256_CTX sha256;\n\t/* supplement to ISO3200, 3.5.2 Algorithm 3.11 */\n\tsha256_init(&sha256);\n\t/* user validation salt */\n\tsha256_update(&sha256, U+32, 8);\n\tsha256_final(&sha256, result2);\n\tdbg_printhex(\"Computed U\", result2, 32);\n\tif (!memcmp(result2, U, 32)) {\n\t    password_empty = 1;\n\t    /* Algorithm 3.2a could be used to recover encryption key */\n\t}\n    } else {\n\t/* 7.6.3.3 Algorithm 2 */\n\tcli_md5_init(&md5);\n\t/* empty password, password == padding */\n\tcli_md5_update(&md5, key_padding, 32);\n\tcli_md5_update(&md5, O, 32);\n\tP = le32_to_host(P);\n\tcli_md5_update(&md5, &P, 4);\n\tcli_md5_update(&md5, pdf->fileID, pdf->fileIDlen);\n\tif (R >= 4 && !EM) {\n\t    uint32_t v = 0xFFFFFFFF;\n\t    cli_md5_update(&md5, &v, 4);\n\t}\n\tcli_md5_final(result, &md5);\n\tif (R >= 3) {\n\t    if (length > 128)\n\t\tlength = 128;\n\t    for (i=0;i<50;i++) {\n\t\tcli_md5_init(&md5);\n\t\tcli_md5_update(&md5, result, length/8);\n\t\tcli_md5_final(result, &md5);\n\t    }\n\t}\n\tif (R == 2)\n\t    length = 40;\n\tpdf->keylen = length / 8;\n\tpdf->key = cli_malloc(pdf->keylen);\n\tif (!pdf->key)\n\t    return;\n\tmemcpy(pdf->key, result, pdf->keylen);\n\tdbg_printhex(\"md5\", result, 16);\n\tdbg_printhex(\"Candidate encryption key\", pdf->key, pdf->keylen);\n\n\t/* 7.6.3.3 Algorithm 6 */\n\tif (R == 2) {\n\t    /* 7.6.3.3 Algorithm 4 */\n\t    memcpy(data, key_padding, 32);\n\t    arc4_init(&arc4, pdf->key, pdf->keylen);\n\t    arc4_apply(&arc4, data, 32);\n\t    dbg_printhex(\"computed U (R2)\", data, 32);\n\t    if (!memcmp(data, U, 32))\n\t\tpassword_empty = 1;\n\t} else if (R >= 3) {\n\t    unsigned len = pdf->keylen;\n\t    /* 7.6.3.3 Algorithm 5 */\n\t    cli_md5_init(&md5);\n\t    cli_md5_update(&md5, key_padding, 32);\n\t    cli_md5_update(&md5, pdf->fileID, pdf->fileIDlen);\n\t    cli_md5_final(result, &md5);\n\t    memcpy(data, pdf->key, len);\n\t    arc4_init(&arc4, data, len);\n\t    arc4_apply(&arc4, result, 16);\n\t    for (i=1;i<=19;i++) {\n\t\tunsigned j;\n\t\tfor (j=0;j<len;j++)\n\t\t    data[j] = pdf->key[j] ^ i;\n\t\tarc4_init(&arc4, data, len);\n\t\tarc4_apply(&arc4, result, 16);\n\t    }\n\t    dbg_printhex(\"fileID\", pdf->fileID, pdf->fileIDlen);\n\t    dbg_printhex(\"computed U (R>=3)\", result, 16);\n\t    if (!memcmp(result, U, 16))\n\t\tpassword_empty = 1;\n\t} else {\n\t    cli_dbgmsg(\"cli_pdf: invalid revision %d\\n\", R);\n\t}\n    }\n    if (password_empty) {\n\tcli_dbgmsg(\"cli_pdf: user password is empty\\n\");\n\t/* The key we computed above is the key used to encrypt the streams.\n\t * We could decrypt it now if we wanted to */\n\tpdf->flags |= 1 << DECRYPTABLE_PDF;\n    } else {\n\tcli_dbgmsg(\"cli_pdf: user/owner password would be required for decryption\\n\");\n\t/* the key is not valid, we would need the user or the owner password to\n\t * decrypt */\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-119",
            "CWE-189",
            "CWE-79"
        ],
        "project": "clamav-devel",
        "commit_id": "24ff855c82d3f5c62bc5788a5776cefbffce2971",
        "hash": 256264027056176050132751849730897927608,
        "size": 104,
        "message": "pdf: bb #7053"
    },
    {
        "func": "static void pdf_handle_enc(struct pdf_struct *pdf)\n{\n    struct pdf_obj *obj;\n    uint32_t len, required_flags, n, R, P, length, EM, i, oulen;\n    char *O, *U;\n    const char *q, *q2;\n\n    if (pdf->enc_objid == ~0u)\n\treturn;\n    if (!pdf->fileID) {\n\tcli_dbgmsg(\"cli_pdf: pdf_handle_enc no file ID\\n\");\n\treturn;\n    }\n    obj = find_obj(pdf, pdf->objs, pdf->enc_objid);\n    if (!obj) {\n\tcli_dbgmsg(\"cli_pdf: can't find encrypted object %d %d\\n\", pdf->enc_objid>>8, pdf->enc_objid&0xff);\n\treturn;\n    }\n    len = obj_size(pdf, obj, 1);\n    q = pdf->map + obj->start;\n\n    O = U = NULL;\n    do {\n\tEM = pdf_readbool(q, len, \"/EncryptMetadata\", 1);\n\tP = pdf_readint(q, len, \"/P\");\n\tif (P == ~0u) {\n\t    cli_dbgmsg(\"cli_pdf: invalid P\\n\");\n\t    break;\n\t}\n\n\tq2 = cli_memstr(q, len, \"/Standard\", 9);\n\tif (!q2) {\n\t    cli_dbgmsg(\"cli_pdf: /Standard not found\\n\");\n\t    break;\n\t}\n\t/* we can have both of these:\n\t* /AESV2/Length /Standard/Length\n\t* /Length /Standard\n\t* make sure we don't mistake AES's length for Standard's */\n\tlength = pdf_readint(q2, len - (q2 - q), \"/Length\");\n\tif (length == ~0u)\n\t    length = pdf_readint(q, len, \"/Length\");\n\tif (length == ~0u)\n\t    length = 40;\n\tif (length < 40) {\n\t    cli_dbgmsg(\"cli_pdf: invalid length: %d\\n\", length);\n\t    length = 40;\n\t}\n\n\tR = pdf_readint(q, len, \"/R\");\n\tif (R == ~0u) {\n\t    cli_dbgmsg(\"cli_pdf: invalid R\\n\");\n\t    break;\n\t}\n\n\tif (R < 5)\n\t    oulen = 32;\n\telse\n\t    oulen = 48;\n\n\tn = 0;\n\tO = pdf_readstring(q, len, \"/O\", &n);\n\tif (!O || n < oulen) {\n\t    cli_dbgmsg(\"cli_pdf: invalid O: %d\\n\", n);\n\t    if (O)\n\t\tdbg_printhex(\"invalid O\", O, n);\n\t    break;\n\t}\n\tif (n > oulen) {\n\t    for (i=oulen;i<n;i++)\n\t\tif (O[i])\n\t\t    break;\n\t    if (i != n) {\n\t\tdbg_printhex(\"too long O\", O, n);\n\t\tbreak;\n\t    }\n\t}\n\n\tn = 0;\n\tU = pdf_readstring(q, len, \"/U\", &n);\n\tif (!U || n < oulen) {\n\t    cli_dbgmsg(\"cli_pdf: invalid U: %d\\n\", n);\n\t    if (U)\n\t\tdbg_printhex(\"invalid U\", U, n);\n\t    break;\n\t}\n\tif (n > oulen) {\n\t    for (i=oulen;i<n;i++)\n\t\tif (U[i])\n\t\t    break;\n\t    if (i != n) {\n\t\tdbg_printhex(\"too long U\", U, n);\n\t\tbreak;\n\t    }\n\t}\n\tcli_dbgmsg(\"cli_pdf: Encrypt R: %d, P %x, length: %d\\n\", R, P, length);\n\tif (length % 8) {\n\t    cli_dbgmsg(\"cli_pdf: wrong key length, not multiple of 8\\n\");\n\t    break;\n\t}\n\tcheck_user_password(pdf, R, O, U, P, EM, length, oulen);\n    } while (0);\n    free(O);\n    free(U);\n}",
        "target": 1,
        "cwe": [
            "CWE-119",
            "CWE-189",
            "CWE-79"
        ],
        "project": "clamav-devel",
        "commit_id": "24ff855c82d3f5c62bc5788a5776cefbffce2971",
        "hash": 2501264370387468200132183786199096743,
        "size": 105,
        "message": "pdf: bb #7053"
    },
    {
        "func": "SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n{\n\tsapi_header_struct sapi_header;\n\tchar *colon_offset;\n\tchar *header_line;\n\tuint header_line_len;\n\tint http_response_code;\n\n\tif (SG(headers_sent) && !SG(request_info).no_headers) {\n\t\tconst char *output_start_filename = php_output_get_start_filename(TSRMLS_C);\n\t\tint output_start_lineno = php_output_get_start_lineno(TSRMLS_C);\n\n\t\tif (output_start_filename) {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent by (output started at %s:%d)\",\n\t\t\t\toutput_start_filename, output_start_lineno);\n\t\t} else {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_SET_STATUS:\n\t\t\tsapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);\n\t\t\treturn SUCCESS;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\tcase SAPI_HEADER_DELETE: {\n\t\t\t\tsapi_header_line *p = arg;\n\n\t\t\t\tif (!p->line || !p->line_len) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\theader_line = p->line;\n\t\t\t\theader_line_len = p->line_len;\n\t\t\t\thttp_response_code = p->response_code;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tif (sapi_module.header_handler) {\n\t\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_clean(&SG(sapi_headers).headers);\n\t\t\treturn SUCCESS;\n\n\t\tdefault:\n\t\t\treturn FAILURE;\n\t}\n\n\theader_line = estrndup(header_line, header_line_len);\n\n\t/* cut off trailing spaces, linefeeds and carriage-returns */\n\tif (header_line_len && isspace(header_line[header_line_len-1])) {\n\t\tdo {\n\t\t\theader_line_len--;\n\t\t} while(header_line_len && isspace(header_line[header_line_len-1]));\n\t\theader_line[header_line_len]='\\0';\n\t}\n\t\n\tif (op == SAPI_HEADER_DELETE) {\n\t\tif (strchr(header_line, ':')) {\n\t\t\tefree(header_line);\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Header to delete may not contain colon.\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (sapi_module.header_handler) {\n\t\t\tsapi_header.header = header_line;\n\t\t\tsapi_header.header_len = header_line_len;\n\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t}\n\t\tsapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);\n\t\tefree(header_line);\n\t\treturn SUCCESS;\n\t} else {\n\t\t/* new line/NUL character safety check */\n\t\tint i;\n\t\tfor (i = 0; i < header_line_len; i++) {\n\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */\n\t\t\tint illegal_break =\n\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')\n\t\t\t\t\t&& (\n\t\t\t\t\t\theader_line[i] == '\\n'\n\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));\n\t\t\tif (illegal_break) {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n\t\t\t\t\t\t\"more than a single header, new line detected\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (header_line[i] == '\\0') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain NUL bytes\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tsapi_header.header = header_line;\n\tsapi_header.header_len = header_line_len;\n\n\t/* Check the header for a few cases that we have special support for in SAPI */\n\tif (header_line_len>=5 \n\t\t&& !strncasecmp(header_line, \"HTTP/\", 5)) {\n\t\t/* filter out the response code */\n\t\tsapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);\n\t\t/* sapi_update_response_code doesn't free the status line if the code didn't change */\n\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\tefree(SG(sapi_headers).http_status_line);\n\t\t}\n\t\tSG(sapi_headers).http_status_line = header_line;\n\t\treturn SUCCESS;\n\t} else {\n\t\tcolon_offset = strchr(header_line, ':');\n\t\tif (colon_offset) {\n\t\t\t*colon_offset = 0;\n\t\t\tif (!STRCASECMP(header_line, \"Content-Type\")) {\n\t\t\t\tchar *ptr = colon_offset+1, *mimetype = NULL, *newheader;\n\t\t\t\tsize_t len = header_line_len - (ptr - header_line), newlen;\n\t\t\t\twhile (*ptr == ' ') {\n\t\t\t\t\tptr++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\n\t\t\t\t/* Disable possible output compression for images */\n\t\t\t\tif (!strncmp(ptr, \"image/\", sizeof(\"image/\")-1)) {\n\t\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"), \"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t\t}\n\n\t\t\t\tmimetype = estrdup(ptr);\n\t\t\t\tnewlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);\n\t\t\t\tif (!SG(sapi_headers).mimetype){\n\t\t\t\t\tSG(sapi_headers).mimetype = estrdup(mimetype);\n\t\t\t\t}\n\n\t\t\t\tif (newlen != 0) {\n\t\t\t\t\tnewlen += sizeof(\"Content-type: \");\n\t\t\t\t\tnewheader = emalloc(newlen);\n\t\t\t\t\tPHP_STRLCPY(newheader, \"Content-type: \", newlen, sizeof(\"Content-type: \")-1);\n\t\t\t\t\tstrlcat(newheader, mimetype, newlen);\n\t\t\t\t\tsapi_header.header = newheader;\n\t\t\t\t\tsapi_header.header_len = newlen - 1;\n\t\t\t\t\tefree(header_line);\n\t\t\t\t}\n\t\t\t\tefree(mimetype);\n\t\t\t\tSG(sapi_headers).send_default_content_type = 0;\n\t\t\t} else if (!STRCASECMP(header_line, \"Content-Length\")) {\n\t\t\t\t/* Script is setting Content-length. The script cannot reasonably\n\t\t\t\t * know the size of the message body after compression, so it's best\n\t\t\t\t * do disable compression altogether. This contributes to making scripts\n\t\t\t\t * portable between setups that have and don't have zlib compression\n\t\t\t\t * enabled globally. See req #44164 */\n\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"),\n\t\t\t\t\t\"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t} else if (!STRCASECMP(header_line, \"Location\")) {\n\t\t\t\tif ((SG(sapi_headers).http_response_code < 300 ||\n\t\t\t\t\tSG(sapi_headers).http_response_code > 399) &&\n\t\t\t\t\tSG(sapi_headers).http_response_code != 201) {\n\t\t\t\t\t/* Return a Found Redirect if one is not already specified */\n\t\t\t\t\tif (http_response_code) { /* user specified redirect code */\n\t\t\t\t\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t\t\t\t\t} else if (SG(request_info).proto_num > 1000 && \n\t\t\t\t\t   SG(request_info).request_method && \n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"HEAD\") &&\n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"GET\")) {\n\t\t\t\t\t\tsapi_update_response_code(303 TSRMLS_CC);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsapi_update_response_code(302 TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!STRCASECMP(header_line, \"WWW-Authenticate\")) { /* HTTP Authentication */\n\t\t\t\tsapi_update_response_code(401 TSRMLS_CC); /* authentication-required */\n\t\t\t}\n\t\t\tif (sapi_header.header==header_line) {\n\t\t\t\t*colon_offset = ':';\n\t\t\t}\n\t\t}\n\t}\n\tif (http_response_code) {\n\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t}\n\tsapi_header_add_op(op, &sapi_header TSRMLS_CC);\n\treturn SUCCESS;\n}",
        "target": 1,
        "cwe": [
            "CWE-190",
            "CWE-79"
        ],
        "project": "php-src",
        "commit_id": "996faf964bba1aec06b153b370a7f20d3dd2bb8b",
        "hash": 19474592697639177598556303158867795591,
        "size": 185,
        "message": "Update header handling to RFC 7230"
    },
    {
        "func": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-79"
        ],
        "project": "qBittorrent",
        "commit_id": "6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "hash": 99772950963207562529946786486482705731,
        "size": 12,
        "message": "Add Utils::String::toHtmlEscaped"
    },
    {
        "func": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    // Icons\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-79"
        ],
        "project": "qBittorrent",
        "commit_id": "6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "hash": 27335645952006997537074917231948973921,
        "size": 16,
        "message": "Add Utils::String::toHtmlEscaped"
    },
    {
        "func": "QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    int row = m_listModel->rowCount();\n    // Adding Peer to peer list\n    m_listModel->insertRow(row);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n        }\n        else {\n            m_missingFlags.insert(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n\n    return m_listModel->item(row, PeerListDelegate::IP);\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-79"
        ],
        "project": "qBittorrent",
        "commit_id": "6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "hash": 91539942076030743283671483536894229392,
        "size": 36,
        "message": "Add Utils::String::toHtmlEscaped"
    },
    {
        "func": "void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n\n    // Save path\n    updateSavePath(m_torrent);\n    // Hash\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        // Creation date\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n\n        // Comment\n        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));\n\n        // URL seeds\n        loadUrlSeeds();\n\n        label_created_by_val->setText(m_torrent->creator());\n\n        // List files in torrent\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n\n        // Load file priorities\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    // Load dynamic data\n    loadDynamicData();\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-79"
        ],
        "project": "qBittorrent",
        "commit_id": "6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "hash": 52382869532831661388809219886865332884,
        "size": 37,
        "message": "Add Utils::String::toHtmlEscaped"
    },
    {
        "func": "void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-79"
        ],
        "project": "qBittorrent",
        "commit_id": "6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "hash": 319477271934986472806244747703051238712,
        "size": 28,
        "message": "Add Utils::String::toHtmlEscaped"
    },
    {
        "func": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-79"
        ],
        "project": "qBittorrent",
        "commit_id": "6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "hash": 166936103899693075676437440745916635285,
        "size": 12,
        "message": "Add Utils::String::toHtmlEscaped"
    },
    {
        "func": "am_cache_entry_t *am_new_request_session(request_rec *r)\n{\n    const char *session_id;\n\n    /* Generate session id. */\n    session_id = am_generate_id(r);\n    if(session_id == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Error creating session id.\");\n        return NULL;\n    }\n\n\n    /* Set session id. */\n    am_cookie_set(r, session_id);\n\n    return am_cache_new(r->server, session_id);\n}",
        "target": 1,
        "cwe": [
            "CWE-79"
        ],
        "project": "mod_auth_mellon",
        "commit_id": "7af21c53da7bb1de024274ee6da30bc22316a079",
        "hash": 210972283721432557256414120546684092311,
        "size": 18,
        "message": "Fix Cross-Site Session Transfer vulnerability\n\nmod_auth_mellon did not verify that the site the session was created\nfor was the same site as the site the user accessed. This allows an\nattacker with access to one web site on a server to use the same\nsession to get access to a different site running on the same server.\n\nThis patch fixes this vulnerability by storing the cookie parameters\nused when creating the session in the session, and verifying those\nparameters when the session is loaded.\n\nThanks to Fran\u00e7ois Kooman for reporting this vulnerability.\n\nThis vulnerability has been assigned CVE-2017-6807."
    },
    {
        "func": "am_cache_entry_t *am_get_request_session(request_rec *r)\n{\n    const char *session_id;\n\n    /* Get session id from cookie. */\n    session_id = am_cookie_get(r);\n    if(session_id == NULL) {\n        /* Cookie is unset - we don't have a session. */\n        return NULL;\n    }\n\n    return am_cache_lock(r->server, AM_CACHE_SESSION, session_id);\n}",
        "target": 1,
        "cwe": [
            "CWE-79"
        ],
        "project": "mod_auth_mellon",
        "commit_id": "7af21c53da7bb1de024274ee6da30bc22316a079",
        "hash": 178300368467391852299979882451036872915,
        "size": 13,
        "message": "Fix Cross-Site Session Transfer vulnerability\n\nmod_auth_mellon did not verify that the site the session was created\nfor was the same site as the site the user accessed. This allows an\nattacker with access to one web site on a server to use the same\nsession to get access to a different site running on the same server.\n\nThis patch fixes this vulnerability by storing the cookie parameters\nused when creating the session in the session, and verifying those\nparameters when the session is loaded.\n\nThanks to Fran\u00e7ois Kooman for reporting this vulnerability.\n\nThis vulnerability has been assigned CVE-2017-6807."
    },
    {
        "func": "xmlParsePI(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len = 0;\n    int size = XML_PARSER_BUFFER_SIZE;\n    int cur, l;\n    const xmlChar *target;\n    xmlParserInputState state;\n    int count = 0;\n\n    if ((RAW == '<') && (NXT(1) == '?')) {\n\txmlParserInputPtr input = ctxt->input;\n\tstate = ctxt->instate;\n        ctxt->instate = XML_PARSER_PI;\n\t/*\n\t * this is a Processing Instruction.\n\t */\n\tSKIP(2);\n\tSHRINK;\n\n\t/*\n\t * Parse the target name and check for special support like\n\t * namespace.\n\t */\n        target = xmlParsePITarget(ctxt);\n\tif (target != NULL) {\n\t    if ((RAW == '?') && (NXT(1) == '>')) {\n\t\tif (input != ctxt->input) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t    \"PI declaration doesn't start and stop in the same entity\\n\");\n\t\t}\n\t\tSKIP(2);\n\n\t\t/*\n\t\t * SAX: PI detected.\n\t\t */\n\t\tif ((ctxt->sax) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->processingInstruction != NULL))\n\t\t    ctxt->sax->processingInstruction(ctxt->userData,\n\t\t                                     target, NULL);\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n\t    if (buf == NULL) {\n\t\txmlErrMemory(ctxt, NULL);\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    cur = CUR;\n\t    if (!IS_BLANK(cur)) {\n\t\txmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t  \"ParsePI: PI %s space expected\\n\", target);\n\t    }\n            SKIP_BLANKS;\n\t    cur = CUR_CHAR(l);\n\t    while (IS_CHAR(cur) && /* checked */\n\t\t   ((cur != '?') || (NXT(1) != '>'))) {\n\t\tif (len + 5 >= size) {\n\t\t    xmlChar *tmp;\n\n\t\t    size *= 2;\n\t\t    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n\t\t    if (tmp == NULL) {\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\txmlFree(buf);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = tmp;\n\t\t}\n\t\tcount++;\n\t\tif (count > 50) {\n\t\t    GROW;\n\t\t    count = 0;\n\t\t}\n\t\tCOPY_BUF(l,buf,len,cur);\n\t\tNEXTL(l);\n\t\tcur = CUR_CHAR(l);\n\t\tif (cur == 0) {\n\t\t    SHRINK;\n\t\t    GROW;\n\t\t    cur = CUR_CHAR(l);\n\t\t}\n\t    }\n\t    buf[len] = 0;\n\t    if (cur != '?') {\n\t\txmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n\t\t      \"ParsePI: PI %s never end ...\\n\", target);\n\t    } else {\n\t\tif (input != ctxt->input) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t    \"PI declaration doesn't start and stop in the same entity\\n\");\n\t\t}\n\t\tSKIP(2);\n\n#ifdef LIBXML_CATALOG_ENABLED\n\t\tif (((state == XML_PARSER_MISC) ||\n\t             (state == XML_PARSER_START)) &&\n\t\t    (xmlStrEqual(target, XML_CATALOG_PI))) {\n\t\t    xmlCatalogAllow allow = xmlCatalogGetDefaults();\n\t\t    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||\n\t\t\t(allow == XML_CATA_ALLOW_ALL))\n\t\t\txmlParseCatalogPI(ctxt, buf);\n\t\t}\n#endif\n\n\n\t\t/*\n\t\t * SAX: PI detected.\n\t\t */\n\t\tif ((ctxt->sax) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->processingInstruction != NULL))\n\t\t    ctxt->sax->processingInstruction(ctxt->userData,\n\t\t                                     target, buf);\n\t    }\n\t    xmlFree(buf);\n\t} else {\n\t    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);\n\t}\n\tctxt->instate = state;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-125"
        ],
        "project": "libxml2",
        "commit_id": "77404b8b69bc122d12231807abf1a837d121b551",
        "hash": 257663902699256913316201632018828944346,
        "size": 122,
        "message": "Make sure the parser returns when getting a Stop order\n\npatch backported from chromiun bug fixes, assuming author is Chris"
    },
    {
        "func": "xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {\n    int ret = 0;\n    int avail, tlen;\n    xmlChar cur, next;\n    const xmlChar *lastlt, *lastgt;\n\n    if (ctxt->input == NULL)\n        return(0);\n\n#ifdef DEBUG_PUSH\n    switch (ctxt->instate) {\n\tcase XML_PARSER_EOF:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try EOF\\n\"); break;\n\tcase XML_PARSER_START:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try START\\n\"); break;\n\tcase XML_PARSER_MISC:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try MISC\\n\");break;\n\tcase XML_PARSER_COMMENT:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try COMMENT\\n\");break;\n\tcase XML_PARSER_PROLOG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try PROLOG\\n\");break;\n\tcase XML_PARSER_START_TAG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try START_TAG\\n\");break;\n\tcase XML_PARSER_CONTENT:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try CONTENT\\n\");break;\n\tcase XML_PARSER_CDATA_SECTION:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try CDATA_SECTION\\n\");break;\n\tcase XML_PARSER_END_TAG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try END_TAG\\n\");break;\n\tcase XML_PARSER_ENTITY_DECL:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ENTITY_DECL\\n\");break;\n\tcase XML_PARSER_ENTITY_VALUE:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ENTITY_VALUE\\n\");break;\n\tcase XML_PARSER_ATTRIBUTE_VALUE:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ATTRIBUTE_VALUE\\n\");break;\n\tcase XML_PARSER_DTD:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try DTD\\n\");break;\n\tcase XML_PARSER_EPILOG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try EPILOG\\n\");break;\n\tcase XML_PARSER_PI:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try PI\\n\");break;\n        case XML_PARSER_IGNORE:\n            xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try IGNORE\\n\");break;\n    }\n#endif\n\n    if ((ctxt->input != NULL) &&\n        (ctxt->input->cur - ctxt->input->base > 4096)) {\n\txmlSHRINK(ctxt);\n\tctxt->checkIndex = 0;\n    }\n    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n\n    while (1) {\n\tif ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n\t    return(0);\n\n        \n\t/*\n\t * Pop-up of finished entities.\n\t */\n\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t    xmlPopInput(ctxt);\n\n\tif (ctxt->input == NULL) break;\n\tif (ctxt->input->buf == NULL)\n\t    avail = ctxt->input->length -\n\t            (ctxt->input->cur - ctxt->input->base);\n\telse {\n\t    /*\n\t     * If we are operating on converted input, try to flush\n\t     * remainng chars to avoid them stalling in the non-converted\n\t     * buffer.\n\t     */\n\t    if ((ctxt->input->buf->raw != NULL) &&\n\t\t(ctxt->input->buf->raw->use > 0)) {\n\t\tint base = ctxt->input->base -\n\t\t           ctxt->input->buf->buffer->content;\n\t\tint current = ctxt->input->cur - ctxt->input->base;\n\n\t\txmlParserInputBufferPush(ctxt->input->buf, 0, \"\");\n\t\tctxt->input->base = ctxt->input->buf->buffer->content + base;\n\t\tctxt->input->cur = ctxt->input->base + current;\n\t\tctxt->input->end =\n\t\t    &ctxt->input->buf->buffer->content[\n\t\t                       ctxt->input->buf->buffer->use];\n\t    }\n\t    avail = ctxt->input->buf->buffer->use -\n\t\t    (ctxt->input->cur - ctxt->input->base);\n\t}\n        if (avail < 1)\n\t    goto done;\n        switch (ctxt->instate) {\n            case XML_PARSER_EOF:\n\t        /*\n\t\t * Document parsing is done !\n\t\t */\n\t        goto done;\n            case XML_PARSER_START:\n\t\tif (ctxt->charset == XML_CHAR_ENCODING_NONE) {\n\t\t    xmlChar start[4];\n\t\t    xmlCharEncoding enc;\n\n\t\t    /*\n\t\t     * Very first chars read from the document flow.\n\t\t     */\n\t\t    if (avail < 4)\n\t\t\tgoto done;\n\n\t\t    /* \n\t\t     * Get the 4 first bytes and decode the charset\n\t\t     * if enc != XML_CHAR_ENCODING_NONE\n\t\t     * plug some encoding conversion routines,\n\t\t     * else xmlSwitchEncoding will set to (default)\n\t\t     * UTF8.\n\t\t     */\n\t\t    start[0] = RAW;\n\t\t    start[1] = NXT(1);\n\t\t    start[2] = NXT(2);\n\t\t    start[3] = NXT(3);\n\t\t    enc = xmlDetectCharEncoding(start, 4);\n\t\t    xmlSwitchEncoding(ctxt, enc);\n\t\t    break;\n\t\t}\n\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t\tif (cur == 0) {\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering EOF\\n\");\n#endif\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    /* PI or XML decl */\n\t\t    if (avail < 5) return(ret);\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\treturn(ret);\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    if ((ctxt->input->cur[2] == 'x') &&\n\t\t\t(ctxt->input->cur[3] == 'm') &&\n\t\t\t(ctxt->input->cur[4] == 'l') &&\n\t\t\t(IS_BLANK_CH(ctxt->input->cur[5]))) {\n\t\t\tret += 5;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: Parsing XML Decl\\n\");\n#endif\n\t\t\txmlParseXMLDecl(ctxt);\n\t\t\tif (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t\t    /*\n\t\t\t     * The XML REC instructs us to stop parsing right\n\t\t\t     * here\n\t\t\t     */\n\t\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t\t    return(0);\n\t\t\t}\n\t\t\tctxt->standalone = ctxt->input->standalone;\n\t\t\tif ((ctxt->encoding == NULL) &&\n\t\t\t    (ctxt->input->encoding != NULL))\n\t\t\t    ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n\t\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->startDocument(ctxt->userData);\n\t\t\tctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering MISC\\n\");\n#endif\n\t\t    } else {\n\t\t\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n\t\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->startDocument(ctxt->userData);\n\t\t\tctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering MISC\\n\");\n#endif\n\t\t    }\n\t\t} else {\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n\t\t    if (ctxt->version == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tbreak;\n\t\t    }\n\t\t    if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t        (!ctxt->disableSAX))\n\t\t\tctxt->sax->startDocument(ctxt->userData);\n\t\t    ctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering MISC\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_START_TAG: {\n\t        const xmlChar *name;\n\t\tconst xmlChar *prefix = NULL;\n\t\tconst xmlChar *URI = NULL;\n\t\tint nsNr = ctxt->nsNr;\n\n\t\tif ((avail < 2) && (ctxt->inputNr == 1))\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t        if (cur != '<') {\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t\tif (!terminate) {\n\t\t    if (ctxt->progressive) {\n\t\t        /* > can be found unescaped in attribute values */\n\t\t        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n\t\t\t    goto done;\n\t\t    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t\tif (ctxt->spaceNr == 0)\n\t\t    spacePush(ctxt, -1);\n\t\telse if (*ctxt->space == -2)\n\t\t    spacePush(ctxt, -1);\n\t\telse\n\t\t    spacePush(ctxt, *ctxt->space);\n#ifdef LIBXML_SAX1_ENABLED\n\t\tif (ctxt->sax2)\n#endif /* LIBXML_SAX1_ENABLED */\n\t\t    name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n#ifdef LIBXML_SAX1_ENABLED\n\t\telse\n\t\t    name = xmlParseStartTag(ctxt);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\tif (name == NULL) {\n\t\t    spacePop(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n#ifdef LIBXML_VALID_ENABLED\n\t\t/*\n\t\t * [ VC: Root Element Type ]\n\t\t * The Name in the document type declaration must match\n\t\t * the element type of the root element. \n\t\t */\n\t\tif (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n\t\t    ctxt->node && (ctxt->node == ctxt->myDoc->children))\n\t\t    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n#endif /* LIBXML_VALID_ENABLED */\n\n\t\t/*\n\t\t * Check for an Empty Element.\n\t\t */\n\t\tif ((RAW == '/') && (NXT(1) == '>')) {\n\t\t    SKIP(2);\n\n\t\t    if (ctxt->sax2) {\n\t\t\tif ((ctxt->sax != NULL) &&\n\t\t\t    (ctxt->sax->endElementNs != NULL) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->endElementNs(ctxt->userData, name,\n\t\t\t                            prefix, URI);\n\t\t\tif (ctxt->nsNr - nsNr > 0)\n\t\t\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n#ifdef LIBXML_SAX1_ENABLED\n\t\t    } else {\n\t\t\tif ((ctxt->sax != NULL) &&\n\t\t\t    (ctxt->sax->endElement != NULL) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->endElement(ctxt->userData, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\t    }\n\t\t    spacePop(ctxt);\n\t\t    if (ctxt->nameNr == 0) {\n\t\t\tctxt->instate = XML_PARSER_EPILOG;\n\t\t    } else {\n\t\t\tctxt->instate = XML_PARSER_CONTENT;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (RAW == '>') {\n\t\t    NEXT;\n\t\t} else {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\n\t\t\t\t\t \"Couldn't find end of Start Tag %s\\n\",\n\t\t\t\t\t name);\n\t\t    nodePop(ctxt);\n\t\t    spacePop(ctxt);\n\t\t}\n\t\tif (ctxt->sax2)\n\t\t    nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);\n#ifdef LIBXML_SAX1_ENABLED\n\t\telse\n\t\t    namePush(ctxt, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\n\t\tctxt->instate = XML_PARSER_CONTENT;\n                break;\n\t    }\n            case XML_PARSER_CONTENT: {\n\t\tconst xmlChar *test;\n\t\tunsigned int cons;\n\t\tif ((avail < 2) && (ctxt->inputNr == 1))\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\n\t\ttest = CUR_PTR;\n\t        cons = ctxt->input->consumed;\n\t\tif ((cur == '<') && (next == '/')) {\n\t\t    ctxt->instate = XML_PARSER_END_TAG;\n\t\t    break;\n\t        } else if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n\t\t    xmlParsePI(ctxt);\n\t\t} else if ((cur == '<') && (next != '!')) {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    break;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (ctxt->input->cur[2] == '-') &&\n\t\t\t   (ctxt->input->cur[3] == '-')) {\n\t\t    int term;\n\n\t            if (avail < 4)\n\t\t        goto done;\n\t\t    ctxt->input->cur += 4;\n\t\t    term = xmlParseLookupSequence(ctxt, '-', '-', '>');\n\t\t    ctxt->input->cur -= 4;\n\t\t    if ((!terminate) && (term < 0))\n\t\t\tgoto done;\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n\t\t} else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&\n\t\t    (ctxt->input->cur[2] == '[') &&\n\t\t    (ctxt->input->cur[3] == 'C') &&\n\t\t    (ctxt->input->cur[4] == 'D') &&\n\t\t    (ctxt->input->cur[5] == 'A') &&\n\t\t    (ctxt->input->cur[6] == 'T') &&\n\t\t    (ctxt->input->cur[7] == 'A') &&\n\t\t    (ctxt->input->cur[8] == '[')) {\n\t\t    SKIP(9);\n\t\t    ctxt->instate = XML_PARSER_CDATA_SECTION;\n\t\t    break;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 9)) {\n\t\t    goto done;\n\t\t} else if (cur == '&') {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))\n\t\t\tgoto done;\n\t\t    xmlParseReference(ctxt);\n\t\t} else {\n\t\t    /* TODO Avoid the extra copy, handle directly !!! */\n\t\t    /*\n\t\t     * Goal of the following test is:\n\t\t     *  - minimize calls to the SAX 'character' callback\n\t\t     *    when they are mergeable\n\t\t     *  - handle an problem for isBlank when we only parse\n\t\t     *    a sequence of blank chars and the next one is\n\t\t     *    not available to check against '<' presence.\n\t\t     *  - tries to homogenize the differences in SAX\n\t\t     *    callbacks between the push and pull versions\n\t\t     *    of the parser.\n\t\t     */\n\t\t    if ((ctxt->inputNr == 1) &&\n\t\t        (avail < XML_PARSER_BIG_BUFFER_SIZE)) {\n\t\t\tif (!terminate) {\n\t\t\t    if (ctxt->progressive) {\n\t\t\t\tif ((lastlt == NULL) ||\n\t\t\t\t    (ctxt->input->cur > lastlt))\n\t\t\t\t    goto done;\n\t\t\t    } else if (xmlParseLookupSequence(ctxt,\n\t\t\t                                      '<', 0, 0) < 0) {\n\t\t\t\tgoto done;\n\t\t\t    }\n\t\t\t}\n                    }\n\t\t    ctxt->checkIndex = 0;\n\t\t    xmlParseCharData(ctxt, 0);\n\t\t}\n\t\t/*\n\t\t * Pop-up of finished entities.\n\t\t */\n\t\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t\t    xmlPopInput(ctxt);\n\t\tif ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\n\t\t    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t                \"detected an error in element content\\n\");\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    break;\n\t\t}\n\t\tbreak;\n\t    }\n            case XML_PARSER_END_TAG:\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tif (!terminate) {\n\t\t    if (ctxt->progressive) {\n\t\t        /* > can be found unescaped in attribute values */\n\t\t        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n\t\t\t    goto done;\n\t\t    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t\tif (ctxt->sax2) {\n\t\t    xmlParseEndTag2(ctxt,\n\t\t           (void *) ctxt->pushTab[ctxt->nameNr * 3 - 3],\n\t\t           (void *) ctxt->pushTab[ctxt->nameNr * 3 - 2], 0,\n\t\t       (int) (long) ctxt->pushTab[ctxt->nameNr * 3 - 1], 0);\n\t\t    nameNsPop(ctxt);\n\t\t}\n#ifdef LIBXML_SAX1_ENABLED\n\t\t  else\n\t\t    xmlParseEndTag1(ctxt, 0);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\tif (ctxt->nameNr == 0) {\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n\t\t}\n\t\tbreak;\n            case XML_PARSER_CDATA_SECTION: {\n\t        /*\n\t\t * The Push mode need to have the SAX callback for \n\t\t * cdataBlock merge back contiguous callbacks.\n\t\t */\n\t\tint base;\n\n\t\tbase = xmlParseLookupSequence(ctxt, ']', ']', '>');\n\t\tif (base < 0) {\n\t\t    if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {\n\t\t        int tmp;\n\n\t\t\ttmp = xmlCheckCdataPush(ctxt->input->cur, \n\t\t\t                        XML_PARSER_BIG_BUFFER_SIZE);\n\t\t\tif (tmp < 0) {\n\t\t\t    tmp = -tmp;\n\t\t\t    ctxt->input->cur += tmp;\n\t\t\t    goto encoding_error;\n\t\t\t}\n\t\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t\t\t    if (ctxt->sax->cdataBlock != NULL)\n\t\t\t\tctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t\t                      ctxt->input->cur, tmp);\n\t\t\t    else if (ctxt->sax->characters != NULL)\n\t\t\t\tctxt->sax->characters(ctxt->userData,\n\t\t\t\t                      ctxt->input->cur, tmp);\n\t\t\t}\n\t\t\tSKIPL(tmp);\n\t\t\tctxt->checkIndex = 0;\n\t\t    }\n\t\t    goto done;\n\t\t} else {\n\t\t    int tmp;\n\n\t\t    tmp = xmlCheckCdataPush(ctxt->input->cur, base);\n\t\t    if ((tmp < 0) || (tmp != base)) {\n\t\t\ttmp = -tmp;\n\t\t\tctxt->input->cur += tmp;\n\t\t\tgoto encoding_error;\n\t\t    }\n\t\t    if ((ctxt->sax != NULL) && (base == 0) &&\n\t\t        (ctxt->sax->cdataBlock != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\t/*\n\t\t\t * Special case to provide identical behaviour\n\t\t\t * between pull and push parsers on enpty CDATA\n\t\t\t * sections\n\t\t\t */\n\t\t\t if ((ctxt->input->cur - ctxt->input->base >= 9) &&\n\t\t\t     (!strncmp((const char *)&ctxt->input->cur[-9],\n\t\t\t               \"<![CDATA[\", 9)))\n\t\t\t     ctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t                           BAD_CAST \"\", 0);\n\t\t    } else if ((ctxt->sax != NULL) && (base > 0) &&\n\t\t\t(!ctxt->disableSAX)) {\n\t\t\tif (ctxt->sax->cdataBlock != NULL)\n\t\t\t    ctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t\t\t\t  ctxt->input->cur, base);\n\t\t\telse if (ctxt->sax->characters != NULL)\n\t\t\t    ctxt->sax->characters(ctxt->userData,\n\t\t\t\t\t\t  ctxt->input->cur, base);\n\t\t    }\n\t\t    SKIPL(base + 3);\n\t\t    ctxt->checkIndex = 0;\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering CONTENT\\n\");\n#endif\n\t\t}\n\t\tbreak;\n\t    }\n            case XML_PARSER_MISC:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length -\n\t\t            (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use -\n\t\t            (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t    ctxt->checkIndex = 0;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') &&\n\t\t    (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_MISC;\n\t\t    ctxt->checkIndex = 0;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == 'D') &&\n\t\t    (ctxt->input->cur[3] == 'O') &&\n\t\t    (ctxt->input->cur[4] == 'C') &&\n\t\t    (ctxt->input->cur[5] == 'T') &&\n\t\t    (ctxt->input->cur[6] == 'Y') &&\n\t\t    (ctxt->input->cur[7] == 'P') &&\n\t\t    (ctxt->input->cur[8] == 'E')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing internal subset\\n\");\n#endif\n\t\t    ctxt->inSubset = 1;\n\t\t    xmlParseDocTypeDecl(ctxt);\n\t\t    if (RAW == '[') {\n\t\t\tctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\t    } else {\n\t\t\t/*\n\t\t\t * Create and update the external subset.\n\t\t\t */\n\t\t\tctxt->inSubset = 2;\n\t\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t\t    (ctxt->sax->externalSubset != NULL))\n\t\t\t    ctxt->sax->externalSubset(ctxt->userData,\n\t\t\t\t    ctxt->intSubName, ctxt->extSubSystem,\n\t\t\t\t    ctxt->extSubURI);\n\t\t\tctxt->inSubset = 0;\n\t\t\txmlCleanSpecialAttr(ctxt);\n\t\t\tctxt->instate = XML_PARSER_PROLOG;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering PROLOG\\n\");\n#endif\n\t\t    }\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 9)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    ctxt->progressive = 1;\n\t\t    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering START_TAG\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_PROLOG:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2) \n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_PROLOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 4)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    if (ctxt->progressive == 0)\n\t\t\tctxt->progressive = 1;\n\t\t    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering START_TAG\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_EPILOG:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 4)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering EOF\\n\");\n#endif\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t\tbreak;\n            case XML_PARSER_DTD: {\n\t        /*\n\t\t * Sorry but progressive parsing of the internal subset\n\t\t * is not expected to be supported. We first check that\n\t\t * the full content of the internal subset is available and\n\t\t * the parsing is launched only at that point.\n\t\t * Internal subset ends up with \"']' S? '>'\" in an unescaped\n\t\t * section and not in a ']]>' sequence which are conditional\n\t\t * sections (whoever argued to keep that crap in XML deserve\n\t\t * a place in hell !).\n\t\t */\n\t\tint base, i;\n\t\txmlChar *buf;\n\t        xmlChar quote = 0;\n\n\t\tbase = ctxt->input->cur - ctxt->input->base;\n\t\tif (base < 0) return(0);\n\t\tif (ctxt->checkIndex > base)\n\t\t    base = ctxt->checkIndex;\n\t\tbuf = ctxt->input->buf->buffer->content;\n\t\tfor (;(unsigned int) base < ctxt->input->buf->buffer->use;\n\t\t     base++) {\n\t\t    if (quote != 0) {\n\t\t        if (buf[base] == quote)\n\t\t\t    quote = 0;\n\t\t\tcontinue;    \n\t\t    }\n\t\t    if ((quote == 0) && (buf[base] == '<')) {\n\t\t        int found  = 0;\n\t\t\t/* special handling of comments */\n\t\t        if (((unsigned int) base + 4 <\n\t\t\t     ctxt->input->buf->buffer->use) &&\n\t\t\t    (buf[base + 1] == '!') &&\n\t\t\t    (buf[base + 2] == '-') &&\n\t\t\t    (buf[base + 3] == '-')) {\n\t\t\t    for (;(unsigned int) base + 3 <\n\t\t\t          ctxt->input->buf->buffer->use; base++) {\n\t\t\t\tif ((buf[base] == '-') &&\n\t\t\t\t    (buf[base + 1] == '-') &&\n\t\t\t\t    (buf[base + 2] == '>')) {\n\t\t\t\t    found = 1;\n\t\t\t\t    base += 2;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t            }\n\t\t\t    if (!found) {\n#if 0\n\t\t\t        fprintf(stderr, \"unfinished comment\\n\");\n#endif\n\t\t\t        break; /* for */\n\t\t            }\n\t\t            continue;\n\t\t\t}\n\t\t    }\n\t\t    if (buf[base] == '\"') {\n\t\t        quote = '\"';\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (buf[base] == '\\'') {\n\t\t        quote = '\\'';\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (buf[base] == ']') {\n#if 0\n\t\t        fprintf(stderr, \"%c%c%c%c: \", buf[base],\n\t\t\t        buf[base + 1], buf[base + 2], buf[base + 3]);\n#endif\n\t\t        if ((unsigned int) base +1 >=\n\t\t            ctxt->input->buf->buffer->use)\n\t\t\t    break;\n\t\t\tif (buf[base + 1] == ']') {\n\t\t\t    /* conditional crap, skip both ']' ! */\n\t\t\t    base++;\n\t\t\t    continue;\n\t\t\t}\n\t\t        for (i = 1;\n\t\t     (unsigned int) base + i < ctxt->input->buf->buffer->use;\n\t\t             i++) {\n\t\t\t    if (buf[base + i] == '>') {\n#if 0\n\t\t\t        fprintf(stderr, \"found\\n\");\n#endif\n\t\t\t        goto found_end_int_subset;\n\t\t\t    }\n\t\t\t    if (!IS_BLANK_CH(buf[base + i])) {\n#if 0\n\t\t\t        fprintf(stderr, \"not found\\n\");\n#endif\n\t\t\t        goto not_end_of_int_subset;\n\t\t\t    }\n\t\t\t}\n#if 0\n\t\t\tfprintf(stderr, \"end of stream\\n\");\n#endif\n\t\t        break;\n                        \n\t\t    }\nnot_end_of_int_subset:\n                    continue; /* for */\n\t\t}\n\t\t/*\n\t\t * We didn't found the end of the Internal subset\n\t\t */\n#ifdef DEBUG_PUSH\n\t\tif (next == 0)\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: lookup of int subset end filed\\n\");\n#endif\n\t        goto done;\n\nfound_end_int_subset:\n\t\txmlParseInternalSubset(ctxt);\n\t\tctxt->inSubset = 2;\n\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->externalSubset != NULL))\n\t\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t\t\t    ctxt->extSubSystem, ctxt->extSubURI);\n\t\tctxt->inSubset = 0;\n\t\txmlCleanSpecialAttr(ctxt);\n\t\tctxt->instate = XML_PARSER_PROLOG;\n\t\tctxt->checkIndex = 0;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering PROLOG\\n\");\n#endif\n                break;\n\t    }\n            case XML_PARSER_COMMENT:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == COMMENT\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering CONTENT\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_IGNORE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == IGNORE\");\n\t        ctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t        break;\n            case XML_PARSER_PI:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == PI\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering CONTENT\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ENTITY_DECL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ENTITY_DECL\\n\");\n\t\tctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ENTITY_VALUE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ENTITY_VALUE\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ATTRIBUTE_VALUE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ATTRIBUTE_VALUE\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_SYSTEM_LITERAL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == SYSTEM_LITERAL\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_PUBLIC_LITERAL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == PUBLIC_LITERAL\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n\t}\n    }\ndone:    \n#ifdef DEBUG_PUSH\n    xmlGenericError(xmlGenericErrorContext, \"PP: done %d\\n\", ret);\n#endif\n    return(ret);\nencoding_error:\n    {\n        char buffer[150];\n\n\tsnprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\tctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\tctxt->input->cur[2], ctxt->input->cur[3]);\n\t__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n    return(0);\n}",
        "target": 1,
        "cwe": [
            "CWE-125"
        ],
        "project": "libxml2",
        "commit_id": "77404b8b69bc122d12231807abf1a837d121b551",
        "hash": 160276695918049421458784393597410964148,
        "size": 929,
        "message": "Make sure the parser returns when getting a Stop order\n\npatch backported from chromiun bug fixes, assuming author is Chris"
    },
    {
        "func": "xmlParseElement(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n    const xmlChar *prefix = NULL;\n    const xmlChar *URI = NULL;\n    xmlParserNodeInfo node_info;\n    int line, tlen;\n    xmlNodePtr ret;\n    int nsNr = ctxt->nsNr;\n\n    if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n\txmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t \"Excessive depth in document: %d use XML_PARSE_HUGE option\\n\",\n\t\t\t  xmlParserMaxDepth);\n\tctxt->instate = XML_PARSER_EOF;\n\treturn;\n    }\n\n    /* Capture start position */\n    if (ctxt->record_info) {\n        node_info.begin_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n\tnode_info.begin_line = ctxt->input->line;\n    }\n\n    if (ctxt->spaceNr == 0)\n\tspacePush(ctxt, -1);\n    else if (*ctxt->space == -2)\n\tspacePush(ctxt, -1);\n    else\n\tspacePush(ctxt, *ctxt->space);\n\n    line = ctxt->input->line;\n#ifdef LIBXML_SAX1_ENABLED\n    if (ctxt->sax2)\n#endif /* LIBXML_SAX1_ENABLED */\n        name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n#ifdef LIBXML_SAX1_ENABLED\n    else\n\tname = xmlParseStartTag(ctxt);\n#endif /* LIBXML_SAX1_ENABLED */\n    if (name == NULL) {\n\tspacePop(ctxt);\n        return;\n    }\n    namePush(ctxt, name);\n    ret = ctxt->node;\n\n#ifdef LIBXML_VALID_ENABLED\n    /*\n     * [ VC: Root Element Type ]\n     * The Name in the document type declaration must match the element\n     * type of the root element. \n     */\n    if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n        ctxt->node && (ctxt->node == ctxt->myDoc->children))\n        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n#endif /* LIBXML_VALID_ENABLED */\n\n    /*\n     * Check for an Empty Element.\n     */\n    if ((RAW == '/') && (NXT(1) == '>')) {\n        SKIP(2);\n\tif (ctxt->sax2) {\n\t    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n\t\t(!ctxt->disableSAX))\n\t\tctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);\n#ifdef LIBXML_SAX1_ENABLED\n\t} else {\n\t    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&\n\t\t(!ctxt->disableSAX))\n\t\tctxt->sax->endElement(ctxt->userData, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\t}\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\tif ( ret != NULL && ctxt->record_info ) {\n\t   node_info.end_pos = ctxt->input->consumed +\n\t\t\t      (CUR_PTR - ctxt->input->base);\n\t   node_info.end_line = ctxt->input->line;\n\t   node_info.node = ret;\n\t   xmlParserAddNodeInfo(ctxt, &node_info);\n\t}\n\treturn;\n    }\n    if (RAW == '>') {\n        NEXT1;\n    } else {\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,\n\t\t     \"Couldn't find end of Start Tag %s line %d\\n\",\n\t\t                name, line, NULL);\n\n\t/*\n\t * end of parsing of this node.\n\t */\n\tnodePop(ctxt);\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\n\t/*\n\t * Capture end position and add node\n\t */\n\tif ( ret != NULL && ctxt->record_info ) {\n\t   node_info.end_pos = ctxt->input->consumed +\n\t\t\t      (CUR_PTR - ctxt->input->base);\n\t   node_info.end_line = ctxt->input->line;\n\t   node_info.node = ret;\n\t   xmlParserAddNodeInfo(ctxt, &node_info);\n\t}\n\treturn;\n    }\n\n    /*\n     * Parse the content of the element:\n     */\n    xmlParseContent(ctxt);\n    if (!IS_BYTE_CHAR(RAW)) {\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n\t \"Premature end of data in tag %s line %d\\n\",\n\t\t                name, line, NULL);\n\n\t/*\n\t * end of parsing of this node.\n\t */\n\tnodePop(ctxt);\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\treturn;\n    }\n\n    /*\n     * parse the end of tag: '</' should be here.\n     */\n    if (ctxt->sax2) {\n\txmlParseEndTag2(ctxt, prefix, URI, line, ctxt->nsNr - nsNr, tlen);\n\tnamePop(ctxt);\n    }\n#ifdef LIBXML_SAX1_ENABLED\n      else\n\txmlParseEndTag1(ctxt, line);\n#endif /* LIBXML_SAX1_ENABLED */\n\n    /*\n     * Capture end position and add node\n     */\n    if ( ret != NULL && ctxt->record_info ) {\n       node_info.end_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n       node_info.end_line = ctxt->input->line;\n       node_info.node = ret;\n       xmlParserAddNodeInfo(ctxt, &node_info);\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-125"
        ],
        "project": "libxml2",
        "commit_id": "77404b8b69bc122d12231807abf1a837d121b551",
        "hash": 46294417880373271625568321655979622208,
        "size": 160,
        "message": "Make sure the parser returns when getting a Stop order\n\npatch backported from chromiun bug fixes, assuming author is Chris"
    },
    {
        "func": "xsltCompilePatternInternal(const xmlChar *pattern, xmlDocPtr doc,\n\t           xmlNodePtr node, xsltStylesheetPtr style,\n\t\t   xsltTransformContextPtr runtime, int novar) {\n    xsltParserContextPtr ctxt = NULL;\n    xsltCompMatchPtr element, first = NULL, previous = NULL;\n    int current, start, end, level, j;\n\n    if (pattern == NULL) {\n\txsltTransformError(NULL, NULL, node,\n\t\t\t \"xsltCompilePattern : NULL pattern\\n\");\n\treturn(NULL);\n    }\n\n    ctxt = xsltNewParserContext(style, runtime);\n    if (ctxt == NULL)\n\treturn(NULL);\n    ctxt->doc = doc;\n    ctxt->elem = node;\n    current = end = 0;\n    while (pattern[current] != 0) {\n\tstart = current;\n\twhile (IS_BLANK_CH(pattern[current]))\n\t    current++;\n\tend = current;\n\tlevel = 0;\n\twhile ((pattern[end] != 0) && ((pattern[end] != '|') || (level != 0))) {\n\t    if (pattern[end] == '[')\n\t\tlevel++;\n\t    else if (pattern[end] == ']')\n\t\tlevel--;\n\t    else if (pattern[end] == '\\'') {\n\t\tend++;\n\t\twhile ((pattern[end] != 0) && (pattern[end] != '\\''))\n\t\t    end++;\n\t    } else if (pattern[end] == '\"') {\n\t\tend++;\n\t\twhile ((pattern[end] != 0) && (pattern[end] != '\"'))\n\t\t    end++;\n\t    }\n\t    end++;\n\t}\n\tif (current == end) {\n\t    xsltTransformError(NULL, NULL, node,\n\t\t\t     \"xsltCompilePattern : NULL pattern\\n\");\n\t    goto error;\n\t}\n\telement = xsltNewCompMatch();\n\tif (element == NULL) {\n\t    goto error;\n\t}\n\tif (first == NULL)\n\t    first = element;\n\telse if (previous != NULL)\n\t    previous->next = element;\n\tprevious = element;\n\n\tctxt->comp = element;\n\tctxt->base = xmlStrndup(&pattern[start], end - start);\n\tif (ctxt->base == NULL)\n\t    goto error;\n\tctxt->cur = &(ctxt->base)[current - start];\n\telement->pattern = ctxt->base;\n\telement->nsList = xmlGetNsList(doc, node);\n\tj = 0;\n\tif (element->nsList != NULL) {\n\t    while (element->nsList[j] != NULL)\n\t\tj++;\n\t}\n\telement->nsNr = j;\n\n\n#ifdef WITH_XSLT_DEBUG_PATTERN\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"xsltCompilePattern : parsing '%s'\\n\",\n\t\t\t element->pattern);\n#endif\n\t/*\n\t Preset default priority to be zero.\n\t This may be changed by xsltCompileLocationPathPattern.\n\t */\n\telement->priority = 0;\n\txsltCompileLocationPathPattern(ctxt, novar);\n\tif (ctxt->error) {\n\t    xsltTransformError(NULL, style, node,\n\t\t\t     \"xsltCompilePattern : failed to compile '%s'\\n\",\n\t\t\t     element->pattern);\n\t    if (style != NULL) style->errors++;\n\t    goto error;\n\t}\n\n\t/*\n\t * Reverse for faster interpretation.\n\t */\n\txsltReverseCompMatch(ctxt, element);\n\n\t/*\n\t * Set-up the priority\n\t */\n\tif (element->priority == 0) {\t/* if not yet determined */\n\t    if (((element->steps[0].op == XSLT_OP_ELEM) ||\n\t\t (element->steps[0].op == XSLT_OP_ATTR) ||\n\t\t (element->steps[0].op == XSLT_OP_PI)) &&\n\t\t(element->steps[0].value != NULL) &&\n\t\t(element->steps[1].op == XSLT_OP_END)) {\n\t\t;\t/* previously preset */\n\t    } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n\t\t       (element->steps[0].value2 != NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.25;\n\t    } else if ((element->steps[0].op == XSLT_OP_NS) &&\n\t\t       (element->steps[0].value != NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.25;\n\t    } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n\t\t       (element->steps[0].value == NULL) &&\n\t\t       (element->steps[0].value2 == NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.5;\n\t    } else if (((element->steps[0].op == XSLT_OP_PI) ||\n\t\t       (element->steps[0].op == XSLT_OP_TEXT) ||\n\t\t       (element->steps[0].op == XSLT_OP_ALL) ||\n\t\t       (element->steps[0].op == XSLT_OP_NODE) ||\n\t\t       (element->steps[0].op == XSLT_OP_COMMENT)) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.5;\n\t    } else {\n\t\telement->priority = 0.5;\n\t    }\n\t}\n#ifdef WITH_XSLT_DEBUG_PATTERN\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltCompilePattern : parsed %s, default priority %f\\n\",\n\t\t\t element->pattern, element->priority);\n#endif\n\tif (pattern[end] == '|')\n\t    end++;\n\tcurrent = end;\n    }\n    if (end == 0) {\n\txsltTransformError(NULL, style, node,\n\t\t\t \"xsltCompilePattern : NULL pattern\\n\");\n\tif (style != NULL) style->errors++;\n\tgoto error;\n    }\n\n    xsltFreeParserContext(ctxt);\n    return(first);\n\nerror:\n    if (ctxt != NULL)\n\txsltFreeParserContext(ctxt);\n    if (first != NULL)\n\txsltFreeCompMatchList(first);\n    return(NULL);\n}",
        "target": 1,
        "cwe": [
            "CWE-125"
        ],
        "project": "libxslt",
        "commit_id": "fe5a4fa33eb85bce3253ed3742b1ea6c4b59b41b",
        "hash": 148569945607118318089810727546119505190,
        "size": 155,
        "message": "Fix some case of pattern parsing errors\n\nWe could accidentally hit an off by one string array access\ndue to improper loop exit when parsing patterns"
    },
    {
        "func": "static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-476",
            "CWE-125"
        ],
        "project": "FreeRDP",
        "commit_id": "0773bb9303d24473fe1185d85a424dfe159aff53",
        "hash": 111656150449925215860229066966962609071,
        "size": 88,
        "message": "nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished."
    },
    {
        "func": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}",
        "target": 1,
        "cwe": [
            "CWE-476",
            "CWE-125"
        ],
        "project": "FreeRDP",
        "commit_id": "0773bb9303d24473fe1185d85a424dfe159aff53",
        "hash": 274903370694910346266468633797978560893,
        "size": 11,
        "message": "nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished."
    },
    {
        "func": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}",
        "target": 1,
        "cwe": [
            "CWE-476",
            "CWE-125"
        ],
        "project": "FreeRDP",
        "commit_id": "0773bb9303d24473fe1185d85a424dfe159aff53",
        "hash": 171083811977759932847315981258619700066,
        "size": 38,
        "message": "nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished."
    },
    {
        "func": "rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\FreeRDP\\\\Server\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"Using SSPI Module: %s\\n\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}",
        "target": 1,
        "cwe": [
            "CWE-476",
            "CWE-125"
        ],
        "project": "FreeRDP",
        "commit_id": "0773bb9303d24473fe1185d85a424dfe159aff53",
        "hash": 121901165641359104511446250461686024023,
        "size": 52,
        "message": "nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished."
    },
    {
        "func": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}",
        "target": 1,
        "cwe": [
            "CWE-476",
            "CWE-125"
        ],
        "project": "FreeRDP",
        "commit_id": "0773bb9303d24473fe1185d85a424dfe159aff53",
        "hash": 66923380981527376118948751296381384980,
        "size": 11,
        "message": "nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished."
    },
    {
        "func": "SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DeleteSecurityContext(phContext);\n\n\treturn status;\n}",
        "target": 1,
        "cwe": [
            "CWE-476",
            "CWE-125"
        ],
        "project": "FreeRDP",
        "commit_id": "0773bb9303d24473fe1185d85a424dfe159aff53",
        "hash": 40361793844875626967523025835651999591,
        "size": 23,
        "message": "nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished."
    },
    {
        "func": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}",
        "target": 1,
        "cwe": [
            "CWE-476",
            "CWE-125"
        ],
        "project": "FreeRDP",
        "commit_id": "0773bb9303d24473fe1185d85a424dfe159aff53",
        "hash": 231648098731009398452964039878312210920,
        "size": 39,
        "message": "nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished."
    },
    {
        "func": "kg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,\n             conf_state, qop_state, toktype)\n    krb5_context context;\n    OM_uint32 *minor_status;\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    int bodysize;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_error_code code;\n    int conflen = 0;\n    int signalg;\n    int sealalg;\n    gss_buffer_desc token;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    krb5_data plaind;\n    char *data_ptr;\n    unsigned char *plain;\n    unsigned int cksum_len = 0;\n    size_t plainlen;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        message_buffer->length = 0;\n        message_buffer->value = NULL;\n    }\n\n    /* get the sign and seal algorithms */\n\n    signalg = ptr[0] + (ptr[1]<<8);\n    sealalg = ptr[2] + (ptr[3]<<8);\n\n    /* Sanity checks */\n\n    if ((ptr[4] != 0xff) || (ptr[5] != 0xff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((toktype != KG_TOK_SEAL_MSG) &&\n        (sealalg != 0xffff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* in the current spec, there is only one valid seal algorithm per\n       key type, so a simple comparison is ok */\n\n    if ((toktype == KG_TOK_SEAL_MSG) &&\n        !((sealalg == 0xffff) ||\n          (sealalg == ctx->sealalg))) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* there are several mappings of seal algorithms to sign algorithms,\n       but few enough that we can try them all. */\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_SEAL_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n\n    if ((code = kg_get_seq_num(context, ctx->seq, ptr+14, ptr+6, &direction,\n                               &seqnum))) {\n        *minor_status = code;\n        return(GSS_S_BAD_SIG);\n    }\n\n    /* decode the message, if SEAL */\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        size_t tmsglen = bodysize-(14+cksum_len);\n        if (sealalg != 0xffff) {\n            if ((plain = (unsigned char *) xmalloc(tmsglen)) == NULL) {\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                int i;\n                store_32_be(seqnum, bigend_seqnum);\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code)\n                {\n                    xfree(plain);\n                    *minor_status = code;\n                    return(GSS_S_FAILURE);\n                }\n\n                assert (enc_key->length == 16);\n                for (i = 0; i <= 15; i++)\n                    ((char *) enc_key->contents)[i] ^=0xf0;\n                code = kg_arcfour_docrypt (enc_key, 0,\n                                           &bigend_seqnum[0], 4,\n                                           ptr+14+cksum_len, tmsglen,\n                                           plain);\n                krb5_free_keyblock (context, enc_key);\n            } else {\n                code = kg_decrypt(context, ctx->enc, KG_USAGE_SEAL, NULL,\n                                  ptr+14+cksum_len, plain, tmsglen);\n            }\n            if (code) {\n                xfree(plain);\n                *minor_status = code;\n                return(GSS_S_FAILURE);\n            }\n        } else {\n            plain = ptr+14+cksum_len;\n        }\n\n        plainlen = tmsglen;\n\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n        token.length = tmsglen - conflen - plain[tmsglen-1];\n\n        if (token.length) {\n            if ((token.value = (void *) gssalloc_malloc(token.length)) == NULL) {\n                if (sealalg != 0xffff)\n                    xfree(plain);\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            memcpy(token.value, plain+conflen, token.length);\n        } else {\n            token.value = NULL;\n        }\n    } else if (toktype == KG_TOK_SIGN_MSG) {\n        token = *message_buffer;\n        plain = token.value;\n        plainlen = token.length;\n    } else {\n        token.length = 0;\n        token.value = NULL;\n        plain = token.value;\n        plainlen = token.length;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the the cksum */\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort ();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code)\n        return(code);\n    md5cksum.length = sumlen;\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (signalg == 0)\n            cksum.length = 8;\n        else\n            cksum.length = 16;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n\n    case SGN_ALG_MD2_5:\n        if (!ctx->seed_init &&\n            (code = kg_make_seed(context, ctx->subkey, ctx->seed))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (! (data_ptr = xmalloc(sizeof(ctx->seed) + 8 + plainlen))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n        (void) memcpy(data_ptr, ptr-2, 8);\n        (void) memcpy(data_ptr+8, ctx->seed, sizeof(ctx->seed));\n        (void) memcpy(data_ptr+8+sizeof(ctx->seed), plain, plainlen);\n        plaind.length = 8 + sizeof(ctx->seed) + plainlen;\n        plaind.data = data_ptr;\n        krb5_free_checksum_contents(context, &md5cksum);\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, 8);\n        /* Falls through to defective-token??  */\n\n    default:\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    }\n\n    krb5_free_checksum_contents(context, &md5cksum);\n    if (sealalg != 0xffff)\n        xfree(plain);\n\n    /* compare the computed checksum against the transmitted checksum */\n\n    if (code) {\n        if (toktype == KG_TOK_SEAL_MSG)\n            gssalloc_free(token.value);\n        *minor_status = 0;\n        return(GSS_S_BAD_SIG);\n    }\n\n\n    /* it got through unscathed.  Make sure the context is unexpired */\n\n    if (toktype == KG_TOK_SEAL_MSG)\n        *message_buffer = token;\n\n    if (conf_state)\n        *conf_state = (sealalg != 0xffff);\n\n    if (qop_state)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    /* do sequencing checks */\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        if (toktype == KG_TOK_SEAL_MSG) {\n            gssalloc_free(token.value);\n            message_buffer->value = NULL;\n            message_buffer->length = 0;\n        }\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        return(GSS_S_BAD_SIG);\n    }\n\n    retval = g_seqstate_check(ctx->seqstate, (uint64_t)seqnum);\n\n    /* success or ordering violation */\n\n    *minor_status = 0;\n    return(retval);\n}",
        "target": 1,
        "cwe": [
            "CWE-125"
        ],
        "project": "krb5",
        "commit_id": "fb99962cbd063ac04c9a9d2cc7c75eab73f3533d",
        "hash": 35330153554857835075660787607562023682,
        "size": 384,
        "message": "Handle invalid RFC 1964 tokens [CVE-2014-4341...]\n\nDetect the following cases which would otherwise cause invalid memory\naccesses and/or integer underflow:\n\n* An RFC 1964 token being processed by an RFC 4121-only context\n  [CVE-2014-4342]\n\n* A header with fewer than 22 bytes after the token ID or an\n  incomplete checksum [CVE-2014-4341 CVE-2014-4342]\n\n* A ciphertext shorter than the confounder [CVE-2014-4341]\n\n* A declared padding length longer than the plaintext [CVE-2014-4341]\n\nIf we detect a bad pad byte, continue on to compute the checksum to\navoid creating a padding oracle, but treat the checksum as invalid\neven if it compares equal.\n\nCVE-2014-4341:\n\nIn MIT krb5, an unauthenticated remote attacker with the ability to\ninject packets into a legitimately established GSSAPI application\nsession can cause a program crash due to invalid memory references\nwhen attempting to read beyond the end of a buffer.\n\n    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:P/E:POC/RL:OF/RC:C\n\nCVE-2014-4342:\n\nIn MIT krb5 releases krb5-1.7 and later, an unauthenticated remote\nattacker with the ability to inject packets into a legitimately\nestablished GSSAPI application session can cause a program crash due\nto invalid memory references when reading beyond the end of a buffer\nor by causing a null pointer dereference.\n\n    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:P/E:POC/RL:OF/RC:C\n\n[tlyu@mit.edu: CVE summaries, CVSS]\n\nticket: 7949 (new)\nsubject: Handle invalid RFC 1964 tokens [CVE-2014-4341 CVE-2014-4342]\ntaget_version: 1.12.2\ntags: pullup"
    },
    {
        "func": "kg_unseal_v1_iov(krb5_context context,\n                 OM_uint32 *minor_status,\n                 krb5_gss_ctx_id_rec *ctx,\n                 gss_iov_buffer_desc *iov,\n                 int iov_count,\n                 size_t token_wrapper_len,\n                 int *conf_state,\n                 gss_qop_t *qop_state,\n                 int toktype)\n{\n    OM_uint32 code;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t trailer;\n    unsigned char *ptr;\n    int sealalg;\n    int signalg;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    size_t cksum_len = 0;\n    size_t conflen = 0;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    md5cksum.length = cksum.length = 0;\n    md5cksum.contents = cksum.contents = NULL;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    assert(header != NULL);\n\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n    if (trailer != NULL && trailer->buffer.length != 0) {\n        *minor_status = (OM_uint32)KRB5_BAD_MSIZE;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (header->buffer.length < token_wrapper_len + 14) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    ptr = (unsigned char *)header->buffer.value + token_wrapper_len;\n\n    signalg  = ptr[0];\n    signalg |= ptr[1] << 8;\n\n    sealalg  = ptr[2];\n    sealalg |= ptr[3] << 8;\n\n    if (ptr[4] != 0xFF || ptr[5] != 0xFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype == KG_TOK_WRAP_MSG &&\n        !(sealalg == 0xFFFF || sealalg == ctx->sealalg)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_WRAP_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n    code = kg_get_seq_num(context, ctx->seq, ptr + 14, ptr + 6, &direction,\n                          &seqnum);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_BAD_SIG;\n    }\n\n    /* decode the message, if SEAL */\n    if (toktype == KG_TOK_WRAP_MSG) {\n        if (sealalg != 0xFFFF) {\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                size_t i;\n\n                store_32_be(seqnum, bigend_seqnum);\n\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code != 0) {\n                    retval = GSS_S_FAILURE;\n                    goto cleanup;\n                }\n\n                assert(enc_key->length == 16);\n\n                for (i = 0; i < enc_key->length; i++)\n                    ((char *)enc_key->contents)[i] ^= 0xF0;\n\n                code = kg_arcfour_docrypt_iov(context, enc_key, 0,\n                                              &bigend_seqnum[0], 4,\n                                              iov, iov_count);\n                krb5_free_keyblock(context, enc_key);\n            } else {\n                code = kg_decrypt_iov(context, 0,\n                                      ((ctx->gss_flags & GSS_C_DCE_STYLE) != 0),\n                                      0 /*EC*/, 0 /*RRC*/,\n                                      ctx->enc, KG_USAGE_SEAL, NULL,\n                                      iov, iov_count);\n            }\n            if (code != 0) {\n                retval = GSS_S_FAILURE;\n                goto cleanup;\n            }\n        }\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n    }\n\n    if (header->buffer.length != token_wrapper_len + 14 + cksum_len + conflen) {\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the checksum */\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n    md5cksum.length = sumlen;\n\n    /* compute the checksum of the message */\n    code = kg_make_checksum_iov_v1(context, md5cksum.checksum_type,\n                                   cksum_len, ctx->seq, ctx->enc,\n                                   sign_usage, iov, iov_count, toktype,\n                                   &md5cksum);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code != 0) {\n            retval = GSS_S_FAILURE;\n            goto cleanup;\n        }\n\n        cksum.length = cksum_len;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    default:\n        code = 0;\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    if (code != 0) {\n        code = 0;\n        retval = GSS_S_BAD_SIG;\n        goto cleanup;\n    }\n\n    /*\n     * For GSS_C_DCE_STYLE, the caller manages the padding, because the\n     * pad length is in the RPC PDU. The value of the padding may be\n     * uninitialized. For normal GSS, the last bytes of the decrypted\n     * data contain the pad length. kg_fixup_padding_iov() will find\n     * this and fixup the last data IOV appropriately.\n     */\n    if (toktype == KG_TOK_WRAP_MSG &&\n        (ctx->gss_flags & GSS_C_DCE_STYLE) == 0) {\n        retval = kg_fixup_padding_iov(&code, iov, iov_count);\n        if (retval != GSS_S_COMPLETE)\n            goto cleanup;\n    }\n\n    if (conf_state != NULL)\n        *conf_state = (sealalg != 0xFFFF);\n\n    if (qop_state != NULL)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        retval = GSS_S_BAD_SIG;\n    }\n\n    code = 0;\n    retval = g_seqstate_check(ctx->seqstate, (uint64_t)seqnum);\n\ncleanup:\n    krb5_free_checksum_contents(context, &md5cksum);\n\n    *minor_status = code;\n\n    return retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-125"
        ],
        "project": "krb5",
        "commit_id": "fb99962cbd063ac04c9a9d2cc7c75eab73f3533d",
        "hash": 117885488829129454560697637246026284173,
        "size": 258,
        "message": "Handle invalid RFC 1964 tokens [CVE-2014-4341...]\n\nDetect the following cases which would otherwise cause invalid memory\naccesses and/or integer underflow:\n\n* An RFC 1964 token being processed by an RFC 4121-only context\n  [CVE-2014-4342]\n\n* A header with fewer than 22 bytes after the token ID or an\n  incomplete checksum [CVE-2014-4341 CVE-2014-4342]\n\n* A ciphertext shorter than the confounder [CVE-2014-4341]\n\n* A declared padding length longer than the plaintext [CVE-2014-4341]\n\nIf we detect a bad pad byte, continue on to compute the checksum to\navoid creating a padding oracle, but treat the checksum as invalid\neven if it compares equal.\n\nCVE-2014-4341:\n\nIn MIT krb5, an unauthenticated remote attacker with the ability to\ninject packets into a legitimately established GSSAPI application\nsession can cause a program crash due to invalid memory references\nwhen attempting to read beyond the end of a buffer.\n\n    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:P/E:POC/RL:OF/RC:C\n\nCVE-2014-4342:\n\nIn MIT krb5 releases krb5-1.7 and later, an unauthenticated remote\nattacker with the ability to inject packets into a legitimately\nestablished GSSAPI application session can cause a program crash due\nto invalid memory references when reading beyond the end of a buffer\nor by causing a null pointer dereference.\n\n    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:P/E:POC/RL:OF/RC:C\n\n[tlyu@mit.edu: CVE summaries, CVSS]\n\nticket: 7949 (new)\nsubject: Handle invalid RFC 1964 tokens [CVE-2014-4341 CVE-2014-4342]\ntaget_version: 1.12.2\ntags: pullup"
    },
    {
        "func": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n\n    //do padding ourselves\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n\n    if (!cipher.ok())\n        return cipherText;\n\n    if (direction)\n        temp2 = byteToB64(temp2);\n\n    return temp2;\n}",
        "target": 1,
        "cwe": [
            "CWE-125"
        ],
        "project": "quassel",
        "commit_id": "8b5ecd226f9208af3074b33d3b7cf5e14f55b138",
        "hash": 265013214695045996969108866260238317366,
        "size": 29,
        "message": "Check for invalid input in encrypted buffers\n\nThe ECB Blowfish decryption function assumed that encrypted input would\nalways come in blocks of 12 characters, as specified. However, buggy\nclients or annoying people may not adhere to that assumption, causing\nthe core to crash while trying to process the invalid base64 input.\n\nWith this commit we make sure that we're not overstepping the bounds of\nthe input string while decoding it; instead we bail out early and display\nthe original input. Fixes #1314.\n\nThanks to Tucos for finding that one!"
    },
    {
        "func": "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t/* get the size after alignment with the u32 buffer size field */\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->enter_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
        "target": 1,
        "cwe": [
            "CWE-125",
            "CWE-476",
            "CWE-119",
            "CWE-264"
        ],
        "project": "linux",
        "commit_id": "086ba77a6db00ed858ff07451bedee197df868c9",
        "hash": 226612250686586249193735332099919371239,
        "size": 38,
        "message": "tracing/syscalls: Ignore numbers outside NR_syscalls' range\n\nARM has some private syscalls (for example, set_tls(2)) which lie\noutside the range of NR_syscalls.  If any of these are called while\nsyscall tracing is being performed, out-of-bounds array access will\noccur in the ftrace and perf sys_{enter,exit} handlers.\n\n # trace-cmd record -e raw_syscalls:* true && trace-cmd report\n ...\n true-653   [000]   384.675777: sys_enter:            NR 192 (0, 1000, 3, 4000022, ffffffff, 0)\n true-653   [000]   384.675812: sys_exit:             NR 192 = 1995915264\n true-653   [000]   384.675971: sys_enter:            NR 983045 (76f74480, 76f74000, 76f74b28, 76f74480, 76f76f74, 1)\n true-653   [000]   384.675988: sys_exit:             NR 983045 = 0\n ...\n\n # trace-cmd record -e syscalls:* true\n [   17.289329] Unable to handle kernel paging request at virtual address aaaaaace\n [   17.289590] pgd = 9e71c000\n [   17.289696] [aaaaaace] *pgd=00000000\n [   17.289985] Internal error: Oops: 5 [#1] PREEMPT SMP ARM\n [   17.290169] Modules linked in:\n [   17.290391] CPU: 0 PID: 704 Comm: true Not tainted 3.18.0-rc2+ #21\n [   17.290585] task: 9f4dab00 ti: 9e710000 task.ti: 9e710000\n [   17.290747] PC is at ftrace_syscall_enter+0x48/0x1f8\n [   17.290866] LR is at syscall_trace_enter+0x124/0x184\n\nFix this by ignoring out-of-NR_syscalls-bounds syscall numbers.\n\nCommit cd0980fc8add \"tracing: Check invalid syscall nr while tracing syscalls\"\nadded the check for less than zero, but it should have also checked\nfor greater than NR_syscalls.\n\nLink: http://lkml.kernel.org/p/1414620418-29472-1-git-send-email-rabin@rab.in\n\nFixes: cd0980fc8add \"tracing: Check invalid syscall nr while tracing syscalls\"\nCc: stable@vger.kernel.org # 2.6.33+\nSigned-off-by: Rabin Vincent <rabin@rab.in>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>"
    },
    {
        "func": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
        "target": 1,
        "cwe": [
            "CWE-125",
            "CWE-476",
            "CWE-119",
            "CWE-264"
        ],
        "project": "linux",
        "commit_id": "086ba77a6db00ed858ff07451bedee197df868c9",
        "hash": 175793673692406369921617089605350948002,
        "size": 47,
        "message": "tracing/syscalls: Ignore numbers outside NR_syscalls' range\n\nARM has some private syscalls (for example, set_tls(2)) which lie\noutside the range of NR_syscalls.  If any of these are called while\nsyscall tracing is being performed, out-of-bounds array access will\noccur in the ftrace and perf sys_{enter,exit} handlers.\n\n # trace-cmd record -e raw_syscalls:* true && trace-cmd report\n ...\n true-653   [000]   384.675777: sys_enter:            NR 192 (0, 1000, 3, 4000022, ffffffff, 0)\n true-653   [000]   384.675812: sys_exit:             NR 192 = 1995915264\n true-653   [000]   384.675971: sys_enter:            NR 983045 (76f74480, 76f74000, 76f74b28, 76f74480, 76f76f74, 1)\n true-653   [000]   384.675988: sys_exit:             NR 983045 = 0\n ...\n\n # trace-cmd record -e syscalls:* true\n [   17.289329] Unable to handle kernel paging request at virtual address aaaaaace\n [   17.289590] pgd = 9e71c000\n [   17.289696] [aaaaaace] *pgd=00000000\n [   17.289985] Internal error: Oops: 5 [#1] PREEMPT SMP ARM\n [   17.290169] Modules linked in:\n [   17.290391] CPU: 0 PID: 704 Comm: true Not tainted 3.18.0-rc2+ #21\n [   17.290585] task: 9f4dab00 ti: 9e710000 task.ti: 9e710000\n [   17.290747] PC is at ftrace_syscall_enter+0x48/0x1f8\n [   17.290866] LR is at syscall_trace_enter+0x124/0x184\n\nFix this by ignoring out-of-NR_syscalls-bounds syscall numbers.\n\nCommit cd0980fc8add \"tracing: Check invalid syscall nr while tracing syscalls\"\nadded the check for less than zero, but it should have also checked\nfor greater than NR_syscalls.\n\nLink: http://lkml.kernel.org/p/1414620418-29472-1-git-send-email-rabin@rab.in\n\nFixes: cd0980fc8add \"tracing: Check invalid syscall nr while tracing syscalls\"\nCc: stable@vger.kernel.org # 2.6.33+\nSigned-off-by: Rabin Vincent <rabin@rab.in>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>"
    },
    {
        "func": "unsigned long convert_rip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->rip;\n\tseg = regs->cs & 0xffff;\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "29eb51101c02df517ca64ec472d7501127ad1da8",
        "hash": 1508545436095858671693183645763265341,
        "size": 29,
        "message": "Handle bogus %cs selector in single-step instruction decoding\n\nThe code for LDT segment selectors was not robust in the face of a bogus\nselector set in %cs via ptrace before the single-step was done.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->eip;\n\tseg = regs->xcs & 0xffff;\n\tif (regs->eflags & VM_MASK) {\n\t\taddr = (addr & 0xffff) + (seg << 4);\n\t\treturn addr;\n\t}\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "29eb51101c02df517ca64ec472d7501127ad1da8",
        "hash": 106350190623619753707189764532983232553,
        "size": 33,
        "message": "Handle bogus %cs selector in single-step instruction decoding\n\nThe code for LDT segment selectors was not robust in the face of a bogus\nselector set in %cs via ptrace before the single-step was done.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tif (rlim_cur == 0) {\n\t\t\t/*\n\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t\t * never set\".  So let's cheat and make it one second\n\t\t\t * instead\n\t\t\t */\n\t\t\trlim_cur = 1;\n\t\t}\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "9926e4c74300c4b31dee007298c6475d33369df0",
        "hash": 53303886230877642634155857946902981974,
        "size": 63,
        "message": "CPU time limit patch / setrlimit(RLIMIT_CPU, 0) cheat fix\n\nAs discovered here today, the change in Kernel 2.6.17 intended to inhibit\nusers from setting RLIMIT_CPU to 0 (as that is equivalent to unlimited) by\n\"cheating\" and setting it to 1 in such a case, does not make a difference,\nas the check is done in the wrong place (too late), and only applies to the\nprofiling code.\n\nOn all systems I checked running kernels above 2.6.17, no matter what the\nhard and soft CPU time limits were before, a user could escape them by\nissuing in the shell (sh/bash/zsh) \"ulimit -t 0\", and then the user's\nprocess was not ever killed.\n\nAttached is a trivial patch to fix that.  Simply moving the check to a\nslightly earlier location (specifically, before the line that actually\nassigns the limit - *old_rlim = new_rlim), does the trick.\n\nDo note that at least the zsh (but not ash, dash, or bash) shell has the\nproblem of \"caching\" the limits set by the ulimit command, so when running\nzsh the fix will not immediately be evident - after entering \"ulimit -t 0\",\n\"ulimit -a\" will show \"-t: cpu time (seconds) 0\", even though the actual\nlimit as returned by getrlimit(...) will be 1.  It can be verified by\nopening a subshell (which will not have the values of the parent shell in\ncache) and checking in it, or just by running a CPU intensive command like\n\"echo '65536^1048576' | bc\" and verifying that it dumps core after one\nsecond.\n\nRegardless of whether that is a misfeature in the shell, perhaps it would\nbe better to return -EINVAL from setrlimit in such a case instead of\ncheating and setting to 1, as that does not really reflect the actual state\nof the process anymore.  I do not however know what the ground for that\ndecision was in the original 2.6.17 change, and whether there would be any\n\"backward\" compatibility issues, so I preferred not to touch that right\nnow.\n\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "CairoFont *CairoFont::create(GfxFont *gfxFont, XRef *xref, FT_Library lib, GBool useCIDs) {\n  Ref embRef;\n  Object refObj, strObj;\n  GooString *tmpFileName, *fileName,*tmpFileName2;\n  DisplayFontParam *dfp;\n  FILE *tmpFile;\n  int c, i, n;\n  GfxFontType fontType;\n  char **enc;\n  char *name;\n  FoFiTrueType *ff;\n  FoFiType1C *ff1c;\n  Ref ref;\n  static cairo_user_data_key_t cairo_font_face_key;\n  cairo_font_face_t *cairo_font_face;\n  FT_Face face;\n\n  Gushort *codeToGID;\n  int codeToGIDLen;\n  \n  dfp = NULL;\n  codeToGID = NULL;\n  codeToGIDLen = 0;\n  cairo_font_face = NULL;\n  \n  ref = *gfxFont->getID();\n  fontType = gfxFont->getType();\n\n  tmpFileName = NULL;\n\n  if (gfxFont->getEmbeddedFontID(&embRef)) {\n    if (!openTempFile(&tmpFileName, &tmpFile, \"wb\", NULL)) {\n      error(-1, \"Couldn't create temporary font file\");\n      goto err2;\n    }\n    \n    refObj.initRef(embRef.num, embRef.gen);\n    refObj.fetch(xref, &strObj);\n    refObj.free();\n    strObj.streamReset();\n    while ((c = strObj.streamGetChar()) != EOF) {\n      fputc(c, tmpFile);\n    }\n    strObj.streamClose();\n    strObj.free();\n    fclose(tmpFile);\n    fileName = tmpFileName;\n    \n  } else if (!(fileName = gfxFont->getExtFontFile())) {\n    // look for a display font mapping or a substitute font\n    dfp = NULL;\n    if (gfxFont->getName()) {\n      dfp = globalParams->getDisplayFont(gfxFont);\n    }\n    if (!dfp) {\n      error(-1, \"Couldn't find a font for '%s'\",\n\t    gfxFont->getName() ? gfxFont->getName()->getCString()\n\t    : \"(unnamed)\");\n      goto err2;\n    }\n    switch (dfp->kind) {\n    case displayFontT1:\n      fileName = dfp->t1.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType0 : fontType1;\n      break;\n    case displayFontTT:\n      fileName = dfp->tt.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;\n      break;\n    }\n  }\n\n  switch (fontType) {\n  case fontType1:\n  case fontType1C:\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      error(-1, \"could not create type1 face\");\n      goto err2;\n    }\n    \n    enc = ((Gfx8BitFont *)gfxFont)->getEncoding();\n    \n    codeToGID = (Gushort *)gmallocn(256, sizeof(int));\n    codeToGIDLen = 256;\n    for (i = 0; i < 256; ++i) {\n      codeToGID[i] = 0;\n      if ((name = enc[i])) {\n\tcodeToGID[i] = (Gushort)FT_Get_Name_Index(face, name);\n      }\n    }\n    break;\n    \n  case fontCIDType2:\n    codeToGID = NULL;\n    n = 0;\n    if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {\n      n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();\n      if (n) {\n\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n\tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),\n\t\tn * sizeof(Gushort));\n      }\n    } else {\n      ff = FoFiTrueType::load(fileName->getCString());\n      if (! ff)\n\tgoto err2;\n      codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);\n      delete ff;\n    }\n    codeToGIDLen = n;\n    /* Fall through */\n  case fontTrueType:\n    if (!(ff = FoFiTrueType::load(fileName->getCString()))) {\n      error(-1, \"failed to load truetype font\\n\");\n      goto err2;\n    }\n    /* This might be set already for the CIDType2 case */\n    if (fontType == fontTrueType) {\n      codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);\n      codeToGIDLen = 256;\n    }\n    if (!openTempFile(&tmpFileName2, &tmpFile, \"wb\", NULL)) {\n      delete ff;\n      error(-1, \"failed to open truetype tempfile\\n\");\n      goto err2;\n    }\n    ff->writeTTF(&fileWrite, tmpFile);\n    fclose(tmpFile);\n    delete ff;\n\n    if (FT_New_Face(lib, tmpFileName2->getCString(), 0, &face)) {\n      error(-1, \"could not create truetype face\\n\");\n      goto err2;\n    }\n    unlink (tmpFileName2->getCString());\n    delete tmpFileName2;\n    break;\n    \n  case fontCIDType0:\n  case fontCIDType0C:\n\n    codeToGID = NULL;\n    codeToGIDLen = 0;\n\n    if (!useCIDs)\n    {\n      if ((ff1c = FoFiType1C::load(fileName->getCString()))) {\n        codeToGID = ff1c->getCIDToGIDMap(&codeToGIDLen);\n        delete ff1c;\n      }\n    }\n\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      gfree(codeToGID);\n      codeToGID = NULL;\n      error(-1, \"could not create cid face\\n\");\n      goto err2;\n    }\n    break;\n    \n  default:\n    printf (\"font type not handled\\n\");\n    goto err2;\n    break;\n  }\n\n  // delete the (temporary) font file -- with Unix hard link\n  // semantics, this will remove the last link; otherwise it will\n  // return an error, leaving the file to be deleted later\n  if (fileName == tmpFileName) {\n    unlink (fileName->getCString());\n    delete tmpFileName;\n  }\n\n  cairo_font_face = cairo_ft_font_face_create_for_ft_face (face,\n\t\t\t\t\t\t\t   FT_LOAD_NO_HINTING |\n\t\t\t\t\t\t\t   FT_LOAD_NO_BITMAP);\n  if (cairo_font_face == NULL) {\n    error(-1, \"could not create cairo font\\n\");\n    goto err2; /* this doesn't do anything, but it looks like we're\n\t\t* handling the error */\n  } {\n  CairoFont *ret = new CairoFont(ref, cairo_font_face, face, codeToGID, codeToGIDLen);\n  cairo_font_face_set_user_data (cairo_font_face, \n\t\t\t\t &cairo_font_face_key,\n\t\t\t\t ret,\n\t\t\t\t cairo_font_face_destroy);\n\n  return ret;\n  }\n err2:\n  /* hmm? */\n  printf (\"some font thing failed\\n\");\n  return NULL;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "poppler",
        "commit_id": "1a531dcfee1c6fc79a414c38cbe7327fbf9a59d8",
        "hash": 294666036737394333902439398055542844956,
        "size": 195,
        "message": "Fix a crash with invalid embedded fonts"
    },
    {
        "func": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f",
        "hash": 192373302205049669343839180384526250684,
        "size": 136,
        "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static int do_pages_stat(struct mm_struct *mm, struct page_to_node *pm)\n{\n\tdown_read(&mm->mmap_sem);\n\n\tfor ( ; pm->node != MAX_NUMNODES; pm++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err;\n\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pm->addr);\n\t\tif (!vma)\n\t\t\tgoto set_status;\n\n\t\tpage = follow_page(vma, pm->addr, 0);\n\t\terr = -ENOENT;\n\t\t/* Use PageReserved to check for zero page */\n\t\tif (!page || PageReserved(page))\n\t\t\tgoto set_status;\n\n\t\terr = page_to_nid(page);\nset_status:\n\t\tpm->status = err;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f",
        "hash": 190691605824195418496832518891413550081,
        "size": 28,
        "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static int do_move_pages(struct mm_struct *mm, struct page_to_node *pm,\n\t\t\t\tint migrate_all)\n{\n\tint err;\n\tstruct page_to_node *pp;\n\tLIST_HEAD(pagelist);\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Build a list of pages to migrate\n\t */\n\tmigrate_prep();\n\tfor (pp = pm; pp->node != MAX_NUMNODES; pp++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * A valid page pointer that will not match any of the\n\t\t * pages that will be moved.\n\t\t */\n\t\tpp->page = ZERO_PAGE(0);\n\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pp->addr);\n\t\tif (!vma || !vma_migratable(vma))\n\t\t\tgoto set_status;\n\n\t\tpage = follow_page(vma, pp->addr, FOLL_GET);\n\t\terr = -ENOENT;\n\t\tif (!page)\n\t\t\tgoto set_status;\n\n\t\tif (PageReserved(page))\t\t/* Check for zero page */\n\t\t\tgoto put_and_set;\n\n\t\tpp->page = page;\n\t\terr = page_to_nid(page);\n\n\t\tif (err == pp->node)\n\t\t\t/*\n\t\t\t * Node already in the right place\n\t\t\t */\n\t\t\tgoto put_and_set;\n\n\t\terr = -EACCES;\n\t\tif (page_mapcount(page) > 1 &&\n\t\t\t\t!migrate_all)\n\t\t\tgoto put_and_set;\n\n\t\terr = isolate_lru_page(page, &pagelist);\nput_and_set:\n\t\t/*\n\t\t * Either remove the duplicate refcount from\n\t\t * isolate_lru_page() or drop the page ref if it was\n\t\t * not isolated.\n\t\t */\n\t\tput_page(page);\nset_status:\n\t\tpp->status = err;\n\t}\n\n\tif (!list_empty(&pagelist))\n\t\terr = migrate_pages(&pagelist, new_page_node,\n\t\t\t\t(unsigned long)pm);\n\telse\n\t\terr = -ENOENT;\n\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f",
        "hash": 18220699088629601462246906502957374129,
        "size": 71,
        "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static void dump_one_vdso_page(struct page *pg, struct page *upg)\n{\n\tprintk(\"kpg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(pg) << PAGE_SHIFT),\n\t       page_count(pg),\n\t       pg->flags);\n\tif (upg/* && pg != upg*/) {\n\t\tprintk(\" upg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(upg)\n\t\t\t\t\t\t       << PAGE_SHIFT),\n\t\t       page_count(upg),\n\t\t       upg->flags);\n\t}\n\tprintk(\"\\n\");\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f",
        "hash": 198053340576165894602613243780199057717,
        "size": 13,
        "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\tunsigned int flags)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tgoto out;\n\t}\n\n\tpage = NULL;\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto no_page_table;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto no_page_table;\n\t\n\tpmd = pmd_offset(pud, address);\n\tif (pmd_none(*pmd))\n\t\tgoto no_page_table;\n\n\tif (pmd_huge(*pmd)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags & FOLL_WRITE);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(pmd_bad(*pmd)))\n\t\tgoto no_page_table;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!ptep)\n\t\tgoto out;\n\n\tpte = *ptep;\n\tif (!pte_present(pte))\n\t\tgoto unlock;\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\tpage = vm_normal_page(vma, address, pte);\n\tif (unlikely(!page))\n\t\tgoto unlock;\n\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\tmark_page_accessed(page);\n\t}\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn page;\n\nno_page_table:\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate page tables.\n\t */\n\tif (flags & FOLL_ANON) {\n\t\tpage = ZERO_PAGE(0);\n\t\tif (flags & FOLL_GET)\n\t\t\tget_page(page);\n\t\tBUG_ON(flags & FOLL_WRITE);\n\t}\n\treturn page;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f",
        "hash": 210867550916712742645262184349384453522,
        "size": 78,
        "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn i ? i : PTR_ERR(page);\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "672ca28e300c17bf8d792a2a7a8631193e580c74",
        "hash": 139010725753363214663812040837173395590,
        "size": 138,
        "message": "Fix ZERO_PAGE breakage with vmware\n\nCommit 89f5b7da2a6bad2e84670422ab8192382a5aeb9f (\"Reinstate ZERO_PAGE\noptimization in 'get_user_pages()' and fix XIP\") broke vmware, as\nreported by Jeff Chua:\n\n  \"This broke vmware 6.0.4.\n   Jun 22 14:53:03.845: vmx| NOT_IMPLEMENTED\n   /build/mts/release/bora-93057/bora/vmx/main/vmmonPosix.c:774\"\n\nand the reason seems to be that there's an old bug in how we handle do\nFOLL_ANON on VM_SHARED areas in get_user_pages(), but since it only\ntriggered if the whole page table was missing, nobody had apparently hit\nit before.\n\nThe recent changes to 'follow_page()' made the FOLL_ANON logic trigger\nnot just for whole missing page tables, but for individual pages as\nwell, and exposed this problem.\n\nThis fixes it by making the test for when FOLL_ANON is used more\ncareful, and also makes the code easier to read and understand by moving\nthe logic to a separate inline function.\n\nReported-and-tested-by: Jeff Chua <jeff.chua.linux@gmail.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "_dbus_validate_signature_with_reason (const DBusString *type_str,\n                                      int               type_pos,\n                                      int               len)\n{\n  const unsigned char *p;\n  const unsigned char *end;\n  int last;\n  int struct_depth;\n  int array_depth;\n  int dict_entry_depth;\n  DBusValidity result;\n\n  int element_count;\n  DBusList *element_count_stack;\n\n  result = DBUS_VALID;\n  element_count_stack = NULL;\n\n  if (!_dbus_list_append (&element_count_stack, _DBUS_INT_TO_POINTER (0)))\n    {\n      result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n      goto out;\n    }\n\n  _dbus_assert (type_str != NULL);\n  _dbus_assert (type_pos < _DBUS_INT32_MAX - len);\n  _dbus_assert (len >= 0);\n  _dbus_assert (type_pos >= 0);\n\n  if (len > DBUS_MAXIMUM_SIGNATURE_LENGTH)\n    {\n      result = DBUS_INVALID_SIGNATURE_TOO_LONG;\n      goto out;\n    }\n\n  p = _dbus_string_get_const_data_len (type_str, type_pos, 0);\n\n  end = _dbus_string_get_const_data_len (type_str, type_pos + len, 0);\n  struct_depth = 0;\n  array_depth = 0;\n  dict_entry_depth = 0;\n  last = DBUS_TYPE_INVALID;\n\n  while (p != end)\n    {\n      switch (*p)\n        {\n        case DBUS_TYPE_BYTE:\n        case DBUS_TYPE_BOOLEAN:\n        case DBUS_TYPE_INT16:\n        case DBUS_TYPE_UINT16:\n        case DBUS_TYPE_INT32:\n        case DBUS_TYPE_UINT32:\n        case DBUS_TYPE_INT64:\n        case DBUS_TYPE_UINT64:\n        case DBUS_TYPE_DOUBLE:\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n        case DBUS_TYPE_VARIANT:\n          break;\n\n        case DBUS_TYPE_ARRAY:\n          array_depth += 1;\n          if (array_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_ARRAY_RECURSION;\n              goto out;\n            }\n          break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n          struct_depth += 1;\n\n          if (struct_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_STRUCT_RECURSION;\n              goto out;\n            }\n          \n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (0)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n\n          break;\n\n        case DBUS_STRUCT_END_CHAR:\n          if (struct_depth == 0)\n            {\n              result = DBUS_INVALID_STRUCT_ENDED_BUT_NOT_STARTED;\n              goto out;\n            }\n\n          if (last == DBUS_STRUCT_BEGIN_CHAR)\n            {\n              result = DBUS_INVALID_STRUCT_HAS_NO_FIELDS;\n              goto out;\n            }\n\n          _dbus_list_pop_last (&element_count_stack);\n\n          struct_depth -= 1;\n          break;\n\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n          if (last != DBUS_TYPE_ARRAY)\n            {\n              result = DBUS_INVALID_DICT_ENTRY_NOT_INSIDE_ARRAY;\n              goto out;\n            }\n            \n          dict_entry_depth += 1;\n\n          if (dict_entry_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_DICT_ENTRY_RECURSION;\n              goto out;\n            }\n\n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (0)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n\n          break;\n\n        case DBUS_DICT_ENTRY_END_CHAR:\n          if (dict_entry_depth == 0)\n            {\n              result = DBUS_INVALID_DICT_ENTRY_ENDED_BUT_NOT_STARTED;\n              goto out;\n            }\n            \n          dict_entry_depth -= 1;\n\n          element_count = \n            _DBUS_POINTER_TO_INT (_dbus_list_pop_last (&element_count_stack));\n\n          if (element_count != 2)\n            {\n              if (element_count == 0)\n                result = DBUS_INVALID_DICT_ENTRY_HAS_NO_FIELDS;\n              else if (element_count == 1)\n                result = DBUS_INVALID_DICT_ENTRY_HAS_ONLY_ONE_FIELD;\n              else\n                result = DBUS_INVALID_DICT_ENTRY_HAS_TOO_MANY_FIELDS;\n              \n              goto out;\n            }\n          break;\n          \n        case DBUS_TYPE_STRUCT:     /* doesn't appear in signatures */\n        case DBUS_TYPE_DICT_ENTRY: /* ditto */\n        default:\n          result = DBUS_INVALID_UNKNOWN_TYPECODE;\n\t  goto out;\n        }\n\n      if (*p != DBUS_TYPE_ARRAY && \n          *p != DBUS_DICT_ENTRY_BEGIN_CHAR && \n\t  *p != DBUS_STRUCT_BEGIN_CHAR) \n        {\n          element_count = \n            _DBUS_POINTER_TO_INT (_dbus_list_pop_last (&element_count_stack));\n\n          ++element_count;\n\n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (element_count)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n        }\n      \n      if (array_depth > 0)\n        {\n          if (*p == DBUS_TYPE_ARRAY && p != end)\n            {\n\t       const char *p1;\n\t       p1 = p + 1;\n               if (*p1 == DBUS_STRUCT_END_CHAR ||\n                   *p1 == DBUS_DICT_ENTRY_END_CHAR)\n                 {\n                   result = DBUS_INVALID_MISSING_ARRAY_ELEMENT_TYPE;\n                   goto out;\n                 }\n            }\n          else\n\t    {\n              array_depth = 0;\n\t    }\n        }\n\n      if (last == DBUS_DICT_ENTRY_BEGIN_CHAR &&\n          !dbus_type_is_basic (*p))\n        {\n          result = DBUS_INVALID_DICT_KEY_MUST_BE_BASIC_TYPE;\n          goto out;\n        }\n        \n      last = *p;\n      ++p;\n    }\n\n\n  if (array_depth > 0)\n    {\n      result = DBUS_INVALID_MISSING_ARRAY_ELEMENT_TYPE;\n      goto out;\n    }\n    \n  if (struct_depth > 0)\n    {\n       result = DBUS_INVALID_STRUCT_STARTED_BUT_NOT_ENDED;\n       goto out;\n    }\n    \n  if (dict_entry_depth > 0)\n    {\n      result =  DBUS_INVALID_DICT_ENTRY_STARTED_BUT_NOT_ENDED;\n      goto out;\n    }\n    \n  _dbus_assert (last != DBUS_TYPE_ARRAY);\n  _dbus_assert (last != DBUS_STRUCT_BEGIN_CHAR);\n  _dbus_assert (last != DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n  result = DBUS_VALID;\n\nout:\n  _dbus_list_clear (&element_count_stack);\n  return result;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "dbus",
        "commit_id": "7b10b46c5c8658449783ce45f1273dd35c353bce",
        "hash": 213008185461133891530199648793951571977,
        "size": 239,
        "message": "Bug 17803: Panic from dbus_signature_validate\n\n\t* dbus/dbus-marshal-validate.c: Ensure we validate\n\ta basic type before calling is_basic on it.\n\t* dbus-marshal-validate-util.c: Test."
    },
    {
        "func": "_dbus_marshal_validate_test (void)\n{\n  DBusString str;\n  int i;\n\n  const char *valid_paths[] = {\n    \"/\",\n    \"/foo/bar\",\n    \"/foo\",\n    \"/foo/bar/baz\"\n  };\n  const char *invalid_paths[] = {\n    \"bar\",\n    \"bar/baz\",\n    \"/foo/bar/\",\n    \"/foo/\"\n    \"foo/\",\n    \"boo//blah\",\n    \"//\",\n    \"///\",\n    \"foo///blah/\",\n    \"Hello World\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_interfaces[] = {\n    \"org.freedesktop.Foo\",\n    \"Bar.Baz\",\n    \"Blah.Blah.Blah.Blah.Blah\",\n    \"a.b\",\n    \"a.b.c.d.e.f.g\",\n    \"a0.b1.c2.d3.e4.f5.g6\",\n    \"abc123.foo27\"\n  };\n  const char *invalid_interfaces[] = {\n    \".\",\n    \"\",\n    \"..\",\n    \".Foo.Bar\",\n    \"..Foo.Bar\",\n    \"Foo.Bar.\",\n    \"Foo.Bar..\",\n    \"Foo\",\n    \"9foo.bar.baz\",\n    \"foo.bar..baz\",\n    \"foo.bar...baz\",\n    \"foo.bar.b..blah\",\n    \":\",\n    \":0-1\",\n    \"10\",\n    \":11.34324\",\n    \"0.0.0\",\n    \"0..0\",\n    \"foo.Bar.%\",\n    \"foo.Bar!!\",\n    \"!Foo.bar.bz\",\n    \"foo.$.blah\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_unique_names[] = {\n    \":0\",\n    \":a\",\n    \":\",\n    \":.a\",\n    \":.1\",\n    \":0.1\",\n    \":000.2222\",\n    \":.blah\",\n    \":abce.freedesktop.blah\"\n  };\n  const char *invalid_unique_names[] = {\n    //\":-\",\n    \":!\",\n    //\":0-10\",\n    \":blah.\",\n    \":blah.\",\n    \":blah..org\",\n    \":blah.org..\",\n    \":..blah.org\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_members[] = {\n    \"Hello\",\n    \"Bar\",\n    \"foobar\",\n    \"_foobar\",\n    \"foo89\"\n  };\n\n  const char *invalid_members[] = {\n    \"9Hello\",\n    \"10\",\n    \"1\",\n    \"foo-bar\",\n    \"blah.org\",\n    \".blah\",\n    \"blah.\",\n    \"Hello.\",\n    \"!foo\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_signatures[] = {\n    \"\",\n    \"sss\",\n    \"i\",\n    \"b\"\n  };\n\n  const char *invalid_signatures[] = {\n    \" \",\n    \"not a valid signature\",\n    \"123\",\n    \".\",\n    \"(\"\n  };\n\n  /* Signature with reason */\n\n  run_validity_tests (signature_tests, _DBUS_N_ELEMENTS (signature_tests),\n                      _dbus_validate_signature_with_reason);\n\n  /* Path validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_paths))\n    {\n      _dbus_string_init_const (&str, valid_paths[i]);\n\n      if (!_dbus_validate_path (&str, 0,\n                                _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Path \\\"%s\\\" should have been valid\\n\", valid_paths[i]);\n          _dbus_assert_not_reached (\"invalid path\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_paths))\n    {\n      _dbus_string_init_const (&str, invalid_paths[i]);\n\n      if (_dbus_validate_path (&str, 0,\n                               _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Path \\\"%s\\\" should have been invalid\\n\", invalid_paths[i]);\n          _dbus_assert_not_reached (\"valid path\");\n        }\n\n      ++i;\n    }\n\n  /* Interface validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_interface (&str, 0,\n                                     _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Interface \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid interface\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n      if (_dbus_validate_interface (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Interface \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n          _dbus_assert_not_reached (\"valid interface\");\n        }\n\n      ++i;\n    }\n\n  /* Bus name validation (check that valid interfaces are valid bus names,\n   * and invalid interfaces are invalid services except if they start with ':')\n   */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_bus_name (&str, 0,\n                                   _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid bus name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      if (invalid_interfaces[i][0] != ':')\n        {\n          _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n          if (_dbus_validate_bus_name (&str, 0,\n                                       _dbus_string_get_length (&str)))\n            {\n              _dbus_warn (\"Bus name \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n              _dbus_assert_not_reached (\"valid bus name\");\n            }\n        }\n\n      ++i;\n    }\n\n  /* unique name validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_unique_names))\n    {\n      _dbus_string_init_const (&str, valid_unique_names[i]);\n\n      if (!_dbus_validate_bus_name (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been valid\\n\", valid_unique_names[i]);\n          _dbus_assert_not_reached (\"invalid unique name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_unique_names))\n    {\n      _dbus_string_init_const (&str, invalid_unique_names[i]);\n\n      if (_dbus_validate_bus_name (&str, 0,\n                                   _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been invalid\\n\", invalid_unique_names[i]);\n          _dbus_assert_not_reached (\"valid unique name\");\n        }\n\n      ++i;\n    }\n\n\n  /* Error name validation (currently identical to interfaces)\n   */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_error_name (&str, 0,\n                                      _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Error name \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid error name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      if (invalid_interfaces[i][0] != ':')\n        {\n          _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n          if (_dbus_validate_error_name (&str, 0,\n                                         _dbus_string_get_length (&str)))\n            {\n              _dbus_warn (\"Error name \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n              _dbus_assert_not_reached (\"valid error name\");\n            }\n        }\n\n      ++i;\n    }\n\n  /* Member validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_members))\n    {\n      _dbus_string_init_const (&str, valid_members[i]);\n\n      if (!_dbus_validate_member (&str, 0,\n                                  _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Member \\\"%s\\\" should have been valid\\n\", valid_members[i]);\n          _dbus_assert_not_reached (\"invalid member\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_members))\n    {\n      _dbus_string_init_const (&str, invalid_members[i]);\n\n      if (_dbus_validate_member (&str, 0,\n                                 _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Member \\\"%s\\\" should have been invalid\\n\", invalid_members[i]);\n          _dbus_assert_not_reached (\"valid member\");\n        }\n\n      ++i;\n    }\n\n  /* Signature validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_signatures))\n    {\n      _dbus_string_init_const (&str, valid_signatures[i]);\n\n      if (!_dbus_validate_signature (&str, 0,\n                                     _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Signature \\\"%s\\\" should have been valid\\n\", valid_signatures[i]);\n          _dbus_assert_not_reached (\"invalid signature\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_signatures))\n    {\n      _dbus_string_init_const (&str, invalid_signatures[i]);\n\n      if (_dbus_validate_signature (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Signature \\\"%s\\\" should have been invalid\\n\", invalid_signatures[i]);\n          _dbus_assert_not_reached (\"valid signature\");\n        }\n\n      ++i;\n    }\n\n  /* Validate claimed length longer than real length */\n  _dbus_string_init_const (&str, \"abc.efg\");\n  if (_dbus_validate_bus_name (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n  if (_dbus_validate_interface (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n  if (_dbus_validate_error_name (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n\n  _dbus_string_init_const (&str, \"abc\");\n  if (_dbus_validate_member (&str, 0, 4))\n    _dbus_assert_not_reached (\"validated too-long string\");\n\n  _dbus_string_init_const (&str, \"sss\");\n  if (_dbus_validate_signature (&str, 0, 4))\n    _dbus_assert_not_reached (\"validated too-long signature\");\n\n  /* Validate string exceeding max name length */\n  if (!_dbus_string_init (&str))\n    _dbus_assert_not_reached (\"no memory\");\n\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc.def\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_bus_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n  if (_dbus_validate_interface (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n  if (_dbus_validate_error_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  /* overlong member */\n  _dbus_string_set_length (&str, 0);\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_member (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  /* overlong unique name */\n  _dbus_string_set_length (&str, 0);\n  _dbus_string_append (&str, \":\");\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_bus_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  _dbus_string_free (&str);\n\n  /* Body validation; test basic validation of valid bodies for both endian */\n  \n  {\n    int sequence;\n    DBusString signature;\n    DBusString body;\n\n    if (!_dbus_string_init (&signature) || !_dbus_string_init (&body))\n      _dbus_assert_not_reached (\"oom\");\n\n    sequence = 0;\n    while (dbus_internal_do_not_use_generate_bodies (sequence,\n                                                     DBUS_LITTLE_ENDIAN,\n                                                     &signature, &body))\n      {\n        DBusValidity validity;\n\n        validity = _dbus_validate_body_with_reason (&signature, 0,\n                                                    DBUS_LITTLE_ENDIAN,\n                                                    NULL, &body, 0,\n                                                    _dbus_string_get_length (&body));\n        if (validity != DBUS_VALID)\n          {\n            _dbus_warn (\"invalid code %d expected valid on sequence %d little endian\\n\",\n                        validity, sequence);\n            _dbus_verbose_bytes_of_string (&signature, 0, _dbus_string_get_length (&signature));\n            _dbus_verbose_bytes_of_string (&body, 0, _dbus_string_get_length (&body));\n            _dbus_assert_not_reached (\"test failed\");\n          }\n\n        _dbus_string_set_length (&signature, 0);\n        _dbus_string_set_length (&body, 0);\n        ++sequence;\n      }\n                                                     \n    sequence = 0;\n    while (dbus_internal_do_not_use_generate_bodies (sequence,\n                                                     DBUS_BIG_ENDIAN,\n                                                     &signature, &body))\n      {\n        DBusValidity validity;\n\n        validity = _dbus_validate_body_with_reason (&signature, 0,\n                                                    DBUS_BIG_ENDIAN,\n                                                    NULL, &body, 0,\n                                                    _dbus_string_get_length (&body));\n        if (validity != DBUS_VALID)\n          {\n            _dbus_warn (\"invalid code %d expected valid on sequence %d big endian\\n\",\n                        validity, sequence);\n            _dbus_verbose_bytes_of_string (&signature, 0, _dbus_string_get_length (&signature));\n            _dbus_verbose_bytes_of_string (&body, 0, _dbus_string_get_length (&body));\n            _dbus_assert_not_reached (\"test failed\");\n          }\n\n        _dbus_string_set_length (&signature, 0);\n        _dbus_string_set_length (&body, 0);\n        ++sequence;\n      }\n\n    _dbus_string_free (&signature);\n    _dbus_string_free (&body);\n  }\n  \n  return TRUE;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "dbus",
        "commit_id": "7b10b46c5c8658449783ce45f1273dd35c353bce",
        "hash": 213135535826009341630470472220764577494,
        "size": 478,
        "message": "Bug 17803: Panic from dbus_signature_validate\n\n\t* dbus/dbus-marshal-validate.c: Ensure we validate\n\ta basic type before calling is_basic on it.\n\t* dbus-marshal-validate-util.c: Test."
    },
    {
        "func": "sctp_disposition_t sctp_sf_do_asconf_ack(const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type, void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*asconf_ack = arg;\n\tstruct sctp_chunk\t*last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_chunk\t*abort;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*addip_hdr;\n\t__u32\t\t\tsent_serial, rcvd_serial;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!sctp_addip_noauth && !asconf_ack->auth)\n\t\treturn sctp_sf_discard_chunk(ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\taddip_hdr = (sctp_addiphdr_t *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t    (sctp_paramhdr_t *)addip_hdr->params,\n\t    (void *)asconf_ack->chunk_end,\n\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t   (void *)&err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (sctp_addiphdr_t *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack))\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "ba0166708ef4da7eeb61dd92bbba4d5a749d6561",
        "hash": 238014936619603626933694122657580426072,
        "size": 110,
        "message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands) {\n\tstatic const char err_str[] = \"The following parameter had invalid length:\";\n\n\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "ba0166708ef4da7eeb61dd92bbba4d5a749d6561",
        "hash": 99481638255279316689565876330546423538,
        "size": 11,
        "message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int sctp_process_inv_paramlength(const struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_paramhdr *param,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\tstatic const char error[] = \"The following parameter had invalid length:\";\n\tsize_t\t\tpayload_len = WORD_ROUND(sizeof(error)) +\n\t\t\t\t\t\tsizeof(sctp_paramhdr_t);\n\n\n\t/* This is a fatal error.  Any accumulated non-fatal errors are\n\t * not reported.\n\t */\n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t/* Create an error chunk and fill it in with our payload. */\n\t*errp = sctp_make_op_error_space(asoc, chunk, payload_len);\n\n\tif (*errp) {\n\t\tsctp_init_cause(*errp, SCTP_ERROR_PROTO_VIOLATION,\n\t\t\t\tsizeof(error) + sizeof(sctp_paramhdr_t));\n\t\tsctp_addto_chunk(*errp, sizeof(error), error);\n\t\tsctp_addto_param(*errp, sizeof(sctp_paramhdr_t), param);\n\t}\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "ba0166708ef4da7eeb61dd92bbba4d5a749d6561",
        "hash": 98589033401389580925538823963505757446,
        "size": 28,
        "message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "sctp_disposition_t sctp_sf_do_asconf(const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type, void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*chunk = arg;\n\tstruct sctp_chunk\t*asconf_ack = NULL;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\t__u32\t\t\tserial;\n\tint\t\t\tlength;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!sctp_addip_noauth && !chunk->auth)\n\t\treturn sctp_sf_discard_chunk(ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thdr = (sctp_addiphdr_t *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\taddr_param = (union sctp_addr_param *)hdr->params;\n\tlength = ntohs(addr_param->p.length);\n\tif (length < sizeof(sctp_paramhdr_t))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t   (void *)addr_param, commands);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t\t\t    (sctp_paramhdr_t *)((void *)addr_param + length),\n\t\t\t    (void *)chunk->chunk_end,\n\t\t\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t\t\t\t  (void *)&err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created untill we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}",
        "target": 1,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux-2.6",
        "commit_id": "ba0166708ef4da7eeb61dd92bbba4d5a749d6561",
        "hash": 163511805060768299091356245834014520485,
        "size": 110,
        "message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "newsbeuter",
        "commit_id": "26f5a4350f3ab5507bb8727051c87bb04660f333",
        "hash": 8547488974195567524268615964663146787,
        "size": 13,
        "message": "Work around shell code in podcast names (#598)"
    },
    {
        "func": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "newsbeuter",
        "commit_id": "26f5a4350f3ab5507bb8727051c87bb04660f333",
        "hash": 107680217014226123057785726715374321292,
        "size": 18,
        "message": "Work around shell code in podcast names (#598)"
    },
    {
        "func": "dvi_document_file_exporter_end (EvFileExporter *exporter)\n{\n\tgchar *command_line;\n\tgint exit_stat;\n\tGError *err = NULL;\n\tgboolean success;\n\t\n\tDviDocument *dvi_document = DVI_DOCUMENT(exporter);\n\t\n\tcommand_line = g_strdup_printf (\"dvipdfm %s -o %s \\\"%s\\\"\", /* dvipdfm -s 1,2,.., -o exporter_filename dvi_filename */\n\t\t\t\t\tdvi_document->exporter_opts->str,\n\t\t\t\t\tdvi_document->exporter_filename,\n\t\t\t\t\tdvi_document->context->filename);\n\t\n\tsuccess = g_spawn_command_line_sync (command_line,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &exit_stat,\n\t\t\t\t\t     &err);\n\n\tg_free (command_line);\n\n\tif (success == FALSE) {\n\t\tg_warning (\"Error: %s\", err->message);\n\t} else if (!WIFEXITED(exit_stat) || WEXITSTATUS(exit_stat) != EXIT_SUCCESS){\n\t\tg_warning (\"Error: dvipdfm does not end normally or exit with a failure status.\");\n\t}\n\n\tif (err)\n\t\tg_error_free (err);\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "evince",
        "commit_id": "350404c76dc8601e2cdd2636490e2afc83d3090e",
        "hash": 50052591889648541778268542212777747385,
        "size": 31,
        "message": "dvi: Mitigate command injection attacks by quoting filename\n\nWith commit 1fcca0b8041de0d6074d7e17fba174da36c65f99 came a DVI backend.\nIt exports to PDF via the dvipdfm tool.\nIt calls that tool with the filename of the currently loaded document.\nIf that filename is cleverly crafted, it can escape the currently\nused manual quoting of the filename.  Instead of manually quoting the\nfilename, we use g_shell_quote.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=784947"
    },
    {
        "func": "int imap_subscribe (char *path, int subscribe)\n{\n  IMAP_DATA *idata;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  BUFFER err, token;\n  IMAP_MBOX mx;\n\n  if (!mx_is_imap (path) || imap_parse_path (path, &mx) || !mx.mbox)\n  {\n    mutt_error (_(\"Bad mailbox name\"));\n    return -1;\n  }\n  if (!(idata = imap_conn_find (&(mx.account), 0)))\n    goto fail;\n\n  imap_fix_path (idata, mx.mbox, buf, sizeof (buf));\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", sizeof (buf));\n\n  if (option (OPTIMAPCHECKSUBSCRIBED))\n  {\n    mutt_buffer_init (&token);\n    mutt_buffer_init (&err);\n    err.data = errstr;\n    err.dsize = sizeof (errstr);\n    snprintf (mbox, sizeof (mbox), \"%smailboxes \\\"%s\\\"\",\n              subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line (mbox, &token, &err))\n      dprint (1, (debugfile, \"Error adding subscribed mailbox: %s\\n\", errstr));\n    FREE (&token.data);\n  }\n\n  if (subscribe)\n    mutt_message (_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message (_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name (idata, mbox, sizeof(mbox), buf);\n\n  snprintf (buf, sizeof (buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec (idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message (_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message (_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE (&mx.mbox);\n  return 0;\n\n fail:\n  FREE (&mx.mbox);\n  return -1;\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "mutt",
        "commit_id": "185152818541f5cdc059cbff3f3e8b654fc27c1d",
        "hash": 82516163886592472637833336303663731015,
        "size": 57,
        "message": "Properly quote IMAP mailbox names when (un)subscribing.\n\nWhen handling automatic subscription (via $imap_check_subscribed), or\nmanual subscribe/unsubscribe commands, mutt generating a \"mailboxes\"\ncommand but failed to properly escape backquotes.\n\nThanks to Jeriko One for the detailed bug report and patch, which this\ncommit is based upon."
    },
    {
        "func": "void imap_quote_string (char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt;\n  const char *s;\n\n  pt = dest;\n  s  = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr (quote, *s))\n    {\n      dlen -= 2;\n      if (!dlen)\n\tbreak;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "mutt",
        "commit_id": "185152818541f5cdc059cbff3f3e8b654fc27c1d",
        "hash": 331687002791660212622928122166265805500,
        "size": 32,
        "message": "Properly quote IMAP mailbox names when (un)subscribing.\n\nWhen handling automatic subscription (via $imap_check_subscribed), or\nmanual subscribe/unsubscribe commands, mutt generating a \"mailboxes\"\ncommand but failed to properly escape backquotes.\n\nThanks to Jeriko One for the detailed bug report and patch, which this\ncommit is based upon."
    },
    {
        "func": "static void cmd_parse_lsub (IMAP_DATA* idata, char* s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  BUFFER err, token;\n  ciss_url_t url;\n  IMAP_LIST list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list (idata, s);\n    return;\n  }\n\n  if (!option (OPTIMAPCHECKSUBSCRIBED))\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list (idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  dprint (3, (debugfile, \"Subscribing to %s\\n\", list.name));\n\n  strfcpy (buf, \"mailboxes \\\"\", sizeof (buf));\n  mutt_account_tourl (&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof (errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (!mutt_strcmp (url.user, ImapUser))\n    url.user = NULL;\n  url_ciss_tostring (&url, buf + 11, sizeof (buf) - 10, 0);\n  safe_strcat (buf, sizeof (buf), \"\\\"\");\n  mutt_buffer_init (&token);\n  mutt_buffer_init (&err);\n  err.data = errstr;\n  err.dsize = sizeof (errstr);\n  if (mutt_parse_rc_line (buf, &token, &err))\n    dprint (1, (debugfile, \"Error adding subscribed mailbox: %s\\n\", errstr));\n  FREE (&token.data);\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "mutt",
        "commit_id": "185152818541f5cdc059cbff3f3e8b654fc27c1d",
        "hash": 114047141275832769383214078014065262643,
        "size": 46,
        "message": "Properly quote IMAP mailbox names when (un)subscribing.\n\nWhen handling automatic subscription (via $imap_check_subscribed), or\nmanual subscribe/unsubscribe commands, mutt generating a \"mailboxes\"\ncommand but failed to properly escape backquotes.\n\nThanks to Jeriko One for the detailed bug report and patch, which this\ncommit is based upon."
    },
    {
        "func": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "95e80bf9ff10f68cb6443f760b85df4117cb15eb",
        "hash": 51192060095297482675395799069061875357,
        "size": 57,
        "message": "Quote path in imap_subscribe"
    },
    {
        "func": "static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \"OR \");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 222630270967631751654806842484768220801,
        "size": 96,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\"Logging in...\"));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \"Logging in...\".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 58712600715241729698763039907271558401,
        "size": 40,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf);\n\n  FREE(&buf);\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 280064003594277246918076946170594027106,
        "size": 9,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 237931988464177258235718341233506567636,
        "size": 46,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 155394546650805050914751528184108702294,
        "size": 29,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "void nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * If we don't have an init pipe, just return to the go routine.\n\t * We'll only get an init pipe for start or exec.\n\t */\n\tpipenum = initpipe();\n\tif (pipenum == -1)\n\t\treturn;\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tswitch (setjmp(env)) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: JUMP_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase JUMP_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t child, first_child = -1;\n\t\t\tbool ready = false;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\tchild = clone_parent(&env, JUMP_CHILD);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: child_func\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children.\n\t\t\t *\n\t\t\t * Father only return when both child and grandchild are\n\t\t\t * ready, so we can receive all possible error codes\n\t\t\t * generated by children.\n\t\t\t */\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\t\tclose(sync_child_pipe[0]);\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(child, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, child, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, child, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:{\n\t\t\t\t\t\tfirst_child = child;\n\n\t\t\t\t\t\t/* Get the init_func pid. */\n\t\t\t\t\t\tif (read(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: read(childpid)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send the init_func pid back to our parent.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Send the init_func pid and the pid of the first child back to our parent.\n\t\t\t\t\t\t * We need to send both back because we can't reap the first child we created (CLONE_PARENT).\n\t\t\t\t\t\t * It becomes the responsibility of our parent to reap the first child.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tlen = dprintf(pipenum, \"{\\\"pid\\\": %d, \\\"pid_first\\\": %d}\\n\", child, first_child);\n\t\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"unable to generate JSON for child pid\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Now sync with grandchild. */\n\n\t\t\tready = false;\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all\n\t\t *          of the requested namespaces. If we've been asked to\n\t\t *          CLONE_NEWUSER, we will ask our parent (stage 0) to set up\n\t\t *          our user mappings for us. Then, we create a new child\n\t\t *          (stage 2: JUMP_INIT) for PID namespace. We then send the\n\t\t *          child's PID to our parent (stage 0).\n\t\t */\n\tcase JUMP_CHILD:{\n\t\t\tpid_t child;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: JUMP_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal our parent to hook us up.\n\t\t\t\t */\n\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare namespaces\");\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\tchild = clone_parent(&env, JUMP_INIT);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: init_func\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(childpid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_READY)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: JUMP_INIT] is doing the rest of the work. */\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase JUMP_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tclose(sync_grandchild_pipe[1]);\n\t\t\tclose(sync_child_pipe[0]);\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\t/* ... wait until our topmost parent has finished cgroup setup in p.manager.Apply() ... */\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tuint8_t value;\n\t\t\t\tif (read(pipenum, &value, sizeof(value)) != sizeof(value))\n\t\t\t\t\tbail(\"read synchronisation value failed\");\n\t\t\t\tif (value == CREATECGROUPNS) {\n\t\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t\t} else\n\t\t\t\t\tbail(\"received unknown synchronisation value\");\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with patent: write(SYNC_CHILD_READY)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\treturn;\n\t\t}\n\tdefault:\n\t\tbail(\"unexpected jump value\");\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-216"
        ],
        "project": "runc",
        "commit_id": "0a8e4117e7f715d5fbeef398405813ce8e88558b",
        "hash": 106976658066437184536494310579083701192,
        "size": 459,
        "message": "nsenter: clone /proc/self/exe to avoid exposing host binary to container\n\nThere are quite a few circumstances where /proc/self/exe pointing to a\npretty important container binary is a _bad_ thing, so to avoid this we\nhave to make a copy (preferably doing self-clean-up and not being\nwriteable).\n\nWe require memfd_create(2) -- though there is an O_TMPFILE fallback --\nbut we can always extend this to use a scratch MNT_DETACH overlayfs or\ntmpfs. The main downside to this approach is no page-cache sharing for\nthe runc binary (which overlayfs would give us) but this is far less\ncomplicated.\n\nThis is only done during nsenter so that it happens transparently to the\nGo code, and any libcontainer users benefit from it. This also makes\nExtraFiles and --preserve-fds handling trivial (because we don't need to\nworry about it).\n\nFixes: CVE-2019-5736\nCo-developed-by: Christian Brauner <christian.brauner@ubuntu.com>\nSigned-off-by: Aleksa Sarai <asarai@suse.de>"
    },
    {
        "func": "deliver_message(uschar *id, BOOL forced, BOOL give_up)\n{\nint i, rc;\nint final_yield = DELIVER_ATTEMPTED_NORMAL;\ntime_t now = time(NULL);\naddress_item *addr_last = NULL;\nuschar *filter_message = NULL;\nint process_recipients = RECIP_ACCEPT;\nopen_db dbblock;\nopen_db *dbm_file;\nextern int acl_where;\n\nuschar *info = queue_run_pid == (pid_t)0\n  ? string_sprintf(\"delivering %s\", id)\n  : string_sprintf(\"delivering %s (queue run pid %d)\", id, queue_run_pid);\n\n/* If the D_process_info bit is on, set_process_info() will output debugging\ninformation. If not, we want to show this initial information if D_deliver or\nD_queue_run is set or in verbose mode. */\n\nset_process_info(\"%s\", info);\n\nif (  !(debug_selector & D_process_info)\n   && (debug_selector & (D_deliver|D_queue_run|D_v))\n   )\n  debug_printf(\"%s\\n\", info);\n\n/* Ensure that we catch any subprocesses that are created. Although Exim\nsets SIG_DFL as its initial default, some routes through the code end up\nhere with it set to SIG_IGN - cases where a non-synchronous delivery process\nhas been forked, but no re-exec has been done. We use sigaction rather than\nplain signal() on those OS where SA_NOCLDWAIT exists, because we want to be\nsure it is turned off. (There was a problem on AIX with this.) */\n\n#ifdef SA_NOCLDWAIT\n  {\n  struct sigaction act;\n  act.sa_handler = SIG_DFL;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = 0;\n  sigaction(SIGCHLD, &act, NULL);\n  }\n#else\nsignal(SIGCHLD, SIG_DFL);\n#endif\n\n/* Make the forcing flag available for routers and transports, set up the\nglobal message id field, and initialize the count for returned files and the\nmessage size. This use of strcpy() is OK because the length id is checked when\nit is obtained from a command line (the -M or -q options), and otherwise it is\nknown to be a valid message id. */\n\nif (id != message_id)\n  Ustrcpy(message_id, id);\ndeliver_force = forced;\nreturn_count = 0;\nmessage_size = 0;\n\n/* Initialize some flags */\n\nupdate_spool = FALSE;\nremove_journal = TRUE;\n\n/* Set a known context for any ACLs we call via expansions */\nacl_where = ACL_WHERE_DELIVERY;\n\n/* Reset the random number generator, so that if several delivery processes are\nstarted from a queue runner that has already used random numbers (for sorting),\nthey don't all get the same sequence. */\n\nrandom_seed = 0;\n\n/* Open and lock the message's data file. Exim locks on this one because the\nheader file may get replaced as it is re-written during the delivery process.\nAny failures cause messages to be written to the log, except for missing files\nwhile queue running - another process probably completed delivery. As part of\nopening the data file, message_subdir gets set. */\n\nif ((deliver_datafile = spool_open_datafile(id)) < 0)\n  return continue_closedown();  /* yields DELIVER_NOT_ATTEMPTED */\n\n/* The value of message_size at this point has been set to the data length,\nplus one for the blank line that notionally precedes the data. */\n\n/* Now read the contents of the header file, which will set up the headers in\nstore, and also the list of recipients and the tree of non-recipients and\nassorted flags. It updates message_size. If there is a reading or format error,\ngive up; if the message has been around for sufficiently long, remove it. */\n\n  {\n  uschar * spoolname = string_sprintf(\"%s-H\", id);\n  if ((rc = spool_read_header(spoolname, TRUE, TRUE)) != spool_read_OK)\n    {\n    if (errno == ERRNO_SPOOLFORMAT)\n      {\n      struct stat statbuf;\n      if (Ustat(spool_fname(US\"input\", message_subdir, spoolname, US\"\"),\n\t\t&statbuf) == 0)\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s: \"\n\t  \"size=\" OFF_T_FMT, spoolname, statbuf.st_size);\n      else\n\tlog_write(0, LOG_MAIN, \"Format error in spool file %s\", spoolname);\n      }\n    else\n      log_write(0, LOG_MAIN, \"Error reading spool file %s: %s\", spoolname,\n\tstrerror(errno));\n\n    /* If we managed to read the envelope data, received_time contains the\n    time the message was received. Otherwise, we can calculate it from the\n    message id. */\n\n    if (rc != spool_read_hdrerror)\n      {\n      received_time.tv_sec = received_time.tv_usec = 0;\n      /*XXX subsec precision?*/\n      for (i = 0; i < 6; i++)\n\treceived_time.tv_sec = received_time.tv_sec * BASE_62 + tab62[id[i] - '0'];\n      }\n\n    /* If we've had this malformed message too long, sling it. */\n\n    if (now - received_time.tv_sec > keep_malformed)\n      {\n      Uunlink(spool_fname(US\"msglog\", message_subdir, id, US\"\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-D\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-H\"));\n      Uunlink(spool_fname(US\"input\", message_subdir, id, US\"-J\"));\n      log_write(0, LOG_MAIN, \"Message removed because older than %s\",\n\treadconf_printtime(keep_malformed));\n      }\n\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n/* The spool header file has been read. Look to see if there is an existing\njournal file for this message. If there is, it means that a previous delivery\nattempt crashed (program or host) before it could update the spool header file.\nRead the list of delivered addresses from the journal and add them to the\nnonrecipients tree. Then update the spool file. We can leave the journal in\nexistence, as it will get further successful deliveries added to it in this\nrun, and it will be deleted if this function gets to its end successfully.\nOtherwise it might be needed again. */\n\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n  FILE * jread;\n\n  if (  (journal_fd = Uopen(fname, O_RDWR|O_APPEND\n#ifdef O_CLOEXEC\n\t\t\t\t    | O_CLOEXEC\n#endif\n#ifdef O_NOFOLLOW\n\t\t\t\t    | O_NOFOLLOW\n#endif\n\t, SPOOL_MODE)) >= 0\n     && lseek(journal_fd, 0, SEEK_SET) == 0\n     && (jread = fdopen(journal_fd, \"rb\"))\n     )\n    {\n    while (Ufgets(big_buffer, big_buffer_size, jread))\n      {\n      int n = Ustrlen(big_buffer);\n      big_buffer[n-1] = 0;\n      tree_add_nonrecipient(big_buffer);\n      DEBUG(D_deliver) debug_printf(\"Previously delivered address %s taken from \"\n\t\"journal file\\n\", big_buffer);\n      }\n    rewind(jread);\n    if ((journal_fd = dup(fileno(jread))) < 0)\n      journal_fd = fileno(jread);\n    else\n      (void) fclose(jread);\t/* Try to not leak the FILE resource */\n\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n  else if (errno != ENOENT)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"attempt to open journal for reading gave: \"\n      \"%s\", strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* A null recipients list indicates some kind of disaster. */\n\n  if (!recipients_list)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN, \"Spool error: no recipients for %s\", fname);\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* Handle a message that is frozen. There are a number of different things that\ncan happen, but in the default situation, unless forced, no delivery is\nattempted. */\n\nif (deliver_freeze)\n  {\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  /* Moving to another directory removes the message from Exim's view. Other\n  tools must be used to deal with it. Logging of this action happens in\n  spool_move_message() and its subfunctions. */\n\n  if (  move_frozen_messages\n     && spool_move_message(id, message_subdir, US\"\", US\"F\")\n     )\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n#endif\n\n  /* For all frozen messages (bounces or not), timeout_frozen_after sets the\n  maximum time to keep messages that are frozen. Thaw if we reach it, with a\n  flag causing all recipients to be failed. The time is the age of the\n  message, not the time since freezing. */\n\n  if (timeout_frozen_after > 0 && message_age >= timeout_frozen_after)\n    {\n    log_write(0, LOG_MAIN, \"cancelled by timeout_frozen_after\");\n    process_recipients = RECIP_FAIL_TIMEOUT;\n    }\n\n  /* For bounce messages (and others with no sender), thaw if the error message\n  ignore timer is exceeded. The message will be discarded if this delivery\n  fails. */\n\n  else if (!*sender_address && message_age >= ignore_bounce_errors_after)\n    log_write(0, LOG_MAIN, \"Unfrozen by errmsg timer\");\n\n  /* If this is a bounce message, or there's no auto thaw, or we haven't\n  reached the auto thaw time yet, and this delivery is not forced by an admin\n  user, do not attempt delivery of this message. Note that forced is set for\n  continuing messages down the same channel, in order to skip load checking and\n  ignore hold domains, but we don't want unfreezing in that case. */\n\n  else\n    {\n    if (  (  sender_address[0] == 0\n\t  || auto_thaw <= 0\n\t  || now <= deliver_frozen_at + auto_thaw\n          )\n       && (  !forced || !deliver_force_thaw\n\t  || !admin_user || continue_hostname\n       )  )\n      {\n      (void)close(deliver_datafile);\n      deliver_datafile = -1;\n      log_write(L_skip_delivery, LOG_MAIN, \"Message is frozen\");\n      return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n      }\n\n    /* If delivery was forced (by an admin user), assume a manual thaw.\n    Otherwise it's an auto thaw. */\n\n    if (forced)\n      {\n      deliver_manual_thaw = TRUE;\n      log_write(0, LOG_MAIN, \"Unfrozen by forced delivery\");\n      }\n    else log_write(0, LOG_MAIN, \"Unfrozen by auto-thaw\");\n    }\n\n  /* We get here if any of the rules for unfreezing have triggered. */\n\n  deliver_freeze = FALSE;\n  update_spool = TRUE;\n  }\n\n\n/* Open the message log file if we are using them. This records details of\ndeliveries, deferments, and failures for the benefit of the mail administrator.\nThe log is not used by exim itself to track the progress of a message; that is\ndone by rewriting the header spool file. */\n\nif (message_logs)\n  {\n  uschar * fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n  uschar * error;\n  int fd;\n\n  if ((fd = open_msglog_file(fname, SPOOL_MODE, &error)) < 0)\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't %s message log %s: %s\", error,\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Make a C stream out of it. */\n\n  if (!(message_log = fdopen(fd, \"a\")))\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't fdopen message log %s: %s\",\n      fname, strerror(errno));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n  }\n\n\n/* If asked to give up on a message, log who did it, and set the action for all\nthe addresses. */\n\nif (give_up)\n  {\n  struct passwd *pw = getpwuid(real_uid);\n  log_write(0, LOG_MAIN, \"cancelled by %s\",\n      pw ? US pw->pw_name : string_sprintf(\"uid %ld\", (long int)real_uid));\n  process_recipients = RECIP_FAIL;\n  }\n\n/* Otherwise, if there are too many Received: headers, fail all recipients. */\n\nelse if (received_count > received_headers_max)\n  process_recipients = RECIP_FAIL_LOOP;\n\n/* Otherwise, if a system-wide, address-independent message filter is\nspecified, run it now, except in the case when we are failing all recipients as\na result of timeout_frozen_after. If the system filter yields \"delivered\", then\nignore the true recipients of the message. Failure of the filter file is\nlogged, and the delivery attempt fails. */\n\nelse if (system_filter && process_recipients != RECIP_FAIL_TIMEOUT)\n  {\n  int rc;\n  int filtertype;\n  ugid_block ugid;\n  redirect_block redirect;\n\n  if (system_filter_uid_set)\n    {\n    ugid.uid = system_filter_uid;\n    ugid.gid = system_filter_gid;\n    ugid.uid_set = ugid.gid_set = TRUE;\n    }\n  else\n    {\n    ugid.uid_set = ugid.gid_set = FALSE;\n    }\n\n  return_path = sender_address;\n  enable_dollar_recipients = TRUE;   /* Permit $recipients in system filter */\n  system_filtering = TRUE;\n\n  /* Any error in the filter file causes a delivery to be abandoned. */\n\n  redirect.string = system_filter;\n  redirect.isfile = TRUE;\n  redirect.check_owner = redirect.check_group = FALSE;\n  redirect.owners = NULL;\n  redirect.owngroups = NULL;\n  redirect.pw = NULL;\n  redirect.modemask = 0;\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"running system filter\\n\");\n\n  rc = rda_interpret(\n    &redirect,              /* Where the data is */\n    RDO_DEFER |             /* Turn on all the enabling options */\n      RDO_FAIL |            /* Leave off all the disabling options */\n      RDO_FILTER |\n      RDO_FREEZE |\n      RDO_REALLOG |\n      RDO_REWRITE,\n    NULL,                   /* No :include: restriction (not used in filter) */\n    NULL,                   /* No sieve vacation directory (not sieve!) */\n    NULL,                   /* No sieve enotify mailto owner (not sieve!) */\n    NULL,                   /* No sieve user address (not sieve!) */\n    NULL,                   /* No sieve subaddress (not sieve!) */\n    &ugid,                  /* uid/gid data */\n    &addr_new,              /* Where to hang generated addresses */\n    &filter_message,        /* Where to put error message */\n    NULL,                   /* Don't skip syntax errors */\n    &filtertype,            /* Will always be set to FILTER_EXIM for this call */\n    US\"system filter\");     /* For error messages */\n\n  DEBUG(D_deliver|D_filter) debug_printf(\"system filter returned %d\\n\", rc);\n\n  if (rc == FF_ERROR || rc == FF_NONEXIST)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    log_write(0, LOG_MAIN|LOG_PANIC, \"Error in system filter: %s\",\n      string_printing(filter_message));\n    return continue_closedown();   /* yields DELIVER_NOT_ATTEMPTED */\n    }\n\n  /* Reset things. If the filter message is an empty string, which can happen\n  for a filter \"fail\" or \"freeze\" command with no text, reset it to NULL. */\n\n  system_filtering = FALSE;\n  enable_dollar_recipients = FALSE;\n  if (filter_message && filter_message[0] == 0) filter_message = NULL;\n\n  /* Save the values of the system filter variables so that user filters\n  can use them. */\n\n  memcpy(filter_sn, filter_n, sizeof(filter_sn));\n\n  /* The filter can request that delivery of the original addresses be\n  deferred. */\n\n  if (rc == FF_DEFER)\n    {\n    process_recipients = RECIP_DEFER;\n    deliver_msglog(\"Delivery deferred by system filter\\n\");\n    log_write(0, LOG_MAIN, \"Delivery deferred by system filter\");\n    }\n\n  /* The filter can request that a message be frozen, but this does not\n  take place if the message has been manually thawed. In that case, we must\n  unset \"delivered\", which is forced by the \"freeze\" command to make -bF\n  work properly. */\n\n  else if (rc == FF_FREEZE && !deliver_manual_thaw)\n    {\n    deliver_freeze = TRUE;\n    deliver_frozen_at = time(NULL);\n    process_recipients = RECIP_DEFER;\n    frozen_info = string_sprintf(\" by the system filter%s%s\",\n      filter_message ? US\": \" : US\"\",\n      filter_message ? filter_message : US\"\");\n    }\n\n  /* The filter can request that a message be failed. The error message may be\n  quite long - it is sent back to the sender in the bounce - but we don't want\n  to fill up the log with repetitions of it. If it starts with << then the text\n  between << and >> is written to the log, with the rest left for the bounce\n  message. */\n\n  else if (rc == FF_FAIL)\n    {\n    uschar *colon = US\"\";\n    uschar *logmsg = US\"\";\n    int loglen = 0;\n\n    process_recipients = RECIP_FAIL_FILTER;\n\n    if (filter_message)\n      {\n      uschar *logend;\n      colon = US\": \";\n      if (  filter_message[0] == '<'\n         && filter_message[1] == '<'\n\t && (logend = Ustrstr(filter_message, \">>\"))\n\t )\n        {\n        logmsg = filter_message + 2;\n        loglen = logend - logmsg;\n        filter_message = logend + 2;\n        if (filter_message[0] == 0) filter_message = NULL;\n        }\n      else\n        {\n        logmsg = filter_message;\n        loglen = Ustrlen(filter_message);\n        }\n      }\n\n    log_write(0, LOG_MAIN, \"cancelled by system filter%s%.*s\", colon, loglen,\n      logmsg);\n    }\n\n  /* Delivery can be restricted only to those recipients (if any) that the\n  filter specified. */\n\n  else if (rc == FF_DELIVERED)\n    {\n    process_recipients = RECIP_IGNORE;\n    if (addr_new)\n      log_write(0, LOG_MAIN, \"original recipients ignored (system filter)\");\n    else\n      log_write(0, LOG_MAIN, \"=> discarded (system filter)\");\n    }\n\n  /* If any new addresses were created by the filter, fake up a \"parent\"\n  for them. This is necessary for pipes, etc., which are expected to have\n  parents, and it also gives some sensible logging for others. Allow\n  pipes, files, and autoreplies, and run them as the filter uid if set,\n  otherwise as the current uid. */\n\n  if (addr_new)\n    {\n    int uid = (system_filter_uid_set)? system_filter_uid : geteuid();\n    int gid = (system_filter_gid_set)? system_filter_gid : getegid();\n\n    /* The text \"system-filter\" is tested in transport_set_up_command() and in\n    set_up_shell_command() in the pipe transport, to enable them to permit\n    $recipients, so don't change it here without also changing it there. */\n\n    address_item *p = addr_new;\n    address_item *parent = deliver_make_addr(US\"system-filter\", FALSE);\n\n    parent->domain = string_copylc(qualify_domain_recipient);\n    parent->local_part = US\"system-filter\";\n\n    /* As part of this loop, we arrange for addr_last to end up pointing\n    at the final address. This is used if we go on to add addresses for the\n    original recipients. */\n\n    while (p)\n      {\n      if (parent->child_count == USHRT_MAX)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"system filter generated more \"\n          \"than %d delivery addresses\", USHRT_MAX);\n      parent->child_count++;\n      p->parent = parent;\n\n      if (testflag(p, af_pfr))\n        {\n        uschar *tpname;\n        uschar *type;\n        p->uid = uid;\n        p->gid = gid;\n        setflag(p, af_uid_set);\n        setflag(p, af_gid_set);\n        setflag(p, af_allow_file);\n        setflag(p, af_allow_pipe);\n        setflag(p, af_allow_reply);\n\n        /* Find the name of the system filter's appropriate pfr transport */\n\n        if (p->address[0] == '|')\n          {\n          type = US\"pipe\";\n          tpname = system_filter_pipe_transport;\n          address_pipe = p->address;\n          }\n        else if (p->address[0] == '>')\n          {\n          type = US\"reply\";\n          tpname = system_filter_reply_transport;\n          }\n        else\n          {\n          if (p->address[Ustrlen(p->address)-1] == '/')\n            {\n            type = US\"directory\";\n            tpname = system_filter_directory_transport;\n            }\n          else\n            {\n            type = US\"file\";\n            tpname = system_filter_file_transport;\n            }\n          address_file = p->address;\n          }\n\n        /* Now find the actual transport, first expanding the name. We have\n        set address_file or address_pipe above. */\n\n        if (tpname)\n          {\n          uschar *tmp = expand_string(tpname);\n          address_file = address_pipe = NULL;\n          if (!tmp)\n            p->message = string_sprintf(\"failed to expand \\\"%s\\\" as a \"\n              \"system filter transport name\", tpname);\n          tpname = tmp;\n          }\n        else\n          p->message = string_sprintf(\"system_filter_%s_transport is unset\",\n            type);\n\n        if (tpname)\n          {\n          transport_instance *tp;\n          for (tp = transports; tp; tp = tp->next)\n            if (Ustrcmp(tp->name, tpname) == 0)\n              {\n              p->transport = tp;\n              break;\n              }\n          if (!tp)\n            p->message = string_sprintf(\"failed to find \\\"%s\\\" transport \"\n              \"for system filter delivery\", tpname);\n          }\n\n        /* If we couldn't set up a transport, defer the delivery, putting the\n        error on the panic log as well as the main log. */\n\n        if (!p->transport)\n          {\n          address_item *badp = p;\n          p = p->next;\n          if (!addr_last) addr_new = p; else addr_last->next = p;\n          badp->local_part = badp->address;   /* Needed for log line */\n          post_process_one(badp, DEFER, LOG_MAIN|LOG_PANIC, EXIM_DTYPE_ROUTER, 0);\n          continue;\n          }\n        }    /* End of pfr handling */\n\n      /* Either a non-pfr delivery, or we found a transport */\n\n      DEBUG(D_deliver|D_filter)\n        debug_printf(\"system filter added %s\\n\", p->address);\n\n      addr_last = p;\n      p = p->next;\n      }    /* Loop through all addr_new addresses */\n    }\n  }\n\n\n/* Scan the recipients list, and for every one that is not in the non-\nrecipients tree, add an addr item to the chain of new addresses. If the pno\nvalue is non-negative, we must set the onetime parent from it. This which\npoints to the relevant entry in the recipients list.\n\nThis processing can be altered by the setting of the process_recipients\nvariable, which is changed if recipients are to be ignored, failed, or\ndeferred. This can happen as a result of system filter activity, or if the -Mg\noption is used to fail all of them.\n\nDuplicate addresses are handled later by a different tree structure; we can't\njust extend the non-recipients tree, because that will be re-written to the\nspool if the message is deferred, and in any case there are casing\ncomplications for local addresses. */\n\nif (process_recipients != RECIP_IGNORE)\n  for (i = 0; i < recipients_count; i++)\n    if (!tree_search(tree_nonrecipients, recipients_list[i].address))\n      {\n      recipient_item *r = recipients_list + i;\n      address_item *new = deliver_make_addr(r->address, FALSE);\n      new->prop.errors_address = r->errors_to;\n#ifdef SUPPORT_I18N\n      if ((new->prop.utf8_msg = message_smtputf8))\n\t{\n\tnew->prop.utf8_downcvt =       message_utf8_downconvert == 1;\n\tnew->prop.utf8_downcvt_maybe = message_utf8_downconvert == -1;\n\tDEBUG(D_deliver) debug_printf(\"utf8, downconvert %s\\n\",\n\t  new->prop.utf8_downcvt ? \"yes\"\n\t  : new->prop.utf8_downcvt_maybe ? \"ifneeded\"\n\t  : \"no\");\n\t}\n#endif\n\n      if (r->pno >= 0)\n        new->onetime_parent = recipients_list[r->pno].address;\n\n      /* If DSN support is enabled, set the dsn flags and the original receipt\n         to be passed on to other DSN enabled MTAs */\n      new->dsn_flags = r->dsn_flags & rf_dsnflags;\n      new->dsn_orcpt = r->orcpt;\n      DEBUG(D_deliver) debug_printf(\"DSN: set orcpt: %s  flags: %d\\n\",\n\tnew->dsn_orcpt ? new->dsn_orcpt : US\"\", new->dsn_flags);\n\n      switch (process_recipients)\n        {\n        /* RECIP_DEFER is set when a system filter freezes a message. */\n\n        case RECIP_DEFER:\n        new->next = addr_defer;\n        addr_defer = new;\n        break;\n\n\n        /* RECIP_FAIL_FILTER is set when a system filter has obeyed a \"fail\"\n        command. */\n\n        case RECIP_FAIL_FILTER:\n        new->message =\n          filter_message ? filter_message : US\"delivery cancelled\";\n        setflag(new, af_pass_message);\n        goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL_TIMEOUT is set when a message is frozen, but is older\n        than the value in timeout_frozen_after. Treat non-bounce messages\n        similarly to -Mg; for bounce messages we just want to discard, so\n        don't put the address on the failed list. The timeout has already\n        been logged. */\n\n        case RECIP_FAIL_TIMEOUT:\n        new->message  = US\"delivery cancelled; message timed out\";\n        goto RECIP_QUEUE_FAILED;   /* below */\n\n\n        /* RECIP_FAIL is set when -Mg has been used. */\n\n        case RECIP_FAIL:\n        new->message  = US\"delivery cancelled by administrator\";\n        /* Fall through */\n\n        /* Common code for the failure cases above. If this is not a bounce\n        message, put the address on the failed list so that it is used to\n        create a bounce. Otherwise do nothing - this just discards the address.\n        The incident has already been logged. */\n\n        RECIP_QUEUE_FAILED:\n        if (sender_address[0] != 0)\n          {\n          new->next = addr_failed;\n          addr_failed = new;\n          }\n        break;\n\n\n        /* RECIP_FAIL_LOOP is set when there are too many Received: headers\n        in the message. Process each address as a routing failure; if this\n        is a bounce message, it will get frozen. */\n\n        case RECIP_FAIL_LOOP:\n        new->message = US\"Too many \\\"Received\\\" headers - suspected mail loop\";\n        post_process_one(new, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        break;\n\n\n        /* Value should be RECIP_ACCEPT; take this as the safe default. */\n\n        default:\n        if (!addr_new) addr_new = new; else addr_last->next = new;\n        addr_last = new;\n        break;\n        }\n\n#ifndef DISABLE_EVENT\n      if (process_recipients != RECIP_ACCEPT)\n\t{\n\tuschar * save_local =  deliver_localpart;\n\tconst uschar * save_domain = deliver_domain;\n\n\tdeliver_localpart = expand_string(\n\t\t      string_sprintf(\"${local_part:%s}\", new->address));\n\tdeliver_domain =    expand_string(\n\t\t      string_sprintf(\"${domain:%s}\", new->address));\n\n\t(void) event_raise(event_action,\n\t\t      US\"msg:fail:internal\", new->message);\n\n\tdeliver_localpart = save_local;\n\tdeliver_domain =    save_domain;\n\t}\n#endif\n      }\n\nDEBUG(D_deliver)\n  {\n  address_item *p;\n  debug_printf(\"Delivery address list:\\n\");\n  for (p = addr_new; p; p = p->next)\n    debug_printf(\"  %s %s\\n\", p->address,\n      p->onetime_parent ? p->onetime_parent : US\"\");\n  }\n\n/* Set up the buffers used for copying over the file when delivering. */\n\ndeliver_in_buffer = store_malloc(DELIVER_IN_BUFFER_SIZE);\ndeliver_out_buffer = store_malloc(DELIVER_OUT_BUFFER_SIZE);\n\n\n\n/* Until there are no more new addresses, handle each one as follows:\n\n . If this is a generated address (indicated by the presence of a parent\n   pointer) then check to see whether it is a pipe, file, or autoreply, and\n   if so, handle it directly here. The router that produced the address will\n   have set the allow flags into the address, and also set the uid/gid required.\n   Having the routers generate new addresses and then checking them here at\n   the outer level is tidier than making each router do the checking, and\n   means that routers don't need access to the failed address queue.\n\n . Break up the address into local part and domain, and make lowercased\n   versions of these strings. We also make unquoted versions of the local part.\n\n . Handle the percent hack for those domains for which it is valid.\n\n . For child addresses, determine if any of the parents have the same address.\n   If so, generate a different string for previous delivery checking. Without\n   this code, if the address spqr generates spqr via a forward or alias file,\n   delivery of the generated spqr stops further attempts at the top level spqr,\n   which is not what is wanted - it may have generated other addresses.\n\n . Check on the retry database to see if routing was previously deferred, but\n   only if in a queue run. Addresses that are to be routed are put on the\n   addr_route chain. Addresses that are to be deferred are put on the\n   addr_defer chain. We do all the checking first, so as not to keep the\n   retry database open any longer than necessary.\n\n . Now we run the addresses through the routers. A router may put the address\n   on either the addr_local or the addr_remote chain for local or remote\n   delivery, respectively, or put it on the addr_failed chain if it is\n   undeliveable, or it may generate child addresses and put them on the\n   addr_new chain, or it may defer an address. All the chain anchors are\n   passed as arguments so that the routers can be called for verification\n   purposes as well.\n\n . If new addresses have been generated by the routers, da capo.\n*/\n\nheader_rewritten = FALSE;          /* No headers rewritten yet */\nwhile (addr_new)           /* Loop until all addresses dealt with */\n  {\n  address_item *addr, *parent;\n\n  /* Failure to open the retry database is treated the same as if it does\n  not exist. In both cases, dbm_file is NULL. */\n\n  if (!(dbm_file = dbfn_open(US\"retry\", O_RDONLY, &dbblock, FALSE)))\n    DEBUG(D_deliver|D_retry|D_route|D_hints_lookup)\n      debug_printf(\"no retry data available\\n\");\n\n  /* Scan the current batch of new addresses, to handle pipes, files and\n  autoreplies, and determine which others are ready for routing. */\n\n  while (addr_new)\n    {\n    int rc;\n    uschar *p;\n    tree_node *tnode;\n    dbdata_retry *domain_retry_record;\n    dbdata_retry *address_retry_record;\n\n    addr = addr_new;\n    addr_new = addr->next;\n\n    DEBUG(D_deliver|D_retry|D_route)\n      {\n      debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n      debug_printf(\"Considering: %s\\n\", addr->address);\n      }\n\n    /* Handle generated address that is a pipe or a file or an autoreply. */\n\n    if (testflag(addr, af_pfr))\n      {\n      /* If an autoreply in a filter could not generate a syntactically valid\n      address, give up forthwith. Set af_ignore_error so that we don't try to\n      generate a bounce. */\n\n      if (testflag(addr, af_bad_reply))\n        {\n        addr->basic_errno = ERRNO_BADADDRESS2;\n        addr->local_part = addr->address;\n        addr->message =\n          US\"filter autoreply generated syntactically invalid recipient\";\n        addr->prop.ignore_error = TRUE;\n        (void) post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;   /* with the next new address */\n        }\n\n      /* If two different users specify delivery to the same pipe or file or\n      autoreply, there should be two different deliveries, so build a unique\n      string that incorporates the original address, and use this for\n      duplicate testing and recording delivery, and also for retrying. */\n\n      addr->unique =\n        string_sprintf(\"%s:%s\", addr->address, addr->parent->unique +\n          (testflag(addr->parent, af_homonym)? 3:0));\n\n      addr->address_retry_key = addr->domain_retry_key =\n        string_sprintf(\"T:%s\", addr->unique);\n\n      /* If a filter file specifies two deliveries to the same pipe or file,\n      we want to de-duplicate, but this is probably not wanted for two mail\n      commands to the same address, where probably both should be delivered.\n      So, we have to invent a different unique string in that case. Just\n      keep piling '>' characters on the front. */\n\n      if (addr->address[0] == '>')\n        {\n        while (tree_search(tree_duplicates, addr->unique))\n          addr->unique = string_sprintf(\">%s\", addr->unique);\n        }\n\n      else if ((tnode = tree_search(tree_duplicates, addr->unique)))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s is a duplicate address: discarded\\n\", addr->address);\n        addr->dupof = tnode->data.ptr;\n        addr->next = addr_duplicate;\n        addr_duplicate = addr;\n        continue;\n        }\n\n      DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n      /* Check for previous delivery */\n\n      if (tree_search(tree_nonrecipients, addr->unique))\n        {\n        DEBUG(D_deliver|D_route)\n          debug_printf(\"%s was previously delivered: discarded\\n\", addr->address);\n        child_done(addr, tod_stamp(tod_log));\n        continue;\n        }\n\n      /* Save for checking future duplicates */\n\n      tree_add_duplicate(addr->unique, addr);\n\n      /* Set local part and domain */\n\n      addr->local_part = addr->address;\n      addr->domain = addr->parent->domain;\n\n      /* Ensure that the delivery is permitted. */\n\n      if (testflag(addr, af_file))\n        {\n        if (!testflag(addr, af_allow_file))\n          {\n          addr->basic_errno = ERRNO_FORBIDFILE;\n          addr->message = US\"delivery to file forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (addr->address[0] == '|')\n        {\n        if (!testflag(addr, af_allow_pipe))\n          {\n          addr->basic_errno = ERRNO_FORBIDPIPE;\n          addr->message = US\"delivery to pipe forbidden\";\n          (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          continue;   /* with the next new address */\n          }\n        }\n      else if (!testflag(addr, af_allow_reply))\n        {\n        addr->basic_errno = ERRNO_FORBIDREPLY;\n        addr->message = US\"autoreply forbidden\";\n        (void)post_process_one(addr, FAIL, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;     /* with the next new address */\n        }\n\n      /* If the errno field is already set to BADTRANSPORT, it indicates\n      failure to expand a transport string, or find the associated transport,\n      or an unset transport when one is required. Leave this test till now so\n      that the forbid errors are given in preference. */\n\n      if (addr->basic_errno == ERRNO_BADTRANSPORT)\n        {\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        continue;\n        }\n\n      /* Treat /dev/null as a special case and abandon the delivery. This\n      avoids having to specify a uid on the transport just for this case.\n      Arrange for the transport name to be logged as \"**bypassed**\". */\n\n      if (Ustrcmp(addr->address, \"/dev/null\") == 0)\n        {\n        uschar *save = addr->transport->name;\n        addr->transport->name = US\"**bypassed**\";\n        (void)post_process_one(addr, OK, LOG_MAIN, EXIM_DTYPE_TRANSPORT, '=');\n        addr->transport->name = save;\n        continue;   /* with the next new address */\n        }\n\n      /* Pipe, file, or autoreply delivery is to go ahead as a normal local\n      delivery. */\n\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"queued for %s transport\\n\", addr->transport->name);\n      addr->next = addr_local;\n      addr_local = addr;\n      continue;       /* with the next new address */\n      }\n\n    /* Handle normal addresses. First, split up into local part and domain,\n    handling the %-hack if necessary. There is the possibility of a defer from\n    a lookup in percent_hack_domains. */\n\n    if ((rc = deliver_split_address(addr)) == DEFER)\n      {\n      addr->message = US\"cannot check percent_hack_domains\";\n      addr->basic_errno = ERRNO_LISTDEFER;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Check to see if the domain is held. If so, proceed only if the\n    delivery was forced by hand. */\n\n    deliver_domain = addr->domain;  /* set $domain */\n    if (  !forced && hold_domains\n       && (rc = match_isinlist(addr->domain, (const uschar **)&hold_domains, 0,\n           &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE,\n           NULL)) != FAIL\n       )\n      {\n      if (rc == DEFER)\n        {\n        addr->message = US\"hold_domains lookup deferred\";\n        addr->basic_errno = ERRNO_LISTDEFER;\n        }\n      else\n        {\n        addr->message = US\"domain is held\";\n        addr->basic_errno = ERRNO_HELD;\n        }\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_NONE, 0);\n      continue;\n      }\n\n    /* Now we can check for duplicates and previously delivered addresses. In\n    order to do this, we have to generate a \"unique\" value for each address,\n    because there may be identical actual addresses in a line of descendents.\n    The \"unique\" field is initialized to the same value as the \"address\" field,\n    but gets changed here to cope with identically-named descendents. */\n\n    for (parent = addr->parent; parent; parent = parent->parent)\n      if (strcmpic(addr->address, parent->address) == 0) break;\n\n    /* If there's an ancestor with the same name, set the homonym flag. This\n    influences how deliveries are recorded. Then add a prefix on the front of\n    the unique address. We use \\n\\ where n starts at 0 and increases each time.\n    It is unlikely to pass 9, but if it does, it may look odd but will still\n    work. This means that siblings or cousins with the same names are treated\n    as duplicates, which is what we want. */\n\n    if (parent)\n      {\n      setflag(addr, af_homonym);\n      if (parent->unique[0] != '\\\\')\n        addr->unique = string_sprintf(\"\\\\0\\\\%s\", addr->address);\n      else\n        addr->unique = string_sprintf(\"\\\\%c\\\\%s\", parent->unique[1] + 1,\n          addr->address);\n      }\n\n    /* Ensure that the domain in the unique field is lower cased, because\n    domains are always handled caselessly. */\n\n    p = Ustrrchr(addr->unique, '@');\n    while (*p != 0) { *p = tolower(*p); p++; }\n\n    DEBUG(D_deliver|D_route) debug_printf(\"unique = %s\\n\", addr->unique);\n\n    if (tree_search(tree_nonrecipients, addr->unique))\n      {\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s was previously delivered: discarded\\n\", addr->unique);\n      child_done(addr, tod_stamp(tod_log));\n      continue;\n      }\n\n    /* Get the routing retry status, saving the two retry keys (with and\n    without the local part) for subsequent use. If there is no retry record for\n    the standard address routing retry key, we look for the same key with the\n    sender attached, because this form is used by the smtp transport after a\n    4xx response to RCPT when address_retry_include_sender is true. */\n\n    addr->domain_retry_key = string_sprintf(\"R:%s\", addr->domain);\n    addr->address_retry_key = string_sprintf(\"R:%s@%s\", addr->local_part,\n      addr->domain);\n\n    if (dbm_file)\n      {\n      domain_retry_record = dbfn_read(dbm_file, addr->domain_retry_key);\n      if (  domain_retry_record\n         && now - domain_retry_record->time_stamp > retry_data_expire\n\t )\n        domain_retry_record = NULL;    /* Ignore if too old */\n\n      address_retry_record = dbfn_read(dbm_file, addr->address_retry_key);\n      if (  address_retry_record\n         && now - address_retry_record->time_stamp > retry_data_expire\n\t )\n        address_retry_record = NULL;   /* Ignore if too old */\n\n      if (!address_retry_record)\n        {\n        uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n          sender_address);\n        address_retry_record = dbfn_read(dbm_file, altkey);\n        if (  address_retry_record\n\t   && now - address_retry_record->time_stamp > retry_data_expire)\n          address_retry_record = NULL;   /* Ignore if too old */\n        }\n      }\n    else\n      domain_retry_record = address_retry_record = NULL;\n\n    DEBUG(D_deliver|D_retry)\n      {\n      if (!domain_retry_record)\n        debug_printf(\"no domain retry record\\n\");\n      if (!address_retry_record)\n        debug_printf(\"no address retry record\\n\");\n      }\n\n    /* If we are sending a message down an existing SMTP connection, we must\n    assume that the message which created the connection managed to route\n    an address to that connection. We do not want to run the risk of taking\n    a long time over routing here, because if we do, the server at the other\n    end of the connection may time it out. This is especially true for messages\n    with lots of addresses. For this kind of delivery, queue_running is not\n    set, so we would normally route all addresses. We take a pragmatic approach\n    and defer routing any addresses that have any kind of domain retry record.\n    That is, we don't even look at their retry times. It doesn't matter if this\n    doesn't work occasionally. This is all just an optimization, after all.\n\n    The reason for not doing the same for address retries is that they normally\n    arise from 4xx responses, not DNS timeouts. */\n\n    if (continue_hostname && domain_retry_record)\n      {\n      addr->message = US\"reusing SMTP connection skips previous routing defer\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* If we are in a queue run, defer routing unless there is no retry data or\n    we've passed the next retry time, or this message is forced. In other\n    words, ignore retry data when not in a queue run.\n\n    However, if the domain retry time has expired, always allow the routing\n    attempt. If it fails again, the address will be failed. This ensures that\n    each address is routed at least once, even after long-term routing\n    failures.\n\n    If there is an address retry, check that too; just wait for the next\n    retry time. This helps with the case when the temporary error on the\n    address was really message-specific rather than address specific, since\n    it allows other messages through.\n\n    We also wait for the next retry time if this is a message sent down an\n    existing SMTP connection (even though that will be forced). Otherwise there\n    will be far too many attempts for an address that gets a 4xx error. In\n    fact, after such an error, we should not get here because, the host should\n    not be remembered as one this message needs. However, there was a bug that\n    used to cause this to  happen, so it is best to be on the safe side.\n\n    Even if we haven't reached the retry time in the hints, there is one more\n    check to do, which is for the ultimate address timeout. We only do this\n    check if there is an address retry record and there is not a domain retry\n    record; this implies that previous attempts to handle the address had the\n    retry_use_local_parts option turned on. We use this as an approximation\n    for the destination being like a local delivery, for example delivery over\n    LMTP to an IMAP message store. In this situation users are liable to bump\n    into their quota and thereby have intermittently successful deliveries,\n    which keep the retry record fresh, which can lead to us perpetually\n    deferring messages. */\n\n    else if (  (  queue_running && !deliver_force\n\t       || continue_hostname\n\t       )\n            && (  (  domain_retry_record\n\t\t  && now < domain_retry_record->next_try\n\t\t  && !domain_retry_record->expired\n\t\t  )\n\t       || (  address_retry_record\n\t\t  && now < address_retry_record->next_try\n\t       )  )\n            && (  domain_retry_record\n\t       || !address_retry_record\n\t       || !retry_ultimate_address_timeout(addr->address_retry_key,\n\t\t\t\t addr->domain, address_retry_record, now)\n\t    )  )\n      {\n      addr->message = US\"retry time not reached\";\n      addr->basic_errno = ERRNO_RRETRY;\n      (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      }\n\n    /* The domain is OK for routing. Remember if retry data exists so it\n    can be cleaned up after a successful delivery. */\n\n    else\n      {\n      if (domain_retry_record || address_retry_record)\n        setflag(addr, af_dr_retry_exists);\n      addr->next = addr_route;\n      addr_route = addr;\n      DEBUG(D_deliver|D_route)\n        debug_printf(\"%s: queued for routing\\n\", addr->address);\n      }\n    }\n\n  /* The database is closed while routing is actually happening. Requests to\n  update it are put on a chain and all processed together at the end. */\n\n  if (dbm_file) dbfn_close(dbm_file);\n\n  /* If queue_domains is set, we don't even want to try routing addresses in\n  those domains. During queue runs, queue_domains is forced to be unset.\n  Optimize by skipping this pass through the addresses if nothing is set. */\n\n  if (!deliver_force && queue_domains)\n    {\n    address_item *okaddr = NULL;\n    while (addr_route)\n      {\n      address_item *addr = addr_route;\n      addr_route = addr->next;\n\n      deliver_domain = addr->domain;  /* set $domain */\n      if ((rc = match_isinlist(addr->domain, (const uschar **)&queue_domains, 0,\n            &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE, NULL))\n              != OK)\n        if (rc == DEFER)\n          {\n          addr->basic_errno = ERRNO_LISTDEFER;\n          addr->message = US\"queue_domains lookup deferred\";\n          (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n          }\n        else\n          {\n          addr->next = okaddr;\n          okaddr = addr;\n          }\n      else\n        {\n        addr->basic_errno = ERRNO_QUEUE_DOMAIN;\n        addr->message = US\"domain is in queue_domains\";\n        (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n        }\n      }\n\n    addr_route = okaddr;\n    }\n\n  /* Now route those addresses that are not deferred. */\n\n  while (addr_route)\n    {\n    int rc;\n    address_item *addr = addr_route;\n    const uschar *old_domain = addr->domain;\n    uschar *old_unique = addr->unique;\n    addr_route = addr->next;\n    addr->next = NULL;\n\n    /* Just in case some router parameter refers to it. */\n\n    if (!(return_path = addr->prop.errors_address))\n      return_path = sender_address;\n\n    /* If a router defers an address, add a retry item. Whether or not to\n    use the local part in the key is a property of the router. */\n\n    if ((rc = route_address(addr, &addr_local, &addr_remote, &addr_new,\n         &addr_succeed, v_none)) == DEFER)\n      retry_add_item(addr,\n        addr->router->retry_use_local_part\n        ? string_sprintf(\"R:%s@%s\", addr->local_part, addr->domain)\n\t: string_sprintf(\"R:%s\", addr->domain),\n\t0);\n\n    /* Otherwise, if there is an existing retry record in the database, add\n    retry items to delete both forms. We must also allow for the possibility\n    of a routing retry that includes the sender address. Since the domain might\n    have been rewritten (expanded to fully qualified) as a result of routing,\n    ensure that the rewritten form is also deleted. */\n\n    else if (testflag(addr, af_dr_retry_exists))\n      {\n      uschar *altkey = string_sprintf(\"%s:<%s>\", addr->address_retry_key,\n        sender_address);\n      retry_add_item(addr, altkey, rf_delete);\n      retry_add_item(addr, addr->address_retry_key, rf_delete);\n      retry_add_item(addr, addr->domain_retry_key, rf_delete);\n      if (Ustrcmp(addr->domain, old_domain) != 0)\n        retry_add_item(addr, string_sprintf(\"R:%s\", old_domain), rf_delete);\n      }\n\n    /* DISCARD is given for :blackhole: and \"seen finish\". The event has been\n    logged, but we need to ensure the address (and maybe parents) is marked\n    done. */\n\n    if (rc == DISCARD)\n      {\n      address_done(addr, tod_stamp(tod_log));\n      continue;  /* route next address */\n      }\n\n    /* The address is finished with (failed or deferred). */\n\n    if (rc != OK)\n      {\n      (void)post_process_one(addr, rc, LOG_MAIN, EXIM_DTYPE_ROUTER, 0);\n      continue;  /* route next address */\n      }\n\n    /* The address has been routed. If the router changed the domain, it will\n    also have changed the unique address. We have to test whether this address\n    has already been delivered, because it's the unique address that finally\n    gets recorded. */\n\n    if (  addr->unique != old_unique\n       && tree_search(tree_nonrecipients, addr->unique) != 0\n       )\n      {\n      DEBUG(D_deliver|D_route) debug_printf(\"%s was previously delivered: \"\n        \"discarded\\n\", addr->address);\n      if (addr_remote == addr) addr_remote = addr->next;\n      else if (addr_local == addr) addr_local = addr->next;\n      }\n\n    /* If the router has same_domain_copy_routing set, we are permitted to copy\n    the routing for any other addresses with the same domain. This is an\n    optimisation to save repeated DNS lookups for \"standard\" remote domain\n    routing. The option is settable only on routers that generate host lists.\n    We play it very safe, and do the optimization only if the address is routed\n    to a remote transport, there are no header changes, and the domain was not\n    modified by the router. */\n\n    if (  addr_remote == addr\n       && addr->router->same_domain_copy_routing\n       && !addr->prop.extra_headers\n       && !addr->prop.remove_headers\n       && old_domain == addr->domain\n       )\n      {\n      address_item **chain = &addr_route;\n      while (*chain)\n        {\n        address_item *addr2 = *chain;\n        if (Ustrcmp(addr2->domain, addr->domain) != 0)\n          {\n          chain = &(addr2->next);\n          continue;\n          }\n\n        /* Found a suitable address; take it off the routing list and add it to\n        the remote delivery list. */\n\n        *chain = addr2->next;\n        addr2->next = addr_remote;\n        addr_remote = addr2;\n\n        /* Copy the routing data */\n\n        addr2->domain = addr->domain;\n        addr2->router = addr->router;\n        addr2->transport = addr->transport;\n        addr2->host_list = addr->host_list;\n        addr2->fallback_hosts = addr->fallback_hosts;\n        addr2->prop.errors_address = addr->prop.errors_address;\n        copyflag(addr2, addr, af_hide_child);\n        copyflag(addr2, addr, af_local_host_removed);\n\n        DEBUG(D_deliver|D_route)\n          debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\"\n                       \"routing %s\\n\"\n                       \"Routing for %s copied from %s\\n\",\n            addr2->address, addr2->address, addr->address);\n        }\n      }\n    }  /* Continue with routing the next address. */\n  }    /* Loop to process any child addresses that the routers created, and\n          any rerouted addresses that got put back on the new chain. */\n\n\n/* Debugging: show the results of the routing */\n\nDEBUG(D_deliver|D_retry|D_route)\n  {\n  address_item *p;\n  debug_printf(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n  debug_printf(\"After routing:\\n  Local deliveries:\\n\");\n  for (p = addr_local; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Remote deliveries:\\n\");\n  for (p = addr_remote; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Failed addresses:\\n\");\n  for (p = addr_failed; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n\n  debug_printf(\"  Deferred addresses:\\n\");\n  for (p = addr_defer; p; p = p->next)\n    debug_printf(\"    %s\\n\", p->address);\n  }\n\n/* Free any resources that were cached during routing. */\n\nsearch_tidyup();\nroute_tidyup();\n\n/* These two variables are set only during routing, after check_local_user.\nEnsure they are not set in transports. */\n\nlocal_user_gid = (gid_t)(-1);\nlocal_user_uid = (uid_t)(-1);\n\n/* Check for any duplicate addresses. This check is delayed until after\nrouting, because the flexibility of the routing configuration means that\nidentical addresses with different parentage may end up being redirected to\ndifferent addresses. Checking for duplicates too early (as we previously used\nto) makes this kind of thing not work. */\n\ndo_duplicate_check(&addr_local);\ndo_duplicate_check(&addr_remote);\n\n/* When acting as an MUA wrapper, we proceed only if all addresses route to a\nremote transport. The check that they all end up in one transaction happens in\nthe do_remote_deliveries() function. */\n\nif (  mua_wrapper\n   && (addr_local || addr_failed || addr_defer)\n   )\n  {\n  address_item *addr;\n  uschar *which, *colon, *msg;\n\n  if (addr_local)\n    {\n    addr = addr_local;\n    which = US\"local\";\n    }\n  else if (addr_defer)\n    {\n    addr = addr_defer;\n    which = US\"deferred\";\n    }\n  else\n    {\n    addr = addr_failed;\n    which = US\"failed\";\n    }\n\n  while (addr->parent) addr = addr->parent;\n\n  if (addr->message)\n    {\n    colon = US\": \";\n    msg = addr->message;\n    }\n  else colon = msg = US\"\";\n\n  /* We don't need to log here for a forced failure as it will already\n  have been logged. Defer will also have been logged, but as a defer, so we do\n  need to do the failure logging. */\n\n  if (addr != addr_failed)\n    log_write(0, LOG_MAIN, \"** %s routing yielded a %s delivery\",\n      addr->address, which);\n\n  /* Always write an error to the caller */\n\n  fprintf(stderr, \"routing %s yielded a %s delivery%s%s\\n\", addr->address,\n    which, colon, msg);\n\n  final_yield = DELIVER_MUA_FAILED;\n  addr_failed = addr_defer = NULL;   /* So that we remove the message */\n  goto DELIVERY_TIDYUP;\n  }\n\n\n/* If this is a run to continue deliveries to an external channel that is\nalready set up, defer any local deliveries. */\n\nif (continue_transport)\n  {\n  if (addr_defer)\n    {\n    address_item *addr = addr_defer;\n    while (addr->next) addr = addr->next;\n    addr->next = addr_local;\n    }\n  else\n    addr_defer = addr_local;\n  addr_local = NULL;\n  }\n\n\n/* Because address rewriting can happen in the routers, we should not really do\nANY deliveries until all addresses have been routed, so that all recipients of\nthe message get the same headers. However, this is in practice not always\npossible, since sometimes remote addresses give DNS timeouts for days on end.\nThe pragmatic approach is to deliver what we can now, saving any rewritten\nheaders so that at least the next lot of recipients benefit from the rewriting\nthat has already been done.\n\nIf any headers have been rewritten during routing, update the spool file to\nremember them for all subsequent deliveries. This can be delayed till later if\nthere is only address to be delivered - if it succeeds the spool write need not\nhappen. */\n\nif (  header_rewritten\n   && (  addr_local && (addr_local->next || addr_remote)\n      || addr_remote && addr_remote->next\n   )  )\n  {\n  /* Panic-dies on error */\n  (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  header_rewritten = FALSE;\n  }\n\n\n/* If there are any deliveries to be and we do not already have the journal\nfile, create it. This is used to record successful deliveries as soon as\npossible after each delivery is known to be complete. A file opened with\nO_APPEND is used so that several processes can run simultaneously.\n\nThe journal is just insurance against crashes. When the spool file is\nultimately updated at the end of processing, the journal is deleted. If a\njournal is found to exist at the start of delivery, the addresses listed\ntherein are added to the non-recipients. */\n\nif (addr_local || addr_remote)\n  {\n  if (journal_fd < 0)\n    {\n    uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n    if ((journal_fd = Uopen(fname,\n#ifdef O_CLOEXEC\n\t\t\tO_CLOEXEC |\n#endif\n\t\t\tO_WRONLY|O_APPEND|O_CREAT|O_EXCL, SPOOL_MODE)) < 0)\n      {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't open journal file %s: %s\",\n\tfname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n\n    /* Set the close-on-exec flag, make the file owned by Exim, and ensure\n    that the mode is correct - the group setting doesn't always seem to get\n    set automatically. */\n\n    if(  fchown(journal_fd, exim_uid, exim_gid)\n      || fchmod(journal_fd, SPOOL_MODE)\n#ifndef O_CLOEXEC\n      || fcntl(journal_fd, F_SETFD, fcntl(journal_fd, F_GETFD) | FD_CLOEXEC)\n#endif\n      )\n      {\n      int ret = Uunlink(fname);\n      log_write(0, LOG_MAIN|LOG_PANIC, \"Couldn't set perms on journal file %s: %s\",\n\tfname, strerror(errno));\n      if(ret  &&  errno != ENOENT)\n\tlog_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t  fname, strerror(errno));\n      return DELIVER_NOT_ATTEMPTED;\n      }\n    }\n  }\nelse if (journal_fd >= 0)\n  {\n  close(journal_fd);\n  journal_fd = -1;\n  }\n\n\n\n/* Now we can get down to the business of actually doing deliveries. Local\ndeliveries are done first, then remote ones. If ever the problems of how to\nhandle fallback transports are figured out, this section can be put into a loop\nfor handling fallbacks, though the uid switching will have to be revised. */\n\n/* Precompile a regex that is used to recognize a parameter in response\nto an LHLO command, if is isn't already compiled. This may be used on both\nlocal and remote LMTP deliveries. */\n\nif (!regex_IGNOREQUOTA)\n  regex_IGNOREQUOTA =\n    regex_must_compile(US\"\\\\n250[\\\\s\\\\-]IGNOREQUOTA(\\\\s|\\\\n|$)\", FALSE, TRUE);\n\n/* Handle local deliveries */\n\nif (addr_local)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Local deliveries >>>>>>>>>>>>>>>>\\n\");\n  do_local_deliveries();\n  disable_logging = FALSE;\n  }\n\n/* If queue_run_local is set, we do not want to attempt any remote deliveries,\nso just queue them all. */\n\nif (queue_run_local)\n  while (addr_remote)\n    {\n    address_item *addr = addr_remote;\n    addr_remote = addr->next;\n    addr->next = NULL;\n    addr->basic_errno = ERRNO_LOCAL_ONLY;\n    addr->message = US\"remote deliveries suppressed\";\n    (void)post_process_one(addr, DEFER, LOG_MAIN, EXIM_DTYPE_TRANSPORT, 0);\n    }\n\n/* Handle remote deliveries */\n\nif (addr_remote)\n  {\n  DEBUG(D_deliver|D_transport)\n    debug_printf(\">>>>>>>>>>>>>>>> Remote deliveries >>>>>>>>>>>>>>>>\\n\");\n\n  /* Precompile some regex that are used to recognize parameters in response\n  to an EHLO command, if they aren't already compiled. */\n\n  deliver_init();\n\n  /* Now sort the addresses if required, and do the deliveries. The yield of\n  do_remote_deliveries is FALSE when mua_wrapper is set and all addresses\n  cannot be delivered in one transaction. */\n\n  if (remote_sort_domains) sort_remote_deliveries();\n  if (!do_remote_deliveries(FALSE))\n    {\n    log_write(0, LOG_MAIN, \"** mua_wrapper is set but recipients cannot all \"\n      \"be delivered in one transaction\");\n    fprintf(stderr, \"delivery to smarthost failed (configuration problem)\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = addr_defer = NULL;   /* So that we remove the message */\n    goto DELIVERY_TIDYUP;\n    }\n\n  /* See if any of the addresses that failed got put on the queue for delivery\n  to their fallback hosts. We do it this way because often the same fallback\n  host is used for many domains, so all can be sent in a single transaction\n  (if appropriately configured). */\n\n  if (addr_fallback && !mua_wrapper)\n    {\n    DEBUG(D_deliver) debug_printf(\"Delivering to fallback hosts\\n\");\n    addr_remote = addr_fallback;\n    addr_fallback = NULL;\n    if (remote_sort_domains) sort_remote_deliveries();\n    do_remote_deliveries(TRUE);\n    }\n  disable_logging = FALSE;\n  }\n\n\n/* All deliveries are now complete. Ignore SIGTERM during this tidying up\nphase, to minimize cases of half-done things. */\n\nDEBUG(D_deliver)\n  debug_printf(\">>>>>>>>>>>>>>>> deliveries are done >>>>>>>>>>>>>>>>\\n\");\ncancel_cutthrough_connection(TRUE, US\"deliveries are done\");\n\n/* Root privilege is no longer needed */\n\nexim_setugid(exim_uid, exim_gid, FALSE, US\"post-delivery tidying\");\n\nset_process_info(\"tidying up after delivering %s\", message_id);\nsignal(SIGTERM, SIG_IGN);\n\n/* When we are acting as an MUA wrapper, the smtp transport will either have\nsucceeded for all addresses, or failed them all in normal cases. However, there\nare some setup situations (e.g. when a named port does not exist) that cause an\nimmediate exit with deferral of all addresses. Convert those into failures. We\ndo not ever want to retry, nor do we want to send a bounce message. */\n\nif (mua_wrapper)\n  {\n  if (addr_defer)\n    {\n    address_item *addr, *nextaddr;\n    for (addr = addr_defer; addr; addr = nextaddr)\n      {\n      log_write(0, LOG_MAIN, \"** %s mua_wrapper forced failure for deferred \"\n        \"delivery\", addr->address);\n      nextaddr = addr->next;\n      addr->next = addr_failed;\n      addr_failed = addr;\n      }\n    addr_defer = NULL;\n    }\n\n  /* Now all should either have succeeded or failed. */\n\n  if (!addr_failed)\n    final_yield = DELIVER_MUA_SUCCEEDED;\n  else\n    {\n    host_item * host;\n    uschar *s = addr_failed->user_message;\n\n    if (!s) s = addr_failed->message;\n\n    fprintf(stderr, \"Delivery failed: \");\n    if (addr_failed->basic_errno > 0)\n      {\n      fprintf(stderr, \"%s\", strerror(addr_failed->basic_errno));\n      if (s) fprintf(stderr, \": \");\n      }\n    if ((host = addr_failed->host_used))\n      fprintf(stderr, \"H=%s [%s]: \", host->name, host->address);\n    if (s)\n      fprintf(stderr, \"%s\", CS s);\n    else if (addr_failed->basic_errno <= 0)\n      fprintf(stderr, \"unknown error\");\n    fprintf(stderr, \"\\n\");\n\n    final_yield = DELIVER_MUA_FAILED;\n    addr_failed = NULL;\n    }\n  }\n\n/* In a normal configuration, we now update the retry database. This is done in\none fell swoop at the end in order not to keep opening and closing (and\nlocking) the database. The code for handling retries is hived off into a\nseparate module for convenience. We pass it the addresses of the various\nchains, because deferred addresses can get moved onto the failed chain if the\nretry cutoff time has expired for all alternative destinations. Bypass the\nupdating of the database if the -N flag is set, which is a debugging thing that\nprevents actual delivery. */\n\nelse if (!dont_deliver)\n  retry_update(&addr_defer, &addr_failed, &addr_succeed);\n\n/* Send DSN for successful messages if requested */\naddr_senddsn = NULL;\n\nfor (addr_dsntmp = addr_succeed; addr_dsntmp; addr_dsntmp = addr_dsntmp->next)\n  {\n  /* af_ignore_error not honored here. it's not an error */\n  DEBUG(D_deliver) debug_printf(\"DSN: processing router : %s\\n\"\n      \"DSN: processing successful delivery address: %s\\n\"\n      \"DSN: Sender_address: %s\\n\"\n      \"DSN: orcpt: %s  flags: %d\\n\"\n      \"DSN: envid: %s  ret: %d\\n\"\n      \"DSN: Final recipient: %s\\n\"\n      \"DSN: Remote SMTP server supports DSN: %d\\n\",\n      addr_dsntmp->router ? addr_dsntmp->router->name : US\"(unknown)\",\n      addr_dsntmp->address,\n      sender_address,\n      addr_dsntmp->dsn_orcpt ? addr_dsntmp->dsn_orcpt : US\"NULL\",\n      addr_dsntmp->dsn_flags,\n      dsn_envid ? dsn_envid : US\"NULL\", dsn_ret,\n      addr_dsntmp->address,\n      addr_dsntmp->dsn_aware\n      );\n\n  /* send report if next hop not DSN aware or a router flagged \"last DSN hop\"\n     and a report was requested */\n  if (  (  addr_dsntmp->dsn_aware != dsn_support_yes\n\t|| addr_dsntmp->dsn_flags & rf_dsnlasthop\n        )\n     && addr_dsntmp->dsn_flags & rf_dsnflags\n     && addr_dsntmp->dsn_flags & rf_notify_success\n     )\n    {\n    /* copy and relink address_item and send report with all of them at once later */\n    address_item * addr_next = addr_senddsn;\n    addr_senddsn = store_get(sizeof(address_item));\n    *addr_senddsn = *addr_dsntmp;\n    addr_senddsn->next = addr_next;\n    }\n  else\n    DEBUG(D_deliver) debug_printf(\"DSN: not sending DSN success message\\n\");\n  }\n\nif (addr_senddsn)\n  {\n  pid_t pid;\n  int fd;\n\n  /* create exim process to send message */\n  pid = child_open_exim(&fd);\n\n  DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim returns: %d\\n\", pid);\n\n  if (pid < 0)  /* Creation of child failed */\n    {\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n      \"create child process to send failure message: %s\", getpid(),\n      getppid(), strerror(errno));\n\n    DEBUG(D_deliver) debug_printf(\"DSN: child_open_exim failed\\n\");\n    }\n  else  /* Creation of child succeeded */\n    {\n    FILE *f = fdopen(fd, \"wb\");\n    /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n    uschar * bound;\n    transport_ctx tctx = {{0}};\n\n    DEBUG(D_deliver)\n      debug_printf(\"sending error message to: %s\\n\", sender_address);\n\n    /* build unique id for MIME boundary */\n    bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n    DEBUG(D_deliver) debug_printf(\"DSN: MIME boundary: %s\\n\", bound);\n\n    if (errors_reply_to)\n      fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n\n    fprintf(f, \"Auto-Submitted: auto-generated\\n\"\n\t\"From: Mail Delivery System <Mailer-Daemon@%s>\\n\"\n\t\"To: %s\\n\"\n\t\"Subject: Delivery Status Notification\\n\"\n\t\"Content-Type: multipart/report; report-type=delivery-status; boundary=%s\\n\"\n\t\"MIME-Version: 1.0\\n\\n\"\n\n\t\"--%s\\n\"\n\t\"Content-type: text/plain; charset=us-ascii\\n\\n\"\n\n\t\"This message was created automatically by mail delivery software.\\n\"\n\t\" ----- The following addresses had successful delivery notifications -----\\n\",\n      qualify_domain_sender, sender_address, bound, bound);\n\n    for (addr_dsntmp = addr_senddsn; addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      fprintf(f, \"<%s> (relayed %s)\\n\\n\",\n\taddr_dsntmp->address,\n\t(addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1\n\t  ? \"via non DSN router\"\n\t  : addr_dsntmp->dsn_aware == dsn_support_no\n\t  ? \"to non-DSN-aware mailer\"\n\t  : \"via non \\\"Remote SMTP\\\" router\"\n\t);\n\n    fprintf(f, \"--%s\\n\"\n\t\"Content-type: message/delivery-status\\n\\n\"\n\t\"Reporting-MTA: dns; %s\\n\",\n      bound, smtp_active_hostname);\n\n    if (dsn_envid)\n      {\t\t\t/* must be decoded from xtext: see RFC 3461:6.3a */\n      uschar *xdec_envid;\n      if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n        fprintf(f, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n      else\n        fprintf(f, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n      }\n    fputc('\\n', f);\n\n    for (addr_dsntmp = addr_senddsn;\n\t addr_dsntmp;\n\t addr_dsntmp = addr_dsntmp->next)\n      {\n      if (addr_dsntmp->dsn_orcpt)\n        fprintf(f,\"Original-Recipient: %s\\n\", addr_dsntmp->dsn_orcpt);\n\n      fprintf(f, \"Action: delivered\\n\"\n\t  \"Final-Recipient: rfc822;%s\\n\"\n\t  \"Status: 2.0.0\\n\",\n\taddr_dsntmp->address);\n\n      if (addr_dsntmp->host_used && addr_dsntmp->host_used->name)\n        fprintf(f, \"Remote-MTA: dns; %s\\nDiagnostic-Code: smtp; 250 Ok\\n\\n\",\n\t  addr_dsntmp->host_used->name);\n      else\n\tfprintf(f, \"Diagnostic-Code: X-Exim; relayed via non %s router\\n\\n\",\n\t  (addr_dsntmp->dsn_flags & rf_dsnlasthop) == 1 ? \"DSN\" : \"SMTP\");\n      }\n\n    fprintf(f, \"--%s\\nContent-type: text/rfc822-headers\\n\\n\", bound);\n\n    fflush(f);\n    transport_filter_argv = NULL;   /* Just in case */\n    return_path = sender_address;   /* In case not previously set */\n\n    /* Write the original email out */\n\n    tctx.u.fd = fileno(f);\n    tctx.options = topt_add_return_path | topt_no_body;\n    transport_write_message(&tctx, 0);\n    fflush(f);\n\n    fprintf(f,\"\\n--%s--\\n\", bound);\n\n    fflush(f);\n    fclose(f);\n    rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n    }\n  }\n\n/* If any addresses failed, we must send a message to somebody, unless\naf_ignore_error is set, in which case no action is taken. It is possible for\nseveral messages to get sent if there are addresses with different\nrequirements. */\n\nwhile (addr_failed)\n  {\n  pid_t pid;\n  int fd;\n  uschar *logtod = tod_stamp(tod_log);\n  address_item *addr;\n  address_item *handled_addr = NULL;\n  address_item **paddr;\n  address_item *msgchain = NULL;\n  address_item **pmsgchain = &msgchain;\n\n  /* There are weird cases when logging is disabled in the transport. However,\n  there may not be a transport (address failed by a router). */\n\n  disable_logging = FALSE;\n  if (addr_failed->transport)\n    disable_logging = addr_failed->transport->disable_logging;\n\n  DEBUG(D_deliver)\n    debug_printf(\"processing failed address %s\\n\", addr_failed->address);\n\n  /* There are only two ways an address in a bounce message can get here:\n\n  (1) When delivery was initially deferred, but has now timed out (in the call\n      to retry_update() above). We can detect this by testing for\n      af_retry_timedout. If the address does not have its own errors address,\n      we arrange to ignore the error.\n\n  (2) If delivery failures for bounce messages are being ignored. We can detect\n      this by testing for af_ignore_error. This will also be set if a bounce\n      message has been autothawed and the ignore_bounce_errors_after time has\n      passed. It might also be set if a router was explicitly configured to\n      ignore errors (errors_to = \"\").\n\n  If neither of these cases obtains, something has gone wrong. Log the\n  incident, but then ignore the error. */\n\n  if (sender_address[0] == 0 && !addr_failed->prop.errors_address)\n    {\n    if (  !testflag(addr_failed, af_retry_timedout)\n       && !addr_failed->prop.ignore_error)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"internal error: bounce message \"\n        \"failure is neither frozen nor ignored (it's been ignored)\");\n\n    addr_failed->prop.ignore_error = TRUE;\n    }\n\n  /* If the first address on the list has af_ignore_error set, just remove\n  it from the list, throw away any saved message file, log it, and\n  mark the recipient done. */\n\n  if (  addr_failed->prop.ignore_error\n     || (  addr_failed->dsn_flags & rf_dsnflags\n        && (addr_failed->dsn_flags & rf_notify_failure) != rf_notify_failure\n     )  )\n    {\n    addr = addr_failed;\n    addr_failed = addr->next;\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    log_write(0, LOG_MAIN, \"%s%s%s%s: error ignored\",\n      addr->address,\n      !addr->parent ? US\"\" : US\" <\",\n      !addr->parent ? US\"\" : addr->parent->address,\n      !addr->parent ? US\"\" : US\">\");\n\n    address_done(addr, logtod);\n    child_done(addr, logtod);\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n    }\n\n  /* Otherwise, handle the sending of a message. Find the error address for\n  the first address, then send a message that includes all failed addresses\n  that have the same error address. Note the bounce_recipient is a global so\n  that it can be accessed by $bounce_recipient while creating a customized\n  error message. */\n\n  else\n    {\n    if (!(bounce_recipient = addr_failed->prop.errors_address))\n      bounce_recipient = sender_address;\n\n    /* Make a subprocess to send a message */\n\n    if ((pid = child_open_exim(&fd)) < 0)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Process %d (parent %d) failed to \"\n        \"create child process to send failure message: %s\", getpid(),\n        getppid(), strerror(errno));\n\n    /* Creation of child succeeded */\n\n    else\n      {\n      int ch, rc;\n      int filecount = 0;\n      int rcount = 0;\n      uschar *bcc, *emf_text;\n      FILE *f = fdopen(fd, \"wb\");\n      FILE *emf = NULL;\n      BOOL to_sender = strcmpic(sender_address, bounce_recipient) == 0;\n      int max = (bounce_return_size_limit/DELIVER_IN_BUFFER_SIZE + 1) *\n        DELIVER_IN_BUFFER_SIZE;\n      uschar * bound;\n      uschar *dsnlimitmsg;\n      uschar *dsnnotifyhdr;\n      int topt;\n\n      DEBUG(D_deliver)\n        debug_printf(\"sending error message to: %s\\n\", bounce_recipient);\n\n      /* Scan the addresses for all that have the same errors address, removing\n      them from the addr_failed chain, and putting them on msgchain. */\n\n      paddr = &addr_failed;\n      for (addr = addr_failed; addr; addr = *paddr)\n        if (Ustrcmp(bounce_recipient, addr->prop.errors_address\n\t      ? addr->prop.errors_address : sender_address) == 0)\n          {                          /* The same - dechain */\n          *paddr = addr->next;\n          *pmsgchain = addr;\n          addr->next = NULL;\n          pmsgchain = &(addr->next);\n          }\n        else\n          paddr = &addr->next;        /* Not the same; skip */\n\n      /* Include X-Failed-Recipients: for automatic interpretation, but do\n      not let any one header line get too long. We do this by starting a\n      new header every 50 recipients. Omit any addresses for which the\n      \"hide_child\" flag is set. */\n\n      for (addr = msgchain; addr; addr = addr->next)\n        {\n        if (testflag(addr, af_hide_child)) continue;\n        if (rcount >= 50)\n          {\n          fprintf(f, \"\\n\");\n          rcount = 0;\n          }\n        fprintf(f, \"%s%s\",\n          rcount++ == 0\n\t  ? \"X-Failed-Recipients: \"\n\t  : \",\\n  \",\n          testflag(addr, af_pfr) && addr->parent\n\t  ? string_printing(addr->parent->address)\n\t  : string_printing(addr->address));\n        }\n      if (rcount > 0) fprintf(f, \"\\n\");\n\n      /* Output the standard headers */\n\n      if (errors_reply_to)\n        fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n      fprintf(f, \"Auto-Submitted: auto-replied\\n\");\n      moan_write_from(f);\n      fprintf(f, \"To: %s\\n\", bounce_recipient);\n\n      /* generate boundary string and output MIME-Headers */\n      bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n      fprintf(f, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t  \"MIME-Version: 1.0\\n\",\n\tbound);\n\n      /* Open a template file if one is provided. Log failure to open, but\n      carry on - default texts will be used. */\n\n      if (bounce_message_file)\n        if (!(emf = Ufopen(bounce_message_file, \"rb\")))\n          log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for error \"\n            \"message texts: %s\", bounce_message_file, strerror(errno));\n\n      /* Quietly copy to configured additional addresses if required. */\n\n      if ((bcc = moan_check_errorcopy(bounce_recipient)))\n\tfprintf(f, \"Bcc: %s\\n\", bcc);\n\n      /* The texts for the message can be read from a template file; if there\n      isn't one, or if it is too short, built-in texts are used. The first\n      emf text is a Subject: and any other headers. */\n\n      if ((emf_text = next_emf(emf, US\"header\")))\n\tfprintf(f, \"%s\\n\", emf_text);\n      else\n        fprintf(f, \"Subject: Mail delivery failed%s\\n\\n\",\n          to_sender? \": returning message to sender\" : \"\");\n\n      /* output human readable part as text/plain section */\n      fprintf(f, \"--%s\\n\"\n\t  \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\tbound);\n\n      if ((emf_text = next_emf(emf, US\"intro\")))\n\tfprintf(f, \"%s\", CS emf_text);\n      else\n        {\n        fprintf(f,\n/* This message has been reworded several times. It seems to be confusing to\nsomebody, however it is worded. I have retreated to the original, simple\nwording. */\n\"This message was created automatically by mail delivery software.\\n\");\n\n        if (bounce_message_text)\n\t  fprintf(f, \"%s\", CS bounce_message_text);\n        if (to_sender)\n          fprintf(f,\n\"\\nA message that you sent could not be delivered to one or more of its\\n\"\n\"recipients. This is a permanent error. The following address(es) failed:\\n\");\n        else\n          fprintf(f,\n\"\\nA message sent by\\n\\n  <%s>\\n\\n\"\n\"could not be delivered to one or more of its recipients. The following\\n\"\n\"address(es) failed:\\n\", sender_address);\n        }\n      fputc('\\n', f);\n\n      /* Process the addresses, leaving them on the msgchain if they have a\n      file name for a return message. (There has already been a check in\n      post_process_one() for the existence of data in the message file.) A TRUE\n      return from print_address_information() means that the address is not\n      hidden. */\n\n      paddr = &msgchain;\n      for (addr = msgchain; addr; addr = *paddr)\n        {\n        if (print_address_information(addr, f, US\"  \", US\"\\n    \", US\"\"))\n          print_address_error(addr, f, US\"\");\n\n        /* End the final line for the address */\n\n        fputc('\\n', f);\n\n        /* Leave on msgchain if there's a return file. */\n\n        if (addr->return_file >= 0)\n          {\n          paddr = &(addr->next);\n          filecount++;\n          }\n\n        /* Else save so that we can tick off the recipient when the\n        message is sent. */\n\n        else\n          {\n          *paddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = addr;\n          }\n        }\n\n      fputc('\\n', f);\n\n      /* Get the next text, whether we need it or not, so as to be\n      positioned for the one after. */\n\n      emf_text = next_emf(emf, US\"generated text\");\n\n      /* If there were any file messages passed by the local transports,\n      include them in the message. Then put the address on the handled chain.\n      In the case of a batch of addresses that were all sent to the same\n      transport, the return_file field in all of them will contain the same\n      fd, and the return_filename field in the *last* one will be set (to the\n      name of the file). */\n\n      if (msgchain)\n        {\n        address_item *nextaddr;\n\n        if (emf_text)\n\t  fprintf(f, \"%s\", CS emf_text);\n\telse\n          fprintf(f,\n            \"The following text was generated during the delivery \"\n            \"attempt%s:\\n\", (filecount > 1)? \"s\" : \"\");\n\n        for (addr = msgchain; addr; addr = nextaddr)\n          {\n          FILE *fm;\n          address_item *topaddr = addr;\n\n          /* List all the addresses that relate to this file */\n\n\t  fputc('\\n', f);\n          while(addr)                   /* Insurance */\n            {\n            print_address_information(addr, f, US\"------ \",  US\"\\n       \",\n              US\" ------\\n\");\n            if (addr->return_filename) break;\n            addr = addr->next;\n            }\n\t  fputc('\\n', f);\n\n          /* Now copy the file */\n\n          if (!(fm = Ufopen(addr->return_filename, \"rb\")))\n            fprintf(f, \"    +++ Exim error... failed to open text file: %s\\n\",\n              strerror(errno));\n          else\n            {\n            while ((ch = fgetc(fm)) != EOF) fputc(ch, f);\n            (void)fclose(fm);\n            }\n          Uunlink(addr->return_filename);\n\n          /* Can now add to handled chain, first fishing off the next\n          address on the msgchain. */\n\n          nextaddr = addr->next;\n          addr->next = handled_addr;\n          handled_addr = topaddr;\n          }\n\tfputc('\\n', f);\n        }\n\n      /* output machine readable part */\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfprintf(f, \"--%s\\n\"\n\t    \"Content-type: message/global-delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n      else\n#endif\n\tfprintf(f, \"--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound, smtp_active_hostname);\n\n      if (dsn_envid)\n\t{\n        /* must be decoded from xtext: see RFC 3461:6.3a */\n        uschar *xdec_envid;\n        if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n          fprintf(f, \"Original-Envelope-ID: %s\\n\", dsn_envid);\n        else\n          fprintf(f, \"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n        }\n      fputc('\\n', f);\n\n      for (addr = handled_addr; addr; addr = addr->next)\n        {\n\thost_item * hu;\n        fprintf(f, \"Action: failed\\n\"\n\t    \"Final-Recipient: rfc822;%s\\n\"\n\t    \"Status: 5.0.0\\n\",\n\t    addr->address);\n        if ((hu = addr->host_used) && hu->name)\n\t  {\n\t  const uschar * s;\n\t  fprintf(f, \"Remote-MTA: dns; %s\\n\", hu->name);\n#ifdef EXPERIMENTAL_DSN_INFO\n\t  if (hu->address)\n\t    {\n\t    uschar * p = hu->port == 25\n\t      ? US\"\" : string_sprintf(\":%d\", hu->port);\n\t    fprintf(f, \"Remote-MTA: X-ip; [%s]%s\\n\", hu->address, p);\n\t    }\n\t  if ((s = addr->smtp_greeting) && *s)\n\t    fprintf(f, \"X-Remote-MTA-smtp-greeting: X-str; %s\\n\", s);\n\t  if ((s = addr->helo_response) && *s)\n\t    fprintf(f, \"X-Remote-MTA-helo-response: X-str; %s\\n\", s);\n\t  if ((s = addr->message) && *s)\n\t    fprintf(f, \"X-Exim-Diagnostic: X-str; %s\\n\", s);\n#endif\n\t  print_dsn_diagnostic_code(addr, f);\n\t  }\n\tfputc('\\n', f);\n        }\n\n      /* Now copy the message, trying to give an intelligible comment if\n      it is too long for it all to be copied. The limit isn't strictly\n      applied because of the buffering. There is, however, an option\n      to suppress copying altogether. */\n\n      emf_text = next_emf(emf, US\"copy\");\n\n      /* add message body\n         we ignore the intro text from template and add\n         the text for bounce_return_size_limit at the end.\n\n         bounce_return_message is ignored\n         in case RET= is defined we honor these values\n         otherwise bounce_return_body is honored.\n\n         bounce_return_size_limit is always honored.\n      */\n\n      fprintf(f, \"--%s\\n\", bound);\n\n      dsnlimitmsg = US\"X-Exim-DSN-Information: Due to administrative limits only headers are returned\";\n      dsnnotifyhdr = NULL;\n      topt = topt_add_return_path;\n\n      /* RET=HDRS? top priority */\n      if (dsn_ret == dsn_ret_hdrs)\n        topt |= topt_no_body;\n      else\n\t{\n\tstruct stat statbuf;\n\n        /* no full body return at all? */\n        if (!bounce_return_body)\n          {\n          topt |= topt_no_body;\n          /* add header if we overrule RET=FULL */\n          if (dsn_ret == dsn_ret_full)\n            dsnnotifyhdr = dsnlimitmsg;\n          }\n\t/* line length limited... return headers only if oversize */\n        /* size limited ... return headers only if limit reached */\n\telse if (  max_received_linelength > bounce_return_linesize_limit\n\t\t|| (  bounce_return_size_limit > 0\n\t\t   && fstat(deliver_datafile, &statbuf) == 0\n\t\t   && statbuf.st_size > max\n\t\t)  )\n\t  {\n\t  topt |= topt_no_body;\n\t  dsnnotifyhdr = dsnlimitmsg;\n          }\n\t}\n\n#ifdef SUPPORT_I18N\n      if (message_smtputf8)\n\tfputs(topt & topt_no_body ? \"Content-type: message/global-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/global\\n\\n\",\n\t      f);\n      else\n#endif\n\tfputs(topt & topt_no_body ? \"Content-type: text/rfc822-headers\\n\\n\"\n\t\t\t\t  : \"Content-type: message/rfc822\\n\\n\",\n\t      f);\n\n      fflush(f);\n      transport_filter_argv = NULL;   /* Just in case */\n      return_path = sender_address;   /* In case not previously set */\n\t{\t\t\t      /* Dummy transport for headers add */\n\ttransport_ctx tctx = {{0}};\n\ttransport_instance tb = {0};\n\n\ttctx.u.fd = fileno(f);\n\ttctx.tblock = &tb;\n\ttctx.options = topt;\n\ttb.add_headers = dsnnotifyhdr;\n\n\ttransport_write_message(&tctx, 0);\n\t}\n      fflush(f);\n\n      /* we never add the final text. close the file */\n      if (emf)\n        (void)fclose(emf);\n\n      fprintf(f, \"\\n--%s--\\n\", bound);\n\n      /* Close the file, which should send an EOF to the child process\n      that is receiving the message. Wait for it to finish. */\n\n      (void)fclose(f);\n      rc = child_close(pid, 0);     /* Waits for child to close, no timeout */\n\n      /* In the test harness, let the child do it's thing first. */\n\n      if (running_in_test_harness) millisleep(500);\n\n      /* If the process failed, there was some disaster in setting up the\n      error message. Unless the message is very old, ensure that addr_defer\n      is non-null, which will have the effect of leaving the message on the\n      spool. The failed addresses will get tried again next time. However, we\n      don't really want this to happen too often, so freeze the message unless\n      there are some genuine deferred addresses to try. To do this we have\n      to call spool_write_header() here, because with no genuine deferred\n      addresses the normal code below doesn't get run. */\n\n      if (rc != 0)\n        {\n        uschar *s = US\"\";\n        if (now - received_time.tv_sec < retry_maximum_timeout && !addr_defer)\n          {\n          addr_defer = (address_item *)(+1);\n          deliver_freeze = TRUE;\n          deliver_frozen_at = time(NULL);\n          /* Panic-dies on error */\n          (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n          s = US\" (frozen)\";\n          }\n        deliver_msglog(\"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        log_write(0, LOG_MAIN, \"Process failed (%d) when writing error message \"\n          \"to %s%s\", rc, bounce_recipient, s);\n        }\n\n      /* The message succeeded. Ensure that the recipients that failed are\n      now marked finished with on the spool and their parents updated. */\n\n      else\n        {\n        for (addr = handled_addr; addr; addr = addr->next)\n          {\n          address_done(addr, logtod);\n          child_done(addr, logtod);\n          }\n        /* Panic-dies on error */\n        (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n        }\n      }\n    }\n  }\n\ndisable_logging = FALSE;  /* In case left set */\n\n/* Come here from the mua_wrapper case if routing goes wrong */\n\nDELIVERY_TIDYUP:\n\n/* If there are now no deferred addresses, we are done. Preserve the\nmessage log if so configured, and we are using them. Otherwise, sling it.\nThen delete the message itself. */\n\nif (!addr_defer)\n  {\n  uschar * fname;\n\n  if (message_logs)\n    {\n    fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n    if (preserve_message_logs)\n      {\n      int rc;\n      uschar * moname = spool_fname(US\"msglog.OLD\", US\"\", id, US\"\");\n\n      if ((rc = Urename(fname, moname)) < 0)\n        {\n        (void)directory_make(spool_directory,\n\t\t\t      spool_sname(US\"msglog.OLD\", US\"\"),\n\t\t\t      MSGLOG_DIRECTORY_MODE, TRUE);\n        rc = Urename(fname, moname);\n        }\n      if (rc < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to move %s to the \"\n          \"msglog.OLD directory\", fname);\n      }\n    else\n      if (Uunlink(fname) < 0)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n\t\t  fname, strerror(errno));\n    }\n\n  /* Remove the two message files. */\n\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-D\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n  fname = spool_fname(US\"input\", message_subdir, id, US\"-H\");\n  if (Uunlink(fname) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\",\n      fname, strerror(errno));\n\n  /* Log the end of this message, with queue time if requested. */\n\n  if (LOGGING(queue_time_overall))\n    log_write(0, LOG_MAIN, \"Completed QT=%s\", string_timesince(&received_time));\n  else\n    log_write(0, LOG_MAIN, \"Completed\");\n\n  /* Unset deliver_freeze so that we won't try to move the spool files further down */\n  deliver_freeze = FALSE;\n\n#ifndef DISABLE_EVENT\n  (void) event_raise(event_action, US\"msg:complete\", NULL);\n#endif\n  }\n\n/* If there are deferred addresses, we are keeping this message because it is\nnot yet completed. Lose any temporary files that were catching output from\npipes for any of the deferred addresses, handle one-time aliases, and see if\nthe message has been on the queue for so long that it is time to send a warning\nmessage to the sender, unless it is a mailer-daemon. If all deferred addresses\nhave the same domain, we can set deliver_domain for the expansion of\ndelay_warning_ condition - if any of them are pipes, files, or autoreplies, use\nthe parent's domain.\n\nIf all the deferred addresses have an error number that indicates \"retry time\nnot reached\", skip sending the warning message, because it won't contain the\nreason for the delay. It will get sent at the next real delivery attempt.\nHowever, if at least one address has tried, we'd better include all of them in\nthe message.\n\nIf we can't make a process to send the message, don't worry.\n\nFor mailing list expansions we want to send the warning message to the\nmailing list manager. We can't do a perfect job here, as some addresses may\nhave different errors addresses, but if we take the errors address from\neach deferred address it will probably be right in most cases.\n\nIf addr_defer == +1, it means there was a problem sending an error message\nfor failed addresses, and there were no \"real\" deferred addresses. The value\nwas set just to keep the message on the spool, so there is nothing to do here.\n*/\n\nelse if (addr_defer != (address_item *)(+1))\n  {\n  address_item *addr;\n  uschar *recipients = US\"\";\n  BOOL delivery_attempted = FALSE;\n\n  deliver_domain = testflag(addr_defer, af_pfr)\n    ? addr_defer->parent->domain : addr_defer->domain;\n\n  for (addr = addr_defer; addr; addr = addr->next)\n    {\n    address_item *otaddr;\n\n    if (addr->basic_errno > ERRNO_RETRY_BASE) delivery_attempted = TRUE;\n\n    if (deliver_domain)\n      {\n      const uschar *d = testflag(addr, af_pfr)\n\t? addr->parent->domain : addr->domain;\n\n      /* The domain may be unset for an address that has never been routed\n      because the system filter froze the message. */\n\n      if (!d || Ustrcmp(d, deliver_domain) != 0)\n        deliver_domain = NULL;\n      }\n\n    if (addr->return_filename) Uunlink(addr->return_filename);\n\n    /* Handle the case of one-time aliases. If any address in the ancestry\n    of this one is flagged, ensure it is in the recipients list, suitably\n    flagged, and that its parent is marked delivered. */\n\n    for (otaddr = addr; otaddr; otaddr = otaddr->parent)\n      if (otaddr->onetime_parent) break;\n\n    if (otaddr)\n      {\n      int i;\n      int t = recipients_count;\n\n      for (i = 0; i < recipients_count; i++)\n        {\n        uschar *r = recipients_list[i].address;\n        if (Ustrcmp(otaddr->onetime_parent, r) == 0) t = i;\n        if (Ustrcmp(otaddr->address, r) == 0) break;\n        }\n\n      /* Didn't find the address already in the list, and did find the\n      ultimate parent's address in the list, and they really are different\n      (i.e. not from an identity-redirect). After adding the recipient,\n      update the errors address in the recipients list. */\n\n      if (  i >= recipients_count && t < recipients_count\n         && Ustrcmp(otaddr->address, otaddr->parent->address) != 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"one_time: adding %s in place of %s\\n\",\n          otaddr->address, otaddr->parent->address);\n        receive_add_recipient(otaddr->address, t);\n        recipients_list[recipients_count-1].errors_to = otaddr->prop.errors_address;\n        tree_add_nonrecipient(otaddr->parent->address);\n        update_spool = TRUE;\n        }\n      }\n\n    /* Except for error messages, ensure that either the errors address for\n    this deferred address or, if there is none, the sender address, is on the\n    list of recipients for a warning message. */\n\n    if (sender_address[0])\n      {\n      uschar * s = addr->prop.errors_address;\n      if (!s) s = sender_address;\n      if (Ustrstr(recipients, s) == NULL)\n\trecipients = string_sprintf(\"%s%s%s\", recipients,\n\t  recipients[0] ? \",\" : \"\", s);\n      }\n    }\n\n  /* Send a warning message if the conditions are right. If the condition check\n  fails because of a lookup defer, there is nothing we can do. The warning\n  is not sent. Another attempt will be made at the next delivery attempt (if\n  it also defers). */\n\n  if (  !queue_2stage\n     && delivery_attempted\n     && (  ((addr_defer->dsn_flags & rf_dsnflags) == 0)\n        || (addr_defer->dsn_flags & rf_notify_delay) == rf_notify_delay\n\t)\n     && delay_warning[1] > 0\n     && sender_address[0] != 0\n     && (  !delay_warning_condition\n        || expand_check_condition(delay_warning_condition,\n            US\"delay_warning\", US\"option\")\n\t)\n     )\n    {\n    int count;\n    int show_time;\n    int queue_time = time(NULL) - received_time.tv_sec;\n\n    /* When running in the test harness, there's an option that allows us to\n    fudge this time so as to get repeatability of the tests. Take the first\n    time off the list. In queue runs, the list pointer gets updated in the\n    calling process. */\n\n    if (running_in_test_harness && fudged_queue_times[0] != 0)\n      {\n      int qt = readconf_readtime(fudged_queue_times, '/', FALSE);\n      if (qt >= 0)\n        {\n        DEBUG(D_deliver) debug_printf(\"fudged queue_times = %s\\n\",\n          fudged_queue_times);\n        queue_time = qt;\n        }\n      }\n\n    /* See how many warnings we should have sent by now */\n\n    for (count = 0; count < delay_warning[1]; count++)\n      if (queue_time < delay_warning[count+2]) break;\n\n    show_time = delay_warning[count+1];\n\n    if (count >= delay_warning[1])\n      {\n      int extra;\n      int last_gap = show_time;\n      if (count > 1) last_gap -= delay_warning[count];\n      extra = (queue_time - delay_warning[count+1])/last_gap;\n      show_time += last_gap * extra;\n      count += extra;\n      }\n\n    DEBUG(D_deliver)\n      {\n      debug_printf(\"time on queue = %s\\n\", readconf_printtime(queue_time));\n      debug_printf(\"warning counts: required %d done %d\\n\", count,\n        warning_count);\n      }\n\n    /* We have computed the number of warnings there should have been by now.\n    If there haven't been enough, send one, and up the count to what it should\n    have been. */\n\n    if (warning_count < count)\n      {\n      header_line *h;\n      int fd;\n      pid_t pid = child_open_exim(&fd);\n\n      if (pid > 0)\n        {\n        uschar *wmf_text;\n        FILE *wmf = NULL;\n        FILE *f = fdopen(fd, \"wb\");\n\tuschar * bound;\n\ttransport_ctx tctx = {{0}};\n\n        if (warn_message_file)\n          if (!(wmf = Ufopen(warn_message_file, \"rb\")))\n            log_write(0, LOG_MAIN|LOG_PANIC, \"Failed to open %s for warning \"\n              \"message texts: %s\", warn_message_file, strerror(errno));\n\n        warnmsg_recipients = recipients;\n        warnmsg_delay = queue_time < 120*60\n\t  ? string_sprintf(\"%d minutes\", show_time/60)\n\t  : string_sprintf(\"%d hours\", show_time/3600);\n\n        if (errors_reply_to)\n          fprintf(f, \"Reply-To: %s\\n\", errors_reply_to);\n        fprintf(f, \"Auto-Submitted: auto-replied\\n\");\n        moan_write_from(f);\n        fprintf(f, \"To: %s\\n\", recipients);\n\n        /* generated boundary string and output MIME-Headers */\n        bound = string_sprintf(TIME_T_FMT \"-eximdsn-%d\", time(NULL), rand());\n\n        fprintf(f, \"Content-Type: multipart/report;\"\n\t    \" report-type=delivery-status; boundary=%s\\n\"\n\t    \"MIME-Version: 1.0\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"header\")))\n          fprintf(f, \"%s\\n\", wmf_text);\n        else\n          fprintf(f, \"Subject: Warning: message %s delayed %s\\n\\n\",\n            message_id, warnmsg_delay);\n\n        /* output human readable part as text/plain section */\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/plain; charset=us-ascii\\n\\n\",\n\t  bound);\n\n        if ((wmf_text = next_emf(wmf, US\"intro\")))\n\t  fprintf(f, \"%s\", CS wmf_text);\n\telse\n          {\n          fprintf(f,\n\"This message was created automatically by mail delivery software.\\n\");\n\n          if (Ustrcmp(recipients, sender_address) == 0)\n            fprintf(f,\n\"A message that you sent has not yet been delivered to one or more of its\\n\"\n\"recipients after more than \");\n\n          else\n\t    fprintf(f,\n\"A message sent by\\n\\n  <%s>\\n\\n\"\n\"has not yet been delivered to one or more of its recipients after more than \\n\",\n\t      sender_address);\n\n          fprintf(f, \"%s on the queue on %s.\\n\\n\"\n\t      \"The message identifier is:     %s\\n\",\n\t    warnmsg_delay, primary_hostname, message_id);\n\n          for (h = header_list; h; h = h->next)\n            if (strncmpic(h->text, US\"Subject:\", 8) == 0)\n              fprintf(f, \"The subject of the message is: %s\", h->text + 9);\n            else if (strncmpic(h->text, US\"Date:\", 5) == 0)\n              fprintf(f, \"The date of the message is:    %s\", h->text + 6);\n          fputc('\\n', f);\n\n          fprintf(f, \"The address%s to which the message has not yet been \"\n            \"delivered %s:\\n\",\n            !addr_defer->next ? \"\" : \"es\",\n            !addr_defer->next ? \"is\": \"are\");\n          }\n\n        /* List the addresses, with error information if allowed */\n\n        /* store addr_defer for machine readable part */\n        address_item *addr_dsndefer = addr_defer;\n        fputc('\\n', f);\n        while (addr_defer)\n          {\n          address_item *addr = addr_defer;\n          addr_defer = addr->next;\n          if (print_address_information(addr, f, US\"  \", US\"\\n    \", US\"\"))\n            print_address_error(addr, f, US\"Delay reason: \");\n          fputc('\\n', f);\n          }\n        fputc('\\n', f);\n\n        /* Final text */\n\n        if (wmf)\n          {\n          if ((wmf_text = next_emf(wmf, US\"final\")))\n\t    fprintf(f, \"%s\", CS wmf_text);\n          (void)fclose(wmf);\n          }\n        else\n          {\n          fprintf(f,\n\"No action is required on your part. Delivery attempts will continue for\\n\"\n\"some time, and this warning may be repeated at intervals if the message\\n\"\n\"remains undelivered. Eventually the mail delivery software will give up,\\n\"\n\"and when that happens, the message will be returned to you.\\n\");\n          }\n\n        /* output machine readable part */\n        fprintf(f, \"\\n--%s\\n\"\n\t    \"Content-type: message/delivery-status\\n\\n\"\n\t    \"Reporting-MTA: dns; %s\\n\",\n\t  bound,\n\t  smtp_active_hostname);\n\n\n        if (dsn_envid)\n\t  {\n          /* must be decoded from xtext: see RFC 3461:6.3a */\n          uschar *xdec_envid;\n          if (auth_xtextdecode(dsn_envid, &xdec_envid) > 0)\n            fprintf(f,\"Original-Envelope-ID: %s\\n\", dsn_envid);\n          else\n            fprintf(f,\"X-Original-Envelope-ID: error decoding xtext formatted ENVID\\n\");\n          }\n        fputc('\\n', f);\n\n        for ( ; addr_dsndefer; addr_dsndefer = addr_dsndefer->next)\n          {\n          if (addr_dsndefer->dsn_orcpt)\n            fprintf(f, \"Original-Recipient: %s\\n\", addr_dsndefer->dsn_orcpt);\n\n          fprintf(f, \"Action: delayed\\n\"\n\t      \"Final-Recipient: rfc822;%s\\n\"\n\t      \"Status: 4.0.0\\n\",\n\t    addr_dsndefer->address);\n          if (addr_dsndefer->host_used && addr_dsndefer->host_used->name)\n            {\n            fprintf(f, \"Remote-MTA: dns; %s\\n\",\n\t\t    addr_dsndefer->host_used->name);\n            print_dsn_diagnostic_code(addr_dsndefer, f);\n            }\n\t  fputc('\\n', f);\n          }\n\n        fprintf(f, \"--%s\\n\"\n\t    \"Content-type: text/rfc822-headers\\n\\n\",\n\t  bound);\n\n        fflush(f);\n        /* header only as required by RFC. only failure DSN needs to honor RET=FULL */\n\ttctx.u.fd = fileno(f);\n        tctx.options = topt_add_return_path | topt_no_body;\n        transport_filter_argv = NULL;   /* Just in case */\n        return_path = sender_address;   /* In case not previously set */\n\n        /* Write the original email out */\n        transport_write_message(&tctx, 0);\n        fflush(f);\n\n        fprintf(f,\"\\n--%s--\\n\", bound);\n\n        fflush(f);\n\n        /* Close and wait for child process to complete, without a timeout.\n        If there's an error, don't update the count. */\n\n        (void)fclose(f);\n        if (child_close(pid, 0) == 0)\n          {\n          warning_count = count;\n          update_spool = TRUE;    /* Ensure spool rewritten */\n          }\n        }\n      }\n    }\n\n  /* Clear deliver_domain */\n\n  deliver_domain = NULL;\n\n  /* If this was a first delivery attempt, unset the first time flag, and\n  ensure that the spool gets updated. */\n\n  if (deliver_firsttime)\n    {\n    deliver_firsttime = FALSE;\n    update_spool = TRUE;\n    }\n\n  /* If delivery was frozen and freeze_tell is set, generate an appropriate\n  message, unless the message is a local error message (to avoid loops). Then\n  log the freezing. If the text in \"frozen_info\" came from a system filter,\n  it has been escaped into printing characters so as not to mess up log lines.\n  For the \"tell\" message, we turn \\n back into newline. Also, insert a newline\n  near the start instead of the \": \" string. */\n\n  if (deliver_freeze)\n    {\n    if (freeze_tell && freeze_tell[0] != 0 && !local_error_message)\n      {\n      uschar *s = string_copy(frozen_info);\n      uschar *ss = Ustrstr(s, \" by the system filter: \");\n\n      if (ss != NULL)\n        {\n        ss[21] = '.';\n        ss[22] = '\\n';\n        }\n\n      ss = s;\n      while (*ss != 0)\n        {\n        if (*ss == '\\\\' && ss[1] == 'n')\n          {\n          *ss++ = ' ';\n          *ss++ = '\\n';\n          }\n        else ss++;\n        }\n      moan_tell_someone(freeze_tell, addr_defer, US\"Message frozen\",\n        \"Message %s has been frozen%s.\\nThe sender is <%s>.\\n\", message_id,\n        s, sender_address);\n      }\n\n    /* Log freezing just before we update the -H file, to minimize the chance\n    of a race problem. */\n\n    deliver_msglog(\"*** Frozen%s\\n\", frozen_info);\n    log_write(0, LOG_MAIN, \"Frozen%s\", frozen_info);\n    }\n\n  /* If there have been any updates to the non-recipients list, or other things\n  that get written to the spool, we must now update the spool header file so\n  that it has the right information for the next delivery attempt. If there\n  was more than one address being delivered, the header_change update is done\n  earlier, in case one succeeds and then something crashes. */\n\n  DEBUG(D_deliver)\n    debug_printf(\"delivery deferred: update_spool=%d header_rewritten=%d\\n\",\n      update_spool, header_rewritten);\n\n  if (update_spool || header_rewritten)\n    /* Panic-dies on error */\n    (void)spool_write_header(message_id, SW_DELIVERING, NULL);\n  }\n\n/* Finished with the message log. If the message is complete, it will have\nbeen unlinked or renamed above. */\n\nif (message_logs) (void)fclose(message_log);\n\n/* Now we can close and remove the journal file. Its only purpose is to record\nsuccessfully completed deliveries asap so that this information doesn't get\nlost if Exim (or the machine) crashes. Forgetting about a failed delivery is\nnot serious, as trying it again is not harmful. The journal might not be open\nif all addresses were deferred at routing or directing. Nevertheless, we must\nremove it if it exists (may have been lying around from a crash during the\nprevious delivery attempt). We don't remove the journal if a delivery\nsubprocess failed to pass back delivery information; this is controlled by\nthe remove_journal flag. When the journal is left, we also don't move the\nmessage off the main spool if frozen and the option is set. It should get moved\nat the next attempt, after the journal has been inspected. */\n\nif (journal_fd >= 0) (void)close(journal_fd);\n\nif (remove_journal)\n  {\n  uschar * fname = spool_fname(US\"input\", message_subdir, id, US\"-J\");\n\n  if (Uunlink(fname) < 0 && errno != ENOENT)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to unlink %s: %s\", fname,\n      strerror(errno));\n\n  /* Move the message off the spool if requested */\n\n#ifdef SUPPORT_MOVE_FROZEN_MESSAGES\n  if (deliver_freeze && move_frozen_messages)\n    (void)spool_move_message(id, message_subdir, US\"\", US\"F\");\n#endif\n  }\n\n/* Closing the data file frees the lock; if the file has been unlinked it\nwill go away. Otherwise the message becomes available for another process\nto try delivery. */\n\n(void)close(deliver_datafile);\ndeliver_datafile = -1;\nDEBUG(D_deliver) debug_printf(\"end delivery of %s\\n\", id);\n\n/* It is unlikely that there will be any cached resources, since they are\nreleased after routing, and in the delivery subprocesses. However, it's\npossible for an expansion for something afterwards (for example,\nexpand_check_condition) to do a lookup. We must therefore be sure everything is\nreleased. */\n\nsearch_tidyup();\nacl_where = ACL_WHERE_UNKNOWN;\nreturn final_yield;\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "exim",
        "commit_id": "d740d2111f189760593a303124ff6b9b1f83453d",
        "hash": 158919576750160959828921606973044154305,
        "size": 2923,
        "message": "Fix CVE-2019-10149"
    },
    {
        "func": "queue_action(uschar *id, int action, uschar **argv, int argc, int recipients_arg)\n{\nint i, j;\nBOOL yield = TRUE;\nBOOL removed = FALSE;\nstruct passwd *pw;\nuschar *doing = NULL;\nuschar *username;\nuschar *errmsg;\nuschar spoolname[32];\n\n/* Set the global message_id variable, used when re-writing spool files. This\nalso causes message ids to be added to log messages. */\n\nUstrcpy(message_id, id);\n\n/* The \"actions\" that just list the files do not require any locking to be\ndone. Only admin users may read the spool files. */\n\nif (action >= MSG_SHOW_BODY)\n  {\n  int fd, i, rc;\n  uschar *subdirectory, *suffix;\n\n  if (!f.admin_user)\n    {\n    printf(\"Permission denied\\n\");\n    return FALSE;\n    }\n\n  if (recipients_arg < argc)\n    {\n    printf(\"*** Only one message can be listed at once\\n\");\n    return FALSE;\n    }\n\n  if (action == MSG_SHOW_BODY)\n    {\n    subdirectory = US\"input\";\n    suffix = US\"-D\";\n    }\n  else if (action == MSG_SHOW_HEADER)\n    {\n    subdirectory = US\"input\";\n    suffix = US\"-H\";\n    }\n  else\n    {\n    subdirectory = US\"msglog\";\n    suffix = US\"\";\n    }\n\n  for (i = 0; i < 2; i++)\n    {\n    message_subdir[0] = split_spool_directory == (i == 0) ? id[5] : 0;\n    if ((fd = Uopen(spool_fname(subdirectory, message_subdir, id, suffix),\n\t\t    O_RDONLY, 0)) >= 0)\n      break;\n    if (i == 0)\n      continue;\n\n    printf(\"Failed to open %s file for %s%s: %s\\n\", subdirectory, id, suffix,\n      strerror(errno));\n    if (action == MSG_SHOW_LOG && !message_logs)\n      printf(\"(No message logs are being created because the message_logs \"\n        \"option is false.)\\n\");\n    return FALSE;\n    }\n\n  while((rc = read(fd, big_buffer, big_buffer_size)) > 0)\n    rc = write(fileno(stdout), big_buffer, rc);\n\n  (void)close(fd);\n  return TRUE;\n  }\n\n/* For actions that actually act, open and lock the data file to ensure that no\nother process is working on this message. If the file does not exist, continue\nonly if the action is remove and the user is an admin user, to allow for\ntidying up broken states. */\n\nif ((deliver_datafile = spool_open_datafile(id)) < 0)\n  if (errno == ENOENT)\n    {\n    yield = FALSE;\n    printf(\"Spool data file for %s does not exist\\n\", id);\n    if (action != MSG_REMOVE || !f.admin_user) return FALSE;\n    printf(\"Continuing, to ensure all files removed\\n\");\n    }\n  else\n    {\n    if (errno == 0) printf(\"Message %s is locked\\n\", id);\n      else printf(\"Couldn't open spool file for %s: %s\\n\", id,\n        strerror(errno));\n    return FALSE;\n    }\n\n/* Read the spool header file for the message. Again, continue after an\nerror only in the case of deleting by an administrator. Setting the third\nargument false causes it to look both in the main spool directory and in\nthe appropriate subdirectory, and set message_subdir according to where it\nfound the message. */\n\nsprintf(CS spoolname, \"%s-H\", id);\nif (spool_read_header(spoolname, TRUE, FALSE) != spool_read_OK)\n  {\n  yield = FALSE;\n  if (errno != ERRNO_SPOOLFORMAT)\n    printf(\"Spool read error for %s: %s\\n\", spoolname, strerror(errno));\n  else\n    printf(\"Spool format error for %s\\n\", spoolname);\n  if (action != MSG_REMOVE || !f.admin_user)\n    {\n    (void)close(deliver_datafile);\n    deliver_datafile = -1;\n    return FALSE;\n    }\n  printf(\"Continuing to ensure all files removed\\n\");\n  }\n\n/* Check that the user running this process is entitled to operate on this\nmessage. Only admin users may freeze/thaw, add/cancel recipients, or otherwise\nmess about, but the original sender is permitted to remove a message. That's\nwhy we leave this check until after the headers are read. */\n\nif (!f.admin_user && (action != MSG_REMOVE || real_uid != originator_uid))\n  {\n  printf(\"Permission denied\\n\");\n  (void)close(deliver_datafile);\n  deliver_datafile = -1;\n  return FALSE;\n  }\n\n/* Set up the user name for logging. */\n\npw = getpwuid(real_uid);\nusername = (pw != NULL)?\n  US pw->pw_name : string_sprintf(\"uid %ld\", (long int)real_uid);\n\n/* Take the necessary action. */\n\nif (action != MSG_SHOW_COPY) printf(\"Message %s \", id);\n\nswitch(action)\n  {\n  case MSG_SHOW_COPY:\n    {\n    transport_ctx tctx = {{0}};\n    deliver_in_buffer = store_malloc(DELIVER_IN_BUFFER_SIZE);\n    deliver_out_buffer = store_malloc(DELIVER_OUT_BUFFER_SIZE);\n    tctx.u.fd = 1;\n    transport_write_message(&tctx, 0);\n    break;\n    }\n\n\n  case MSG_FREEZE:\n  if (f.deliver_freeze)\n    {\n    yield = FALSE;\n    printf(\"is already frozen\\n\");\n    }\n  else\n    {\n    f.deliver_freeze = TRUE;\n    f.deliver_manual_thaw = FALSE;\n    deliver_frozen_at = time(NULL);\n    if (spool_write_header(id, SW_MODIFYING, &errmsg) >= 0)\n      {\n      printf(\"is now frozen\\n\");\n      log_write(0, LOG_MAIN, \"frozen by %s\", username);\n      }\n    else\n      {\n      yield = FALSE;\n      printf(\"could not be frozen: %s\\n\", errmsg);\n      }\n    }\n  break;\n\n\n  case MSG_THAW:\n  if (!f.deliver_freeze)\n    {\n    yield = FALSE;\n    printf(\"is not frozen\\n\");\n    }\n  else\n    {\n    f.deliver_freeze = FALSE;\n    f.deliver_manual_thaw = TRUE;\n    if (spool_write_header(id, SW_MODIFYING, &errmsg) >= 0)\n      {\n      printf(\"is no longer frozen\\n\");\n      log_write(0, LOG_MAIN, \"unfrozen by %s\", username);\n      }\n    else\n      {\n      yield = FALSE;\n      printf(\"could not be unfrozen: %s\\n\", errmsg);\n      }\n    }\n  break;\n\n\n  /* We must ensure all files are removed from both the input directory\n  and the appropriate subdirectory, to clean up cases when there are odd\n  files left lying around in odd places. In the normal case message_subdir\n  will have been set correctly by spool_read_header, but as this is a rare\n  operation, just run everything twice. */\n\n  case MSG_REMOVE:\n    {\n    uschar suffix[3];\n\n    suffix[0] = '-';\n    suffix[2] = 0;\n    message_subdir[0] = id[5];\n\n    for (j = 0; j < 2; message_subdir[0] = 0, j++)\n      {\n      uschar * fname = spool_fname(US\"msglog\", message_subdir, id, US\"\");\n\n      DEBUG(D_any) debug_printf(\" removing %s\", fname);\n      if (Uunlink(fname) < 0)\n\t{\n\tif (errno != ENOENT)\n\t  {\n\t  yield = FALSE;\n\t  printf(\"Error while removing %s: %s\\n\", fname, strerror(errno));\n\t  }\n\telse DEBUG(D_any) debug_printf(\" (no file)\\n\");\n\t}\n      else\n\t{\n\tremoved = TRUE;\n\tDEBUG(D_any) debug_printf(\" (ok)\\n\");\n\t}\n\n      for (i = 0; i < 3; i++)\n\t{\n\tuschar * fname;\n\n\tsuffix[1] = (US\"DHJ\")[i];\n\tfname = spool_fname(US\"input\", message_subdir, id, suffix);\n\n\tDEBUG(D_any) debug_printf(\" removing %s\", fname);\n\tif (Uunlink(fname) < 0)\n\t  {\n\t  if (errno != ENOENT)\n\t    {\n\t    yield = FALSE;\n\t    printf(\"Error while removing %s: %s\\n\", fname, strerror(errno));\n\t    }\n\t  else DEBUG(D_any) debug_printf(\" (no file)\\n\");\n\t  }\n\telse\n\t  {\n\t  removed = TRUE;\n\t  DEBUG(D_any) debug_printf(\" (done)\\n\");\n\t  }\n\t}\n      }\n\n    /* In the common case, the datafile is open (and locked), so give the\n    obvious message. Otherwise be more specific. */\n\n    if (deliver_datafile >= 0) printf(\"has been removed\\n\");\n      else printf(\"has been removed or did not exist\\n\");\n    if (removed)\n      {\n      log_write(0, LOG_MAIN, \"removed by %s\", username);\n      log_write(0, LOG_MAIN, \"Completed\");\n      }\n    break;\n    }\n\n\n  case MSG_MARK_ALL_DELIVERED:\n  for (i = 0; i < recipients_count; i++)\n    {\n    tree_add_nonrecipient(recipients_list[i].address);\n    }\n  if (spool_write_header(id, SW_MODIFYING, &errmsg) >= 0)\n    {\n    printf(\"has been modified\\n\");\n    for (i = 0; i < recipients_count; i++)\n      log_write(0, LOG_MAIN, \"address <%s> marked delivered by %s\",\n        recipients_list[i].address, username);\n    }\n  else\n    {\n    yield = FALSE;\n    printf(\"- could not mark all delivered: %s\\n\", errmsg);\n    }\n  break;\n\n\n  case MSG_EDIT_SENDER:\n  if (recipients_arg < argc - 1)\n    {\n    yield = FALSE;\n    printf(\"- only one sender address can be specified\\n\");\n    break;\n    }\n  doing = US\"editing sender\";\n  /* Fall through */\n\n  case MSG_ADD_RECIPIENT:\n  if (doing == NULL) doing = US\"adding recipient\";\n  /* Fall through */\n\n  case MSG_MARK_DELIVERED:\n  if (doing == NULL) doing = US\"marking as delivered\";\n\n  /* Common code for EDIT_SENDER, ADD_RECIPIENT, & MARK_DELIVERED */\n\n  if (recipients_arg >= argc)\n    {\n    yield = FALSE;\n    printf(\"- error while %s: no address given\\n\", doing);\n    break;\n    }\n\n  for (; recipients_arg < argc; recipients_arg++)\n    {\n    int start, end, domain;\n    uschar *errmess;\n    uschar *recipient =\n      parse_extract_address(argv[recipients_arg], &errmess, &start, &end,\n        &domain, (action == MSG_EDIT_SENDER));\n\n    if (recipient == NULL)\n      {\n      yield = FALSE;\n      printf(\"- error while %s:\\n  bad address %s: %s\\n\",\n        doing, argv[recipients_arg], errmess);\n      }\n    else if (recipient[0] != 0 && domain == 0)\n      {\n      yield = FALSE;\n      printf(\"- error while %s:\\n  bad address %s: \"\n        \"domain missing\\n\", doing, argv[recipients_arg]);\n      }\n    else\n      {\n      if (action == MSG_ADD_RECIPIENT)\n        {\n#ifdef SUPPORT_I18N\n\tif (string_is_utf8(recipient)) allow_utf8_domains = message_smtputf8 = TRUE;\n#endif\n        receive_add_recipient(recipient, -1);\n        log_write(0, LOG_MAIN, \"recipient <%s> added by %s\",\n          recipient, username);\n        }\n      else if (action == MSG_MARK_DELIVERED)\n        {\n        for (i = 0; i < recipients_count; i++)\n          if (Ustrcmp(recipients_list[i].address, recipient) == 0) break;\n        if (i >= recipients_count)\n          {\n          printf(\"- error while %s:\\n  %s is not a recipient:\"\n            \" message not updated\\n\", doing, recipient);\n          yield = FALSE;\n          }\n        else\n          {\n          tree_add_nonrecipient(recipients_list[i].address);\n          log_write(0, LOG_MAIN, \"address <%s> marked delivered by %s\",\n            recipient, username);\n          }\n        }\n      else  /* MSG_EDIT_SENDER */\n        {\n#ifdef SUPPORT_I18N\n\tif (string_is_utf8(recipient)) allow_utf8_domains = message_smtputf8 = TRUE;\n#endif\n        sender_address = recipient;\n        log_write(0, LOG_MAIN, \"sender address changed to <%s> by %s\",\n          recipient, username);\n        }\n      }\n    }\n\n  if (yield)\n    if (spool_write_header(id, SW_MODIFYING, &errmsg) >= 0)\n      printf(\"has been modified\\n\");\n    else\n      {\n      yield = FALSE;\n      printf(\"- while %s: %s\\n\", doing, errmsg);\n      }\n\n  break;\n  }\n\n/* Closing the datafile releases the lock and permits other processes\nto operate on the message (if it still exists). */\n\nif (deliver_datafile >= 0)\n  {\n  (void)close(deliver_datafile);\n  deliver_datafile = -1;\n  }\nreturn yield;\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "exim",
        "commit_id": "7ea1237c783e380d7bdb86c90b13d8203c7ecf26",
        "hash": 75776037026740351359982731244501766732,
        "size": 406,
        "message": "Events: raise msg:fail:internal & msg:complete for -Mrm.  Bug 2310"
    },
    {
        "func": "event_raise(uschar * action, const uschar * event, uschar * ev_data)\n{\nuschar * s;\nif (action)\n  {\n  DEBUG(D_deliver)\n    debug_printf(\"Event(%s): event_action=|%s| delivery_IP=%s\\n\",\n      event,\n      action, deliver_host_address);\n\n  event_name = event;\n  event_data = ev_data;\n\n  if (!(s = expand_string(action)) && *expand_string_message)\n    log_write(0, LOG_MAIN|LOG_PANIC,\n      \"failed to expand event_action %s in %s: %s\\n\",\n      event, transport_name, expand_string_message);\n\n  event_name = event_data = NULL;\n\n  /* If the expansion returns anything but an empty string, flag for\n  the caller to modify his normal processing\n  */\n  if (s && *s)\n    {\n    DEBUG(D_deliver)\n      debug_printf(\"Event(%s): event_action returned \\\"%s\\\"\\n\", event, s);\n    return s;\n    }\n  }\nreturn NULL;\n}",
        "target": 1,
        "cwe": [
            "CWE-78"
        ],
        "project": "exim",
        "commit_id": "7ea1237c783e380d7bdb86c90b13d8203c7ecf26",
        "hash": 49990118491377915737455850034053900449,
        "size": 32,
        "message": "Events: raise msg:fail:internal & msg:complete for -Mrm.  Bug 2310"
    },
    {
        "func": "void AbstractSqlStorage::addConnectionToPool()\n{\n    QMutexLocker locker(&_connectionPoolMutex);\n    // we have to recheck if the connection pool already contains a connection for\n    // this thread. Since now (after the lock) we can only tell for sure\n    if (_connectionPool.contains(QThread::currentThread()))\n        return;\n\n    QThread *currentThread = QThread::currentThread();\n\n    int connectionId = _nextConnectionId++;\n\n    Connection *connection = new Connection(QLatin1String(QString(\"quassel_%1_con_%2\").arg(driverName()).arg(connectionId).toLatin1()));\n    connection->moveToThread(currentThread);\n    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));\n    connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));\n    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));\n    _connectionPool[currentThread] = connection;\n\n    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());\n    db.setDatabaseName(databaseName());\n\n    if (!hostName().isEmpty())\n        db.setHostName(hostName());\n\n    if (port() != -1)\n        db.setPort(port());\n\n    if (!userName().isEmpty()) {\n        db.setUserName(userName());\n        db.setPassword(password());\n    }\n\n    if (!db.open()) {\n        qWarning() << \"Unable to open database\" << displayName() << \"for thread\" << QThread::currentThread();\n        qWarning() << \"-\" << db.lastError().text();\n    }\n    else {\n        initDbSession(db);\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "quassel",
        "commit_id": "aa1008be162cb27da938cce93ba533f54d228869",
        "hash": 63105552886145246543688692459748995655,
        "size": 41,
        "message": "Fixing security vulnerability with Qt 4.8.5+ and PostgreSQL.\n\nProperly detects whether Qt performs slash escaping in SQL queries or\nnot, and then configures PostgreSQL accordingly. This bug was a\nintroduced due to a bugfix in Qt 4.8.5 disables slash escaping when\nbinding queries: https://bugreports.qt-project.org/browse/QTBUG-30076\nThanks to brot and Tucos.\n\n[Fixes #1244]"
    },
    {
        "func": "void PostgreSqlStorage::initDbSession(QSqlDatabase &db)\n{\n    // this blows... but unfortunately Qt's PG driver forces us to this...\n    db.exec(\"set standard_conforming_strings = off\");\n    db.exec(\"set escape_string_warning = off\");\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "quassel",
        "commit_id": "aa1008be162cb27da938cce93ba533f54d228869",
        "hash": 229525181130309658890094454539581241349,
        "size": 6,
        "message": "Fixing security vulnerability with Qt 4.8.5+ and PostgreSQL.\n\nProperly detects whether Qt performs slash escaping in SQL queries or\nnot, and then configures PostgreSQL accordingly. This bug was a\nintroduced due to a bugfix in Qt 4.8.5 disables slash escaping when\nbinding queries: https://bugreports.qt-project.org/browse/QTBUG-30076\nThanks to brot and Tucos.\n\n[Fixes #1244]"
    },
    {
        "func": "    inline virtual void initDbSession(QSqlDatabase & /* db */) {}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "quassel",
        "commit_id": "aa1008be162cb27da938cce93ba533f54d228869",
        "hash": 335581753661299748300086513372334450061,
        "size": 1,
        "message": "Fixing security vulnerability with Qt 4.8.5+ and PostgreSQL.\n\nProperly detects whether Qt performs slash escaping in SQL queries or\nnot, and then configures PostgreSQL accordingly. This bug was a\nintroduced due to a bugfix in Qt 4.8.5 disables slash escaping when\nbinding queries: https://bugreports.qt-project.org/browse/QTBUG-30076\nThanks to brot and Tucos.\n\n[Fixes #1244]"
    },
    {
        "func": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n\n  if (!lp || !timestring || !timefield)\n    return MS_FALSE;\n\n  /* discrete time */\n  if (strstr(timestring, \",\") == NULL &&\n      strstr(timestring, \"/\") == NULL) { /* discrete time */\n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n\n    /* multiple times, or ranges */\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        /* we don't have range, just a simple time */\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        /* we have a range */\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    /* if the filter is set and it's a string type, concatenate it with\n       the time. If not just free it */\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n\n\n  return MS_TRUE;\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "mapserver",
        "commit_id": "3a10f6b829297dae63492a8c63385044bc6953ed",
        "hash": 229867873991132419286661540040247508528,
        "size": 69,
        "message": "Fix potential SQL Injection with postgis TIME filters (#4834)"
    },
    {
        "func": "RecoveryConflictInterrupt(ProcSignalReason reason)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * Don't joggle the elbow of proc_exit\n\t */\n\tif (!proc_exit_inprogress)\n\t{\n\t\tRecoveryConflictReason = reason;\n\t\tswitch (reason)\n\t\t{\n\t\t\tcase PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK:\n\n\t\t\t\t/*\n\t\t\t\t * If we aren't waiting for a lock we can never deadlock.\n\t\t\t\t */\n\t\t\t\tif (!IsWaitingForLock())\n\t\t\t\t\treturn;\n\n\t\t\t\t/* Intentional drop through to check wait for pin */\n\n\t\t\tcase PROCSIG_RECOVERY_CONFLICT_BUFFERPIN:\n\n\t\t\t\t/*\n\t\t\t\t * If we aren't blocking the Startup process there is nothing\n\t\t\t\t * more to do.\n\t\t\t\t */\n\t\t\t\tif (!HoldingBufferPinThatDelaysRecovery())\n\t\t\t\t\treturn;\n\n\t\t\t\tMyProc->recoveryConflictPending = true;\n\n\t\t\t\t/* Intentional drop through to error handling */\n\n\t\t\tcase PROCSIG_RECOVERY_CONFLICT_LOCK:\n\t\t\tcase PROCSIG_RECOVERY_CONFLICT_TABLESPACE:\n\t\t\tcase PROCSIG_RECOVERY_CONFLICT_SNAPSHOT:\n\n\t\t\t\t/*\n\t\t\t\t * If we aren't in a transaction any longer then ignore.\n\t\t\t\t */\n\t\t\t\tif (!IsTransactionOrTransactionBlock())\n\t\t\t\t\treturn;\n\n\t\t\t\t/*\n\t\t\t\t * If we can abort just the current subtransaction then we are\n\t\t\t\t * OK to throw an ERROR to resolve the conflict. Otherwise\n\t\t\t\t * drop through to the FATAL case.\n\t\t\t\t *\n\t\t\t\t * XXX other times that we can throw just an ERROR *may* be\n\t\t\t\t * PROCSIG_RECOVERY_CONFLICT_LOCK if no locks are held in\n\t\t\t\t * parent transactions\n\t\t\t\t *\n\t\t\t\t * PROCSIG_RECOVERY_CONFLICT_SNAPSHOT if no snapshots are held\n\t\t\t\t * by parent transactions and the transaction is not\n\t\t\t\t * transaction-snapshot mode\n\t\t\t\t *\n\t\t\t\t * PROCSIG_RECOVERY_CONFLICT_TABLESPACE if no temp files or\n\t\t\t\t * cursors open in parent transactions\n\t\t\t\t */\n\t\t\t\tif (!IsSubTransaction())\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If we already aborted then we no longer need to cancel.\n\t\t\t\t\t * We do this here since we do not wish to ignore aborted\n\t\t\t\t\t * subtransactions, which must cause FATAL, currently.\n\t\t\t\t\t */\n\t\t\t\t\tif (IsAbortedTransactionBlockState())\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tRecoveryConflictPending = true;\n\t\t\t\t\tQueryCancelPending = true;\n\t\t\t\t\tInterruptPending = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Intentional drop through to session cancel */\n\n\t\t\tcase PROCSIG_RECOVERY_CONFLICT_DATABASE:\n\t\t\t\tRecoveryConflictPending = true;\n\t\t\t\tProcDiePending = true;\n\t\t\t\tInterruptPending = true;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\telog(FATAL, \"unrecognized conflict mode: %d\",\n\t\t\t\t\t (int) reason);\n\t\t}\n\n\t\tAssert(RecoveryConflictPending && (QueryCancelPending || ProcDiePending));\n\n\t\t/*\n\t\t * All conflicts apart from database cause dynamic errors where the\n\t\t * command or transaction can be retried at a later point with some\n\t\t * potential for success. No need to reset this, since non-retryable\n\t\t * conflict errors are currently FATAL.\n\t\t */\n\t\tif (reason == PROCSIG_RECOVERY_CONFLICT_DATABASE)\n\t\t\tRecoveryConflictRetryable = false;\n\n\t\t/*\n\t\t * If it's safe to interrupt, and we're waiting for input or a lock,\n\t\t * service the interrupt immediately\n\t\t */\n\t\tif (ImmediateInterruptOK && InterruptHoldoffCount == 0 &&\n\t\t\tCritSectionCount == 0)\n\t\t{\n\t\t\t/* bump holdoff count to make ProcessInterrupts() a no-op */\n\t\t\t/* until we are done getting ready for it */\n\t\t\tInterruptHoldoffCount++;\n\t\t\tLockErrorCleanup(); /* prevent CheckDeadLock from running */\n\t\t\tDisableNotifyInterrupt();\n\t\t\tDisableCatchupInterrupt();\n\t\t\tInterruptHoldoffCount--;\n\t\t\tProcessInterrupts();\n\t\t}\n\t}\n\n\t/*\n\t * Set the process latch. This function essentially emulates signal\n\t * handlers like die() and StatementCancelHandler() and it seems prudent\n\t * to behave similarly as they do. Alternatively all plain backend code\n\t * waiting on that latch, expecting to get interrupted by query cancels et\n\t * al., would also need to set set_latch_on_sigusr1.\n\t */\n\tSetLatch(MyLatch);\n\n\terrno = save_errno;\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 297053155428208917250602267292684184718,
        "size": 130,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "StatementCancelHandler(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * Don't joggle the elbow of proc_exit\n\t */\n\tif (!proc_exit_inprogress)\n\t{\n\t\tInterruptPending = true;\n\t\tQueryCancelPending = true;\n\n\t\t/*\n\t\t * If it's safe to interrupt, and we're waiting for input or a lock,\n\t\t * service the interrupt immediately\n\t\t */\n\t\tif (ImmediateInterruptOK && InterruptHoldoffCount == 0 &&\n\t\t\tCritSectionCount == 0)\n\t\t{\n\t\t\t/* bump holdoff count to make ProcessInterrupts() a no-op */\n\t\t\t/* until we are done getting ready for it */\n\t\t\tInterruptHoldoffCount++;\n\t\t\tLockErrorCleanup(); /* prevent CheckDeadLock from running */\n\t\t\tDisableNotifyInterrupt();\n\t\t\tDisableCatchupInterrupt();\n\t\t\tInterruptHoldoffCount--;\n\t\t\tProcessInterrupts();\n\t\t}\n\t}\n\n\t/* If we're still here, waken anything waiting on the process latch */\n\tSetLatch(MyLatch);\n\n\terrno = save_errno;\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 271833847094514721547002087924330652881,
        "size": 35,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "pq_getbytes(char *s, size_t len)\n{\n\tsize_t\t\tamount;\n\n\twhile (len > 0)\n\t{\n\t\twhile (PqRecvPointer >= PqRecvLength)\n\t\t{\n\t\t\tif (pq_recvbuf())\t/* If nothing in buffer, then recv some */\n\t\t\t\treturn EOF;\t\t/* Failed to recv data */\n\t\t}\n\t\tamount = PqRecvLength - PqRecvPointer;\n\t\tif (amount > len)\n\t\t\tamount = len;\n\t\tmemcpy(s, PqRecvBuffer + PqRecvPointer, amount);\n\t\tPqRecvPointer += amount;\n\t\ts += amount;\n\t\tlen -= amount;\n\t}\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 173231122613601221075914630498352086224,
        "size": 21,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "CopyFrom(CopyState cstate)\n{\n\tHeapTuple\ttuple;\n\tTupleDesc\ttupDesc;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tResultRelInfo *resultRelInfo;\n\tEState\t   *estate = CreateExecutorState(); /* for ExecConstraints() */\n\tExprContext *econtext;\n\tTupleTableSlot *myslot;\n\tMemoryContext oldcontext = CurrentMemoryContext;\n\n\tErrorContextCallback errcallback;\n\tCommandId\tmycid = GetCurrentCommandId(true);\n\tint\t\t\thi_options = 0; /* start with default heap_insert options */\n\tBulkInsertState bistate;\n\tuint64\t\tprocessed = 0;\n\tbool\t\tuseHeapMultiInsert;\n\tint\t\t\tnBufferedTuples = 0;\n\n#define MAX_BUFFERED_TUPLES 1000\n\tHeapTuple  *bufferedTuples = NULL;\t/* initialize to silence warning */\n\tSize\t\tbufferedTuplesSize = 0;\n\tint\t\t\tfirstBufferedLineNo = 0;\n\n\tAssert(cstate->rel);\n\n\tif (cstate->rel->rd_rel->relkind != RELKIND_RELATION)\n\t{\n\t\tif (cstate->rel->rd_rel->relkind == RELKIND_VIEW)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"cannot copy to view \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(cstate->rel))));\n\t\telse if (cstate->rel->rd_rel->relkind == RELKIND_MATVIEW)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"cannot copy to materialized view \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(cstate->rel))));\n\t\telse if (cstate->rel->rd_rel->relkind == RELKIND_FOREIGN_TABLE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"cannot copy to foreign table \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(cstate->rel))));\n\t\telse if (cstate->rel->rd_rel->relkind == RELKIND_SEQUENCE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"cannot copy to sequence \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(cstate->rel))));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"cannot copy to non-table relation \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(cstate->rel))));\n\t}\n\n\ttupDesc = RelationGetDescr(cstate->rel);\n\n\t/*----------\n\t * Check to see if we can avoid writing WAL\n\t *\n\t * If archive logging/streaming is not enabled *and* either\n\t *\t- table was created in same transaction as this COPY\n\t *\t- data is being written to relfilenode created in this transaction\n\t * then we can skip writing WAL.  It's safe because if the transaction\n\t * doesn't commit, we'll discard the table (or the new relfilenode file).\n\t * If it does commit, we'll have done the heap_sync at the bottom of this\n\t * routine first.\n\t *\n\t * As mentioned in comments in utils/rel.h, the in-same-transaction test\n\t * is not always set correctly, since in rare cases rd_newRelfilenodeSubid\n\t * can be cleared before the end of the transaction. The exact case is\n\t * when a relation sets a new relfilenode twice in same transaction, yet\n\t * the second one fails in an aborted subtransaction, e.g.\n\t *\n\t * BEGIN;\n\t * TRUNCATE t;\n\t * SAVEPOINT save;\n\t * TRUNCATE t;\n\t * ROLLBACK TO save;\n\t * COPY ...\n\t *\n\t * Also, if the target file is new-in-transaction, we assume that checking\n\t * FSM for free space is a waste of time, even if we must use WAL because\n\t * of archiving.  This could possibly be wrong, but it's unlikely.\n\t *\n\t * The comments for heap_insert and RelationGetBufferForTuple specify that\n\t * skipping WAL logging is only safe if we ensure that our tuples do not\n\t * go into pages containing tuples from any other transactions --- but this\n\t * must be the case if we have a new table or new relfilenode, so we need\n\t * no additional work to enforce that.\n\t *----------\n\t */\n\t/* createSubid is creation check, newRelfilenodeSubid is truncation check */\n\tif (cstate->rel->rd_createSubid != InvalidSubTransactionId ||\n\t\tcstate->rel->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t{\n\t\thi_options |= HEAP_INSERT_SKIP_FSM;\n\t\tif (!XLogIsNeeded())\n\t\t\thi_options |= HEAP_INSERT_SKIP_WAL;\n\t}\n\n\t/*\n\t * Optimize if new relfilenode was created in this subxact or one of its\n\t * committed children and we won't see those rows later as part of an\n\t * earlier scan or command. This ensures that if this subtransaction\n\t * aborts then the frozen rows won't be visible after xact cleanup. Note\n\t * that the stronger test of exactly which subtransaction created it is\n\t * crucial for correctness of this optimisation.\n\t */\n\tif (cstate->freeze)\n\t{\n\t\tif (!ThereAreNoPriorRegisteredSnapshots() || !ThereAreNoReadyPortals())\n\t\t\tereport(ERROR,\n\t\t\t\t\t(ERRCODE_INVALID_TRANSACTION_STATE,\n\t\t\t\t\t errmsg(\"cannot perform FREEZE because of prior transaction activity\")));\n\n\t\tif (cstate->rel->rd_createSubid != GetCurrentSubTransactionId() &&\n\t\t cstate->rel->rd_newRelfilenodeSubid != GetCurrentSubTransactionId())\n\t\t\tereport(ERROR,\n\t\t\t\t\t(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE,\n\t\t\t\t\t errmsg(\"cannot perform FREEZE because the table was not created or truncated in the current subtransaction\")));\n\n\t\thi_options |= HEAP_INSERT_FROZEN;\n\t}\n\n\t/*\n\t * We need a ResultRelInfo so we can use the regular executor's\n\t * index-entry-making machinery.  (There used to be a huge amount of code\n\t * here that basically duplicated execUtils.c ...)\n\t */\n\tresultRelInfo = makeNode(ResultRelInfo);\n\tInitResultRelInfo(resultRelInfo,\n\t\t\t\t\t  cstate->rel,\n\t\t\t\t\t  1,\t\t/* dummy rangetable index */\n\t\t\t\t\t  0);\n\n\tExecOpenIndices(resultRelInfo);\n\n\testate->es_result_relations = resultRelInfo;\n\testate->es_num_result_relations = 1;\n\testate->es_result_relation_info = resultRelInfo;\n\testate->es_range_table = cstate->range_table;\n\n\t/* Set up a tuple slot too */\n\tmyslot = ExecInitExtraTupleSlot(estate);\n\tExecSetSlotDescriptor(myslot, tupDesc);\n\t/* Triggers might need a slot as well */\n\testate->es_trig_tuple_slot = ExecInitExtraTupleSlot(estate);\n\n\t/*\n\t * It's more efficient to prepare a bunch of tuples for insertion, and\n\t * insert them in one heap_multi_insert() call, than call heap_insert()\n\t * separately for every tuple. However, we can't do that if there are\n\t * BEFORE/INSTEAD OF triggers, or we need to evaluate volatile default\n\t * expressions. Such triggers or expressions might query the table we're\n\t * inserting to, and act differently if the tuples that have already been\n\t * processed and prepared for insertion are not there.\n\t */\n\tif ((resultRelInfo->ri_TrigDesc != NULL &&\n\t\t (resultRelInfo->ri_TrigDesc->trig_insert_before_row ||\n\t\t  resultRelInfo->ri_TrigDesc->trig_insert_instead_row)) ||\n\t\tcstate->volatile_defexprs)\n\t{\n\t\tuseHeapMultiInsert = false;\n\t}\n\telse\n\t{\n\t\tuseHeapMultiInsert = true;\n\t\tbufferedTuples = palloc(MAX_BUFFERED_TUPLES * sizeof(HeapTuple));\n\t}\n\n\t/* Prepare to catch AFTER triggers. */\n\tAfterTriggerBeginQuery();\n\n\t/*\n\t * Check BEFORE STATEMENT insertion triggers. It's debatable whether we\n\t * should do this for COPY, since it's not really an \"INSERT\" statement as\n\t * such. However, executing these triggers maintains consistency with the\n\t * EACH ROW triggers that we already fire on COPY.\n\t */\n\tExecBSInsertTriggers(estate, resultRelInfo);\n\n\tvalues = (Datum *) palloc(tupDesc->natts * sizeof(Datum));\n\tnulls = (bool *) palloc(tupDesc->natts * sizeof(bool));\n\n\tbistate = GetBulkInsertState();\n\tecontext = GetPerTupleExprContext(estate);\n\n\t/* Set up callback to identify error line number */\n\terrcallback.callback = CopyFromErrorCallback;\n\terrcallback.arg = (void *) cstate;\n\terrcallback.previous = error_context_stack;\n\terror_context_stack = &errcallback;\n\n\tfor (;;)\n\t{\n\t\tTupleTableSlot *slot;\n\t\tbool\t\tskip_tuple;\n\t\tOid\t\t\tloaded_oid = InvalidOid;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (nBufferedTuples == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Reset the per-tuple exprcontext. We can only do this if the\n\t\t\t * tuple buffer is empty. (Calling the context the per-tuple\n\t\t\t * memory context is a bit of a misnomer now.)\n\t\t\t */\n\t\t\tResetPerTupleExprContext(estate);\n\t\t}\n\n\t\t/* Switch into its memory context */\n\t\tMemoryContextSwitchTo(GetPerTupleMemoryContext(estate));\n\n\t\tif (!NextCopyFrom(cstate, econtext, values, nulls, &loaded_oid))\n\t\t\tbreak;\n\n\t\t/* And now we can form the input tuple. */\n\t\ttuple = heap_form_tuple(tupDesc, values, nulls);\n\n\t\tif (loaded_oid != InvalidOid)\n\t\t\tHeapTupleSetOid(tuple, loaded_oid);\n\n\t\t/*\n\t\t * Constraints might reference the tableoid column, so initialize\n\t\t * t_tableOid before evaluating them.\n\t\t */\n\t\ttuple->t_tableOid = RelationGetRelid(resultRelInfo->ri_RelationDesc);\n\n\t\t/* Triggers and stuff need to be invoked in query context. */\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t/* Place tuple in tuple slot --- but slot shouldn't free it */\n\t\tslot = myslot;\n\t\tExecStoreTuple(tuple, slot, InvalidBuffer, false);\n\n\t\tskip_tuple = false;\n\n\t\t/* BEFORE ROW INSERT Triggers */\n\t\tif (resultRelInfo->ri_TrigDesc &&\n\t\t\tresultRelInfo->ri_TrigDesc->trig_insert_before_row)\n\t\t{\n\t\t\tslot = ExecBRInsertTriggers(estate, resultRelInfo, slot);\n\n\t\t\tif (slot == NULL)\t/* \"do nothing\" */\n\t\t\t\tskip_tuple = true;\n\t\t\telse\t/* trigger might have changed tuple */\n\t\t\t\ttuple = ExecMaterializeSlot(slot);\n\t\t}\n\n\t\tif (!skip_tuple)\n\t\t{\n\t\t\t/* Check the constraints of the tuple */\n\t\t\tif (cstate->rel->rd_att->constr)\n\t\t\t\tExecConstraints(resultRelInfo, slot, estate);\n\n\t\t\tif (useHeapMultiInsert)\n\t\t\t{\n\t\t\t\t/* Add this tuple to the tuple buffer */\n\t\t\t\tif (nBufferedTuples == 0)\n\t\t\t\t\tfirstBufferedLineNo = cstate->cur_lineno;\n\t\t\t\tbufferedTuples[nBufferedTuples++] = tuple;\n\t\t\t\tbufferedTuplesSize += tuple->t_len;\n\n\t\t\t\t/*\n\t\t\t\t * If the buffer filled up, flush it. Also flush if the total\n\t\t\t\t * size of all the tuples in the buffer becomes large, to\n\t\t\t\t * avoid using large amounts of memory for the buffers when\n\t\t\t\t * the tuples are exceptionally wide.\n\t\t\t\t */\n\t\t\t\tif (nBufferedTuples == MAX_BUFFERED_TUPLES ||\n\t\t\t\t\tbufferedTuplesSize > 65535)\n\t\t\t\t{\n\t\t\t\t\tCopyFromInsertBatch(cstate, estate, mycid, hi_options,\n\t\t\t\t\t\t\t\t\t\tresultRelInfo, myslot, bistate,\n\t\t\t\t\t\t\t\t\t\tnBufferedTuples, bufferedTuples,\n\t\t\t\t\t\t\t\t\t\tfirstBufferedLineNo);\n\t\t\t\t\tnBufferedTuples = 0;\n\t\t\t\t\tbufferedTuplesSize = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tList\t   *recheckIndexes = NIL;\n\n\t\t\t\t/* OK, store the tuple and create index entries for it */\n\t\t\t\theap_insert(cstate->rel, tuple, mycid, hi_options, bistate);\n\n\t\t\t\tif (resultRelInfo->ri_NumIndices > 0)\n\t\t\t\t\trecheckIndexes = ExecInsertIndexTuples(slot, &(tuple->t_self),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   estate);\n\n\t\t\t\t/* AFTER ROW INSERT Triggers */\n\t\t\t\tExecARInsertTriggers(estate, resultRelInfo, tuple,\n\t\t\t\t\t\t\t\t\t recheckIndexes);\n\n\t\t\t\tlist_free(recheckIndexes);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We count only tuples not suppressed by a BEFORE INSERT trigger;\n\t\t\t * this is the same definition used by execMain.c for counting\n\t\t\t * tuples inserted by an INSERT command.\n\t\t\t */\n\t\t\tprocessed++;\n\t\t}\n\t}\n\n\t/* Flush any remaining buffered tuples */\n\tif (nBufferedTuples > 0)\n\t\tCopyFromInsertBatch(cstate, estate, mycid, hi_options,\n\t\t\t\t\t\t\tresultRelInfo, myslot, bistate,\n\t\t\t\t\t\t\tnBufferedTuples, bufferedTuples,\n\t\t\t\t\t\t\tfirstBufferedLineNo);\n\n\t/* Done, clean up */\n\terror_context_stack = errcallback.previous;\n\n\tFreeBulkInsertState(bistate);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Execute AFTER STATEMENT insertion triggers */\n\tExecASInsertTriggers(estate, resultRelInfo);\n\n\t/* Handle queued AFTER triggers */\n\tAfterTriggerEndQuery(estate);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\tExecResetTupleTable(estate->es_tupleTable, false);\n\n\tExecCloseIndices(resultRelInfo);\n\n\tFreeExecutorState(estate);\n\n\t/*\n\t * If we skipped writing WAL, then we need to sync the heap (but not\n\t * indexes since those use WAL anyway)\n\t */\n\tif (hi_options & HEAP_INSERT_SKIP_WAL)\n\t\theap_sync(cstate->rel);\n\n\treturn processed;\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 40529089928919033647147113637464667774,
        "size": 348,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "pq_init(void)\n{\n\tPqSendBufferSize = PQ_SEND_BUFFER_SIZE;\n\tPqSendBuffer = MemoryContextAlloc(TopMemoryContext, PqSendBufferSize);\n\tPqSendPointer = PqSendStart = PqRecvPointer = PqRecvLength = 0;\n\tPqCommBusy = false;\n\tDoingCopyOut = false;\n\ton_proc_exit(socket_close, 0);\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 46041498890020567291952209726463295678,
        "size": 9,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "SocketBackend(StringInfo inBuf)\n{\n\tint\t\t\tqtype;\n\n\t/*\n\t * Get message type code from the frontend.\n\t */\n\tqtype = pq_getbyte();\n\n\tif (qtype == EOF)\t\t\t/* frontend disconnected */\n\t{\n\t\tif (IsTransactionState())\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_CONNECTION_FAILURE),\n\t\t\t\t\t errmsg(\"unexpected EOF on client connection with an open transaction\")));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Can't send DEBUG log messages to client at this point. Since\n\t\t\t * we're disconnecting right away, we don't need to restore\n\t\t\t * whereToSendOutput.\n\t\t\t */\n\t\t\twhereToSendOutput = DestNone;\n\t\t\tereport(DEBUG1,\n\t\t\t\t\t(errcode(ERRCODE_CONNECTION_DOES_NOT_EXIST),\n\t\t\t\t\t errmsg(\"unexpected EOF on client connection\")));\n\t\t}\n\t\treturn qtype;\n\t}\n\n\t/*\n\t * Validate message type code before trying to read body; if we have lost\n\t * sync, better to say \"command unknown\" than to run out of memory because\n\t * we used garbage as a length word.\n\t *\n\t * This also gives us a place to set the doing_extended_query_message flag\n\t * as soon as possible.\n\t */\n\tswitch (qtype)\n\t{\n\t\tcase 'Q':\t\t\t\t/* simple query */\n\t\t\tdoing_extended_query_message = false;\n\t\t\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)\n\t\t\t{\n\t\t\t\t/* old style without length word; convert */\n\t\t\t\tif (pq_getstring(inBuf))\n\t\t\t\t{\n\t\t\t\t\tif (IsTransactionState())\n\t\t\t\t\t\tereport(COMMERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CONNECTION_FAILURE),\n\t\t\t\t\t\t\t\t errmsg(\"unexpected EOF on client connection with an open transaction\")));\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Can't send DEBUG log messages to client at this\n\t\t\t\t\t\t * point.Since we're disconnecting right away, we\n\t\t\t\t\t\t * don't need to restore whereToSendOutput.\n\t\t\t\t\t\t */\n\t\t\t\t\t\twhereToSendOutput = DestNone;\n\t\t\t\t\t\tereport(DEBUG1,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CONNECTION_DOES_NOT_EXIST),\n\t\t\t\t\t\t\t errmsg(\"unexpected EOF on client connection\")));\n\t\t\t\t\t}\n\t\t\t\t\treturn EOF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'F':\t\t\t\t/* fastpath function call */\n\t\t\t/* we let fastpath.c cope with old-style input of this */\n\t\t\tdoing_extended_query_message = false;\n\t\t\tbreak;\n\n\t\tcase 'X':\t\t\t\t/* terminate */\n\t\t\tdoing_extended_query_message = false;\n\t\t\tignore_till_sync = false;\n\t\t\tbreak;\n\n\t\tcase 'B':\t\t\t\t/* bind */\n\t\tcase 'C':\t\t\t\t/* close */\n\t\tcase 'D':\t\t\t\t/* describe */\n\t\tcase 'E':\t\t\t\t/* execute */\n\t\tcase 'H':\t\t\t\t/* flush */\n\t\tcase 'P':\t\t\t\t/* parse */\n\t\t\tdoing_extended_query_message = true;\n\t\t\t/* these are only legal in protocol 3 */\n\t\t\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t\t errmsg(\"invalid frontend message type %d\", qtype)));\n\t\t\tbreak;\n\n\t\tcase 'S':\t\t\t\t/* sync */\n\t\t\t/* stop any active skip-till-Sync */\n\t\t\tignore_till_sync = false;\n\t\t\t/* mark not-extended, so that a new error doesn't begin skip */\n\t\t\tdoing_extended_query_message = false;\n\t\t\t/* only legal in protocol 3 */\n\t\t\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t\t errmsg(\"invalid frontend message type %d\", qtype)));\n\t\t\tbreak;\n\n\t\tcase 'd':\t\t\t\t/* copy data */\n\t\tcase 'c':\t\t\t\t/* copy done */\n\t\tcase 'f':\t\t\t\t/* copy fail */\n\t\t\tdoing_extended_query_message = false;\n\t\t\t/* these are only legal in protocol 3 */\n\t\t\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t\t errmsg(\"invalid frontend message type %d\", qtype)));\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * Otherwise we got garbage from the frontend.  We treat this as\n\t\t\t * fatal because we have probably lost message boundary sync, and\n\t\t\t * there's no good way to recover.\n\t\t\t */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"invalid frontend message type %d\", qtype)));\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * In protocol version 3, all frontend messages have a length word next\n\t * after the type code; we can read the message contents independently of\n\t * the type.\n\t */\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)\n\t{\n\t\tif (pq_getmessage(inBuf, 0))\n\t\t\treturn EOF;\t\t\t/* suitable message already logged */\n\t}\n\n\treturn qtype;\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 230563570214040676042227252163105512216,
        "size": 141,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "pg_SSPI_recvauth(Port *port)\n{\n\tint\t\t\tmtype;\n\tStringInfoData buf;\n\tSECURITY_STATUS r;\n\tCredHandle\tsspicred;\n\tCtxtHandle *sspictx = NULL,\n\t\t\t\tnewctx;\n\tTimeStamp\texpiry;\n\tULONG\t\tcontextattr;\n\tSecBufferDesc inbuf;\n\tSecBufferDesc outbuf;\n\tSecBuffer\tOutBuffers[1];\n\tSecBuffer\tInBuffers[1];\n\tHANDLE\t\ttoken;\n\tTOKEN_USER *tokenuser;\n\tDWORD\t\tretlen;\n\tchar\t\taccountname[MAXPGPATH];\n\tchar\t\tdomainname[MAXPGPATH];\n\tDWORD\t\taccountnamesize = sizeof(accountname);\n\tDWORD\t\tdomainnamesize = sizeof(domainname);\n\tSID_NAME_USE accountnameuse;\n\tHMODULE\t\tsecur32;\n\tQUERY_SECURITY_CONTEXT_TOKEN_FN _QuerySecurityContextToken;\n\n\t/*\n\t * SSPI auth is not supported for protocol versions before 3, because it\n\t * relies on the overall message length word to determine the SSPI payload\n\t * size in AuthenticationGSSContinue and PasswordMessage messages. (This\n\t * is, in fact, a design error in our SSPI support, because protocol\n\t * messages are supposed to be parsable without relying on the length\n\t * word; but it's not worth changing it now.)\n\t */\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"SSPI is not supported in protocol version 2\")));\n\n\t/*\n\t * Acquire a handle to the server credentials.\n\t */\n\tr = AcquireCredentialsHandle(NULL,\n\t\t\t\t\t\t\t\t \"negotiate\",\n\t\t\t\t\t\t\t\t SECPKG_CRED_INBOUND,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t &sspicred,\n\t\t\t\t\t\t\t\t &expiry);\n\tif (r != SEC_E_OK)\n\t\tpg_SSPI_error(ERROR, _(\"could not acquire SSPI credentials\"), r);\n\n\t/*\n\t * Loop through SSPI message exchange. This exchange can consist of\n\t * multiple messags sent in both directions. First message is always from\n\t * the client. All messages from client to server are password packets\n\t * (type 'p').\n\t */\n\tdo\n\t{\n\t\tmtype = pq_getbyte();\n\t\tif (mtype != 'p')\n\t\t{\n\t\t\t/* Only log error if client didn't disconnect. */\n\t\t\tif (mtype != EOF)\n\t\t\t\tereport(COMMERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t\t errmsg(\"expected SSPI response, got message type %d\",\n\t\t\t\t\t\t\t\tmtype)));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\n\t\t/* Get the actual SSPI token */\n\t\tinitStringInfo(&buf);\n\t\tif (pq_getmessage(&buf, PG_MAX_AUTH_TOKEN_LENGTH))\n\t\t{\n\t\t\t/* EOF - pq_getmessage already logged error */\n\t\t\tpfree(buf.data);\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\n\t\t/* Map to SSPI style buffer */\n\t\tinbuf.ulVersion = SECBUFFER_VERSION;\n\t\tinbuf.cBuffers = 1;\n\t\tinbuf.pBuffers = InBuffers;\n\t\tInBuffers[0].pvBuffer = buf.data;\n\t\tInBuffers[0].cbBuffer = buf.len;\n\t\tInBuffers[0].BufferType = SECBUFFER_TOKEN;\n\n\t\t/* Prepare output buffer */\n\t\tOutBuffers[0].pvBuffer = NULL;\n\t\tOutBuffers[0].BufferType = SECBUFFER_TOKEN;\n\t\tOutBuffers[0].cbBuffer = 0;\n\t\toutbuf.cBuffers = 1;\n\t\toutbuf.pBuffers = OutBuffers;\n\t\toutbuf.ulVersion = SECBUFFER_VERSION;\n\n\n\t\telog(DEBUG4, \"Processing received SSPI token of length %u\",\n\t\t\t (unsigned int) buf.len);\n\n\t\tr = AcceptSecurityContext(&sspicred,\n\t\t\t\t\t\t\t\t  sspictx,\n\t\t\t\t\t\t\t\t  &inbuf,\n\t\t\t\t\t\t\t\t  ASC_REQ_ALLOCATE_MEMORY,\n\t\t\t\t\t\t\t\t  SECURITY_NETWORK_DREP,\n\t\t\t\t\t\t\t\t  &newctx,\n\t\t\t\t\t\t\t\t  &outbuf,\n\t\t\t\t\t\t\t\t  &contextattr,\n\t\t\t\t\t\t\t\t  NULL);\n\n\t\t/* input buffer no longer used */\n\t\tpfree(buf.data);\n\n\t\tif (outbuf.cBuffers > 0 && outbuf.pBuffers[0].cbBuffer > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Negotiation generated data to be sent to the client.\n\t\t\t */\n\t\t\telog(DEBUG4, \"sending SSPI response token of length %u\",\n\t\t\t\t (unsigned int) outbuf.pBuffers[0].cbBuffer);\n\n\t\t\tport->gss->outbuf.length = outbuf.pBuffers[0].cbBuffer;\n\t\t\tport->gss->outbuf.value = outbuf.pBuffers[0].pvBuffer;\n\n\t\t\tsendAuthRequest(port, AUTH_REQ_GSS_CONT);\n\n\t\t\tFreeContextBuffer(outbuf.pBuffers[0].pvBuffer);\n\t\t}\n\n\t\tif (r != SEC_E_OK && r != SEC_I_CONTINUE_NEEDED)\n\t\t{\n\t\t\tif (sspictx != NULL)\n\t\t\t{\n\t\t\t\tDeleteSecurityContext(sspictx);\n\t\t\t\tfree(sspictx);\n\t\t\t}\n\t\t\tFreeCredentialsHandle(&sspicred);\n\t\t\tpg_SSPI_error(ERROR,\n\t\t\t\t\t\t  _(\"could not accept SSPI security context\"), r);\n\t\t}\n\n\t\t/*\n\t\t * Overwrite the current context with the one we just received. If\n\t\t * sspictx is NULL it was the first loop and we need to allocate a\n\t\t * buffer for it. On subsequent runs, we can just overwrite the buffer\n\t\t * contents since the size does not change.\n\t\t */\n\t\tif (sspictx == NULL)\n\t\t{\n\t\t\tsspictx = malloc(sizeof(CtxtHandle));\n\t\t\tif (sspictx == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"out of memory\")));\n\t\t}\n\n\t\tmemcpy(sspictx, &newctx, sizeof(CtxtHandle));\n\n\t\tif (r == SEC_I_CONTINUE_NEEDED)\n\t\t\telog(DEBUG4, \"SSPI continue needed\");\n\n\t} while (r == SEC_I_CONTINUE_NEEDED);\n\n\n\t/*\n\t * Release service principal credentials\n\t */\n\tFreeCredentialsHandle(&sspicred);\n\n\n\t/*\n\t * SEC_E_OK indicates that authentication is now complete.\n\t *\n\t * Get the name of the user that authenticated, and compare it to the pg\n\t * username that was specified for the connection.\n\t *\n\t * MingW is missing the export for QuerySecurityContextToken in the\n\t * secur32 library, so we have to load it dynamically.\n\t */\n\n\tsecur32 = LoadLibrary(\"SECUR32.DLL\");\n\tif (secur32 == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg_internal(\"could not load secur32.dll: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\n\t_QuerySecurityContextToken = (QUERY_SECURITY_CONTEXT_TOKEN_FN)\n\t\tGetProcAddress(secur32, \"QuerySecurityContextToken\");\n\tif (_QuerySecurityContextToken == NULL)\n\t{\n\t\tFreeLibrary(secur32);\n\t\tereport(ERROR,\n\t\t\t\t(errmsg_internal(\"could not locate QuerySecurityContextToken in secur32.dll: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\t}\n\n\tr = (_QuerySecurityContextToken) (sspictx, &token);\n\tif (r != SEC_E_OK)\n\t{\n\t\tFreeLibrary(secur32);\n\t\tpg_SSPI_error(ERROR,\n\t\t\t\t\t  _(\"could not get token from SSPI security context\"), r);\n\t}\n\n\tFreeLibrary(secur32);\n\n\t/*\n\t * No longer need the security context, everything from here on uses the\n\t * token instead.\n\t */\n\tDeleteSecurityContext(sspictx);\n\tfree(sspictx);\n\n\tif (!GetTokenInformation(token, TokenUser, NULL, 0, &retlen) && GetLastError() != 122)\n\t\tereport(ERROR,\n\t\t\t(errmsg_internal(\"could not get token user size: error code %lu\",\n\t\t\t\t\t\t\t GetLastError())));\n\n\ttokenuser = malloc(retlen);\n\tif (tokenuser == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"out of memory\")));\n\n\tif (!GetTokenInformation(token, TokenUser, tokenuser, retlen, &retlen))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg_internal(\"could not get user token: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\n\tif (!LookupAccountSid(NULL, tokenuser->User.Sid, accountname, &accountnamesize,\n\t\t\t\t\t\t  domainname, &domainnamesize, &accountnameuse))\n\t\tereport(ERROR,\n\t\t\t(errmsg_internal(\"could not look up account SID: error code %lu\",\n\t\t\t\t\t\t\t GetLastError())));\n\n\tfree(tokenuser);\n\n\t/*\n\t * Compare realm/domain if requested. In SSPI, always compare case\n\t * insensitive.\n\t */\n\tif (port->hba->krb_realm && strlen(port->hba->krb_realm))\n\t{\n\t\tif (pg_strcasecmp(port->hba->krb_realm, domainname) != 0)\n\t\t{\n\t\t\telog(DEBUG2,\n\t\t\t\t \"SSPI domain (%s) and configured domain (%s) don't match\",\n\t\t\t\t domainname, port->hba->krb_realm);\n\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * We have the username (without domain/realm) in accountname, compare to\n\t * the supplied value. In SSPI, always compare case insensitive.\n\t *\n\t * If set to include realm, append it in <username>@<realm> format.\n\t */\n\tif (port->hba->include_realm)\n\t{\n\t\tchar\t   *namebuf;\n\t\tint\t\t\tretval;\n\n\t\tnamebuf = psprintf(\"%s@%s\", accountname, domainname);\n\t\tretval = check_usermap(port->hba->usermap, port->user_name, namebuf, true);\n\t\tpfree(namebuf);\n\t\treturn retval;\n\t}\n\telse\n\t\treturn check_usermap(port->hba->usermap, port->user_name, accountname, true);\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 323272905563442215958307751249115391966,
        "size": 272,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "pq_getstring(StringInfo s)\n{\n\tint\t\t\ti;\n\n\tresetStringInfo(s);\n\n\t/* Read until we get the terminating '\\0' */\n\tfor (;;)\n\t{\n\t\twhile (PqRecvPointer >= PqRecvLength)\n\t\t{\n\t\t\tif (pq_recvbuf())\t/* If nothing in buffer, then recv some */\n\t\t\t\treturn EOF;\t\t/* Failed to recv data */\n\t\t}\n\n\t\tfor (i = PqRecvPointer; i < PqRecvLength; i++)\n\t\t{\n\t\t\tif (PqRecvBuffer[i] == '\\0')\n\t\t\t{\n\t\t\t\t/* include the '\\0' in the copy */\n\t\t\t\tappendBinaryStringInfo(s, PqRecvBuffer + PqRecvPointer,\n\t\t\t\t\t\t\t\t\t   i - PqRecvPointer + 1);\n\t\t\t\tPqRecvPointer = i + 1;\t/* advance past \\0 */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/* If we're here we haven't got the \\0 in the buffer yet. */\n\t\tappendBinaryStringInfo(s, PqRecvBuffer + PqRecvPointer,\n\t\t\t\t\t\t\t   PqRecvLength - PqRecvPointer);\n\t\tPqRecvPointer = PqRecvLength;\n\t}\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 266912787197933425414233832946857947028,
        "size": 33,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "pg_GSS_recvauth(Port *port)\n{\n\tOM_uint32\tmaj_stat,\n\t\t\t\tmin_stat,\n\t\t\t\tlmin_s,\n\t\t\t\tgflags;\n\tint\t\t\tmtype;\n\tint\t\t\tret;\n\tStringInfoData buf;\n\tgss_buffer_desc gbuf;\n\n\t/*\n\t * GSS auth is not supported for protocol versions before 3, because it\n\t * relies on the overall message length word to determine the GSS payload\n\t * size in AuthenticationGSSContinue and PasswordMessage messages. (This\n\t * is, in fact, a design error in our GSS support, because protocol\n\t * messages are supposed to be parsable without relying on the length\n\t * word; but it's not worth changing it now.)\n\t */\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"GSSAPI is not supported in protocol version 2\")));\n\n\tif (pg_krb_server_keyfile && strlen(pg_krb_server_keyfile) > 0)\n\t{\n\t\t/*\n\t\t * Set default Kerberos keytab file for the Krb5 mechanism.\n\t\t *\n\t\t * setenv(\"KRB5_KTNAME\", pg_krb_server_keyfile, 0); except setenv()\n\t\t * not always available.\n\t\t */\n\t\tif (getenv(\"KRB5_KTNAME\") == NULL)\n\t\t{\n\t\t\tsize_t\t\tkt_len = strlen(pg_krb_server_keyfile) + 14;\n\t\t\tchar\t   *kt_path = malloc(kt_len);\n\n\t\t\tif (!kt_path)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t\t\treturn STATUS_ERROR;\n\t\t\t}\n\t\t\tsnprintf(kt_path, kt_len, \"KRB5_KTNAME=%s\", pg_krb_server_keyfile);\n\t\t\tputenv(kt_path);\n\t\t}\n\t}\n\n\t/*\n\t * We accept any service principal that's present in our keytab. This\n\t * increases interoperability between kerberos implementations that see\n\t * for example case sensitivity differently, while not really opening up\n\t * any vector of attack.\n\t */\n\tport->gss->cred = GSS_C_NO_CREDENTIAL;\n\n\t/*\n\t * Initialize sequence with an empty context\n\t */\n\tport->gss->ctx = GSS_C_NO_CONTEXT;\n\n\t/*\n\t * Loop through GSSAPI message exchange. This exchange can consist of\n\t * multiple messags sent in both directions. First message is always from\n\t * the client. All messages from client to server are password packets\n\t * (type 'p').\n\t */\n\tdo\n\t{\n\t\tmtype = pq_getbyte();\n\t\tif (mtype != 'p')\n\t\t{\n\t\t\t/* Only log error if client didn't disconnect. */\n\t\t\tif (mtype != EOF)\n\t\t\t\tereport(COMMERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t\t errmsg(\"expected GSS response, got message type %d\",\n\t\t\t\t\t\t\t\tmtype)));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\n\t\t/* Get the actual GSS token */\n\t\tinitStringInfo(&buf);\n\t\tif (pq_getmessage(&buf, PG_MAX_AUTH_TOKEN_LENGTH))\n\t\t{\n\t\t\t/* EOF - pq_getmessage already logged error */\n\t\t\tpfree(buf.data);\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\n\t\t/* Map to GSSAPI style buffer */\n\t\tgbuf.length = buf.len;\n\t\tgbuf.value = buf.data;\n\n\t\telog(DEBUG4, \"Processing received GSS token of length %u\",\n\t\t\t (unsigned int) gbuf.length);\n\n\t\tmaj_stat = gss_accept_sec_context(\n\t\t\t\t\t\t\t\t\t\t  &min_stat,\n\t\t\t\t\t\t\t\t\t\t  &port->gss->ctx,\n\t\t\t\t\t\t\t\t\t\t  port->gss->cred,\n\t\t\t\t\t\t\t\t\t\t  &gbuf,\n\t\t\t\t\t\t\t\t\t\t  GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t\t\t\t\t\t  &port->gss->name,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  &port->gss->outbuf,\n\t\t\t\t\t\t\t\t\t\t  &gflags,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t\t/* gbuf no longer used */\n\t\tpfree(buf.data);\n\n\t\telog(DEBUG5, \"gss_accept_sec_context major: %d, \"\n\t\t\t \"minor: %d, outlen: %u, outflags: %x\",\n\t\t\t maj_stat, min_stat,\n\t\t\t (unsigned int) port->gss->outbuf.length, gflags);\n\n\t\tif (port->gss->outbuf.length != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Negotiation generated data to be sent to the client.\n\t\t\t */\n\t\t\telog(DEBUG4, \"sending GSS response token of length %u\",\n\t\t\t\t (unsigned int) port->gss->outbuf.length);\n\n\t\t\tsendAuthRequest(port, AUTH_REQ_GSS_CONT);\n\n\t\t\tgss_release_buffer(&lmin_s, &port->gss->outbuf);\n\t\t}\n\n\t\tif (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n\t\t{\n\t\t\tgss_delete_sec_context(&lmin_s, &port->gss->ctx, GSS_C_NO_BUFFER);\n\t\t\tpg_GSS_error(ERROR,\n\t\t\t\t\t   gettext_noop(\"accepting GSS security context failed\"),\n\t\t\t\t\t\t maj_stat, min_stat);\n\t\t}\n\n\t\tif (maj_stat == GSS_S_CONTINUE_NEEDED)\n\t\t\telog(DEBUG4, \"GSS continue needed\");\n\n\t} while (maj_stat == GSS_S_CONTINUE_NEEDED);\n\n\tif (port->gss->cred != GSS_C_NO_CREDENTIAL)\n\t{\n\t\t/*\n\t\t * Release service principal credentials\n\t\t */\n\t\tgss_release_cred(&min_stat, &port->gss->cred);\n\t}\n\n\t/*\n\t * GSS_S_COMPLETE indicates that authentication is now complete.\n\t *\n\t * Get the name of the user that authenticated, and compare it to the pg\n\t * username that was specified for the connection.\n\t */\n\tmaj_stat = gss_display_name(&min_stat, port->gss->name, &gbuf, NULL);\n\tif (maj_stat != GSS_S_COMPLETE)\n\t\tpg_GSS_error(ERROR,\n\t\t\t\t\t gettext_noop(\"retrieving GSS user name failed\"),\n\t\t\t\t\t maj_stat, min_stat);\n\n\t/*\n\t * Split the username at the realm separator\n\t */\n\tif (strchr(gbuf.value, '@'))\n\t{\n\t\tchar\t   *cp = strchr(gbuf.value, '@');\n\n\t\t/*\n\t\t * If we are not going to include the realm in the username that is\n\t\t * passed to the ident map, destructively modify it here to remove the\n\t\t * realm. Then advance past the separator to check the realm.\n\t\t */\n\t\tif (!port->hba->include_realm)\n\t\t\t*cp = '\\0';\n\t\tcp++;\n\n\t\tif (port->hba->krb_realm != NULL && strlen(port->hba->krb_realm))\n\t\t{\n\t\t\t/*\n\t\t\t * Match the realm part of the name first\n\t\t\t */\n\t\t\tif (pg_krb_caseins_users)\n\t\t\t\tret = pg_strcasecmp(port->hba->krb_realm, cp);\n\t\t\telse\n\t\t\t\tret = strcmp(port->hba->krb_realm, cp);\n\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\t/* GSS realm does not match */\n\t\t\t\telog(DEBUG2,\n\t\t\t\t   \"GSSAPI realm (%s) and configured realm (%s) don't match\",\n\t\t\t\t\t cp, port->hba->krb_realm);\n\t\t\t\tgss_release_buffer(&lmin_s, &gbuf);\n\t\t\t\treturn STATUS_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\telse if (port->hba->krb_realm && strlen(port->hba->krb_realm))\n\t{\n\t\telog(DEBUG2,\n\t\t\t \"GSSAPI did not return realm but realm matching was requested\");\n\n\t\tgss_release_buffer(&lmin_s, &gbuf);\n\t\treturn STATUS_ERROR;\n\t}\n\n\tret = check_usermap(port->hba->usermap, port->user_name, gbuf.value,\n\t\t\t\t\t\tpg_krb_caseins_users);\n\n\tgss_release_buffer(&lmin_s, &gbuf);\n\n\treturn ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 89146156099281568023903249524999225198,
        "size": 218,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "pq_getbyte(void)\n{\n\twhile (PqRecvPointer >= PqRecvLength)\n\t{\n\t\tif (pq_recvbuf())\t\t/* If nothing in buffer, then recv some */\n\t\t\treturn EOF;\t\t\t/* Failed to recv data */\n\t}\n\treturn (unsigned char) PqRecvBuffer[PqRecvPointer++];\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 204109733640366718651847243610654545027,
        "size": 9,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "ProcessStartupPacket(Port *port, bool SSLdone)\n{\n\tint32\t\tlen;\n\tvoid\t   *buf;\n\tProtocolVersion proto;\n\tMemoryContext oldcontext;\n\n\tif (pq_getbytes((char *) &len, 4) == EOF)\n\t{\n\t\t/*\n\t\t * EOF after SSLdone probably means the client didn't like our\n\t\t * response to NEGOTIATE_SSL_CODE.  That's not an error condition, so\n\t\t * don't clutter the log with a complaint.\n\t\t */\n\t\tif (!SSLdone)\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tlen = ntohl(len);\n\tlen -= 4;\n\n\tif (len < (int32) sizeof(ProtocolVersion) ||\n\t\tlen > MAX_STARTUP_PACKET_LENGTH)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid length of startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Allocate at least the size of an old-style startup packet, plus one\n\t * extra byte, and make sure all are zeroes.  This ensures we will have\n\t * null termination of all strings, in both fixed- and variable-length\n\t * packet layouts.\n\t */\n\tif (len <= (int32) sizeof(StartupPacket))\n\t\tbuf = palloc0(sizeof(StartupPacket) + 1);\n\telse\n\t\tbuf = palloc0(len + 1);\n\n\tif (pq_getbytes(buf, len) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * The first field is either a protocol version number or a special\n\t * request code.\n\t */\n\tport->proto = proto = ntohl(*((ProtocolVersion *) buf));\n\n\tif (proto == CANCEL_REQUEST_CODE)\n\t{\n\t\tprocessCancelRequest(port, buf);\n\t\t/* Not really an error, but we don't want to proceed further */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (proto == NEGOTIATE_SSL_CODE && !SSLdone)\n\t{\n\t\tchar\t\tSSLok;\n\n#ifdef USE_SSL\n\t\t/* No SSL when disabled or on Unix sockets */\n\t\tif (!EnableSSL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tSSLok = 'N';\n\t\telse\n\t\t\tSSLok = 'S';\t\t/* Support for SSL */\n#else\n\t\tSSLok = 'N';\t\t\t/* No support for SSL */\n#endif\n\nretry1:\n\t\tif (send(port->sock, &SSLok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto retry1;\t/* if interrupted, just retry */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send SSL negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef USE_SSL\n\t\tif (SSLok == 'S' && secure_open_server(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\t\t/* regular startup packet, cancel, etc packet should follow... */\n\t\t/* but not another SSL negotiation request */\n\t\treturn ProcessStartupPacket(port, true);\n\t}\n\n\t/* Could add additional special packet types here */\n\n\t/*\n\t * Set FrontendProtocol now so that ereport() knows what format to send if\n\t * we fail during startup.\n\t */\n\tFrontendProtocol = proto;\n\n\t/* Check we can handle the protocol the frontend is using. */\n\n\tif (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||\n\t\tPG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST) ||\n\t\t(PG_PROTOCOL_MAJOR(proto) == PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST) &&\n\t\t PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST)))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u\",\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),\n\t\t\t\t\t\tPG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));\n\n\t/*\n\t * Now fetch parameters out of startup packet and save them into the Port\n\t * structure.  All data structures attached to the Port struct must be\n\t * allocated in TopMemoryContext so that they will remain available in a\n\t * running backend (even after PostmasterContext is destroyed).  We need\n\t * not worry about leaking this storage on failure, since we aren't in the\n\t * postmaster process anymore.\n\t */\n\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\n\tif (PG_PROTOCOL_MAJOR(proto) >= 3)\n\t{\n\t\tint32\t\toffset = sizeof(ProtocolVersion);\n\n\t\t/*\n\t\t * Scan packet body for name/option pairs.  We can assume any string\n\t\t * beginning within the packet body is null-terminated, thanks to\n\t\t * zeroing extra byte above.\n\t\t */\n\t\tport->guc_options = NIL;\n\n\t\twhile (offset < len)\n\t\t{\n\t\t\tchar\t   *nameptr = ((char *) buf) + offset;\n\t\t\tint32\t\tvaloffset;\n\t\t\tchar\t   *valptr;\n\n\t\t\tif (*nameptr == '\\0')\n\t\t\t\tbreak;\t\t\t/* found packet terminator */\n\t\t\tvaloffset = offset + strlen(nameptr) + 1;\n\t\t\tif (valoffset >= len)\n\t\t\t\tbreak;\t\t\t/* missing value, will complain below */\n\t\t\tvalptr = ((char *) buf) + valoffset;\n\n\t\t\tif (strcmp(nameptr, \"database\") == 0)\n\t\t\t\tport->database_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"user\") == 0)\n\t\t\t\tport->user_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"options\") == 0)\n\t\t\t\tport->cmdline_options = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"replication\") == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Due to backward compatibility concerns the replication\n\t\t\t\t * parameter is a hybrid beast which allows the value to be\n\t\t\t\t * either boolean or the string 'database'. The latter\n\t\t\t\t * connects to a specific database which is e.g. required for\n\t\t\t\t * logical decoding while.\n\t\t\t\t */\n\t\t\t\tif (strcmp(valptr, \"database\") == 0)\n\t\t\t\t{\n\t\t\t\t\tam_walsender = true;\n\t\t\t\t\tam_db_walsender = true;\n\t\t\t\t}\n\t\t\t\telse if (!parse_bool(valptr, &am_walsender))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t   errmsg(\"invalid value for parameter \\\"replication\\\"\"),\n\t\t\t\t\t\t\t errhint(\"Valid values are: false, 0, true, 1, database.\")));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Assume it's a generic GUC option */\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(nameptr));\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(valptr));\n\t\t\t}\n\t\t\toffset = valoffset + strlen(valptr) + 1;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't find a packet terminator exactly at the end of the\n\t\t * given packet length, complain.\n\t\t */\n\t\tif (offset != len - 1)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"invalid startup packet layout: expected terminator as last byte\")));\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Get the parameters from the old-style, fixed-width-fields startup\n\t\t * packet as C strings.  The packet destination was cleared first so a\n\t\t * short packet has zeros silently added.  We have to be prepared to\n\t\t * truncate the pstrdup result for oversize fields, though.\n\t\t */\n\t\tStartupPacket *packet = (StartupPacket *) buf;\n\n\t\tport->database_name = pstrdup(packet->database);\n\t\tif (strlen(port->database_name) > sizeof(packet->database))\n\t\t\tport->database_name[sizeof(packet->database)] = '\\0';\n\t\tport->user_name = pstrdup(packet->user);\n\t\tif (strlen(port->user_name) > sizeof(packet->user))\n\t\t\tport->user_name[sizeof(packet->user)] = '\\0';\n\t\tport->cmdline_options = pstrdup(packet->options);\n\t\tif (strlen(port->cmdline_options) > sizeof(packet->options))\n\t\t\tport->cmdline_options[sizeof(packet->options)] = '\\0';\n\t\tport->guc_options = NIL;\n\t}\n\n\t/* Check a user name was given. */\n\tif (port->user_name == NULL || port->user_name[0] == '\\0')\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t errmsg(\"no PostgreSQL user name specified in startup packet\")));\n\n\t/* The database defaults to the user name. */\n\tif (port->database_name == NULL || port->database_name[0] == '\\0')\n\t\tport->database_name = pstrdup(port->user_name);\n\n\tif (Db_user_namespace)\n\t{\n\t\t/*\n\t\t * If user@, it is a global user, remove '@'. We only want to do this\n\t\t * if there is an '@' at the end and no earlier in the user string or\n\t\t * they may fake as a local user of another database attaching to this\n\t\t * database.\n\t\t */\n\t\tif (strchr(port->user_name, '@') ==\n\t\t\tport->user_name + strlen(port->user_name) - 1)\n\t\t\t*strchr(port->user_name, '@') = '\\0';\n\t\telse\n\t\t{\n\t\t\t/* Append '@' and dbname */\n\t\t\tport->user_name = psprintf(\"%s@%s\", port->user_name, port->database_name);\n\t\t}\n\t}\n\n\t/*\n\t * Truncate given database and user names to length of a Postgres name.\n\t * This avoids lookup failures when overlength names are given.\n\t */\n\tif (strlen(port->database_name) >= NAMEDATALEN)\n\t\tport->database_name[NAMEDATALEN - 1] = '\\0';\n\tif (strlen(port->user_name) >= NAMEDATALEN)\n\t\tport->user_name[NAMEDATALEN - 1] = '\\0';\n\n\t/*\n\t * Normal walsender backends, e.g. for streaming replication, are not\n\t * connected to a particular database. But walsenders used for logical\n\t * replication need to connect to a specific database. We allow streaming\n\t * replication commands to be issued even if connected to a database as it\n\t * can make sense to first make a basebackup and then stream changes\n\t * starting from that.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t\tport->database_name[0] = '\\0';\n\n\t/*\n\t * Done putting stuff in TopMemoryContext.\n\t */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * If we're going to reject the connection due to database state, say so\n\t * now instead of wasting cycles on an authentication exchange. (This also\n\t * allows a pg_ping utility to be written.)\n\t */\n\tswitch (port->canAcceptConnections)\n\t{\n\t\tcase CAC_STARTUP:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is starting up\")));\n\t\t\tbreak;\n\t\tcase CAC_SHUTDOWN:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is shutting down\")));\n\t\t\tbreak;\n\t\tcase CAC_RECOVERY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is in recovery mode\")));\n\t\t\tbreak;\n\t\tcase CAC_TOOMANY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"sorry, too many clients already\")));\n\t\t\tbreak;\n\t\tcase CAC_WAITBACKUP:\n\t\t\t/* OK for now, will check in InitPostgres */\n\t\t\tbreak;\n\t\tcase CAC_OK:\n\t\t\tbreak;\n\t}\n\n\treturn STATUS_OK;\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 127571964776307142121582173470796430958,
        "size": 312,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "ReceiveCopyBegin(CopyState cstate)\n{\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)\n\t{\n\t\t/* new way */\n\t\tStringInfoData buf;\n\t\tint\t\t\tnatts = list_length(cstate->attnumlist);\n\t\tint16\t\tformat = (cstate->binary ? 1 : 0);\n\t\tint\t\t\ti;\n\n\t\tpq_beginmessage(&buf, 'G');\n\t\tpq_sendbyte(&buf, format);\t\t/* overall format */\n\t\tpq_sendint(&buf, natts, 2);\n\t\tfor (i = 0; i < natts; i++)\n\t\t\tpq_sendint(&buf, format, 2);\t\t/* per-column formats */\n\t\tpq_endmessage(&buf);\n\t\tcstate->copy_dest = COPY_NEW_FE;\n\t\tcstate->fe_msgbuf = makeStringInfo();\n\t}\n\telse if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 2)\n\t{\n\t\t/* old way */\n\t\tif (cstate->binary)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\terrmsg(\"COPY BINARY is not supported to stdout or from stdin\")));\n\t\tpq_putemptymessage('G');\n\t\tcstate->copy_dest = COPY_OLD_FE;\n\t}\n\telse\n\t{\n\t\t/* very old way */\n\t\tif (cstate->binary)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\terrmsg(\"COPY BINARY is not supported to stdout or from stdin\")));\n\t\tpq_putemptymessage('D');\n\t\tcstate->copy_dest = COPY_OLD_FE;\n\t}\n\t/* We *must* flush here to ensure FE knows it can send. */\n\tpq_flush();\n}",
        "target": 1,
        "cwe": [
            "CWE-89"
        ],
        "project": "postgres",
        "commit_id": "2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b",
        "hash": 60753143640720708622998530449234606444,
        "size": 42,
        "message": "Be more careful to not lose sync in the FE/BE protocol.\n\nIf any error occurred while we were in the middle of reading a protocol\nmessage from the client, we could lose sync, and incorrectly try to\ninterpret a part of another message as a new protocol message. That will\nusually lead to an \"invalid frontend message\" error that terminates the\nconnection. However, this is a security issue because an attacker might\nbe able to deliberately cause an error, inject a Query message in what's\nsupposed to be just user data, and have the server execute it.\n\nWe were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other\noperations that could ereport(ERROR) in the middle of processing a message,\nbut a query cancel interrupt or statement timeout could nevertheless cause\nit to happen. Also, the V2 fastpath and COPY handling were not so careful.\nIt's very difficult to recover in the V2 COPY protocol, so we will just\nterminate the connection on error. In practice, that's what happened\npreviously anyway, as we lost protocol sync.\n\nTo fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set\nwhenever we're in the middle of reading a message. When it's set, we cannot\nsafely ERROR out and continue running, because we might've read only part\nof a message. PqCommReadingMsg acts somewhat similarly to critical sections\nin that if an error occurs while it's set, the error handler will force the\nconnection to be terminated, as if the error was FATAL. It's not\nimplemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted\nto PANIC in critical sections, because we want to be able to use\nPG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes\nadvantage of that to prevent an OOM error from terminating the connection.\n\nTo prevent unnecessary connection terminations, add a holdoff mechanism\nsimilar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel\ninterrupts, but still allow die interrupts. The rules on which interrupts\nare processed when are now a bit more complicated, so refactor\nProcessInterrupts() and the calls to it in signal handlers so that the\nsignal handlers always call it if ImmediateInterruptOK is set, and\nProcessInterrupts() can decide to not do anything if the other conditions\nare not met.\n\nReported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.\nBackpatch to all supported versions.\n\nSecurity: CVE-2015-0244"
    },
    {
        "func": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\n\t/* AdjustTimestampForTypmod(&result, typmod); */\n\n\t/*\n\t * Since it's difficult to test for noresult, make sure errno is 0 if no\n\t * error occurred.\n\t */\n\terrno = 0;\n\treturn result;\n}",
        "target": 1,
        "cwe": [
            "CWE-416",
            "CWE-119"
        ],
        "project": "postgres",
        "commit_id": "4318daecc959886d001a6e79c6ea853e8b1dfb4b",
        "hash": 325193846501532670870598142871536569746,
        "size": 73,
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063"
    },
    {
        "func": "PGTYPESdate_from_asc(char *str, char **endptr)\n{\n\tdate\t\tdDate;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + 1];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\n\tbool\t\tEuroDates = FALSE;\n\n\terrno = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, EuroDates) != 0)\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tif (GetEpochTime(tm) < 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\treturn INT_MIN;\n\t}\n\n\tdDate = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - date2j(2000, 1, 1));\n\n\treturn dDate;\n}",
        "target": 1,
        "cwe": [
            "CWE-416",
            "CWE-119"
        ],
        "project": "postgres",
        "commit_id": "4318daecc959886d001a6e79c6ea853e8b1dfb4b",
        "hash": 86482207738238369203525661579473701203,
        "size": 52,
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063"
    },
    {
        "func": "main(void)\n{\n\t/* exec sql begin declare section */\n\t\t \n\t\t  \n\t\t \n\t\t \n\t\t \n\t\n#line 52 \"dt_test2.pgc\"\n date date1 ;\n \n#line 53 \"dt_test2.pgc\"\n timestamp ts1 , ts2 ;\n \n#line 54 \"dt_test2.pgc\"\n char * text ;\n \n#line 55 \"dt_test2.pgc\"\n interval * i1 ;\n \n#line 56 \"dt_test2.pgc\"\n date * dc ;\n/* exec sql end declare section */\n#line 57 \"dt_test2.pgc\"\n\n\n\tint i, j;\n\tchar *endptr;\n\n\tECPGdebug(1, stderr);\n\n\tts1 = PGTYPEStimestamp_from_asc(\"2003-12-04 17:34:29\", NULL);\n\ttext = PGTYPEStimestamp_to_asc(ts1);\n\n\tprintf(\"timestamp: %s\\n\", text);\n\tfree(text);\n\n\tdate1 = PGTYPESdate_from_timestamp(ts1);\n\tdc = PGTYPESdate_new();\n\t*dc = date1;\n\ttext = PGTYPESdate_to_asc(*dc);\n\tprintf(\"Date of timestamp: %s\\n\", text);\n\tfree(text);\n\tPGTYPESdate_free(dc);\n\n\tfor (i = 0; dates[i]; i++)\n\t{\n\t\tbool err = false;\n\t\tdate1 = PGTYPESdate_from_asc(dates[i], &endptr);\n\t\tif (date1 == INT_MIN) {\n\t\t\terr = true;\n\t\t}\n\t\ttext = PGTYPESdate_to_asc(date1);\n\t\tprintf(\"Date[%d]: %s (%c - %c)\\n\",\n\t\t\t\t\ti, err ? \"-\" : text,\n\t\t\t\t\tendptr ? 'N' : 'Y',\n\t\t\t\t\terr ? 'T' : 'F');\n\t\tfree(text);\n\t\tif (!err)\n\t\t{\n\t\t\tfor (j = 0; times[j]; j++)\n\t\t\t{\n\t\t\t\tint length = strlen(dates[i])\n\t\t\t\t\t\t+ 1\n\t\t\t\t\t\t+ strlen(times[j])\n\t\t\t\t\t\t+ 1;\n\t\t\t\tchar* t = malloc(length);\n\t\t\t\tsprintf(t, \"%s %s\", dates[i], times[j]);\n\t\t\t\tts1 = PGTYPEStimestamp_from_asc(t, NULL);\n\t\t\t\ttext = PGTYPEStimestamp_to_asc(ts1);\n\t\t\t\tif (i != 19 || j != 3) /* timestamp as integer or double differ for this case */\n\t\t\t\t\tprintf(\"TS[%d,%d]: %s\\n\",\n\t\t\t\t\t\ti, j, errno ? \"-\" : text);\n\t\t\t\tfree(text);\n\t\t\t\tfree(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tts1 = PGTYPEStimestamp_from_asc(\"2004-04-04 23:23:23\", NULL);\n\n\tfor (i = 0; intervals[i]; i++)\n\t{\n\t\tinterval *ic;\n\t\ti1 = PGTYPESinterval_from_asc(intervals[i], &endptr);\n\t\tif (*endptr)\n\t\t\tprintf(\"endptr set to %s\\n\", endptr);\n\t\tif (!i1)\n\t\t{\n\t\t\tprintf(\"Error parsing interval %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tj = PGTYPEStimestamp_add_interval(&ts1, i1, &ts2);\n\t\tif (j < 0)\n\t\t\tcontinue;\n\t\ttext = PGTYPESinterval_to_asc(i1);\n\t\tprintf(\"interval[%d]: %s\\n\", i, text ? text : \"-\");\n\t\tfree(text);\n\n\t\tic = PGTYPESinterval_new();\n\t\tPGTYPESinterval_copy(i1, ic);\n\t\ttext = PGTYPESinterval_to_asc(i1);\n\t\tprintf(\"interval_copy[%d]: %s\\n\", i, text ? text : \"-\");\n\t\tfree(text);\n\t\tPGTYPESinterval_free(ic);\n\t\tPGTYPESinterval_free(i1);\n\t}\n\n\treturn (0);\n}",
        "target": 1,
        "cwe": [
            "CWE-416",
            "CWE-119"
        ],
        "project": "postgres",
        "commit_id": "4318daecc959886d001a6e79c6ea853e8b1dfb4b",
        "hash": 31716886469425819756615542055415630560,
        "size": 111,
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063"
    },
    {
        "func": "PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &dtype, tm, &fsec) != 0 &&\n\t\t DecodeISO8601Interval(str, &dtype, tm, &fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\terrno = 0;\n\treturn result;\n}",
        "target": 1,
        "cwe": [
            "CWE-416",
            "CWE-119"
        ],
        "project": "postgres",
        "commit_id": "4318daecc959886d001a6e79c6ea853e8b1dfb4b",
        "hash": 149551951396418074034945720925398440149,
        "size": 57,
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063"
    },
    {
        "func": "static int queue_userspace_packet(struct datapath *dp, struct sk_buff *skb,\n\t\t\t\t  const struct dp_upcall_info *upcall_info)\n{\n\tstruct ovs_header *upcall;\n\tstruct sk_buff *nskb = NULL;\n\tstruct sk_buff *user_skb; /* to be queued to userspace */\n\tstruct nlattr *nla;\n\tstruct genl_info info = {\n\t\t.dst_sk = ovs_dp_get_net(dp)->genl_sock,\n\t\t.snd_portid = upcall_info->portid,\n\t};\n\tsize_t len;\n\tunsigned int hlen;\n\tint err, dp_ifindex;\n\n\tdp_ifindex = get_dpifindex(dp);\n\tif (!dp_ifindex)\n\t\treturn -ENODEV;\n\n\tif (vlan_tx_tag_present(skb)) {\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\treturn -ENOMEM;\n\n\t\tnskb = __vlan_put_tag(nskb, nskb->vlan_proto, vlan_tx_tag_get(nskb));\n\t\tif (!nskb)\n\t\t\treturn -ENOMEM;\n\n\t\tnskb->vlan_tci = 0;\n\t\tskb = nskb;\n\t}\n\n\tif (nla_attr_size(skb->len) > USHRT_MAX) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\t/* Complete checksum if needed */\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    (err = skb_checksum_help(skb)))\n\t\tgoto out;\n\n\t/* Older versions of OVS user space enforce alignment of the last\n\t * Netlink attribute to NLA_ALIGNTO which would require extensive\n\t * padding logic. Only perform zerocopy if padding is not required.\n\t */\n\tif (dp->user_features & OVS_DP_F_UNALIGNED)\n\t\thlen = skb_zerocopy_headlen(skb);\n\telse\n\t\thlen = skb->len;\n\n\tlen = upcall_msg_size(upcall_info->userdata, hlen);\n\tuser_skb = genlmsg_new_unicast(len, &info, GFP_ATOMIC);\n\tif (!user_skb) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tupcall = genlmsg_put(user_skb, 0, 0, &dp_packet_genl_family,\n\t\t\t     0, upcall_info->cmd);\n\tupcall->dp_ifindex = dp_ifindex;\n\n\tnla = nla_nest_start(user_skb, OVS_PACKET_ATTR_KEY);\n\tovs_nla_put_flow(upcall_info->key, upcall_info->key, user_skb);\n\tnla_nest_end(user_skb, nla);\n\n\tif (upcall_info->userdata)\n\t\t__nla_put(user_skb, OVS_PACKET_ATTR_USERDATA,\n\t\t\t  nla_len(upcall_info->userdata),\n\t\t\t  nla_data(upcall_info->userdata));\n\n\t/* Only reserve room for attribute header, packet data is added\n\t * in skb_zerocopy() */\n\tif (!(nla = nla_reserve(user_skb, OVS_PACKET_ATTR_PACKET, 0))) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\tnla->nla_len = nla_attr_size(skb->len);\n\n\tskb_zerocopy(user_skb, skb, skb->len, hlen);\n\n\t/* Pad OVS_PACKET_ATTR_PACKET if linear copy was performed */\n\tif (!(dp->user_features & OVS_DP_F_UNALIGNED)) {\n\t\tsize_t plen = NLA_ALIGN(user_skb->len) - user_skb->len;\n\n\t\tif (plen > 0)\n\t\t\tmemset(skb_put(user_skb, plen), 0, plen);\n\t}\n\n\t((struct nlmsghdr *) user_skb->data)->nlmsg_len = user_skb->len;\n\n\terr = genlmsg_unicast(ovs_dp_get_net(dp), user_skb, upcall_info->portid);\nout:\n\tkfree_skb(nskb);\n\treturn err;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "net",
        "commit_id": "36d5fe6a000790f56039afe26834265db0a3ad4c",
        "hash": 294381724353627868532053545975854526688,
        "size": 96,
        "message": "core, nfqueue, openvswitch: Orphan frags in skb_zerocopy and handle errors\n\nskb_zerocopy can copy elements of the frags array between skbs, but it doesn't\norphan them. Also, it doesn't handle errors, so this patch takes care of that\nas well, and modify the callers accordingly. skb_tx_error() is also added to\nthe callers so they will signal the failed delivery towards the creator of the\nskb.\n\nSigned-off-by: Zoltan Kiss <zoltan.kiss@citrix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,\n\t\t\t   struct nf_queue_entry *entry,\n\t\t\t   __be32 **packet_id_ptr)\n{\n\tsize_t size;\n\tsize_t data_len = 0, cap_len = 0;\n\tunsigned int hlen = 0;\n\tstruct sk_buff *skb;\n\tstruct nlattr *nla;\n\tstruct nfqnl_msg_packet_hdr *pmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct nfgenmsg *nfmsg;\n\tstruct sk_buff *entskb = entry->skb;\n\tstruct net_device *indev;\n\tstruct net_device *outdev;\n\tstruct nf_conn *ct = NULL;\n\tenum ip_conntrack_info uninitialized_var(ctinfo);\n\tbool csum_verify;\n\n\tsize =    nlmsg_total_size(sizeof(struct nfgenmsg))\n\t\t+ nla_total_size(sizeof(struct nfqnl_msg_packet_hdr))\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n#ifdef CONFIG_BRIDGE_NETFILTER\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* ifindex */\n#endif\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* mark */\n\t\t+ nla_total_size(sizeof(struct nfqnl_msg_packet_hw))\n\t\t+ nla_total_size(sizeof(u_int32_t))\t/* skbinfo */\n\t\t+ nla_total_size(sizeof(u_int32_t));\t/* cap_len */\n\n\tif (entskb->tstamp.tv64)\n\t\tsize += nla_total_size(sizeof(struct nfqnl_msg_packet_timestamp));\n\n\tif (entry->hook <= NF_INET_FORWARD ||\n\t   (entry->hook == NF_INET_POST_ROUTING && entskb->sk == NULL))\n\t\tcsum_verify = !skb_csum_unnecessary(entskb);\n\telse\n\t\tcsum_verify = false;\n\n\toutdev = entry->outdev;\n\n\tswitch ((enum nfqnl_config_mode)ACCESS_ONCE(queue->copy_mode)) {\n\tcase NFQNL_COPY_META:\n\tcase NFQNL_COPY_NONE:\n\t\tbreak;\n\n\tcase NFQNL_COPY_PACKET:\n\t\tif (!(queue->flags & NFQA_CFG_F_GSO) &&\n\t\t    entskb->ip_summed == CHECKSUM_PARTIAL &&\n\t\t    skb_checksum_help(entskb))\n\t\t\treturn NULL;\n\n\t\tdata_len = ACCESS_ONCE(queue->copy_range);\n\t\tif (data_len > entskb->len)\n\t\t\tdata_len = entskb->len;\n\n\t\thlen = skb_zerocopy_headlen(entskb);\n\t\thlen = min_t(unsigned int, hlen, data_len);\n\t\tsize += sizeof(struct nlattr) + hlen;\n\t\tcap_len = entskb->len;\n\t\tbreak;\n\t}\n\n\tif (queue->flags & NFQA_CFG_F_CONNTRACK)\n\t\tct = nfqnl_ct_get(entskb, &size, &ctinfo);\n\n\tif (queue->flags & NFQA_CFG_F_UID_GID) {\n\t\tsize +=  (nla_total_size(sizeof(u_int32_t))\t/* uid */\n\t\t\t+ nla_total_size(sizeof(u_int32_t)));\t/* gid */\n\t}\n\n\tskb = nfnetlink_alloc_skb(net, size, queue->peer_portid,\n\t\t\t\t  GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh = nlmsg_put(skb, 0, 0,\n\t\t\tNFNL_SUBSYS_QUEUE << 8 | NFQNL_MSG_PACKET,\n\t\t\tsizeof(struct nfgenmsg), 0);\n\tif (!nlh) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\tnfmsg = nlmsg_data(nlh);\n\tnfmsg->nfgen_family = entry->pf;\n\tnfmsg->version = NFNETLINK_V0;\n\tnfmsg->res_id = htons(queue->queue_num);\n\n\tnla = __nla_reserve(skb, NFQA_PACKET_HDR, sizeof(*pmsg));\n\tpmsg = nla_data(nla);\n\tpmsg->hw_protocol\t= entskb->protocol;\n\tpmsg->hook\t\t= entry->hook;\n\t*packet_id_ptr\t\t= &pmsg->packet_id;\n\n\tindev = entry->indev;\n\tif (indev) {\n#ifndef CONFIG_BRIDGE_NETFILTER\n\t\tif (nla_put_be32(skb, NFQA_IFINDEX_INDEV, htonl(indev->ifindex)))\n\t\t\tgoto nla_put_failure;\n#else\n\t\tif (entry->pf == PF_BRIDGE) {\n\t\t\t/* Case 1: indev is physical input device, we need to\n\t\t\t * look for bridge group (when called from\n\t\t\t * netfilter_bridge) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_PHYSINDEV,\n\t\t\t\t\t htonl(indev->ifindex)) ||\n\t\t\t/* this is the bridge group \"brX\" */\n\t\t\t/* rcu_read_lock()ed by __nf_queue */\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_INDEV,\n\t\t\t\t\t htonl(br_port_get_rcu(indev)->br->dev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\t/* Case 2: indev is bridge group, we need to look for\n\t\t\t * physical device (when called from ipv4) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_INDEV,\n\t\t\t\t\t htonl(indev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (entskb->nf_bridge && entskb->nf_bridge->physindev &&\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_PHYSINDEV,\n\t\t\t\t\t htonl(entskb->nf_bridge->physindev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t}\n\n\tif (outdev) {\n#ifndef CONFIG_BRIDGE_NETFILTER\n\t\tif (nla_put_be32(skb, NFQA_IFINDEX_OUTDEV, htonl(outdev->ifindex)))\n\t\t\tgoto nla_put_failure;\n#else\n\t\tif (entry->pf == PF_BRIDGE) {\n\t\t\t/* Case 1: outdev is physical output device, we need to\n\t\t\t * look for bridge group (when called from\n\t\t\t * netfilter_bridge) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_PHYSOUTDEV,\n\t\t\t\t\t htonl(outdev->ifindex)) ||\n\t\t\t/* this is the bridge group \"brX\" */\n\t\t\t/* rcu_read_lock()ed by __nf_queue */\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_OUTDEV,\n\t\t\t\t\t htonl(br_port_get_rcu(outdev)->br->dev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\t/* Case 2: outdev is bridge group, we need to look for\n\t\t\t * physical output device (when called from ipv4) */\n\t\t\tif (nla_put_be32(skb, NFQA_IFINDEX_OUTDEV,\n\t\t\t\t\t htonl(outdev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (entskb->nf_bridge && entskb->nf_bridge->physoutdev &&\n\t\t\t    nla_put_be32(skb, NFQA_IFINDEX_PHYSOUTDEV,\n\t\t\t\t\t htonl(entskb->nf_bridge->physoutdev->ifindex)))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t}\n\n\tif (entskb->mark &&\n\t    nla_put_be32(skb, NFQA_MARK, htonl(entskb->mark)))\n\t\tgoto nla_put_failure;\n\n\tif (indev && entskb->dev &&\n\t    entskb->mac_header != entskb->network_header) {\n\t\tstruct nfqnl_msg_packet_hw phw;\n\t\tint len;\n\n\t\tmemset(&phw, 0, sizeof(phw));\n\t\tlen = dev_parse_header(entskb, phw.hw_addr);\n\t\tif (len) {\n\t\t\tphw.hw_addrlen = htons(len);\n\t\t\tif (nla_put(skb, NFQA_HWADDR, sizeof(phw), &phw))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (entskb->tstamp.tv64) {\n\t\tstruct nfqnl_msg_packet_timestamp ts;\n\t\tstruct timeval tv = ktime_to_timeval(entskb->tstamp);\n\t\tts.sec = cpu_to_be64(tv.tv_sec);\n\t\tts.usec = cpu_to_be64(tv.tv_usec);\n\n\t\tif (nla_put(skb, NFQA_TIMESTAMP, sizeof(ts), &ts))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif ((queue->flags & NFQA_CFG_F_UID_GID) && entskb->sk &&\n\t    nfqnl_put_sk_uidgid(skb, entskb->sk) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (ct && nfqnl_ct_put(skb, ct, ctinfo) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cap_len > data_len &&\n\t    nla_put_be32(skb, NFQA_CAP_LEN, htonl(cap_len)))\n\t\tgoto nla_put_failure;\n\n\tif (nfqnl_put_packet_info(skb, entskb, csum_verify))\n\t\tgoto nla_put_failure;\n\n\tif (data_len) {\n\t\tstruct nlattr *nla;\n\n\t\tif (skb_tailroom(skb) < sizeof(*nla) + hlen)\n\t\t\tgoto nla_put_failure;\n\n\t\tnla = (struct nlattr *)skb_put(skb, sizeof(*nla));\n\t\tnla->nla_type = NFQA_PAYLOAD;\n\t\tnla->nla_len = nla_attr_size(data_len);\n\n\t\tskb_zerocopy(skb, entskb, data_len, hlen);\n\t}\n\n\tnlh->nlmsg_len = skb->len;\n\treturn skb;\n\nnla_put_failure:\n\tkfree_skb(skb);\n\tnet_err_ratelimited(\"nf_queue: error creating packet message\\n\");\n\treturn NULL;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "net",
        "commit_id": "36d5fe6a000790f56039afe26834265db0a3ad4c",
        "hash": 317943166861995623271320624382963904349,
        "size": 220,
        "message": "core, nfqueue, openvswitch: Orphan frags in skb_zerocopy and handle errors\n\nskb_zerocopy can copy elements of the frags array between skbs, but it doesn't\norphan them. Also, it doesn't handle errors, so this patch takes care of that\nas well, and modify the callers accordingly. skb_tx_error() is also added to\nthe callers so they will signal the failed delivery towards the creator of the\nskb.\n\nSigned-off-by: Zoltan Kiss <zoltan.kiss@citrix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "skb_zerocopy(struct sk_buff *to, const struct sk_buff *from, int len, int hlen)\n{\n\tint i, j = 0;\n\tint plen = 0; /* length of skb->head fragment */\n\tstruct page *page;\n\tunsigned int offset;\n\n\tBUG_ON(!from->head_frag && !hlen);\n\n\t/* dont bother with small payloads */\n\tif (len <= skb_tailroom(to)) {\n\t\tskb_copy_bits(from, 0, skb_put(to, len), len);\n\t\treturn;\n\t}\n\n\tif (hlen) {\n\t\tskb_copy_bits(from, 0, skb_put(to, hlen), hlen);\n\t\tlen -= hlen;\n\t} else {\n\t\tplen = min_t(int, skb_headlen(from), len);\n\t\tif (plen) {\n\t\t\tpage = virt_to_head_page(from->head);\n\t\t\toffset = from->data - (unsigned char *)page_address(page);\n\t\t\t__skb_fill_page_desc(to, 0, page, offset, plen);\n\t\t\tget_page(page);\n\t\t\tj = 1;\n\t\t\tlen -= plen;\n\t\t}\n\t}\n\n\tto->truesize += len + plen;\n\tto->len += len + plen;\n\tto->data_len += len + plen;\n\n\tfor (i = 0; i < skb_shinfo(from)->nr_frags; i++) {\n\t\tif (!len)\n\t\t\tbreak;\n\t\tskb_shinfo(to)->frags[j] = skb_shinfo(from)->frags[i];\n\t\tskb_shinfo(to)->frags[j].size = min_t(int, skb_shinfo(to)->frags[j].size, len);\n\t\tlen -= skb_shinfo(to)->frags[j].size;\n\t\tskb_frag_ref(to, j);\n\t\tj++;\n\t}\n\tskb_shinfo(to)->nr_frags = j;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "net",
        "commit_id": "36d5fe6a000790f56039afe26834265db0a3ad4c",
        "hash": 42058540119202125587503818784485992412,
        "size": 45,
        "message": "core, nfqueue, openvswitch: Orphan frags in skb_zerocopy and handle errors\n\nskb_zerocopy can copy elements of the frags array between skbs, but it doesn't\norphan them. Also, it doesn't handle errors, so this patch takes care of that\nas well, and modify the callers accordingly. skb_tx_error() is also added to\nthe callers so they will signal the failed delivery towards the creator of the\nskb.\n\nSigned-off-by: Zoltan Kiss <zoltan.kiss@citrix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info = get_current_groups();\n\tint i, j, count = group_info->ngroups;\n\tkgid_t low, high;\n\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tcount -= cp_count;\n\t}\n\n\treturn -EACCES;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "net",
        "commit_id": "b04c46190219a4f845e46a459e3102137b7f6cac",
        "hash": 68750851989058394599616531965961612224,
        "size": 25,
        "message": "net: ipv4: current group_info should be put after using.\n\nPlug a group_info refcount leak in ping_init.\ngroup_info is only needed during initialization and\nthe code failed to release the reference on exit.\nWhile here move grabbing the reference to a place\nwhere it is actually needed.\n\nSigned-off-by: Chuansheng Liu <chuansheng.liu@intel.com>\nSigned-off-by: Zhang Dongxing <dongxing.zhang@intel.com>\nSigned-off-by: xiaoming wang <xiaoming.wang@intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\t/* We don't need a base pointer in the /proc filesystem */\n\tpath_put(&nd->path);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-362",
            "CWE-416"
        ],
        "project": "linux",
        "commit_id": "86acdca1b63e6890540fa19495cfc708beff3d8b",
        "hash": 136319961353335967115851107094655129411,
        "size": 17,
        "message": "fix autofs/afs/etc. magic mountpoint breakage\n\nWe end up trying to kfree() nd.last.name on open(\"/mnt/tmp\", O_CREAT)\nif /mnt/tmp is an autofs direct mount.  The reason is that nd.last_type\nis bogus here; we want LAST_BIND for everything of that kind and we\nget LAST_NORM left over from finding parent directory.\n\nSo make sure that it *is* set properly; set to LAST_BIND before\ndoing ->follow_link() - for normal symlinks it will be changed\nby __vfs_follow_link() and everything else needs it set that way.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>"
    },
    {
        "func": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t\tdget(dentry);\n\t}\n\tmntget(path->mnt);\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(cookie);\n\tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-362",
            "CWE-416"
        ],
        "project": "linux",
        "commit_id": "86acdca1b63e6890540fa19495cfc708beff3d8b",
        "hash": 169624171139452673269190838636576487921,
        "size": 31,
        "message": "fix autofs/afs/etc. magic mountpoint breakage\n\nWe end up trying to kfree() nd.last.name on open(\"/mnt/tmp\", O_CREAT)\nif /mnt/tmp is an autofs direct mount.  The reason is that nd.last_type\nis bogus here; we want LAST_BIND for everything of that kind and we\nget LAST_NORM left over from finding parent directory.\n\nSo make sure that it *is* set properly; set to LAST_BIND before\ndoing ->follow_link() - for normal symlinks it will be changed\nby __vfs_follow_link() and everything else needs it set that way.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>"
    },
    {
        "func": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source)\n{\n\tvoid *old_p, *retval;\n\n\tif ((old_p = zend_hash_index_find_ptr(&xlat_table, (zend_ulong)source)) != NULL) {\n\t\t/* we already duplicated this pointer */\n\t\treturn old_p;\n\t}\n\tretval = ZCG(mem);\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tefree(source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "php-src",
        "commit_id": "777c39f4042327eac4b63c7ee87dc1c7a09a3115",
        "hash": 279748979862750298440498249779967822964,
        "size": 17,
        "message": "Fixed #68677"
    },
    {
        "func": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\t/* we already duplicated this pointer */\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "php-src",
        "commit_id": "0a8f28b43212cc2ddbc1f2df710e37b1bec0addd",
        "hash": 299352734408075147829433838475904463433,
        "size": 17,
        "message": "Fixed bug #68677 (Use After Free in OPcache)\n\n(cherry picked from commit 777c39f4042327eac4b63c7ee87dc1c7a09a3115)"
    },
    {
        "func": "parse_keyblock_image (iobuf_t iobuf, int pk_no, int uid_no,\n                      const u32 *sigstatus, kbnode_t *r_keyblock)\n{\n  gpg_error_t err;\n  PACKET *pkt;\n  kbnode_t keyblock = NULL;\n  kbnode_t node, *tail;\n  int in_cert, save_mode;\n  u32 n_sigs;\n  int pk_count, uid_count;\n\n  *r_keyblock = NULL;\n\n  pkt = xtrymalloc (sizeof *pkt);\n  if (!pkt)\n    return gpg_error_from_syserror ();\n  init_packet (pkt);\n  save_mode = set_packet_list_mode (0);\n  in_cert = 0;\n  n_sigs = 0;\n  tail = NULL;\n  pk_count = uid_count = 0;\n  while ((err = parse_packet (iobuf, pkt)) != -1)\n    {\n      if (gpg_err_code (err) == GPG_ERR_UNKNOWN_PACKET)\n        {\n          free_packet (pkt);\n          init_packet (pkt);\n          continue;\n\t}\n      if (err)\n        {\n          log_error (\"parse_keyblock_image: read error: %s\\n\",\n                     gpg_strerror (err));\n          err = gpg_error (GPG_ERR_INV_KEYRING);\n          break;\n        }\n      if (pkt->pkttype == PKT_COMPRESSED)\n        {\n          log_error (\"skipped compressed packet in keybox blob\\n\");\n          free_packet(pkt);\n          init_packet(pkt);\n          continue;\n        }\n      if (pkt->pkttype == PKT_RING_TRUST)\n        {\n          log_info (\"skipped ring trust packet in keybox blob\\n\");\n          free_packet(pkt);\n          init_packet(pkt);\n          continue;\n        }\n\n      if (!in_cert && pkt->pkttype != PKT_PUBLIC_KEY)\n        {\n          log_error (\"parse_keyblock_image: first packet in a keybox blob \"\n                     \"is not a public key packet\\n\");\n          err = gpg_error (GPG_ERR_INV_KEYRING);\n          break;\n        }\n      if (in_cert && (pkt->pkttype == PKT_PUBLIC_KEY\n                      || pkt->pkttype == PKT_SECRET_KEY))\n        {\n          log_error (\"parse_keyblock_image: \"\n                     \"multiple keyblocks in a keybox blob\\n\");\n          err = gpg_error (GPG_ERR_INV_KEYRING);\n          break;\n        }\n      in_cert = 1;\n\n      if (pkt->pkttype == PKT_SIGNATURE && sigstatus)\n        {\n          PKT_signature *sig = pkt->pkt.signature;\n\n          n_sigs++;\n          if (n_sigs > sigstatus[0])\n            {\n              log_error (\"parse_keyblock_image: \"\n                         \"more signatures than found in the meta data\\n\");\n              err = gpg_error (GPG_ERR_INV_KEYRING);\n              break;\n\n            }\n          if (sigstatus[n_sigs])\n            {\n              sig->flags.checked = 1;\n              if (sigstatus[n_sigs] == 1 )\n                ; /* missing key */\n              else if (sigstatus[n_sigs] == 2 )\n                ; /* bad signature */\n              else if (sigstatus[n_sigs] < 0x10000000)\n                ; /* bad flag */\n              else\n                {\n                  sig->flags.valid = 1;\n                  /* Fixme: Shall we set the expired flag here?  */\n                }\n            }\n        }\n\n      node = new_kbnode (pkt);\n\n      switch (pkt->pkttype)\n        {\n        case PKT_PUBLIC_KEY:\n        case PKT_PUBLIC_SUBKEY:\n        case PKT_SECRET_KEY:\n        case PKT_SECRET_SUBKEY:\n          if (++pk_count == pk_no)\n            node->flag |= 1;\n          break;\n\n        case PKT_USER_ID:\n          if (++uid_count == uid_no)\n            node->flag |= 2;\n          break;\n\n        default:\n          break;\n        }\n\n      if (!keyblock)\n        keyblock = node;\n      else\n        *tail = node;\n      tail = &node->next;\n      pkt = xtrymalloc (sizeof *pkt);\n      if (!pkt)\n        {\n          err = gpg_error_from_syserror ();\n          break;\n        }\n      init_packet (pkt);\n    }\n  set_packet_list_mode (save_mode);\n\n  if (err == -1 && keyblock)\n    err = 0; /* Got the entire keyblock.  */\n\n  if (!err && sigstatus && n_sigs != sigstatus[0])\n    {\n      log_error (\"parse_keyblock_image: signature count does not match\\n\");\n      err = gpg_error (GPG_ERR_INV_KEYRING);\n    }\n\n  if (err)\n    release_kbnode (keyblock);\n  else\n    *r_keyblock = keyblock;\n  free_packet (pkt);\n  xfree (pkt);\n  return err;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "gnupg",
        "commit_id": "f0f71a721ccd7ab9e40b8b6b028b59632c0cc648",
        "hash": 46344756122396077344449773357563167734,
        "size": 152,
        "message": "gpg: Prevent an invalid memory read using a garbled keyring.\n\n* g10/keyring.c (keyring_get_keyblock): Whitelist allowed packet\ntypes.\n* g10/keydb.c (parse_keyblock_image): Ditto.\n--\n\nThe keyring DB code did not reject packets which don't belong into a\nkeyring.  If for example the keyblock contains a literal data packet\nit is expected that the processing code stops at the data packet and\nreads from the input stream which is referenced from the data packets.\nObviously the keyring processing code does not and cannot do that.\nHowever, when exporting this messes up the IOBUF and leads to an\ninvalid read of sizeof (int).\n\nWe now skip all packets which are not allowed in a keyring.\n\nReported-by: Hanno B\u00f6ck <hanno@hboeck.de>\n\nTest data:\n\n  gpg2 --no-default-keyring --keyring FILE --export >/dev/null\n\nWith this unpacked data for FILE:\n\n-----BEGIN PGP ARMORED FILE-----\n\nmI0EVNP2zQEEALvETPVDCJDBXkegF4esiV1fqlne40yJnCmJeDEJYocwFPXfFA86\nsSGjInzgDbpbC9gQPwq91Qe9x3Vy81CkyVonPOejhINlzfpzqAAa3A6viJccZTwt\nDJ8E/I9jg53sbYW8q+VgfLn1hlggH/XQRT0HkXMP5y9ClURYnTsNwJhXABEBAAGs\nCXRlc3QgdGVzdIi5BBMBCgAjBQJU0/bNAhsDBwsJCAcDAgEGFQgCCQoLBBYCAwEC\nHgECF4AACgkQlsmuCapsqYLvtQP/byY0tM0Lc3moftbHQZ2eHj9ykLjsCjeMDfPx\nkZUUtUS3HQaqgZLZOeqPjM7XgGh5hJsd9pfhmRWJ0x+iGB47XQNpRTtdLBV/WMCS\nl5z3uW7e9Md7QVUVuSlJnBgQHTS6EgP8JQadPkAiF+jgpJZXP+gFs2j3gobS0qUF\neyTtxs+wAgAD\n=uIt9\n-----END PGP ARMORED FILE-----\n\nSigned-off-by: Werner Koch <wk@gnupg.org>"
    },
    {
        "func": "keyring_get_keyblock (KEYRING_HANDLE hd, KBNODE *ret_kb)\n{\n    PACKET *pkt;\n    int rc;\n    KBNODE keyblock = NULL, node, lastnode;\n    IOBUF a;\n    int in_cert = 0;\n    int pk_no = 0;\n    int uid_no = 0;\n    int save_mode;\n\n    if (ret_kb)\n        *ret_kb = NULL;\n\n    if (!hd->found.kr)\n        return -1; /* no successful search */\n\n    a = iobuf_open (hd->found.kr->fname);\n    if (!a)\n      {\n\tlog_error(_(\"can't open '%s'\\n\"), hd->found.kr->fname);\n\treturn GPG_ERR_KEYRING_OPEN;\n      }\n\n    if (iobuf_seek (a, hd->found.offset) ) {\n        log_error (\"can't seek '%s'\\n\", hd->found.kr->fname);\n\tiobuf_close(a);\n\treturn GPG_ERR_KEYRING_OPEN;\n    }\n\n    pkt = xmalloc (sizeof *pkt);\n    init_packet (pkt);\n    hd->found.n_packets = 0;;\n    lastnode = NULL;\n    save_mode = set_packet_list_mode(0);\n    while ((rc=parse_packet (a, pkt)) != -1) {\n        hd->found.n_packets++;\n        if (gpg_err_code (rc) == GPG_ERR_UNKNOWN_PACKET) {\n\t    free_packet (pkt);\n\t    init_packet (pkt);\n\t    continue;\n\t}\n        if (gpg_err_code (rc) == GPG_ERR_LEGACY_KEY)\n          break;  /* Upper layer needs to handle this.  */\n\tif (rc) {\n            log_error (\"keyring_get_keyblock: read error: %s\\n\",\n                       gpg_strerror (rc) );\n            rc = GPG_ERR_INV_KEYRING;\n            break;\n        }\n\tif (pkt->pkttype == PKT_COMPRESSED) {\n\t    log_error (\"skipped compressed packet in keyring\\n\");\n\t    free_packet(pkt);\n\t    init_packet(pkt);\n\t    continue;\n        }\n\n        if (in_cert && (pkt->pkttype == PKT_PUBLIC_KEY\n                        || pkt->pkttype == PKT_SECRET_KEY)) {\n            hd->found.n_packets--; /* fix counter */\n            break; /* ready */\n        }\n\n        in_cert = 1;\n        if (pkt->pkttype == PKT_RING_TRUST)\n          {\n            /*(this code is duplicated after the loop)*/\n            if ( lastnode\n                 && lastnode->pkt->pkttype == PKT_SIGNATURE\n                 && (pkt->pkt.ring_trust->sigcache & 1) ) {\n                /* This is a ring trust packet with a checked signature\n                 * status cache following directly a signature paket.\n                 * Set the cache status into that signature packet.  */\n                PKT_signature *sig = lastnode->pkt->pkt.signature;\n\n                sig->flags.checked = 1;\n                sig->flags.valid = !!(pkt->pkt.ring_trust->sigcache & 2);\n            }\n            /* Reset LASTNODE, so that we set the cache status only from\n             * the ring trust packet immediately following a signature. */\n            lastnode = NULL;\n\t    free_packet(pkt);\n\t    init_packet(pkt);\n\t    continue;\n          }\n\n\n        node = lastnode = new_kbnode (pkt);\n        if (!keyblock)\n          keyblock = node;\n        else\n          add_kbnode (keyblock, node);\n        switch (pkt->pkttype)\n          {\n          case PKT_PUBLIC_KEY:\n          case PKT_PUBLIC_SUBKEY:\n          case PKT_SECRET_KEY:\n          case PKT_SECRET_SUBKEY:\n            if (++pk_no == hd->found.pk_no)\n              node->flag |= 1;\n            break;\n\n          case PKT_USER_ID:\n            if (++uid_no == hd->found.uid_no)\n              node->flag |= 2;\n            break;\n\n          default:\n            break;\n          }\n\n        pkt = xmalloc (sizeof *pkt);\n        init_packet(pkt);\n    }\n    set_packet_list_mode(save_mode);\n\n    if (rc == -1 && keyblock)\n\trc = 0; /* got the entire keyblock */\n\n    if (rc || !ret_kb)\n\trelease_kbnode (keyblock);\n    else {\n        /*(duplicated form the loop body)*/\n        if ( pkt && pkt->pkttype == PKT_RING_TRUST\n             && lastnode\n             && lastnode->pkt->pkttype == PKT_SIGNATURE\n             && (pkt->pkt.ring_trust->sigcache & 1) ) {\n            PKT_signature *sig = lastnode->pkt->pkt.signature;\n            sig->flags.checked = 1;\n            sig->flags.valid = !!(pkt->pkt.ring_trust->sigcache & 2);\n        }\n\t*ret_kb = keyblock;\n    }\n    free_packet (pkt);\n    xfree (pkt);\n    iobuf_close(a);\n\n    /* Make sure that future search operations fail immediately when\n     * we know that we are working on a invalid keyring\n     */\n    if (gpg_err_code (rc) == GPG_ERR_INV_KEYRING)\n        hd->current.error = rc;\n\n    return rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "gnupg",
        "commit_id": "f0f71a721ccd7ab9e40b8b6b028b59632c0cc648",
        "hash": 106587484339562821907928237418141295349,
        "size": 145,
        "message": "gpg: Prevent an invalid memory read using a garbled keyring.\n\n* g10/keyring.c (keyring_get_keyblock): Whitelist allowed packet\ntypes.\n* g10/keydb.c (parse_keyblock_image): Ditto.\n--\n\nThe keyring DB code did not reject packets which don't belong into a\nkeyring.  If for example the keyblock contains a literal data packet\nit is expected that the processing code stops at the data packet and\nreads from the input stream which is referenced from the data packets.\nObviously the keyring processing code does not and cannot do that.\nHowever, when exporting this messes up the IOBUF and leads to an\ninvalid read of sizeof (int).\n\nWe now skip all packets which are not allowed in a keyring.\n\nReported-by: Hanno B\u00f6ck <hanno@hboeck.de>\n\nTest data:\n\n  gpg2 --no-default-keyring --keyring FILE --export >/dev/null\n\nWith this unpacked data for FILE:\n\n-----BEGIN PGP ARMORED FILE-----\n\nmI0EVNP2zQEEALvETPVDCJDBXkegF4esiV1fqlne40yJnCmJeDEJYocwFPXfFA86\nsSGjInzgDbpbC9gQPwq91Qe9x3Vy81CkyVonPOejhINlzfpzqAAa3A6viJccZTwt\nDJ8E/I9jg53sbYW8q+VgfLn1hlggH/XQRT0HkXMP5y9ClURYnTsNwJhXABEBAAGs\nCXRlc3QgdGVzdIi5BBMBCgAjBQJU0/bNAhsDBwsJCAcDAgEGFQgCCQoLBBYCAwEC\nHgECF4AACgkQlsmuCapsqYLvtQP/byY0tM0Lc3moftbHQZ2eHj9ykLjsCjeMDfPx\nkZUUtUS3HQaqgZLZOeqPjM7XgGh5hJsd9pfhmRWJ0x+iGB47XQNpRTtdLBV/WMCS\nl5z3uW7e9Md7QVUVuSlJnBgQHTS6EgP8JQadPkAiF+jgpJZXP+gFs2j3gobS0qUF\neyTtxs+wAgAD\n=uIt9\n-----END PGP ARMORED FILE-----\n\nSigned-off-by: Werner Koch <wk@gnupg.org>"
    },
    {
        "func": "static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC) /* {{{ */\n{\n\tconst char *oldname = NULL;\n\tchar *oldpath = NULL;\n\tchar *basename = NULL, *basepath = NULL;\n\tchar *newname = NULL, *newpath = NULL;\n\tzval *ret, arg1;\n\tzend_class_entry *ce;\n\tchar *error;\n\tconst char *pcr_error;\n\tint ext_len = ext ? strlen(ext) : 0;\n\tint oldname_len;\n\tphar_archive_data **pphar = NULL;\n\tphp_stream_statbuf ssb;\n\n\tif (!ext) {\n\t\tif (phar->is_zip) {\n\n\t\t\tif (phar->is_data) {\n\t\t\t\text = \"zip\";\n\t\t\t} else {\n\t\t\t\text = \"phar.zip\";\n\t\t\t}\n\n\t\t} else if (phar->is_tar) {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.gz\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.gz\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.bz2\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.bz2\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar\";\n\t\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\text = \"phar.gz\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\text = \"phar.bz2\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\text = \"phar\";\n\t\t\t}\n\t\t}\n\t} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {\n\n\t\tif (phar->is_data) {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (ext[0] == '.') {\n\t\t++ext;\n\t}\n\n\toldpath = estrndup(phar->fname, phar->fname_len);\n\toldname = zend_memrchr(phar->fname, '/', phar->fname_len);\n\t++oldname;\n\toldname_len = strlen(oldname);\n\n\tbasename = estrndup(oldname, oldname_len);\n\tspprintf(&newname, 0, \"%s.%s\", strtok(basename, \".\"), ext);\n\tefree(basename);\n\n\t\n\n\tbasepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));\n\tphar->fname_len = spprintf(&newpath, 0, \"%s%s\", basepath, newname);\n\tphar->fname = newpath;\n\tphar->ext = newpath + phar->fname_len - strlen(ext) - 1;\n\tefree(basepath);\n\tefree(newname);\n\n\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, new phar name is in phar.cache_list\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {\n\t\tif ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {\n\t\t\tif (!zend_hash_num_elements(&phar->manifest)) {\n\t\t\t\t(*pphar)->is_tar = phar->is_tar;\n\t\t\t\t(*pphar)->is_zip = phar->is_zip;\n\t\t\t\t(*pphar)->is_data = phar->is_data;\n\t\t\t\t(*pphar)->flags = phar->flags;\n\t\t\t\t(*pphar)->fp = phar->fp;\n\t\t\t\tphar->fp = NULL;\n\t\t\t\tphar_destroy_phar_data(phar TSRMLS_CC);\n\t\t\t\tphar = *pphar;\n\t\t\t\tphar->refcount++;\n\t\t\t\tnewpath = oldpath;\n\t\t\t\tgoto its_ok;\n\t\t\t}\n\t\t}\n\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, a phar with that name already exists\", phar->fname);\n\t\treturn NULL;\n\t}\nits_ok:\n\tif (SUCCESS == php_stream_stat_path(newpath, &ssb)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" exists and must be unlinked prior to conversion\", newpath);\n\t\treturn NULL;\n\t}\n\tif (!phar->is_data) {\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (phar->alias) {\n\t\t\tif (phar->is_temporary_alias) {\n\t\t\t\tphar->alias = NULL;\n\t\t\t\tphar->alias_len = 0;\n\t\t\t} else {\n\t\t\t\tphar->alias = estrndup(newpath, strlen(newpath));\n\t\t\t\tphar->alias_len = strlen(newpath);\n\t\t\t\tphar->is_temporary_alias = 1;\n\t\t\t\tzend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tphar->alias = NULL;\n\t\tphar->alias_len = 0;\n\t}\n\n\tif ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tphar_flush(phar, 0, 0, 1, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t\tefree(oldpath);\n\t\treturn NULL;\n\t}\n\n\tefree(oldpath);\n\n\tif (phar->is_data) {\n\t\tce = phar_ce_data;\n\t} else {\n\t\tce = phar_ce_archive;\n\t}\n\n\tMAKE_STD_ZVAL(ret);\n\n\tif (SUCCESS != object_init_ex(ret, ce)) {\n\t\tzval_dtor(ret);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate phar object when converting archive \\\"%s\\\"\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tINIT_PZVAL(&arg1);\n\tZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);\n\n\tzend_call_method_with_1_params(&ret, ce, &ce->constructor, \"__construct\", NULL, &arg1);\n\treturn ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "php-src",
        "commit_id": "b2cf3f064b8f5efef89bb084521b61318c71781b",
        "hash": 55514648493563640623085659819286233714,
        "size": 194,
        "message": "Fixed bug #68901 (use after free)"
    },
    {
        "func": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\n\terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { /* trailing symlink */\n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tpath_cleanup(nd);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}",
        "target": 1,
        "cwe": [
            "CWE-416"
        ],
        "project": "linux",
        "commit_id": "f15133df088ecadd141ea1907f2c96df67c729f0",
        "hash": 139007575312172811894863838395435351207,
        "size": 61,
        "message": "path_openat(): fix double fput()\n\npath_openat() jumps to the wrong place after do_tmpfile() - it has\nalready done path_cleanup() (as part of path_lookupat() called by\ndo_tmpfile()), so doing that again can lead to double fput().\n\nCc: stable@vger.kernel.org\t# v3.11+\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>"
    },
    {
        "func": "static NTSTATUS smb_set_file_unix_link(connection_struct *conn,\n\t\t\t\t       struct smb_request *req,\n\t\t\t\t       const char *pdata,\n\t\t\t\t       int total_data,\n\t\t\t\t       const struct smb_filename *smb_fname)\n{\n\tchar *link_target = NULL;\n\tconst char *newname = smb_fname->base_name;\n\tNTSTATUS status = NT_STATUS_OK;\n\tTALLOC_CTX *ctx = talloc_tos();\n\n\t/* Set a symbolic link. */\n\t/* Don't allow this if follow links is false. */\n\n\tif (total_data == 0) {\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\tif (!lp_symlinks(SNUM(conn))) {\n\t\treturn NT_STATUS_ACCESS_DENIED;\n\t}\n\n\tsrvstr_pull_talloc(ctx, pdata, req->flags2, &link_target, pdata,\n\t\t    total_data, STR_TERMINATE);\n\n\tif (!link_target) {\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\t/* !widelinks forces the target path to be within the share. */\n\t/* This means we can interpret the target as a pathname. */\n\tif (!lp_widelinks(SNUM(conn))) {\n\t\tchar *rel_name = NULL;\n\t\tchar *last_dirp = NULL;\n\n\t\tif (*link_target == '/') {\n\t\t\t/* No absolute paths allowed. */\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n\t\t}\n\t\trel_name = talloc_strdup(ctx,newname);\n\t\tif (!rel_name) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tlast_dirp = strrchr_m(rel_name, '/');\n\t\tif (last_dirp) {\n\t\t\tlast_dirp[1] = '\\0';\n\t\t} else {\n\t\t\trel_name = talloc_strdup(ctx,\"./\");\n\t\t\tif (!rel_name) {\n\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t}\n\t\t}\n\t\trel_name = talloc_asprintf_append(rel_name,\n\t\t\t\t\"%s\",\n\t\t\t\tlink_target);\n\t\tif (!rel_name) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\tstatus = check_name(conn, rel_name);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tDEBUG(10,(\"smb_set_file_unix_link: SMB_SET_FILE_UNIX_LINK doing symlink %s -> %s\\n\",\n\t\t\tnewname, link_target ));\n\n\tif (SMB_VFS_SYMLINK(conn,link_target,newname) != 0) {\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\n\treturn NT_STATUS_OK;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "samba",
        "commit_id": "bd269443e311d96ef495a9db47d1b95eb83bb8f4",
        "hash": 50610553973009064620922486896934754771,
        "size": 74,
        "message": "Fix bug 7104 - \"wide links\" and \"unix extensions\" are incompatible.\n\nChange parameter \"wide links\" to default to \"no\".\nEnsure \"wide links = no\" if \"unix extensions = yes\" on a share.\nFix man pages to refect this.\n\nRemove \"within share\" checks for a UNIX symlink set - even if\nwidelinks = no. The server will not follow that link anyway.\n\nCorrect DEBUG message in check_reduced_name() to add missing \"\\n\"\nso it's really clear when a path is being denied as it's outside\nthe enclosing share path.\n\nJeremy."
    },
    {
        "func": "connection_struct *make_connection_snum(struct smbd_server_connection *sconn,\n\t\t\t\t\tint snum, user_struct *vuser,\n\t\t\t\t\tDATA_BLOB password,\n\t\t\t\t\tconst char *pdev,\n\t\t\t\t\tNTSTATUS *pstatus)\n{\n\tconnection_struct *conn;\n\tstruct smb_filename *smb_fname_cpath = NULL;\n\tfstring dev;\n\tint ret;\n\tchar addr[INET6_ADDRSTRLEN];\n\tbool on_err_call_dis_hook = false;\n\tNTSTATUS status;\n\n\tfstrcpy(dev, pdev);\n\n\tif (NT_STATUS_IS_ERR(*pstatus = share_sanity_checks(snum, dev))) {\n\t\treturn NULL;\n\t}\t\n\n\tconn = conn_new(sconn);\n\tif (!conn) {\n\t\tDEBUG(0,(\"Couldn't find free connection.\\n\"));\n\t\t*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;\n\t\treturn NULL;\n\t}\n\n\tconn->params->service = snum;\n\n\tstatus = create_connection_server_info(sconn,\n\t\tconn, snum, vuser ? vuser->server_info : NULL, password,\n\t\t&conn->server_info);\n\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tDEBUG(1, (\"create_connection_server_info failed: %s\\n\",\n\t\t\t  nt_errstr(status)));\n\t\t*pstatus = status;\n\t\tconn_free(conn);\n\t\treturn NULL;\n\t}\n\n\tif ((lp_guest_only(snum)) || (lp_security() == SEC_SHARE)) {\n\t\tconn->force_user = true;\n\t}\n\n\tadd_session_user(sconn, conn->server_info->unix_name);\n\n\tsafe_strcpy(conn->client_address,\n\t\t\tclient_addr(get_client_fd(),addr,sizeof(addr)), \n\t\t\tsizeof(conn->client_address)-1);\n\tconn->num_files_open = 0;\n\tconn->lastused = conn->lastused_count = time(NULL);\n\tconn->used = True;\n\tconn->printer = (strncmp(dev,\"LPT\",3) == 0);\n\tconn->ipc = ( (strncmp(dev,\"IPC\",3) == 0) ||\n\t\t      ( lp_enable_asu_support() && strequal(dev,\"ADMIN$\")) );\n\n\t/* Case options for the share. */\n\tif (lp_casesensitive(snum) == Auto) {\n\t\t/* We will be setting this per packet. Set to be case\n\t\t * insensitive for now. */\n\t\tconn->case_sensitive = False;\n\t} else {\n\t\tconn->case_sensitive = (bool)lp_casesensitive(snum);\n\t}\n\n\tconn->case_preserve = lp_preservecase(snum);\n\tconn->short_case_preserve = lp_shortpreservecase(snum);\n\n\tconn->encrypt_level = lp_smb_encrypt(snum);\n\n\tconn->veto_list = NULL;\n\tconn->hide_list = NULL;\n\tconn->veto_oplock_list = NULL;\n\tconn->aio_write_behind_list = NULL;\n\n\tconn->read_only = lp_readonly(SNUM(conn));\n\tconn->admin_user = False;\n\n\tif (*lp_force_user(snum)) {\n\n\t\t/*\n\t\t * Replace conn->server_info with a completely faked up one\n\t\t * from the username we are forced into :-)\n\t\t */\n\n\t\tchar *fuser;\n\t\tstruct auth_serversupplied_info *forced_serverinfo;\n\n\t\tfuser = talloc_string_sub(conn, lp_force_user(snum), \"%S\",\n\t\t\t\t\t  lp_servicename(snum));\n\t\tif (fuser == NULL) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstatus = make_serverinfo_from_username(\n\t\t\tconn, fuser, conn->server_info->guest,\n\t\t\t&forced_serverinfo);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = status;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tTALLOC_FREE(conn->server_info);\n\t\tconn->server_info = forced_serverinfo;\n\n\t\tconn->force_user = True;\n\t\tDEBUG(3,(\"Forced user %s\\n\", fuser));\n\t}\n\n\t/*\n\t * If force group is true, then override\n\t * any groupid stored for the connecting user.\n\t */\n\n\tif (*lp_force_group(snum)) {\n\n\t\tstatus = find_forced_group(\n\t\t\tconn->force_user, snum, conn->server_info->unix_name,\n\t\t\t&conn->server_info->ptok->user_sids[1],\n\t\t\t&conn->server_info->utok.gid);\n\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = status;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * We need to cache this gid, to use within\n \t\t * change_to_user() separately from the conn->server_info\n \t\t * struct. We only use conn->server_info directly if\n \t\t * \"force_user\" was set.\n \t\t */\n\t\tconn->force_group_gid = conn->server_info->utok.gid;\n\t}\n\n\tconn->vuid = (vuser != NULL) ? vuser->vuid : UID_FIELD_INVALID;\n\n\t{\n\t\tchar *s = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_pathname(snum));\n\t\tif (!s) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!set_conn_connectpath(conn,s)) {\n\t\t\tTALLOC_FREE(s);\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\t\tDEBUG(3,(\"Connect path is '%s' for service [%s]\\n\",s,\n\t\t\t lp_servicename(snum)));\n\t\tTALLOC_FREE(s);\n\t}\n\n\t/*\n\t * New code to check if there's a share security descripter\n\t * added from NT server manager. This is done after the\n\t * smb.conf checks are done as we need a uid and token. JRA.\n\t *\n\t */\n\n\t{\n\t\tbool can_write = False;\n\n\t\tcan_write = share_access_check(conn->server_info->ptok,\n\t\t\t\t\t       lp_servicename(snum),\n\t\t\t\t\t       FILE_WRITE_DATA);\n\n\t\tif (!can_write) {\n\t\t\tif (!share_access_check(conn->server_info->ptok,\n\t\t\t\t\t\tlp_servicename(snum),\n\t\t\t\t\t\tFILE_READ_DATA)) {\n\t\t\t\t/* No access, read or write. */\n\t\t\t\tDEBUG(0,(\"make_connection: connection to %s \"\n\t\t\t\t\t \"denied due to security \"\n\t\t\t\t\t \"descriptor.\\n\",\n\t\t\t\t\t  lp_servicename(snum)));\n\t\t\t\tconn_free(conn);\n\t\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tconn->read_only = True;\n\t\t\t}\n\t\t}\n\t}\n\t/* Initialise VFS function pointers */\n\n\tif (!smbd_vfs_init(conn)) {\n\t\tDEBUG(0, (\"vfs_init failed for service %s\\n\",\n\t\t\t  lp_servicename(snum)));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If widelinks are disallowed we need to canonicalise the connect\n\t * path here to ensure we don't have any symlinks in the\n\t * connectpath. We will be checking all paths on this connection are\n\t * below this directory. We must do this after the VFS init as we\n\t * depend on the realpath() pointer in the vfs table. JRA.\n\t */\n\tif (!lp_widelinks(snum)) {\n\t\tif (!canonicalize_connect_path(conn)) {\n\t\t\tDEBUG(0, (\"canonicalize_connect_path failed \"\n\t\t\t\"for service %s, path %s\\n\",\n\t\t\t\tlp_servicename(snum),\n\t\t\t\tconn->connectpath));\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif ((!conn->printer) && (!conn->ipc)) {\n\t\tconn->notify_ctx = notify_init(conn, server_id_self(),\n\t\t\t\t\t       smbd_messaging_context(),\n\t\t\t\t\t       smbd_event_context(),\n\t\t\t\t\t       conn);\n\t}\n\n/* ROOT Activities: */\t\n\t/*\n\t * Enforce the max connections parameter.\n\t */\n\n\tif ((lp_max_connections(snum) > 0)\n\t    && (count_current_connections(lp_servicename(SNUM(conn)), True) >=\n\t\tlp_max_connections(snum))) {\n\n\t\tDEBUG(1, (\"Max connections (%d) exceeded for %s\\n\",\n\t\t\t  lp_max_connections(snum), lp_servicename(snum)));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;\n\t\treturn NULL;\n\t}  \n\n\t/*\n\t * Get us an entry in the connections db\n\t */\n\tif (!claim_connection(conn, lp_servicename(snum), 0)) {\n\t\tDEBUG(1, (\"Could not store connections entry\\n\"));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_INTERNAL_DB_ERROR;\n\t\treturn NULL;\n\t}  \n\n\t/* Preexecs are done here as they might make the dir we are to ChDir\n\t * to below */\n\t/* execute any \"root preexec = \" line */\n\tif (*lp_rootpreexec(snum)) {\n\t\tchar *cmd = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_rootpreexec(snum));\n\t\tDEBUG(5,(\"cmd=%s\\n\",cmd));\n\t\tret = smbrun(cmd,NULL);\n\t\tTALLOC_FREE(cmd);\n\t\tif (ret != 0 && lp_rootpreexec_close(snum)) {\n\t\t\tDEBUG(1,(\"root preexec gave %d - failing \"\n\t\t\t\t \"connection\\n\", ret));\n\t\t\tyield_connection(conn, lp_servicename(snum));\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n/* USER Activites: */\n\tif (!change_to_user(conn, conn->vuid)) {\n\t\t/* No point continuing if they fail the basic checks */\n\t\tDEBUG(0,(\"Can't become connected user!\\n\"));\n\t\tyield_connection(conn, lp_servicename(snum));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_LOGON_FAILURE;\n\t\treturn NULL;\n\t}\n\n\t/* Remember that a different vuid can connect later without these\n\t * checks... */\n\t\n\t/* Preexecs are done here as they might make the dir we are to ChDir\n\t * to below */\n\n\t/* execute any \"preexec = \" line */\n\tif (*lp_preexec(snum)) {\n\t\tchar *cmd = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_preexec(snum));\n\t\tret = smbrun(cmd,NULL);\n\t\tTALLOC_FREE(cmd);\n\t\tif (ret != 0 && lp_preexec_close(snum)) {\n\t\t\tDEBUG(1,(\"preexec gave %d - failing connection\\n\",\n\t\t\t\t ret));\n\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\tgoto err_root_exit;\n\t\t}\n\t}\n\n#ifdef WITH_FAKE_KASERVER\n\tif (lp_afs_share(snum)) {\n\t\tafs_login(conn);\n\t}\n#endif\n\t\n\t/* Add veto/hide lists */\n\tif (!IS_IPC(conn) && !IS_PRINT(conn)) {\n\t\tset_namearray( &conn->veto_list, lp_veto_files(snum));\n\t\tset_namearray( &conn->hide_list, lp_hide_files(snum));\n\t\tset_namearray( &conn->veto_oplock_list, lp_veto_oplocks(snum));\n\t\tset_namearray( &conn->aio_write_behind_list,\n\t\t\t\tlp_aio_write_behind(snum));\n\t}\n\t\n\t/* Invoke VFS make connection hook - do this before the VFS_STAT call\n\t   to allow any filesystems needing user credentials to initialize\n\t   themselves. */\n\n\tif (SMB_VFS_CONNECT(conn, lp_servicename(snum),\n\t\t\t    conn->server_info->unix_name) < 0) {\n\t\tDEBUG(0,(\"make_connection: VFS make connection failed!\\n\"));\n\t\t*pstatus = NT_STATUS_UNSUCCESSFUL;\n\t\tgoto err_root_exit;\n\t}\n\n\t/* Any error exit after here needs to call the disconnect hook. */\n\ton_err_call_dis_hook = true;\n\n\tstatus = create_synthetic_smb_fname(talloc_tos(), conn->connectpath,\n\t\t\t\t\t    NULL, NULL, &smb_fname_cpath);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\t*pstatus = status;\n\t\tgoto err_root_exit;\n\t}\n\n\t/* win2000 does not check the permissions on the directory\n\t   during the tree connect, instead relying on permission\n\t   check during individual operations. To match this behaviour\n\t   I have disabled this chdir check (tridge) */\n\t/* the alternative is just to check the directory exists */\n\tif ((ret = SMB_VFS_STAT(conn, smb_fname_cpath)) != 0 ||\n\t    !S_ISDIR(smb_fname_cpath->st.st_ex_mode)) {\n\t\tif (ret == 0 && !S_ISDIR(smb_fname_cpath->st.st_ex_mode)) {\n\t\t\tDEBUG(0,(\"'%s' is not a directory, when connecting to \"\n\t\t\t\t \"[%s]\\n\", conn->connectpath,\n\t\t\t\t lp_servicename(snum)));\n\t\t} else {\n\t\t\tDEBUG(0,(\"'%s' does not exist or permission denied \"\n\t\t\t\t \"when connecting to [%s] Error was %s\\n\",\n\t\t\t\t conn->connectpath, lp_servicename(snum),\n\t\t\t\t strerror(errno) ));\n\t\t}\n\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\tgoto err_root_exit;\n\t}\n\n\tstring_set(&conn->origpath,conn->connectpath);\n\n#if SOFTLINK_OPTIMISATION\n\t/* resolve any soft links early if possible */\n\tif (vfs_ChDir(conn,conn->connectpath) == 0) {\n\t\tTALLOC_CTX *ctx = talloc_tos();\n\t\tchar *s = vfs_GetWd(ctx,s);\n\t\tif (!s) {\n\t\t\t*status = map_nt_error_from_unix(errno);\n\t\t\tgoto err_root_exit;\n\t\t}\n\t\tif (!set_conn_connectpath(conn,s)) {\n\t\t\t*status = NT_STATUS_NO_MEMORY;\n\t\t\tgoto err_root_exit;\n\t\t}\n\t\tvfs_ChDir(conn,conn->connectpath);\n\t}\n#endif\n\n\t/* Figure out the characteristics of the underlying filesystem. This\n\t * assumes that all the filesystem mounted withing a share path have\n\t * the same characteristics, which is likely but not guaranteed.\n\t */\n\n\tconn->fs_capabilities = SMB_VFS_FS_CAPABILITIES(conn, &conn->ts_res);\n\n\t/*\n\t * Print out the 'connected as' stuff here as we need\n\t * to know the effective uid and gid we will be using\n\t * (at least initially).\n\t */\n\n\tif( DEBUGLVL( IS_IPC(conn) ? 3 : 1 ) ) {\n\t\tdbgtext( \"%s (%s) \", get_remote_machine_name(),\n\t\t\t conn->client_address );\n\t\tdbgtext( \"%s\", srv_is_signing_active(smbd_server_conn) ? \"signed \" : \"\");\n\t\tdbgtext( \"connect to service %s \", lp_servicename(snum) );\n\t\tdbgtext( \"initially as user %s \",\n\t\t\t conn->server_info->unix_name );\n\t\tdbgtext( \"(uid=%d, gid=%d) \", (int)geteuid(), (int)getegid() );\n\t\tdbgtext( \"(pid %d)\\n\", (int)sys_getpid() );\n\t}\n\n\t/* we've finished with the user stuff - go back to root */\n\tchange_to_root_user();\n\treturn(conn);\n\n  err_root_exit:\n\tTALLOC_FREE(smb_fname_cpath);\n\tchange_to_root_user();\n\tif (on_err_call_dis_hook) {\n\t\t/* Call VFS disconnect hook */\n\t\tSMB_VFS_DISCONNECT(conn);\n\t}\n\tyield_connection(conn, lp_servicename(snum));\n\tconn_free(conn);\n\treturn NULL;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "samba",
        "commit_id": "bd269443e311d96ef495a9db47d1b95eb83bb8f4",
        "hash": 322712926393091497386259417985684201014,
        "size": 437,
        "message": "Fix bug 7104 - \"wide links\" and \"unix extensions\" are incompatible.\n\nChange parameter \"wide links\" to default to \"no\".\nEnsure \"wide links = no\" if \"unix extensions = yes\" on a share.\nFix man pages to refect this.\n\nRemove \"within share\" checks for a UNIX symlink set - even if\nwidelinks = no. The server will not follow that link anyway.\n\nCorrect DEBUG message in check_reduced_name() to add missing \"\\n\"\nso it's really clear when a path is being denied as it's outside\nthe enclosing share path.\n\nJeremy."
    },
    {
        "func": "NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)\n{\n#ifdef REALPATH_TAKES_NULL\n\tbool free_resolved_name = True;\n#else\n        char resolved_name_buf[PATH_MAX+1];\n\tbool free_resolved_name = False;\n#endif\n\tchar *resolved_name = NULL;\n\tchar *p = NULL;\n\n\tDEBUG(3,(\"check_reduced_name [%s] [%s]\\n\", fname, conn->connectpath));\n\n#ifdef REALPATH_TAKES_NULL\n\tresolved_name = SMB_VFS_REALPATH(conn,fname,NULL);\n#else\n\tresolved_name = SMB_VFS_REALPATH(conn,fname,resolved_name_buf);\n#endif\n\n\tif (!resolved_name) {\n\t\tswitch (errno) {\n\t\t\tcase ENOTDIR:\n\t\t\t\tDEBUG(3,(\"check_reduced_name: Component not a \"\n\t\t\t\t\t \"directory in getting realpath for \"\n\t\t\t\t\t \"%s\\n\", fname));\n\t\t\t\treturn NT_STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tcase ENOENT:\n\t\t\t{\n\t\t\t\tTALLOC_CTX *ctx = talloc_tos();\n\t\t\t\tchar *tmp_fname = NULL;\n\t\t\t\tchar *last_component = NULL;\n\t\t\t\t/* Last component didn't exist. Remove it and try and canonicalise the directory. */\n\n\t\t\t\ttmp_fname = talloc_strdup(ctx, fname);\n\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tp = strrchr_m(tmp_fname, '/');\n\t\t\t\tif (p) {\n\t\t\t\t\t*p++ = '\\0';\n\t\t\t\t\tlast_component = p;\n\t\t\t\t} else {\n\t\t\t\t\tlast_component = tmp_fname;\n\t\t\t\t\ttmp_fname = talloc_strdup(ctx,\n\t\t\t\t\t\t\t\".\");\n\t\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef REALPATH_TAKES_NULL\n\t\t\t\tresolved_name = SMB_VFS_REALPATH(conn,tmp_fname,NULL);\n#else\n\t\t\t\tresolved_name = SMB_VFS_REALPATH(conn,tmp_fname,resolved_name_buf);\n#endif\n\t\t\t\tif (!resolved_name) {\n\t\t\t\t\tNTSTATUS status = map_nt_error_from_unix(errno);\n\n\t\t\t\t\tif (errno == ENOENT || errno == ENOTDIR) {\n\t\t\t\t\t\tstatus = NT_STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\t\t\t}\n\n\t\t\t\t\tDEBUG(3,(\"check_reduce_named: \"\n\t\t\t\t\t\t \"couldn't get realpath for \"\n\t\t\t\t\t\t \"%s (%s)\\n\",\n\t\t\t\t\t\tfname,\n\t\t\t\t\t\tnt_errstr(status)));\n\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t\ttmp_fname = talloc_asprintf(ctx,\n\t\t\t\t\t\t\"%s/%s\",\n\t\t\t\t\t\tresolved_name,\n\t\t\t\t\t\tlast_component);\n\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n#ifdef REALPATH_TAKES_NULL\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t\tresolved_name = SMB_STRDUP(tmp_fname);\n\t\t\t\tif (!resolved_name) {\n\t\t\t\t\tDEBUG(0, (\"check_reduced_name: malloc \"\n\t\t\t\t\t\t  \"fail for %s\\n\", tmp_fname));\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n#else\n\t\t\t\tsafe_strcpy(resolved_name_buf, tmp_fname, PATH_MAX);\n\t\t\t\tresolved_name = resolved_name_buf;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tDEBUG(1,(\"check_reduced_name: couldn't get \"\n\t\t\t\t\t \"realpath for %s\\n\", fname));\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\t}\n\n\tDEBUG(10,(\"check_reduced_name realpath [%s] -> [%s]\\n\", fname,\n\t\t  resolved_name));\n\n\tif (*resolved_name != '/') {\n\t\tDEBUG(0,(\"check_reduced_name: realpath doesn't return \"\n\t\t\t \"absolute paths !\\n\"));\n\t\tif (free_resolved_name) {\n\t\t\tSAFE_FREE(resolved_name);\n\t\t}\n\t\treturn NT_STATUS_OBJECT_NAME_INVALID;\n\t}\n\n\t/* Check for widelinks allowed. */\n\tif (!lp_widelinks(SNUM(conn))) {\n\t\t    const char *conn_rootdir;\n\n\t\t    conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);\n\t\t    if (conn_rootdir == NULL) {\n\t\t\t    DEBUG(2, (\"check_reduced_name: Could not get \"\n\t\t\t\t      \"conn_rootdir\\n\"));\n\t\t\t    if (free_resolved_name) {\n\t\t\t\t    SAFE_FREE(resolved_name);\n\t\t\t    }\n\t\t\t    return NT_STATUS_ACCESS_DENIED;\n\t\t    }\n\n\t\t    if (strncmp(conn_rootdir, resolved_name,\n\t\t\t\tstrlen(conn_rootdir)) != 0) {\n\t\t\t    DEBUG(2, (\"check_reduced_name: Bad access \"\n\t\t\t\t      \"attempt: %s is a symlink outside the \"\n\t\t\t\t      \"share path\", fname));\n\t\t\t    if (free_resolved_name) {\n\t\t\t\t    SAFE_FREE(resolved_name);\n\t\t\t    }\n\t\t\t    return NT_STATUS_ACCESS_DENIED;\n\t\t    }\n\t}\n\n        /* Check if we are allowing users to follow symlinks */\n        /* Patch from David Clerc <David.Clerc@cui.unige.ch>\n                University of Geneva */\n\n#ifdef S_ISLNK\n        if (!lp_symlinks(SNUM(conn))) {\n\t\tstruct smb_filename *smb_fname = NULL;\n\t\tNTSTATUS status;\n\n\t\tstatus = create_synthetic_smb_fname(talloc_tos(), fname, NULL,\n\t\t\t\t\t\t    NULL, &smb_fname);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tif (free_resolved_name) {\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t}\n                        return status;\n\t\t}\n\n\t\tif ( (SMB_VFS_LSTAT(conn, smb_fname) != -1) &&\n                                (S_ISLNK(smb_fname->st.st_ex_mode)) ) {\n\t\t\tif (free_resolved_name) {\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t}\n                        DEBUG(3,(\"check_reduced_name: denied: file path name \"\n\t\t\t\t \"%s is a symlink\\n\",resolved_name));\n\t\t\tTALLOC_FREE(smb_fname);\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n                }\n\t\tTALLOC_FREE(smb_fname);\n        }\n#endif\n\n\tDEBUG(3,(\"check_reduced_name: %s reduced to %s\\n\", fname,\n\t\t resolved_name));\n\tif (free_resolved_name) {\n\t\tSAFE_FREE(resolved_name);\n\t}\n\treturn NT_STATUS_OK;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "samba",
        "commit_id": "bd269443e311d96ef495a9db47d1b95eb83bb8f4",
        "hash": 58312061691157569648928165653556543873,
        "size": 174,
        "message": "Fix bug 7104 - \"wide links\" and \"unix extensions\" are incompatible.\n\nChange parameter \"wide links\" to default to \"no\".\nEnsure \"wide links = no\" if \"unix extensions = yes\" on a share.\nFix man pages to refect this.\n\nRemove \"within share\" checks for a UNIX symlink set - even if\nwidelinks = no. The server will not follow that link anyway.\n\nCorrect DEBUG message in check_reduced_name() to add missing \"\\n\"\nso it's really clear when a path is being denied as it's outside\nthe enclosing share path.\n\nJeremy."
    },
    {
        "func": "strip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "patch",
        "commit_id": "685a78b6052f4df6eac6d625a545cfb54a6ac0e1",
        "hash": 264885369498121145908754829228247076588,
        "size": 23,
        "message": "Do not let a malicious patch create files above current directory\n\nThis addresses CVE-2010-4651, reported by Jakub Wilk.\nhttps://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-4651\n* src/util.c (strip_leading_slashes): Reject absolute file names\nand file names containing a component of \"..\".\n* tests/bad-filenames: New file.  Test for this.\n* tests/Makefile.am (TESTS): Add it.\nImprovements by Andreas Gruenbacher."
    },
    {
        "func": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "radvd",
        "commit_id": "92e22ca23e52066da2258df8c76a2dca8a428bcc",
        "hash": 75598449882234786500556211680606334472,
        "size": 24,
        "message": "set_interface_var() doesn't check interface name and blindly does\nfopen(path \"/\" ifname, \"w\") on it.  As \"ifname\" is an untrusted input, it\nshould be checked for \"..\" and/or \"/\" in it.  Otherwise, an infected\nunprivileged daemon may overwrite contents of file named \"mtu\",\n\"hoplimit\", etc. in arbitrary location with arbitrary 32-bit value in\ndecimal representation (\"%d\").  If an attacker has a local account or\nmay create arbitrary symlinks with these names in any location (e.g.\n/tmp), any file may be overwritten with a decimal value."
    },
    {
        "func": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\n\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\tg_file_query_info_async (destination,\n\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t odata);\n\n\t\tg_object_unref (destination);\n\n\t\treturn;\n\t}\n\n\tif (odata->edata->file_list != NULL) {\n\t\t/* speed optimization: passing NULL when extracting all the\n\t\t * files is faster if the command supports the\n\t\t * propCanExtractAll property. */\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\n\tg_free (odata);\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "file-roller",
        "commit_id": "b147281293a8307808475e102a14857055f81631",
        "hash": 1868168910819853230293213295641486824,
        "size": 50,
        "message": "libarchive: sanitize filenames before extracting"
    },
    {
        "func": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\tfile = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (fullpath, extract_data->base_dir, extract_data->junk_paths));\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar  *link_fullpath;\n\t\t\t\tGFile *link_file;\n\t\t\t\tchar  *oldname;\n\t\t\t\tchar  *newname;\n\t\t\t\tint    r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (link_fullpath, extract_data->base_dir, extract_data->junk_paths));\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "file-roller",
        "commit_id": "b147281293a8307808475e102a14857055f81631",
        "hash": 146521485464683242231569868140802651647,
        "size": 242,
        "message": "libarchive: sanitize filenames before extracting"
    },
    {
        "func": "check_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (strncmp(tty, \"/dev/\", 5) != 0) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (strlen(tty) == 0) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "linux-pam",
        "commit_id": "9dcead87e6d7f66d34e7a56d11a30daca367dffb",
        "hash": 336131573636879399421041172856936495490,
        "size": 21,
        "message": "pam_timestamp: fix potential directory traversal issue (ticket #27)\n\npam_timestamp uses values of PAM_RUSER and PAM_TTY as components of\nthe timestamp pathname it creates, so extra care should be taken to\navoid potential directory traversal issues.\n\n* modules/pam_timestamp/pam_timestamp.c (check_tty): Treat\n\".\" and \"..\" tty values as invalid.\n(get_ruser): Treat \".\" and \"..\" ruser values, as well as any ruser\nvalue containing '/', as invalid.\n\nFixes CVE-2014-2583.\n\nReported-by: Sebastian Krahmer <krahmer@suse.de>"
    },
    {
        "func": "get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "linux-pam",
        "commit_id": "9dcead87e6d7f66d34e7a56d11a30daca367dffb",
        "hash": 227818384334126316111651650155998253999,
        "size": 25,
        "message": "pam_timestamp: fix potential directory traversal issue (ticket #27)\n\npam_timestamp uses values of PAM_RUSER and PAM_TTY as components of\nthe timestamp pathname it creates, so extra care should be taken to\navoid potential directory traversal issues.\n\n* modules/pam_timestamp/pam_timestamp.c (check_tty): Treat\n\".\" and \"..\" tty values as invalid.\n(get_ruser): Treat \".\" and \"..\" ruser values, as well as any ruser\nvalue containing '/', as invalid.\n\nFixes CVE-2014-2583.\n\nReported-by: Sebastian Krahmer <krahmer@suse.de>"
    },
    {
        "func": "defaults (void)\n{\n  char *tmp;\n\n  /* Most of the default values are 0 (and 0.0, NULL, and false).\n     Just reset everything, and fill in the non-zero values.  Note\n     that initializing pointers to NULL this way is technically\n     illegal, but porting Wget to a machine where NULL is not all-zero\n     bit pattern will be the least of the implementors' worries.  */\n  xzero (opt);\n\n  opt.cookies = true;\n  opt.verbose = -1;\n  opt.ntry = 20;\n  opt.reclevel = 5;\n  opt.add_hostdir = true;\n  opt.netrc = true;\n  opt.ftp_glob = true;\n  opt.htmlify = true;\n  opt.http_keep_alive = true;\n  opt.use_proxy = true;\n  tmp = getenv (\"no_proxy\");\n  if (tmp)\n    opt.no_proxy = sepstring (tmp);\n  opt.prefer_family = prefer_none;\n  opt.allow_cache = true;\n\n  opt.read_timeout = 900;\n  opt.use_robots = true;\n\n  opt.remove_listing = true;\n\n  opt.dot_bytes = 1024;\n  opt.dot_spacing = 10;\n  opt.dots_in_line = 50;\n\n  opt.dns_cache = true;\n  opt.ftp_pasv = true;\n\n#ifdef HAVE_SSL\n  opt.check_cert = true;\n#endif\n\n  /* The default for file name restriction defaults to the OS type. */\n#if defined(WINDOWS) || defined(MSDOS) || defined(__CYGWIN__)\n  opt.restrict_files_os = restrict_windows;\n#else\n  opt.restrict_files_os = restrict_unix;\n#endif\n  opt.restrict_files_ctrl = true;\n  opt.restrict_files_nonascii = false;\n  opt.restrict_files_case = restrict_no_case_restriction;\n\n  opt.regex_type = regex_type_posix;\n\n  opt.max_redirect = 20;\n\n  opt.waitretry = 10;\n\n#ifdef ENABLE_IRI\n  opt.enable_iri = true;\n#else\n  opt.enable_iri = false;\n#endif\n  opt.locale = NULL;\n  opt.encoding_remote = NULL;\n\n  opt.useservertimestamps = true;\n  opt.show_all_dns_entries = false;\n\n  opt.warc_maxsize = 0; /* 1024 * 1024 * 1024; */\n#ifdef HAVE_LIBZ\n  opt.warc_compression_enabled = true;\n#else\n  opt.warc_compression_enabled = false;\n#endif\n  opt.warc_digests_enabled = true;\n  opt.warc_cdx_enabled = false;\n  opt.warc_cdx_dedup_filename = NULL;\n  opt.warc_tempdir = NULL;\n  opt.warc_keep_log = true;\n\n  /* Use a negative value to mark the absence of --start-pos option */\n  opt.start_pos = -1;\n  opt.show_progress = false;\n  opt.noscroll = false;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "wget",
        "commit_id": "18b0979357ed7dc4e11d4f2b1d7e0f5932d82aa7",
        "hash": 263288308017348595416138729121731498004,
        "size": 87,
        "message": "CVE-2014-4877: Arbitrary Symlink Access\n\nWget was susceptible to a symlink attack which could create arbitrary\nfiles, directories or symbolic links and set their permissions when\nretrieving a directory recursively through FTP. This commit changes the\ndefault settings in Wget such that Wget no longer creates local symbolic\nlinks, but rather traverses them and retrieves the pointed-to file in\nsuch a retrieval.\n\nThe old behaviour can be attained by passing the --retr-symlinks=no\noption to the Wget invokation command."
    },
    {
        "func": "ftp_retrieve_glob (struct url *u, ccon *con, int action)\n{\n  struct fileinfo *f, *start;\n  uerr_t res;\n\n  con->cmd |= LEAVE_PENDING;\n\n  res = ftp_get_listing (u, con, &start);\n  if (res != RETROK)\n    return res;\n  /* First: weed out that do not conform the global rules given in\n     opt.accepts and opt.rejects.  */\n  if (opt.accepts || opt.rejects)\n    {\n      f = start;\n      while (f)\n        {\n          if (f->type != FT_DIRECTORY && !acceptable (f->name))\n            {\n              logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                         quote (f->name));\n              f = delelement (f, &start);\n            }\n          else\n            f = f->next;\n        }\n    }\n  /* Remove all files with possible harmful names */\n  f = start;\n  while (f)\n    {\n      if (has_insecure_name_p (f->name))\n        {\n          logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                     quote (f->name));\n          f = delelement (f, &start);\n        }\n      else\n        f = f->next;\n    }\n  /* Now weed out the files that do not match our globbing pattern.\n     If we are dealing with a globbing pattern, that is.  */\n  if (*u->file)\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          int (*matcher) (const char *, const char *, int)\n            = opt.ignore_case ? fnmatch_nocase : fnmatch;\n          int matchres = 0;\n\n          f = start;\n          while (f)\n            {\n              matchres = matcher (u->file, f->name, 0);\n              if (matchres == -1)\n                {\n                  logprintf (LOG_NOTQUIET, _(\"Error matching %s against %s: %s\\n\"),\n                             u->file, quotearg_style (escape_quoting_style, f->name),\n                             strerror (errno));\n                  break;\n                }\n              if (matchres == FNM_NOMATCH)\n                f = delelement (f, &start); /* delete the element from the list */\n              else\n                f = f->next;        /* leave the element in the list */\n            }\n          if (matchres == -1)\n            {\n              freefileinfo (start);\n              return RETRBADPATTERN;\n            }\n        }\n      else if (action == GLOB_GETONE)\n        {\n#ifdef __VMS\n          /* 2009-09-09 SMS.\n           * Odd-ball compiler (\"HP C V7.3-009 on OpenVMS Alpha V7.3-2\")\n           * bug causes spurious %CC-E-BADCONDIT complaint with this\n           * \"?:\" statement.  (Different linkage attributes for strcmp()\n           * and strcasecmp().)  Converting to \"if\" changes the\n           * complaint to %CC-W-PTRMISMATCH on \"cmp = strcmp;\".  Adding\n           * the senseless type cast clears the complaint, and looks\n           * harmless.\n           */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : (int (*)())strcmp;\n#else /* def __VMS */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : strcmp;\n#endif /* def __VMS [else] */\n          f = start;\n          while (f)\n            {\n              if (0 != cmp(u->file, f->name))\n                f = delelement (f, &start);\n              else\n                f = f->next;\n            }\n        }\n    }\n  if (start)\n    {\n      /* Just get everything.  */\n      res = ftp_retrieve_list (u, start, con);\n    }\n  else\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          /* No luck.  */\n          /* #### This message SUCKS.  We should see what was the\n             reason that nothing was retrieved.  */\n          logprintf (LOG_VERBOSE, _(\"No matches on pattern %s.\\n\"),\n                     quote (u->file));\n        }\n      else if (action == GLOB_GETONE) /* GLOB_GETONE or GLOB_GETALL */\n        {\n          /* Let's try retrieving it anyway.  */\n          con->st |= ON_YOUR_OWN;\n          res = ftp_loop_internal (u, NULL, con, NULL);\n          return res;\n        }\n\n      /* If action == GLOB_GETALL, and the file list is empty, there's\n         no point in trying to download anything or in complaining about\n         it.  (An empty directory should not cause complaints.)\n      */\n    }\n  freefileinfo (start);\n  if (opt.quota && total_downloaded_bytes > opt.quota)\n    return QUOTEXC;\n  else\n    return res;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "wget",
        "commit_id": "69c45cba4382fcaabe3d86876bd5463dc34f442c",
        "hash": 145713471669899097887449630272469885990,
        "size": 134,
        "message": "Add checks for valid listing file in FTP\n\nWhen Wget retrieves a file through FTP, it first downloads a .listing\nfile and parses it for information about the files and other metadata.\nSome servers may serve invalid .listing files. This patch checks for one\nsuch known inconsistency wherein multiple lines in a listing file have\nthe same name. Such a filesystem is clearly not possible and hence we\neliminate duplicate entries here.\n\nSigned-off-by: Darshit Shah <darnir@gmail.com>"
    },
    {
        "func": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "abrt",
        "commit_id": "c796c76341ee846cfb897ed645bac211d7d0a932",
        "hash": 107071740552030765009809141077260543645,
        "size": 28,
        "message": "daemon: use libreport's function checking file name\n\nMove the functions to libreport because we need the same functionality\nthere too.\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>"
    },
    {
        "func": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "abrt",
        "commit_id": "c796c76341ee846cfb897ed645bac211d7d0a932",
        "hash": 237715831510363764875991283651115531677,
        "size": 9,
        "message": "daemon: use libreport's function checking file name\n\nMove the functions to libreport because we need the same functionality\nthere too.\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>"
    },
    {
        "func": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "abrt",
        "commit_id": "c796c76341ee846cfb897ed645bac211d7d0a932",
        "hash": 254414467925773928908544649619730694275,
        "size": 4,
        "message": "daemon: use libreport's function checking file name\n\nMove the functions to libreport because we need the same functionality\nthere too.\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>"
    },
    {
        "func": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (element == NULL || element[0] == '\\0' || strlen(element) > 64)\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "abrt",
        "commit_id": "f3c2a6af3455b2882e28570e8a04f1c2d4500d5b",
        "hash": 328748050382932470752410762313705617742,
        "size": 441,
        "message": "dbus: report invalid element names\n\nReturn D-Bus error in case of invalid problem element name.\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>"
    },
    {
        "func": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        /* only files should contain '/' and those are handled earlier */\n        if (name[0] == '.' || strchr(name, '/'))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}",
        "target": 1,
        "cwe": [
            "CWE-22"
        ],
        "project": "libreport",
        "commit_id": "239c4f7d1f47265526b39ad70106767d00805277",
        "hash": 300476702224173815433810732372792545734,
        "size": 115,
        "message": "dd: harden functions against directory traversal issues\n\nTest correctness of all accessed dump dir files in all dd* functions.\nBefore this commit, the callers were allowed to pass strings like\n\"../../etc/shadow\" in the filename argument of all dd* functions.\n\nRelated: #1214457\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>"
    },
    {
        "func": "main (int argc, char **argv)\n{\n  int last_argc = -1;\n  gpg_error_t err;\n  int rc;  parsed_uri_t uri;\n  uri_tuple_t r;\n  http_t hd;\n  int c;\n  unsigned int my_http_flags = 0;\n  int no_out = 0;\n  int tls_dbg = 0;\n  int no_crl = 0;\n  const char *cafile = NULL;\n  http_session_t session = NULL;\n  unsigned int timeout = 0;\n\n  gpgrt_init ();\n  log_set_prefix (PGM, GPGRT_LOG_WITH_PREFIX | GPGRT_LOG_WITH_PID);\n  if (argc)\n    { argc--; argv++; }\n  while (argc && last_argc != argc )\n    {\n      last_argc = argc;\n      if (!strcmp (*argv, \"--\"))\n        {\n          argc--; argv++;\n          break;\n        }\n      else if (!strcmp (*argv, \"--help\"))\n        {\n          fputs (\"usage: \" PGM \" URL\\n\"\n                 \"Options:\\n\"\n                 \"  --verbose         print timings etc.\\n\"\n                 \"  --debug           flyswatter\\n\"\n                 \"  --tls-debug N     use TLS debug level N\\n\"\n                 \"  --cacert FNAME    expect CA certificate in file FNAME\\n\"\n                 \"  --timeout MS      timeout for connect in MS\\n\"\n                 \"  --no-verify       do not verify the certificate\\n\"\n                 \"  --force-tls       use HTTP_FLAG_FORCE_TLS\\n\"\n                 \"  --force-tor       use HTTP_FLAG_FORCE_TOR\\n\"\n                 \"  --no-out          do not print the content\\n\"\n                 \"  --no-crl          do not consuilt a CRL\\n\",\n                 stdout);\n          exit (0);\n        }\n      else if (!strcmp (*argv, \"--verbose\"))\n        {\n          verbose++;\n          argc--; argv++;\n        }\n      else if (!strcmp (*argv, \"--debug\"))\n        {\n          verbose += 2;\n          debug++;\n          argc--; argv++;\n        }\n      else if (!strcmp (*argv, \"--tls-debug\"))\n        {\n          argc--; argv++;\n          if (argc)\n            {\n              tls_dbg = atoi (*argv);\n              argc--; argv++;\n            }\n        }\n      else if (!strcmp (*argv, \"--cacert\"))\n        {\n          argc--; argv++;\n          if (argc)\n            {\n              cafile = *argv;\n              argc--; argv++;\n            }\n        }\n      else if (!strcmp (*argv, \"--timeout\"))\n        {\n          argc--; argv++;\n          if (argc)\n            {\n              timeout = strtoul (*argv, NULL, 10);\n              argc--; argv++;\n            }\n        }\n      else if (!strcmp (*argv, \"--no-verify\"))\n        {\n          no_verify = 1;\n          argc--; argv++;\n        }\n      else if (!strcmp (*argv, \"--force-tls\"))\n        {\n          my_http_flags |= HTTP_FLAG_FORCE_TLS;\n          argc--; argv++;\n        }\n      else if (!strcmp (*argv, \"--force-tor\"))\n        {\n          my_http_flags |= HTTP_FLAG_FORCE_TOR;\n          argc--; argv++;\n        }\n      else if (!strcmp (*argv, \"--no-out\"))\n        {\n          no_out = 1;\n          argc--; argv++;\n        }\n      else if (!strcmp (*argv, \"--no-crl\"))\n        {\n          no_crl = 1;\n          argc--; argv++;\n        }\n      else if (!strncmp (*argv, \"--\", 2))\n        {\n          fprintf (stderr, PGM \": unknown option '%s'\\n\", *argv);\n          exit (1);\n        }\n    }\n  if (argc != 1)\n    {\n      fprintf (stderr, PGM \": no or too many URLS given\\n\");\n      exit (1);\n    }\n\n  if (!cafile)\n    cafile = prepend_srcdir (\"tls-ca.pem\");\n\n  if (verbose)\n    my_http_flags |= HTTP_FLAG_LOG_RESP;\n\n  if (verbose || debug)\n    http_set_verbose (verbose, debug);\n\n  /* http.c makes use of the assuan socket wrapper.  */\n  assuan_sock_init ();\n\n  if ((my_http_flags & HTTP_FLAG_FORCE_TOR))\n    {\n      enable_dns_tormode (1);\n      if (assuan_sock_set_flag (ASSUAN_INVALID_FD, \"tor-mode\", 1))\n        {\n          log_error (\"error enabling Tor mode: %s\\n\", strerror (errno));\n          log_info (\"(is your Libassuan recent enough?)\\n\");\n        }\n    }\n\n#if HTTP_USE_NTBTLS\n  log_info (\"new session.\\n\");\n  err = http_session_new (&session, NULL,\n                          ((no_crl? HTTP_FLAG_NO_CRL : 0)\n                           | HTTP_FLAG_TRUST_DEF),\n                          my_http_tls_verify_cb, NULL);\n  if (err)\n    log_error (\"http_session_new failed: %s\\n\", gpg_strerror (err));\n  ntbtls_set_debug (tls_dbg, NULL, NULL);\n\n#elif HTTP_USE_GNUTLS\n\n  rc = gnutls_global_init ();\n  if (rc)\n    log_error (\"gnutls_global_init failed: %s\\n\", gnutls_strerror (rc));\n\n  http_register_tls_callback (verify_callback);\n  http_register_tls_ca (cafile);\n\n  err = http_session_new (&session, NULL,\n                          ((no_crl? HTTP_FLAG_NO_CRL : 0)\n                           | HTTP_FLAG_TRUST_DEF),\n                          NULL, NULL);\n  if (err)\n    log_error (\"http_session_new failed: %s\\n\", gpg_strerror (err));\n\n  /* rc = gnutls_dh_params_init(&dh_params); */\n  /* if (rc) */\n  /*   log_error (\"gnutls_dh_params_init failed: %s\\n\", gnutls_strerror (rc)); */\n  /* read_dh_params (\"dh_param.pem\"); */\n\n  /* rc = gnutls_certificate_set_x509_trust_file */\n  /*   (certcred, \"ca.pem\", GNUTLS_X509_FMT_PEM); */\n  /* if (rc) */\n  /*   log_error (\"gnutls_certificate_set_x509_trust_file failed: %s\\n\", */\n  /*              gnutls_strerror (rc)); */\n\n  /* gnutls_certificate_set_dh_params (certcred, dh_params); */\n\n  gnutls_global_set_log_function (my_gnutls_log);\n  if (tls_dbg)\n    gnutls_global_set_log_level (tls_dbg);\n\n#else\n  (void)err;\n  (void)tls_dbg;\n  (void)no_crl;\n#endif /*HTTP_USE_GNUTLS*/\n\n  rc = http_parse_uri (&uri, *argv, 1);\n  if (rc)\n    {\n      log_error (\"'%s': %s\\n\", *argv, gpg_strerror (rc));\n      return 1;\n    }\n\n  printf (\"Scheme: %s\\n\", uri->scheme);\n  if (uri->opaque)\n    printf (\"Value : %s\\n\", uri->path);\n  else\n    {\n      printf (\"Auth  : %s\\n\", uri->auth? uri->auth:\"[none]\");\n      printf (\"Host  : %s\\n\", uri->host);\n      printf (\"Port  : %u\\n\", uri->port);\n      printf (\"Path  : %s\\n\", uri->path);\n      for (r = uri->params; r; r = r->next)\n        {\n          printf (\"Params: %s\", r->name);\n          if (!r->no_value)\n            {\n              printf (\"=%s\", r->value);\n              if (strlen (r->value) != r->valuelen)\n                printf (\" [real length=%d]\", (int) r->valuelen);\n            }\n          putchar ('\\n');\n        }\n      for (r = uri->query; r; r = r->next)\n        {\n          printf (\"Query : %s\", r->name);\n          if (!r->no_value)\n            {\n              printf (\"=%s\", r->value);\n              if (strlen (r->value) != r->valuelen)\n                printf (\" [real length=%d]\", (int) r->valuelen);\n            }\n          putchar ('\\n');\n        }\n      printf (\"Flags :%s%s%s%s\\n\",\n              uri->is_http? \" http\":\"\",\n              uri->opaque?  \" opaque\":\"\",\n              uri->v6lit?   \" v6lit\":\"\",\n              uri->onion?   \" onion\":\"\");\n      printf (\"TLS   : %s\\n\",\n              uri->use_tls? \"yes\":\n              (my_http_flags&HTTP_FLAG_FORCE_TLS)? \"forced\" : \"no\");\n      printf (\"Tor   : %s\\n\",\n              (my_http_flags&HTTP_FLAG_FORCE_TOR)? \"yes\" : \"no\");\n\n    }\n  fflush (stdout);\n  http_release_parsed_uri (uri);\n  uri = NULL;\n\n  if (session)\n    http_session_set_timeout (session, timeout);\n\n  rc = http_open_document (&hd, *argv, NULL, my_http_flags,\n                           NULL, session, NULL, NULL);\n  if (rc)\n    {\n      log_error (\"can't get '%s': %s\\n\", *argv, gpg_strerror (rc));\n      return 1;\n    }\n  log_info (\"open_http_document succeeded; status=%u\\n\",\n            http_get_status_code (hd));\n\n  {\n    const char **names;\n    int i;\n\n    names = http_get_header_names (hd);\n    if (!names)\n      log_fatal (\"http_get_header_names failed: %s\\n\",\n                 gpg_strerror (gpg_error_from_syserror ()));\n    for (i = 0; names[i]; i++)\n      printf (\"HDR: %s: %s\\n\", names[i], http_get_header (hd, names[i]));\n    xfree (names);\n  }\n  fflush (stdout);\n\n  switch (http_get_status_code (hd))\n    {\n    case 200:\n    case 400:\n    case 401:\n    case 403:\n    case 404:\n      {\n        unsigned long count = 0;\n        while ((c = es_getc (http_get_read_ptr (hd))) != EOF)\n          {\n            count++;\n            if (!no_out)\n              putchar (c);\n          }\n        log_info (\"Received bytes: %lu\\n\", count);\n      }\n      break;\n    case 301:\n    case 302:\n    case 307:\n      log_info (\"Redirected to: %s\\n\", http_get_header (hd, \"Location\"));\n      break;\n    }\n  http_close (hd, 0);\n\n  http_session_release (session);\n#ifdef HTTP_USE_GNUTLS\n  gnutls_global_deinit ();\n#endif /*HTTP_USE_GNUTLS*/\n\n  return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 299291997878190238370809985967320089811,
        "size": 305,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "ks_http_fetch (ctrl_t ctrl, const char *url, unsigned int flags,\n               estream_t *r_fp)\n{\n  gpg_error_t err;\n  http_session_t session = NULL;\n  unsigned int session_flags;\n  http_t http = NULL;\n  int redirects_left = MAX_REDIRECTS;\n  estream_t fp = NULL;\n  char *request_buffer = NULL;\n  parsed_uri_t uri = NULL;\n  int is_onion, is_https;\n\n  err = http_parse_uri (&uri, url, 0);\n  if (err)\n    goto leave;\n  is_onion = uri->onion;\n  is_https = uri->use_tls;\n\n  /* By default we only use the system provided certificates with this\n   * fetch command.  */\n  session_flags = HTTP_FLAG_TRUST_SYS;\n  if ((flags & KS_HTTP_FETCH_NO_CRL) || ctrl->http_no_crl)\n    session_flags |= HTTP_FLAG_NO_CRL;\n  if ((flags & KS_HTTP_FETCH_TRUST_CFG))\n    session_flags |= HTTP_FLAG_TRUST_CFG;\n\n once_more:\n  err = http_session_new (&session, NULL, session_flags,\n                          gnupg_http_tls_verify_cb, ctrl);\n  if (err)\n    goto leave;\n  http_session_set_log_cb (session, cert_log_cb);\n  http_session_set_timeout (session, ctrl->timeout);\n\n  *r_fp = NULL;\n  err = http_open (&http,\n                   HTTP_REQ_GET,\n                   url,\n                   /* httphost */ NULL,\n                   /* fixme: AUTH */ NULL,\n                   ((opt.honor_http_proxy? HTTP_FLAG_TRY_PROXY:0)\n                    | (DBG_LOOKUP? HTTP_FLAG_LOG_RESP:0)\n                    | (dirmngr_use_tor ()? HTTP_FLAG_FORCE_TOR:0)\n                    | (opt.disable_ipv4? HTTP_FLAG_IGNORE_IPv4 : 0)\n                    | (opt.disable_ipv6? HTTP_FLAG_IGNORE_IPv6 : 0)),\n                   ctrl->http_proxy,\n                   session,\n                   NULL,\n                   /*FIXME curl->srvtag*/NULL);\n  if (!err)\n    {\n      fp = http_get_write_ptr (http);\n      /* Avoid caches to get the most recent copy of the key.  We set\n       * both the Pragma and Cache-Control versions of the header, so\n       * we're good with both HTTP 1.0 and 1.1.  */\n      if ((flags & KS_HTTP_FETCH_NOCACHE))\n        es_fputs (\"Pragma: no-cache\\r\\n\"\n                  \"Cache-Control: no-cache\\r\\n\", fp);\n      http_start_data (http);\n      if (es_ferror (fp))\n        err = gpg_error_from_syserror ();\n    }\n  if (err)\n    {\n      /* Fixme: After a redirection we show the old host name.  */\n      log_error (_(\"error connecting to '%s': %s\\n\"),\n                 url, gpg_strerror (err));\n      goto leave;\n    }\n\n  /* Wait for the response.  */\n  dirmngr_tick (ctrl);\n  err = http_wait_response (http);\n  if (err)\n    {\n      log_error (_(\"error reading HTTP response for '%s': %s\\n\"),\n                 url, gpg_strerror (err));\n      goto leave;\n    }\n\n  switch (http_get_status_code (http))\n    {\n    case 200:\n      err = 0;\n      break; /* Success.  */\n\n    case 301:\n    case 302:\n    case 307:\n      {\n        const char *s = http_get_header (http, \"Location\");\n\n        log_info (_(\"URL '%s' redirected to '%s' (%u)\\n\"),\n                  url, s?s:\"[none]\", http_get_status_code (http));\n        if (s && *s && redirects_left-- )\n          {\n            if (is_onion || is_https)\n              {\n                /* Make sure that an onion address only redirects to\n                 * another onion address, or that a https address\n                 * only redirects to a https address. */\n                http_release_parsed_uri (uri);\n                uri = NULL;\n                err = http_parse_uri (&uri, s, 0);\n                if (err)\n                  goto leave;\n\n                if (is_onion && !uri->onion)\n                  {\n                    err = gpg_error (GPG_ERR_FORBIDDEN);\n                    goto leave;\n                  }\n                if (!(flags & KS_HTTP_FETCH_ALLOW_DOWNGRADE)\n                    && is_https && !uri->use_tls)\n                  {\n                    err = gpg_error (GPG_ERR_FORBIDDEN);\n                    goto leave;\n                  }\n              }\n\n            xfree (request_buffer);\n            request_buffer = xtrystrdup (s);\n            if (request_buffer)\n              {\n                url = request_buffer;\n                http_close (http, 0);\n                http = NULL;\n                http_session_release (session);\n                goto once_more;\n              }\n            err = gpg_error_from_syserror ();\n          }\n        else\n          err = gpg_error (GPG_ERR_NO_DATA);\n        log_error (_(\"too many redirections\\n\"));\n      }\n      goto leave;\n\n    default:\n      log_error (_(\"error accessing '%s': http status %u\\n\"),\n                 url, http_get_status_code (http));\n      err = gpg_error (GPG_ERR_NO_DATA);\n      goto leave;\n    }\n\n  fp = http_get_read_ptr (http);\n  if (!fp)\n    {\n      err = gpg_error (GPG_ERR_BUG);\n      goto leave;\n    }\n\n  /* Return the read stream and close the HTTP context.  */\n  *r_fp = fp;\n  http_close (http, 1);\n  http = NULL;\n\n leave:\n  http_close (http, 0);\n  http_session_release (session);\n  xfree (request_buffer);\n  http_release_parsed_uri (uri);\n  return err;\n}",
        "target": 1,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 64544617138829267129903382194281986613,
        "size": 165,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "send_request (ctrl_t ctrl, const char *request, const char *hostportstr,\n              const char *httphost, unsigned int httpflags,\n              gpg_error_t (*post_cb)(void *, http_t), void *post_cb_value,\n              estream_t *r_fp, unsigned int *r_http_status)\n{\n  gpg_error_t err;\n  http_session_t session = NULL;\n  http_t http = NULL;\n  int redirects_left = MAX_REDIRECTS;\n  estream_t fp = NULL;\n  char *request_buffer = NULL;\n  parsed_uri_t uri = NULL;\n  int is_onion;\n\n  *r_fp = NULL;\n\n  err = http_parse_uri (&uri, request, 0);\n  if (err)\n    goto leave;\n  is_onion = uri->onion;\n\n  err = http_session_new (&session, httphost,\n                          ((ctrl->http_no_crl? HTTP_FLAG_NO_CRL : 0)\n                           | HTTP_FLAG_TRUST_DEF),\n                          gnupg_http_tls_verify_cb, ctrl);\n  if (err)\n    goto leave;\n  http_session_set_log_cb (session, cert_log_cb);\n  http_session_set_timeout (session, ctrl->timeout);\n\n once_more:\n  err = http_open (&http,\n                   post_cb? HTTP_REQ_POST : HTTP_REQ_GET,\n                   request,\n                   httphost,\n                   /* fixme: AUTH */ NULL,\n                   (httpflags\n                    |(opt.honor_http_proxy? HTTP_FLAG_TRY_PROXY:0)\n                    |(dirmngr_use_tor ()? HTTP_FLAG_FORCE_TOR:0)\n                    |(opt.disable_ipv4? HTTP_FLAG_IGNORE_IPv4 : 0)\n                    |(opt.disable_ipv6? HTTP_FLAG_IGNORE_IPv6 : 0)),\n                   ctrl->http_proxy,\n                   session,\n                   NULL,\n                   /*FIXME curl->srvtag*/NULL);\n  if (!err)\n    {\n      fp = http_get_write_ptr (http);\n      /* Avoid caches to get the most recent copy of the key.  We set\n         both the Pragma and Cache-Control versions of the header, so\n         we're good with both HTTP 1.0 and 1.1.  */\n      es_fputs (\"Pragma: no-cache\\r\\n\"\n                \"Cache-Control: no-cache\\r\\n\", fp);\n      if (post_cb)\n        err = post_cb (post_cb_value, http);\n      if (!err)\n        {\n          http_start_data (http);\n          if (es_ferror (fp))\n            err = gpg_error_from_syserror ();\n        }\n    }\n  if (err)\n    {\n      /* Fixme: After a redirection we show the old host name.  */\n      log_error (_(\"error connecting to '%s': %s\\n\"),\n                 hostportstr, gpg_strerror (err));\n      goto leave;\n    }\n\n  /* Wait for the response.  */\n  dirmngr_tick (ctrl);\n  err = http_wait_response (http);\n  if (err)\n    {\n      log_error (_(\"error reading HTTP response for '%s': %s\\n\"),\n                 hostportstr, gpg_strerror (err));\n      goto leave;\n    }\n\n  if (http_get_tls_info (http, NULL))\n    {\n      /* Update the httpflags so that a redirect won't fallback to an\n         unencrypted connection.  */\n      httpflags |= HTTP_FLAG_FORCE_TLS;\n    }\n\n  if (r_http_status)\n    *r_http_status = http_get_status_code (http);\n\n  switch (http_get_status_code (http))\n    {\n    case 200:\n      err = 0;\n      break; /* Success.  */\n\n    case 301:\n    case 302:\n    case 307:\n      {\n        const char *s = http_get_header (http, \"Location\");\n\n        log_info (_(\"URL '%s' redirected to '%s' (%u)\\n\"),\n                  request, s?s:\"[none]\", http_get_status_code (http));\n        if (s && *s && redirects_left-- )\n          {\n            if (is_onion)\n              {\n                /* Make sure that an onion address only redirects to\n                 * another onion address.  */\n                http_release_parsed_uri (uri);\n                uri = NULL;\n                err = http_parse_uri (&uri, s, 0);\n                if (err)\n                  goto leave;\n\n                if (! uri->onion)\n                  {\n                    err = gpg_error (GPG_ERR_FORBIDDEN);\n                    goto leave;\n                  }\n              }\n\n            xfree (request_buffer);\n            request_buffer = xtrystrdup (s);\n            if (request_buffer)\n              {\n                request = request_buffer;\n                http_close (http, 0);\n                http = NULL;\n                goto once_more;\n              }\n            err = gpg_error_from_syserror ();\n          }\n        else\n          err = gpg_error (GPG_ERR_NO_DATA);\n        log_error (_(\"too many redirections\\n\"));\n      }\n      goto leave;\n\n    case 501:\n      err = gpg_error (GPG_ERR_NOT_IMPLEMENTED);\n      goto leave;\n\n    default:\n      log_error (_(\"error accessing '%s': http status %u\\n\"),\n                 request, http_get_status_code (http));\n      err = gpg_error (GPG_ERR_NO_DATA);\n      goto leave;\n    }\n\n  /* FIXME: We should register a permanent redirection and whether a\n     host has ever used TLS so that future calls will always use\n     TLS. */\n\n  fp = http_get_read_ptr (http);\n  if (!fp)\n    {\n      err = gpg_error (GPG_ERR_BUG);\n      goto leave;\n    }\n\n  /* Return the read stream and close the HTTP context.  */\n  *r_fp = fp;\n  http_close (http, 1);\n  http = NULL;\n\n leave:\n  http_close (http, 0);\n  http_session_release (session);\n  xfree (request_buffer);\n  http_release_parsed_uri (uri);\n  return err;\n}",
        "target": 1,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 294552583654907190046836053234230337152,
        "size": 174,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "do_parse_uri (parsed_uri_t uri, int only_local_part,\n              int no_scheme_check, int force_tls)\n{\n  uri_tuple_t *tail;\n  char *p, *p2, *p3, *pp;\n  int n;\n\n  p = uri->buffer;\n  n = strlen (uri->buffer);\n\n  /* Initialize all fields to an empty string or an empty list. */\n  uri->scheme = uri->host = uri->path = p + n;\n  uri->port = 0;\n  uri->params = uri->query = NULL;\n  uri->use_tls = 0;\n  uri->is_http = 0;\n  uri->opaque = 0;\n  uri->v6lit = 0;\n  uri->onion = 0;\n  uri->explicit_port = 0;\n\n  /* A quick validity check. */\n  if (strspn (p, VALID_URI_CHARS) != n)\n    return GPG_ERR_BAD_URI;\t/* Invalid characters found. */\n\n  if (!only_local_part)\n    {\n      /* Find the scheme. */\n      if (!(p2 = strchr (p, ':')) || p2 == p)\n\treturn GPG_ERR_BAD_URI; /* No scheme. */\n      *p2++ = 0;\n      for (pp=p; *pp; pp++)\n       *pp = tolower (*(unsigned char*)pp);\n      uri->scheme = p;\n      if (!strcmp (uri->scheme, \"http\") && !force_tls)\n        {\n          uri->port = 80;\n          uri->is_http = 1;\n        }\n      else if (!strcmp (uri->scheme, \"hkp\") && !force_tls)\n        {\n          uri->port = 11371;\n          uri->is_http = 1;\n        }\n#ifdef USE_TLS\n      else if (!strcmp (uri->scheme, \"https\") || !strcmp (uri->scheme,\"hkps\")\n               || (force_tls && (!strcmp (uri->scheme, \"http\")\n                                 || !strcmp (uri->scheme,\"hkp\"))))\n        {\n          uri->port = 443;\n          uri->is_http = 1;\n          uri->use_tls = 1;\n        }\n#endif /*USE_TLS*/\n      else if (!no_scheme_check)\n\treturn GPG_ERR_INV_URI; /* Unsupported scheme */\n\n      p = p2;\n\n      if (*p == '/' && p[1] == '/' ) /* There seems to be a hostname. */\n\t{\n          p += 2;\n\t  if ((p2 = strchr (p, '/')))\n\t    *p2++ = 0;\n\n          /* Check for username/password encoding */\n          if ((p3 = strchr (p, '@')))\n            {\n              uri->auth = p;\n              *p3++ = '\\0';\n              p = p3;\n            }\n\n          for (pp=p; *pp; pp++)\n            *pp = tolower (*(unsigned char*)pp);\n\n\t  /* Handle an IPv6 literal */\n\t  if( *p == '[' && (p3=strchr( p, ']' )) )\n\t    {\n\t      *p3++ = '\\0';\n\t      /* worst case, uri->host should have length 0, points to \\0 */\n\t      uri->host = p + 1;\n              uri->v6lit = 1;\n\t      p = p3;\n\t    }\n\t  else\n\t    uri->host = p;\n\n\t  if ((p3 = strchr (p, ':')))\n\t    {\n\t      *p3++ = '\\0';\n\t      uri->port = atoi (p3);\n              uri->explicit_port = 1;\n\t    }\n\n\t  if ((n = remove_escapes (uri->host)) < 0)\n\t    return GPG_ERR_BAD_URI;\n\t  if (n != strlen (uri->host))\n\t    return GPG_ERR_BAD_URI;\t/* Hostname includes a Nul. */\n\t  p = p2 ? p2 : NULL;\n\t}\n      else if (uri->is_http)\n\treturn GPG_ERR_INV_URI; /* No Leading double slash for HTTP.  */\n      else\n        {\n          uri->opaque = 1;\n          uri->path = p;\n          if (is_onion_address (uri->path))\n            uri->onion = 1;\n          return 0;\n        }\n\n    } /* End global URI part. */\n\n  /* Parse the pathname part if any.  */\n  if (p && *p)\n    {\n      /* TODO: Here we have to check params. */\n\n      /* Do we have a query part? */\n      if ((p2 = strchr (p, '?')))\n        *p2++ = 0;\n\n      uri->path = p;\n      if ((n = remove_escapes (p)) < 0)\n        return GPG_ERR_BAD_URI;\n      if (n != strlen (p))\n        return GPG_ERR_BAD_URI;\t/* Path includes a Nul. */\n      p = p2 ? p2 : NULL;\n\n      /* Parse a query string if any.  */\n      if (p && *p)\n        {\n          tail = &uri->query;\n          for (;;)\n            {\n              uri_tuple_t elem;\n\n              if ((p2 = strchr (p, '&')))\n                *p2++ = 0;\n              if (!(elem = parse_tuple (p)))\n                return GPG_ERR_BAD_URI;\n              *tail = elem;\n              tail = &elem->next;\n\n              if (!p2)\n                break; /* Ready. */\n              p = p2;\n            }\n        }\n    }\n\n  if (is_onion_address (uri->host))\n    uri->onion = 1;\n\n  return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 102158798592724938910312864939225849699,
        "size": 157,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n\n    return nonce->references;\n}",
        "target": 1,
        "cwe": [
            "CWE-190",
            "CWE-352"
        ],
        "project": "squid",
        "commit_id": "eeebf0f37a72a2de08348e85ae34b02c34e9a811",
        "hash": 195188440302833983114491322146821993802,
        "size": 7,
        "message": "Fix auth digest refcount integer overflow (#585)\n\nThis fixes a possible overflow of the nonce reference counter in the\ndigest authentication scheme, found by security researchers\n@synacktiv.\n\nIt changes `references` to be an 64 bits unsigned integer. This makes\noverflowing the counter impossible in practice."
    },
    {
        "func": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}",
        "target": 1,
        "cwe": [
            "CWE-190",
            "CWE-352"
        ],
        "project": "squid",
        "commit_id": "eeebf0f37a72a2de08348e85ae34b02c34e9a811",
        "hash": 234789472396219593349017890600308184896,
        "size": 6,
        "message": "Fix auth digest refcount integer overflow (#585)\n\nThis fixes a possible overflow of the nonce reference counter in the\ndigest authentication scheme, found by security researchers\n@synacktiv.\n\nIt changes `references` to be an 64 bits unsigned integer. This makes\noverflowing the counter impossible in practice."
    },
    {
        "func": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-352"
        ],
        "project": "taglib",
        "commit_id": "cb9f07d9dcd791b63e622da43f7b232adaec0a9a",
        "hash": 90554238838364427332066692407325541305,
        "size": 30,
        "message": "Don't assume TDRC is an instance of TextIdentificationFrame (#831)\n\nIf TDRC is encrypted, FrameFactory::createFrame() returns UnknownFrame\r\nwhich causes problems in rebuildAggregateFrames() when it is assumed\r\nthat TDRC is a TextIdentificationFrame"
    },
    {
        "func": "int Lua::handle_script_request(struct mg_connection *conn,\n\t\t\t       const struct mg_request_info *request_info,\n\t\t\t       char *script_path) {\n  char buf[64], key[64], ifname[MAX_INTERFACE_NAME_LEN];\n  char *_cookies, user[64] = { '\\0' }, outbuf[FILENAME_MAX];\n  AddressTree ptree;\n  int rc;\n\n  if(!L) return(-1);\n\n  luaL_openlibs(L); /* Load base libraries */\n  lua_register_classes(L, true); /* Load custom classes */\n\n  lua_pushlightuserdata(L, (char*)conn);\n  lua_setglobal(L, CONST_HTTP_CONN);\n\n  /* Put the GET params into the environment */\n  lua_newtable(L);\n  if(request_info->query_string != NULL) {\n    char *query_string = strdup(request_info->query_string);\n\n    if(query_string) {\n      char *where;\n      char *tok;\n\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n      tok = strtok_r(query_string, \"&\", &where);\n\n      while(tok != NULL) {\n\t/* key=val */\n\tchar *_equal = strchr(tok, '=');\n\n\tif(_equal) {\n\t  char *equal;\n\t  int len;\n\n\t  _equal[0] = '\\0';\n\t  _equal = &_equal[1];\n\t  len = strlen(_equal);\n\n\t  purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n\t  // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);\n\n\t  if((equal = (char*)malloc(len+1)) != NULL) {\n\t    char *decoded_buf;\n\n\t    Utils::urlDecode(_equal, equal, len+1);\n\n\t    if((decoded_buf = http_decode(equal)) != NULL) {\n\t      FILE *fd;\n\n\t      Utils::purifyHTTPparam(tok, true, false);\n\t      Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t      /* Now make sure that decoded_buf is not a file path */\n\t      if((decoded_buf[0] == '.')\n\t\t && ((fd = fopen(decoded_buf, \"r\"))\n\t\t     || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\t\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t     tok, decoded_buf);\n\n\t\tdecoded_buf[0] = '\\0';\n\t\tfclose(fd);\n\t      }\n\n\t      /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, decoded_buf); */\n\n\t      if(strcmp(tok, \"csrf\") == 0) {\n\t\tchar rsp[32], user[64] = { '\\0' };\n\n\t\tmg_get_cookie(conn, \"user\", user, sizeof(user));\n\n\t\tif((ntop->getRedis()->get(decoded_buf, rsp, sizeof(rsp)) == -1)\n\t\t   || (strcmp(rsp, user) != 0)) {\n\t\t  const char *msg = \"The submitted form is expired. Please reload the page and try again\";\n\n\t\t  ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t\t       \"Invalid CSRF parameter specified [%s][%s][%s][%s]: page expired?\",\n\t\t\t\t\t       decoded_buf, rsp, user, tok);\n\t\t  free(equal);\n\t\t  return(send_error(conn, 500 /* Internal server error */,\n\t\t\t\t    msg, PAGE_ERROR, query_string, msg));\n\t\t} else\n\t\t  ntop->getRedis()->delKey(decoded_buf);\n\t      }\n\n\t      lua_push_str_table_entry(L, tok, decoded_buf);\n\t      free(decoded_buf);\n\t    }\n\n\t    free(equal);\n\t  } else\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\t}\n\n\ttok = strtok_r(NULL, \"&\", &where);\n      } /* while */\n\n      free(query_string);\n    } else\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n  }\n  lua_setglobal(L, \"_GET\"); /* Like in php */\n\n  /* _SERVER */\n  lua_newtable(L);\n  lua_push_str_table_entry(L, \"HTTP_REFERER\", (char*)mg_get_header(conn, \"Referer\"));\n  lua_push_str_table_entry(L, \"HTTP_USER_AGENT\", (char*)mg_get_header(conn, \"User-Agent\"));\n  lua_push_str_table_entry(L, \"SERVER_NAME\", (char*)mg_get_header(conn, \"Host\"));\n  lua_setglobal(L, \"_SERVER\"); /* Like in php */\n\n  /* Cookies */\n  lua_newtable(L);\n  if((_cookies = (char*)mg_get_header(conn, \"Cookie\")) != NULL) {\n    char *cookies = strdup(_cookies);\n    char *tok, *where;\n\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"=> '%s'\", cookies);\n    tok = strtok_r(cookies, \"=\", &where);\n    while(tok != NULL) {\n      char *val;\n\n      while(tok[0] == ' ') tok++;\n\n      if((val = strtok_r(NULL, \";\", &where)) != NULL) {\n\tlua_push_str_table_entry(L, tok, val);\n\t// ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, val);\n      } else\n\tbreak;\n\n      tok = strtok_r(NULL, \"=\", &where);\n    }\n\n    free(cookies);\n  }\n  lua_setglobal(L, \"_COOKIE\"); /* Like in php */\n\n  /* Put the _SESSION params into the environment */\n  lua_newtable(L);\n\n  mg_get_cookie(conn, \"user\", user, sizeof(user));\n  lua_push_str_table_entry(L, \"user\", user);\n  mg_get_cookie(conn, \"session\", buf, sizeof(buf));\n  lua_push_str_table_entry(L, \"session\", buf);\n\n  // now it's time to set the interface.\n  setInterface(user);\n\n  lua_setglobal(L, \"_SESSION\"); /* Like in php */\n\n  if(user[0] != '\\0') {\n    char val[255];\n\n    lua_pushlightuserdata(L, user);\n    lua_setglobal(L, \"user\");\n\n    snprintf(key, sizeof(key), \"ntopng.user.%s.allowed_nets\", user);\n    if((ntop->getRedis()->get(key, val, sizeof(val)) != -1)\n       && (val[0] != '\\0')) {\n      ptree.addAddresses(val);\n      lua_pushlightuserdata(L, &ptree);\n      lua_setglobal(L, CONST_ALLOWED_NETS);\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"SET %p\", ptree);\n    }\n\n    snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user);\n    if(snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user)\n       && !ntop->getRedis()->get(key, ifname, sizeof(ifname))) {\n      lua_pushlightuserdata(L, ifname);\n      lua_setglobal(L, CONST_ALLOWED_IFNAME);\n    }\n  }\n\n#ifndef NTOPNG_PRO\n  rc = luaL_dofile(L, script_path);\n#else\n  if(ntop->getPro()->has_valid_license())\n    rc = __ntop_lua_handlefile(L, script_path, true);\n  else\n    rc = luaL_dofile(L, script_path);\n#endif\n\n  if(rc != 0) {\n    const char *err = lua_tostring(L, -1);\n\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s][%s]\", script_path, err);\n    return(send_error(conn, 500 /* Internal server error */,\n\t\t      \"Internal server error\", PAGE_ERROR, script_path, err));\n  }\n\n  return(CONST_LUA_OK);\n}",
        "target": 1,
        "cwe": [
            "CWE-284",
            "CWE-352"
        ],
        "project": "ntopng",
        "commit_id": "f91fbe3d94c8346884271838ae3406ae633f6f15",
        "hash": 149977628082213141718437243359762927911,
        "size": 194,
        "message": "Check for presence of crsf in admin scripts"
    },
    {
        "func": "make_host_part (ctrl_t ctrl,\n                const char *scheme, const char *host, unsigned short port,\n                int force_reselect, int no_srv,\n                char **r_hostport, unsigned int *r_httpflags, char **r_httphost)\n{\n  gpg_error_t err;\n  const char *srvtag;\n  char portstr[10];\n  char *hostname;\n  enum ks_protocol protocol;\n\n  *r_hostport = NULL;\n\n  if (!strcmp (scheme, \"hkps\") || !strcmp (scheme,\"https\"))\n    {\n      scheme = \"https\";\n      srvtag = no_srv? NULL : \"pgpkey-https\";\n      protocol = KS_PROTOCOL_HKPS;\n    }\n  else /* HKP or HTTP.  */\n    {\n      scheme = \"http\";\n      srvtag = no_srv? NULL : \"pgpkey-http\";\n      protocol = KS_PROTOCOL_HKP;\n    }\n\n  portstr[0] = 0;\n  err = map_host (ctrl, host, srvtag, force_reselect, protocol,\n                  &hostname, portstr, r_httpflags, r_httphost);\n  if (err)\n    return err;\n\n  /* If map_host did not return a port (from a SRV record) but a port\n   * has been specified (implicitly or explicitly) then use that port.\n   * In the case that a port was not specified (which is probably a\n   * bug in https.c) we will set up defaults.  */\n  if (*portstr)\n    ;\n  else if (!*portstr && port)\n    snprintf (portstr, sizeof portstr, \"%hu\", port);\n  else if (!strcmp (scheme,\"https\"))\n    strcpy (portstr, \"443\");\n  else\n    strcpy (portstr, \"11371\");\n\n  if (*hostname != '[' && is_ip_address (hostname) == 6)\n    *r_hostport = strconcat (scheme, \"://[\", hostname, \"]:\", portstr, NULL);\n  else\n    *r_hostport = strconcat (scheme, \"://\", hostname, \":\", portstr, NULL);\n  xfree (hostname);\n  if (!*r_hostport)\n    {\n      if (r_httphost)\n        {\n          xfree (*r_httphost);\n          *r_httphost = NULL;\n        }\n      return gpg_error_from_syserror ();\n    }\n  return 0;\n}",
        "target": 0,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 322464777097034839513817278590469957543,
        "size": 61,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "send_request (ctrl_t ctrl, const char *request, const char *hostportstr,\n              const char *httphost, unsigned int httpflags,\n              gpg_error_t (*post_cb)(void *, http_t), void *post_cb_value,\n              estream_t *r_fp, unsigned int *r_http_status)\n{\n  gpg_error_t err;\n  http_session_t session = NULL;\n  http_t http = NULL;\n  http_redir_info_t redirinfo = { MAX_REDIRECTS };\n  estream_t fp = NULL;\n  char *request_buffer = NULL;\n  parsed_uri_t uri = NULL;\n\n  *r_fp = NULL;\n\n  err = http_parse_uri (&uri, request, 0);\n  if (err)\n    goto leave;\n  redirinfo.orig_url   = request;\n  redirinfo.orig_onion = uri->onion;\n  redirinfo.allow_downgrade = 1;\n  /* FIXME: I am not sure whey we allow a downgrade for hkp requests.\n   * Needs at least an explanation here..  */\n\n  err = http_session_new (&session, httphost,\n                          ((ctrl->http_no_crl? HTTP_FLAG_NO_CRL : 0)\n                           | HTTP_FLAG_TRUST_DEF),\n                          gnupg_http_tls_verify_cb, ctrl);\n  if (err)\n    goto leave;\n  http_session_set_log_cb (session, cert_log_cb);\n  http_session_set_timeout (session, ctrl->timeout);\n\n once_more:\n  err = http_open (&http,\n                   post_cb? HTTP_REQ_POST : HTTP_REQ_GET,\n                   request,\n                   httphost,\n                   /* fixme: AUTH */ NULL,\n                   (httpflags\n                    |(opt.honor_http_proxy? HTTP_FLAG_TRY_PROXY:0)\n                    |(dirmngr_use_tor ()? HTTP_FLAG_FORCE_TOR:0)\n                    |(opt.disable_ipv4? HTTP_FLAG_IGNORE_IPv4 : 0)\n                    |(opt.disable_ipv6? HTTP_FLAG_IGNORE_IPv6 : 0)),\n                   ctrl->http_proxy,\n                   session,\n                   NULL,\n                   /*FIXME curl->srvtag*/NULL);\n  if (!err)\n    {\n      fp = http_get_write_ptr (http);\n      /* Avoid caches to get the most recent copy of the key.  We set\n         both the Pragma and Cache-Control versions of the header, so\n         we're good with both HTTP 1.0 and 1.1.  */\n      es_fputs (\"Pragma: no-cache\\r\\n\"\n                \"Cache-Control: no-cache\\r\\n\", fp);\n      if (post_cb)\n        err = post_cb (post_cb_value, http);\n      if (!err)\n        {\n          http_start_data (http);\n          if (es_ferror (fp))\n            err = gpg_error_from_syserror ();\n        }\n    }\n  if (err)\n    {\n      /* Fixme: After a redirection we show the old host name.  */\n      log_error (_(\"error connecting to '%s': %s\\n\"),\n                 hostportstr, gpg_strerror (err));\n      goto leave;\n    }\n\n  /* Wait for the response.  */\n  dirmngr_tick (ctrl);\n  err = http_wait_response (http);\n  if (err)\n    {\n      log_error (_(\"error reading HTTP response for '%s': %s\\n\"),\n                 hostportstr, gpg_strerror (err));\n      goto leave;\n    }\n\n  if (http_get_tls_info (http, NULL))\n    {\n      /* Update the httpflags so that a redirect won't fallback to an\n         unencrypted connection.  */\n      httpflags |= HTTP_FLAG_FORCE_TLS;\n    }\n\n  if (r_http_status)\n    *r_http_status = http_get_status_code (http);\n\n  switch (http_get_status_code (http))\n    {\n    case 200:\n      err = 0;\n      break; /* Success.  */\n\n    case 301:\n    case 302:\n    case 307:\n      {\n        xfree (request_buffer);\n        err = http_prepare_redirect (&redirinfo, http_get_status_code (http),\n                                     http_get_header (http, \"Location\"),\n                                     &request_buffer);\n        if (err)\n          goto leave;\n\n        request = request_buffer;\n        http_close (http, 0);\n        http = NULL;\n      }\n      goto once_more;\n\n    case 501:\n      err = gpg_error (GPG_ERR_NOT_IMPLEMENTED);\n      goto leave;\n\n    default:\n      log_error (_(\"error accessing '%s': http status %u\\n\"),\n                 request, http_get_status_code (http));\n      err = gpg_error (GPG_ERR_NO_DATA);\n      goto leave;\n    }\n\n  /* FIXME: We should register a permanent redirection and whether a\n     host has ever used TLS so that future calls will always use\n     TLS. */\n\n  fp = http_get_read_ptr (http);\n  if (!fp)\n    {\n      err = gpg_error (GPG_ERR_BUG);\n      goto leave;\n    }\n\n  /* Return the read stream and close the HTTP context.  */\n  *r_fp = fp;\n  http_close (http, 1);\n  http = NULL;\n\n leave:\n  http_close (http, 0);\n  http_session_release (session);\n  xfree (request_buffer);\n  http_release_parsed_uri (uri);\n  return err;\n}",
        "target": 0,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 308978386606727038138333207925123481062,
        "size": 150,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "cookie_write (void *cookie, const void *buffer_arg, size_t size)\n{\n  const char *buffer = buffer_arg;\n  cookie_t c = cookie;\n  int nwritten = 0;\n\n#if HTTP_USE_NTBTLS\n  if (c->use_tls && c->session && c->session->tls_session)\n    {\n      estream_t in, out;\n\n      ntbtls_get_stream (c->session->tls_session, &in, &out);\n      if (size == 0)\n        es_fflush (out);\n      else\n        nwritten = es_fwrite (buffer, 1, size, out);\n      if (opt_debug)\n        log_debug (\"TLS network write: %d/%zu\\n\", nwritten, size);\n    }\n  else\n#elif HTTP_USE_GNUTLS\n  if (c->use_tls && c->session && c->session->tls_session)\n    {\n      int nleft = size;\n      while (nleft > 0)\n        {\n          nwritten = gnutls_record_send (c->session->tls_session,\n                                         buffer, nleft);\n          if (nwritten <= 0)\n            {\n              if (nwritten == GNUTLS_E_INTERRUPTED)\n                continue;\n              if (nwritten == GNUTLS_E_AGAIN)\n                {\n                  struct timeval tv;\n\n                  tv.tv_sec = 0;\n                  tv.tv_usec = 50000;\n                  my_select (0, NULL, NULL, NULL, &tv);\n                  continue;\n                }\n              log_info (\"TLS network write failed: %s\\n\",\n                        gnutls_strerror (nwritten));\n              gpg_err_set_errno (EIO);\n              return -1;\n            }\n          nleft -= nwritten;\n          buffer += nwritten;\n        }\n    }\n  else\n#endif /*HTTP_USE_GNUTLS*/\n    {\n      if ( write_server (c->sock->fd, buffer, size) )\n        {\n          gpg_err_set_errno (EIO);\n          nwritten = -1;\n        }\n      else\n        nwritten = size;\n    }\n\n  return (gpgrt_ssize_t)nwritten;\n}",
        "target": 0,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 89287088909435856015436469777205926639,
        "size": 64,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "http_escape_string (const char *string, const char *specials)\n{\n  int n;\n  char *buf;\n\n  n = insert_escapes (NULL, string, specials);\n  buf = xtrymalloc (n+1);\n  if (buf)\n    {\n      insert_escapes (buf, string, specials);\n      buf[n] = 0;\n    }\n  return buf;\n}",
        "target": 0,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 208996079478463061320678139537838575384,
        "size": 14,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "my_wsagetlasterror (void)\n{\n  int wsaerr;\n  gpg_err_code_t ec;\n\n  wsaerr = WSAGetLastError ();\n  switch (wsaerr)\n    {\n    case WSAENOTSOCK:        ec = GPG_ERR_EINVAL;       break;\n    case WSAEWOULDBLOCK:     ec = GPG_ERR_EAGAIN;       break;\n    case ERROR_BROKEN_PIPE:  ec = GPG_ERR_EPIPE;        break;\n    case WSANOTINITIALISED:  ec = GPG_ERR_ENOSYS;       break;\n    case WSAENOBUFS:         ec = GPG_ERR_ENOBUFS;      break;\n    case WSAEMSGSIZE:        ec = GPG_ERR_EMSGSIZE;     break;\n    case WSAECONNREFUSED:    ec = GPG_ERR_ECONNREFUSED; break;\n    case WSAEISCONN:         ec = GPG_ERR_EISCONN;      break;\n    case WSAEALREADY:        ec = GPG_ERR_EALREADY;     break;\n    case WSAETIMEDOUT:       ec = GPG_ERR_ETIMEDOUT;    break;\n    default:                 ec = GPG_ERR_EIO;          break;\n    }\n\n  return gpg_err_make (default_errsource, ec);\n}",
        "target": 0,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 263247362446156614815018141793115503221,
        "size": 23,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "http_session_new (http_session_t *r_session,\n                  const char *intended_hostname, unsigned int flags,\n                  http_verify_cb_t verify_cb, void *verify_cb_value)\n{\n  gpg_error_t err;\n  http_session_t sess;\n\n  *r_session = NULL;\n\n  sess = xtrycalloc (1, sizeof *sess);\n  if (!sess)\n    return gpg_error_from_syserror ();\n  sess->magic = HTTP_SESSION_MAGIC;\n  sess->refcount = 1;\n  sess->flags = flags;\n  sess->verify_cb = verify_cb;\n  sess->verify_cb_value = verify_cb_value;\n  sess->connect_timeout = 0;\n\n#if HTTP_USE_NTBTLS\n  {\n    (void)intended_hostname; /* Not needed because we do not preload\n                              * certificates.  */\n\n    err = ntbtls_new (&sess->tls_session, NTBTLS_CLIENT);\n    if (err)\n      {\n        log_error (\"ntbtls_new failed: %s\\n\", gpg_strerror (err));\n        goto leave;\n      }\n\n  }\n#elif HTTP_USE_GNUTLS\n  {\n    const char *errpos;\n    int rc;\n    strlist_t sl;\n    int add_system_cas = !!(flags & HTTP_FLAG_TRUST_SYS);\n    int is_hkps_pool;\n\n    rc = gnutls_certificate_allocate_credentials (&sess->certcred);\n    if (rc < 0)\n      {\n        log_error (\"gnutls_certificate_allocate_credentials failed: %s\\n\",\n                   gnutls_strerror (rc));\n        err = gpg_error (GPG_ERR_GENERAL);\n        goto leave;\n      }\n\n    is_hkps_pool = (intended_hostname\n                    && !ascii_strcasecmp (intended_hostname,\n                                          get_default_keyserver (1)));\n\n    /* If the user has not specified a CA list, and they are looking\n     * for the hkps pool from sks-keyservers.net, then default to\n     * Kristian's certificate authority:  */\n    if (!tls_ca_certlist && is_hkps_pool)\n      {\n        char *pemname = make_filename_try (gnupg_datadir (),\n                                           \"sks-keyservers.netCA.pem\", NULL);\n        if (!pemname)\n          {\n            err = gpg_error_from_syserror ();\n            log_error (\"setting CA from file '%s' failed: %s\\n\",\n                       pemname, gpg_strerror (err));\n          }\n        else\n          {\n            rc = gnutls_certificate_set_x509_trust_file\n              (sess->certcred, pemname, GNUTLS_X509_FMT_PEM);\n            if (rc < 0)\n              log_info (\"setting CA from file '%s' failed: %s\\n\",\n                        pemname, gnutls_strerror (rc));\n            xfree (pemname);\n          }\n      }\n\n    /* Add configured certificates to the session.  */\n    if ((flags & HTTP_FLAG_TRUST_DEF))\n      {\n        for (sl = tls_ca_certlist; sl; sl = sl->next)\n          {\n            rc = gnutls_certificate_set_x509_trust_file\n              (sess->certcred, sl->d,\n               (sl->flags & 1)? GNUTLS_X509_FMT_PEM : GNUTLS_X509_FMT_DER);\n            if (rc < 0)\n              log_info (\"setting CA from file '%s' failed: %s\\n\",\n                        sl->d, gnutls_strerror (rc));\n          }\n        if (!tls_ca_certlist && !is_hkps_pool)\n          add_system_cas = 1;\n      }\n\n    /* Add system certificates to the session.  */\n    if (add_system_cas)\n      {\n#if GNUTLS_VERSION_NUMBER >= 0x030014\n        static int shown;\n\n        rc = gnutls_certificate_set_x509_system_trust (sess->certcred);\n        if (rc < 0)\n          log_info (\"setting system CAs failed: %s\\n\", gnutls_strerror (rc));\n        else if (!shown)\n          {\n            shown = 1;\n            log_info (\"number of system provided CAs: %d\\n\", rc);\n          }\n#endif /* gnutls >= 3.0.20 */\n      }\n\n    /* Add other configured certificates to the session.  */\n    if ((flags & HTTP_FLAG_TRUST_CFG))\n      {\n        for (sl = cfg_ca_certlist; sl; sl = sl->next)\n          {\n            rc = gnutls_certificate_set_x509_trust_file\n              (sess->certcred, sl->d,\n               (sl->flags & 1)? GNUTLS_X509_FMT_PEM : GNUTLS_X509_FMT_DER);\n            if (rc < 0)\n              log_info (\"setting extra CA from file '%s' failed: %s\\n\",\n                        sl->d, gnutls_strerror (rc));\n          }\n      }\n\n\n    rc = gnutls_init (&sess->tls_session, GNUTLS_CLIENT);\n    if (rc < 0)\n      {\n        log_error (\"gnutls_init failed: %s\\n\", gnutls_strerror (rc));\n        err = gpg_error (GPG_ERR_GENERAL);\n        goto leave;\n      }\n    /* A new session has the transport ptr set to (void*(-1), we need\n       it to be NULL.  */\n    gnutls_transport_set_ptr (sess->tls_session, NULL);\n\n    rc = gnutls_priority_set_direct (sess->tls_session,\n                                     \"NORMAL\",\n                                     &errpos);\n    if (rc < 0)\n      {\n        log_error (\"gnutls_priority_set_direct failed at '%s': %s\\n\",\n                   errpos, gnutls_strerror (rc));\n        err = gpg_error (GPG_ERR_GENERAL);\n        goto leave;\n      }\n\n    rc = gnutls_credentials_set (sess->tls_session,\n                                 GNUTLS_CRD_CERTIFICATE, sess->certcred);\n    if (rc < 0)\n      {\n        log_error (\"gnutls_credentials_set failed: %s\\n\", gnutls_strerror (rc));\n        err = gpg_error (GPG_ERR_GENERAL);\n        goto leave;\n      }\n  }\n#else /*!HTTP_USE_GNUTLS && !HTTP_USE_NTBTLS*/\n  {\n    (void)intended_hostname;\n    (void)flags;\n  }\n#endif /*!HTTP_USE_GNUTLS && !HTTP_USE_NTBTLS*/\n\n  if (opt_debug > 1)\n    log_debug (\"http.c:session_new: sess %p created\\n\", sess);\n  err = 0;\n\n#if USE_TLS\n leave:\n#endif /*USE_TLS*/\n  if (err)\n    http_session_unref (sess);\n  else\n    *r_session = sess;\n\n  return err;\n}",
        "target": 0,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 236649693869640091458302816164193336988,
        "size": 177,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "connect_server (const char *server, unsigned short port,\n                unsigned int flags, const char *srvtag, unsigned int timeout,\n                assuan_fd_t *r_sock)\n{\n  gpg_error_t err;\n  assuan_fd_t sock = ASSUAN_INVALID_FD;\n  unsigned int srvcount = 0;\n  int hostfound = 0;\n  int anyhostaddr = 0;\n  int srv, connected;\n  gpg_error_t last_err = 0;\n  struct srventry *serverlist = NULL;\n\n  *r_sock = ASSUAN_INVALID_FD;\n\n#if defined(HAVE_W32_SYSTEM) && !defined(HTTP_NO_WSASTARTUP)\n  init_sockets ();\n#endif /*Windows*/\n\n  /* Onion addresses require special treatment.  */\n  if (is_onion_address (server))\n    {\n#ifdef ASSUAN_SOCK_TOR\n\n      if (opt_debug)\n        log_debug (\"http.c:connect_server:onion: name='%s' port=%hu\\n\",\n                   server, port);\n      sock = assuan_sock_connect_byname (server, port, 0, NULL,\n                                         ASSUAN_SOCK_TOR);\n      if (sock == ASSUAN_INVALID_FD)\n        {\n          err = gpg_err_make (default_errsource,\n                              (errno == EHOSTUNREACH)? GPG_ERR_UNKNOWN_HOST\n                              : gpg_err_code_from_syserror ());\n          log_error (\"can't connect to '%s': %s\\n\", server, gpg_strerror (err));\n          return err;\n        }\n\n      notify_netactivity ();\n      *r_sock = sock;\n      return 0;\n\n#else /*!ASSUAN_SOCK_TOR*/\n\n      err = gpg_err_make (default_errsource, GPG_ERR_ENETUNREACH);\n      return ASSUAN_INVALID_FD;\n\n#endif /*!HASSUAN_SOCK_TOR*/\n    }\n\n  /* Do the SRV thing */\n  if (srvtag)\n    {\n      err = get_dns_srv (server, srvtag, NULL, &serverlist, &srvcount);\n      if (err)\n        log_info (\"getting '%s' SRV for '%s' failed: %s\\n\",\n                  srvtag, server, gpg_strerror (err));\n      /* Note that on error SRVCOUNT is zero.  */\n      err = 0;\n    }\n\n  if (!serverlist)\n    {\n      /* Either we're not using SRV, or the SRV lookup failed.  Make\n\t up a fake SRV record. */\n      serverlist = xtrycalloc (1, sizeof *serverlist);\n      if (!serverlist)\n        return gpg_err_make (default_errsource, gpg_err_code_from_syserror ());\n\n      serverlist->port = port;\n      strncpy (serverlist->target, server, DIMof (struct srventry, target));\n      serverlist->target[DIMof (struct srventry, target)-1] = '\\0';\n      srvcount = 1;\n    }\n\n  connected = 0;\n  for (srv=0; srv < srvcount && !connected; srv++)\n    {\n      dns_addrinfo_t aibuf, ai;\n\n      if (opt_debug)\n        log_debug (\"http.c:connect_server: trying name='%s' port=%hu\\n\",\n                   serverlist[srv].target, port);\n      err = resolve_dns_name (serverlist[srv].target, port, 0, SOCK_STREAM,\n                              &aibuf, NULL);\n      if (err)\n        {\n          log_info (\"resolving '%s' failed: %s\\n\",\n                    serverlist[srv].target, gpg_strerror (err));\n          last_err = err;\n          continue; /* Not found - try next one. */\n        }\n      hostfound = 1;\n\n      for (ai = aibuf; ai && !connected; ai = ai->next)\n        {\n          if (ai->family == AF_INET && (flags & HTTP_FLAG_IGNORE_IPv4))\n            continue;\n          if (ai->family == AF_INET6 && (flags & HTTP_FLAG_IGNORE_IPv6))\n            continue;\n\n          if (sock != ASSUAN_INVALID_FD)\n            assuan_sock_close (sock);\n          sock = my_sock_new_for_addr (ai->addr, ai->socktype, ai->protocol);\n          if (sock == ASSUAN_INVALID_FD)\n            {\n              err = gpg_err_make (default_errsource,\n                                  gpg_err_code_from_syserror ());\n              log_error (\"error creating socket: %s\\n\", gpg_strerror (err));\n              free_dns_addrinfo (aibuf);\n              xfree (serverlist);\n              return err;\n            }\n\n          anyhostaddr = 1;\n          err = connect_with_timeout (sock, (struct sockaddr *)ai->addr,\n                                      ai->addrlen, timeout);\n          if (err)\n            {\n              last_err = err;\n            }\n          else\n            {\n              connected = 1;\n              notify_netactivity ();\n            }\n        }\n      free_dns_addrinfo (aibuf);\n    }\n\n  xfree (serverlist);\n\n  if (!connected)\n    {\n      if (!hostfound)\n        log_error (\"can't connect to '%s': %s\\n\",\n                   server, \"host not found\");\n      else if (!anyhostaddr)\n        log_error (\"can't connect to '%s': %s\\n\",\n                   server, \"no IP address for host\");\n      else\n        {\n#ifdef HAVE_W32_SYSTEM\n        log_error (\"can't connect to '%s': ec=%d\\n\",\n                   server, (int)WSAGetLastError());\n#else\n        log_error (\"can't connect to '%s': %s\\n\",\n                   server, gpg_strerror (last_err));\n#endif\n        }\n      err = last_err? last_err : gpg_err_make (default_errsource,\n                                               GPG_ERR_UNKNOWN_HOST);\n      if (sock != ASSUAN_INVALID_FD)\n\tassuan_sock_close (sock);\n      return err;\n    }\n\n  *r_sock = sock;\n  return 0;\n}",
        "target": 0,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 187530667335305494530399083340692516457,
        "size": 160,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "http_get_read_ptr (http_t hd)\n{\n  return hd?hd->fp_read:NULL;\n}",
        "target": 0,
        "cwe": [
            "CWE-352"
        ],
        "project": "gnupg",
        "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060",
        "hash": 262357717209195039627738785793176191127,
        "size": 4,
        "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)"
    },
    {
        "func": "static int zipfileUpdate(\n  sqlite3_vtab *pVtab, \n  int nVal, \n  sqlite3_value **apVal, \n  sqlite_int64 *pRowid\n){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;             /* Return Code */\n  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */\n\n  u32 mode = 0;                   /* Mode for new entry */\n  u32 mTime = 0;                  /* Modification time for new entry */\n  i64 sz = 0;                     /* Uncompressed size */\n  const char *zPath = 0;          /* Path for new entry */\n  int nPath = 0;                  /* strlen(zPath) */\n  const u8 *pData = 0;            /* Pointer to buffer containing content */\n  int nData = 0;                  /* Size of pData buffer in bytes */\n  int iMethod = 0;                /* Compression method for new entry */\n  u8 *pFree = 0;                  /* Free this */\n  char *zFree = 0;                /* Also free this */\n  ZipfileEntry *pOld = 0;\n  ZipfileEntry *pOld2 = 0;\n  int bUpdate = 0;                /* True for an update that modifies \"name\" */\n  int bIsDir = 0;\n  u32 iCrc32 = 0;\n\n  if( pTab->pWriteFd==0 ){\n    rc = zipfileBegin(pVtab);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  /* If this is a DELETE or UPDATE, find the archive entry to delete. */\n  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){\n    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);\n    int nDelete = (int)strlen(zDelete);\n    if( nVal>1 ){\n      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);\n      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){\n        bUpdate = 1;\n      }\n    }\n    for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){\n      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){\n        break;\n      }\n      assert( pOld->pNext );\n    }\n  }\n\n  if( nVal>1 ){\n    /* Check that \"sz\" and \"rawdata\" are both NULL: */\n    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"sz must be NULL\");\n      rc = SQLITE_CONSTRAINT;\n    }\n    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"rawdata must be NULL\"); \n      rc = SQLITE_CONSTRAINT;\n    }\n\n    if( rc==SQLITE_OK ){\n      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){\n        /* data=NULL. A directory */\n        bIsDir = 1;\n      }else{\n        /* Value specified for \"data\", and possibly \"method\". This must be\n        ** a regular file or a symlink. */\n        const u8 *aIn = sqlite3_value_blob(apVal[7]);\n        int nIn = sqlite3_value_bytes(apVal[7]);\n        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;\n\n        iMethod = sqlite3_value_int(apVal[8]);\n        sz = nIn;\n        pData = aIn;\n        nData = nIn;\n        if( iMethod!=0 && iMethod!=8 ){\n          zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);\n          rc = SQLITE_CONSTRAINT;\n        }else{\n          if( bAuto || iMethod ){\n            int nCmp;\n            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);\n            if( rc==SQLITE_OK ){\n              if( iMethod || nCmp<nIn ){\n                iMethod = 8;\n                pData = pFree;\n                nData = nCmp;\n              }\n            }\n          }\n          iCrc32 = crc32(0, aIn, nIn);\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);\n    }\n\n    if( rc==SQLITE_OK ){\n      zPath = (const char*)sqlite3_value_text(apVal[2]);\n      nPath = (int)strlen(zPath);\n      mTime = zipfileGetTime(apVal[4]);\n    }\n\n    if( rc==SQLITE_OK && bIsDir ){\n      /* For a directory, check that the last character in the path is a\n      ** '/'. This appears to be required for compatibility with info-zip\n      ** (the unzip command on unix). It does not create directories\n      ** otherwise.  */\n      if( zPath[nPath-1]!='/' ){\n        zFree = sqlite3_mprintf(\"%s/\", zPath);\n        if( zFree==0 ){ rc = SQLITE_NOMEM; }\n        zPath = (const char*)zFree;\n        nPath++;\n      }\n    }\n\n    /* Check that we're not inserting a duplicate entry -OR- updating an\n    ** entry with a path, thereby making it into a duplicate. */\n    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){\n      ZipfileEntry *p;\n      for(p=pTab->pFirstEntry; p; p=p->pNext){\n        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){\n          switch( sqlite3_vtab_on_conflict(pTab->db) ){\n            case SQLITE_IGNORE: {\n              goto zipfile_update_done;\n            }\n            case SQLITE_REPLACE: {\n              pOld2 = p;\n              break;\n            }\n            default: {\n              zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);\n              rc = SQLITE_CONSTRAINT;\n              break;\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      /* Create the new CDS record. */\n      pNew = zipfileNewEntry(zPath);\n      if( pNew==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n        pNew->cds.iCompression = (u16)iMethod;\n        zipfileMtimeToDos(&pNew->cds, mTime);\n        pNew->cds.crc32 = iCrc32;\n        pNew->cds.szCompressed = nData;\n        pNew->cds.szUncompressed = (u32)sz;\n        pNew->cds.iExternalAttr = (mode<<16);\n        pNew->cds.iOffset = (u32)pTab->szCurrent;\n        pNew->cds.nFile = (u16)nPath;\n        pNew->mUnixTime = (u32)mTime;\n        rc = zipfileAppendEntry(pTab, pNew, pData, nData);\n        zipfileAddEntry(pTab, pOld, pNew);\n      }\n    }\n  }\n\n  if( rc==SQLITE_OK && (pOld || pOld2) ){\n    ZipfileCsr *pCsr;\n    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){\n      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){\n        pCsr->pCurrent = pCsr->pCurrent->pNext;\n        pCsr->bNoop = 1;\n      }\n    }\n\n    zipfileRemoveEntryFromList(pTab, pOld);\n    zipfileRemoveEntryFromList(pTab, pOld2);\n  }\n\nzipfile_update_done:\n  sqlite3_free(pFree);\n  sqlite3_free(zFree);\n  return rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-434"
        ],
        "project": "sqlite",
        "commit_id": "54d501092d88c0cf89bec4279951f548fb0b8618",
        "hash": 327236541099997070257636886847157126359,
        "size": 185,
        "message": "Fix the zipfile extension so that INSERT works even if the pathname of\nthe file being inserted is a NULL.  Bug discovered by the\nYongheng and Rui fuzzer.\n\nFossilOrigin-Name: a80f84b511231204658304226de3e075a55afc2e3f39ac063716f7a57f585c06"
    },
    {
        "func": "void dostor(char *name, const int append, const int autorename)\n{\n    ULHandler ulhandler;\n    int f;\n    const char *ul_name = NULL;\n    const char *atomic_file = NULL;\n    off_t filesize = (off_t) 0U;\n    struct stat st;\n    double started = 0.0;\n    signed char overwrite = 0;\n    int overflow = 0;\n    int ret = -1;\n    off_t max_filesize = (off_t) -1;\n#ifdef QUOTAS\n    Quota quota;\n#endif\n    const char *name2 = NULL;\n\n    if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n        addreply_noformat(503, MSG_NO_ASCII_RESUME);\n        goto end;\n    }\n#ifndef ANON_CAN_RESUME\n    if (guest != 0 && anon_noupload != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n        goto end;\n    }\n#endif\n    if (ul_check_free_space(name, -1.0) == 0) {\n        addreply_noformat(552, MSG_NO_DISK_SPACE);\n        goto end;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        goto end;\n    }\n    if (autorename != 0) {\n        no_truncate = 1;\n    }\n    if (restartat > (off_t) 0 || no_truncate != 0) {\n        if ((atomic_file = get_atomic_file(name)) == NULL) {\n            addreply(553, MSG_SANITY_FILE_FAILURE, name);\n            goto end;\n        }\n        if (restartat > (off_t) 0 &&\n            rename(name, atomic_file) != 0 && errno != ENOENT) {\n            error(553, MSG_RENAME_FAILURE);\n            atomic_file = NULL;\n            goto end;\n        }\n    }\n    if (atomic_file != NULL) {\n        ul_name = atomic_file;\n    } else {\n        ul_name = name;\n    }\n    if (atomic_file == NULL &&\n        (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {\n        overwrite++;\n    } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,\n                         (mode_t) 0777 & ~u_mask)) == -1) {\n        error(553, MSG_OPEN_FAILURE2);\n        goto end;\n    }\n    if (fstat(f, &st) < 0) {\n        (void) close(f);\n        error(553, MSG_STAT_FAILURE2);\n        goto end;\n    }\n    if (!S_ISREG(st.st_mode)) {\n        (void) close(f);\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        goto end;\n    }\n    alarm(MAX_SESSION_XFER_IDLE);\n\n    /* Anonymous users *CAN* overwrite 0-bytes files - This is the right behavior */\n    if (st.st_size > (off_t) 0) {\n#ifndef ANON_CAN_RESUME\n        if (guest != 0) {\n            addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n            (void) close(f);\n            goto end;\n        }\n#endif\n        if (append != 0) {\n            restartat = st.st_size;\n        }\n    } else {\n        restartat = (off_t) 0;\n    }\n    if (restartat > st.st_size) {\n        restartat = st.st_size;\n    }\n    if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {\n        (void) close(f);\n        error(451, \"seek\");\n        goto end;\n    }\n    if (restartat < st.st_size) {\n        if (ftruncate(f, restartat) < 0) {\n            (void) close(f);\n            error(451, \"ftruncate\");\n            goto end;\n        }\n#ifdef QUOTAS\n        if (restartat != st.st_size) {\n            (void) quota_update(NULL, 0LL,\n                                (long long) (restartat - st.st_size),\n                                &overflow);\n        }\n#endif\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&\n        (overflow > 0 || quota.files >= user_quota_files ||\n         quota.size > user_quota_size ||\n         (max_filesize >= (off_t) 0 &&\n          (max_filesize = user_quota_size - quota.size) < (off_t) 0))) {\n        overflow = 1;\n        (void) close(f);\n        goto afterquota;\n    }\n#endif\n    opendata();\n    if (xferfd == -1) {\n        (void) close(f);\n        goto end;\n    }\n    doreply();\n# ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n    }\n# endif\n    state_needs_update = 1;\n    setprocessname(\"pure-ftpd (UPLOAD)\");\n    filesize = restartat;\n\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        const size_t sl = strlen(name);\n\n        ftpwho_lock();\n        shm_data_cur->state = FTPWHO_STATE_UPLOAD;\n        shm_data_cur->download_total_size = (off_t) 0U;\n        shm_data_cur->download_current_size = (off_t) filesize;\n        shm_data_cur->restartat = restartat;\n        (void) time(&shm_data_cur->xfer_date);\n        if (sl < sizeof shm_data_cur->filename) {\n            memcpy(shm_data_cur->filename, name, sl);\n            shm_data_cur->filename[sl] = 0;\n        } else {\n            memcpy(shm_data_cur->filename,\n                   &name[sl - sizeof shm_data_cur->filename - 1U],\n                   sizeof shm_data_cur->filename);\n        }\n        ftpwho_unlock();\n    }\n#endif\n\n    /* Here starts the real upload code */\n\n    started = get_usec_time();\n\n    if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,\n                restartat, type == 1, throttling_bandwidth_ul,\n                max_filesize) == 0) {\n        ret = ul_send(&ulhandler);\n        ul_exit(&ulhandler);\n    } else {\n        ret = -1;\n    }\n    (void) close(f);\n    closedata();\n\n    /* Here ends the real upload code */\n\n#ifdef SHOW_REAL_DISK_SPACE\n    if (FSTATFS(f, &statfsbuf) == 0) {\n        double space;\n\n        space = (double) STATFS_BAVAIL(statfsbuf) *\n            (double) STATFS_FRSIZE(statfsbuf);\n        if (space > 524288.0) {\n            addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);\n        } else {\n            addreply(0, MSG_SPACE_FREE_K, space / 1024.0);\n        }\n    }\n#endif\n\n    uploaded += (unsigned long long) ulhandler.total_uploaded;\n    {\n        off_t atomic_file_size;\n        off_t original_file_size;\n        int files_count;\n\n        if (overwrite == 0) {\n            files_count = 1;\n        } else {\n            files_count = 0;\n        }\n        if (autorename != 0 && restartat == (off_t) 0) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if (tryautorename(atomic_file, name, &name2) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else if (atomic_file != NULL) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if ((original_file_size = get_file_size(name)) < (off_t) 0 ||\n                restartat > original_file_size) {\n                original_file_size = restartat;\n            }\n            if (rename(atomic_file, name) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                overflow = ul_quota_update\n                    (name, files_count, atomic_file_size - original_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else {\n#ifdef QUOTAS\n            overflow = ul_quota_update\n                (name, files_count, ulhandler.total_uploaded);\n#endif\n        }\n    }\n    afterquota:\n    if (overflow > 0) {\n        addreply(552, MSG_QUOTA_EXCEEDED, name);\n    } else {\n        if (ret == 0) {\n            addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n        } else {\n            addreply_noformat(451, MSG_ABORTED);\n        }\n        displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,\n                    name2 ? name2 : name, 1);\n    }\n    end:\n    restartat = (off_t) 0;\n    if (atomic_file != NULL) {\n        unlink(atomic_file);\n        atomic_file = NULL;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-434"
        ],
        "project": "pure-ftpd",
        "commit_id": "37ad222868e52271905b94afea4fc780d83294b4",
        "hash": 113967088182698550414121557184153731623,
        "size": 260,
        "message": "Initialize the max upload file size when quotas are enabled\n\nDue to an unwanted check, files causing the quota to be exceeded\nwere deleted after the upload, but not during the upload.\n\nThe bug was introduced in 2009 in version 1.0.23\n\nSpotted by @DroidTest, thanks!"
    },
    {
        "func": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n\n    lua_pushcfunction(_state, lua_loadstring);\n    lua_setglobal(_state, \"loadstring\");\n\n    // Open Crawl bindings\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n\n    cluaopen_globals(_state);\n\n    execfile(\"dlua/macro.lua\", true, true);\n\n    // All hook names must be chk_????\n    execstring(\"chk_startgame = { }\", \"base\");\n\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n\n    lua_register(_state, \"crawl_require\", _clua_require);\n\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-434"
        ],
        "project": "crawl",
        "commit_id": "fc522ff6eb1bbb85e3de60c60a45762571e48c28",
        "hash": 98210248009368813109925204826422830229,
        "size": 44,
        "message": "Disable lua load(), loadstring() bytcode loading"
    },
    {
        "func": "int CLua::loadfile(lua_State *ls, const char *filename, bool trusted,\n                   bool die_on_fail)\n{\n    if (!ls)\n        return -1;\n\n    if (!is_path_safe(filename, trusted))\n    {\n        lua_pushstring(\n            ls,\n            make_stringf(\"invalid filename: %s\", filename).c_str());\n        return -1;\n    }\n\n    string file = datafile_path(filename, die_on_fail);\n    if (file.empty())\n    {\n        lua_pushstring(ls,\n                       make_stringf(\"Can't find \\\"%s\\\"\", filename).c_str());\n        return -1;\n    }\n\n    FileLineInput f(file.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n\n    // prefixing with @ stops lua from adding [string \"%s\"]\n    return luaL_loadbuffer(ls, &script[0], script.length(),\n                           (\"@\" + file).c_str());\n}",
        "target": 1,
        "cwe": [
            "CWE-434"
        ],
        "project": "crawl",
        "commit_id": "fc522ff6eb1bbb85e3de60c60a45762571e48c28",
        "hash": 221360351941475865616353015828899441819,
        "size": 31,
        "message": "Disable lua load(), loadstring() bytcode loading"
    },
    {
        "func": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n\n    // Open Crawl bindings\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n\n    cluaopen_globals(_state);\n\n    execfile(\"dlua/macro.lua\", true, true);\n\n    // All hook names must be chk_????\n    execstring(\"chk_startgame = { }\", \"base\");\n\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n\n    lua_register(_state, \"crawl_require\", _clua_require);\n\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-434"
        ],
        "project": "crawl",
        "commit_id": "768f60da87a3fa0b5561da5ade9309577c176d04",
        "hash": 154780829118697956425756187036263034182,
        "size": 41,
        "message": "Disable lua bytecode loading"
    },
    {
        "func": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-352"
        ],
        "project": "taglib",
        "commit_id": "cb9f07d9dcd791b63e622da43f7b232adaec0a9a",
        "hash": 90554238838364427332066692407325541305,
        "size": 30,
        "message": "Don't assume TDRC is an instance of TextIdentificationFrame (#831)\n\nIf TDRC is encrypted, FrameFactory::createFrame() returns UnknownFrame\r\nwhich causes problems in rebuildAggregateFrames() when it is assumed\r\nthat TDRC is a TextIdentificationFrame"
    },
    {
        "func": "std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)\n{\n    std::string real_rule, ret;\n\n    for(const RegexMatchConfig &x : emoji_array)\n    {\n        if(!x.Script.empty())\n        {\n            std::string result;\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval(\"getEmoji\");\n                    ret = getEmoji(node);\n                    if(!ret.empty())\n                        result = ret + \" \" + node.Remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            if(!result.empty())\n                return result;\n            continue;\n        }\n        if(x.Replace.empty())\n            continue;\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))\n            return x.Replace + \" \" + node.Remark;\n    }\n    return node.Remark;\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 132002016930276271333333245864217716467,
        "size": 38,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)\n{\n    std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;\n\n    for(const RegexMatchConfig &x : rename_array)\n    {\n        if(!x.Script.empty())\n        {\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto rename = (std::function<std::string(const Proxy&)>) ctx.eval(\"rename\");\n                    returned_remark = rename(node);\n                    if(!returned_remark.empty())\n                        remark = returned_remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            continue;\n        }\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size())\n            remark = regReplace(remark, real_rule, x.Replace);\n    }\n    if(remark.empty())\n        remark = original_remark;\n    return;\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 306901170164017099767137110025532976877,
        "size": 35,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)\n{\n    std::string real_rule;\n    if(startsWith(rule, \"[]\") && add_direct)\n    {\n        filtered_nodelist.emplace_back(rule.substr(2));\n    }\n#ifndef NO_JS_RUNTIME\n    else if(startsWith(rule, \"script:\"))\n    {\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n            std::string script = fileGet(rule.substr(7), true);\n            try\n            {\n                ctx.eval(script);\n                auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(\"filter\");\n                std::string result_list = filter(nodelist);\n                filtered_nodelist = split(regTrim(result_list), \"\\n\");\n            }\n            catch (qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n#endif // NO_JS_RUNTIME\n    else\n    {\n        for(Proxy &x : nodelist)\n        {\n            if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())\n                filtered_nodelist.emplace_back(x.Remark);\n        }\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 204502194084591229745185063800860097354,
        "size": 35,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "void readConf()\n{\n    guarded_mutex guard(gMutexConfigure);\n    //std::cerr<<\"Reading preference settings...\"<<std::endl;\n    writeLog(0, \"Reading preference settings...\", LOG_LEVEL_INFO);\n\n    eraseElements(global.excludeRemarks);\n    eraseElements(global.includeRemarks);\n    eraseElements(global.customProxyGroups);\n    eraseElements(global.customRulesets);\n\n    try\n    {\n        std::string prefdata = fileGet(global.prefPath, false);\n        if(prefdata.find(\"common:\") != prefdata.npos)\n        {\n            YAML::Node yaml = YAML::Load(prefdata);\n            if(yaml.size() && yaml[\"common\"])\n                return readYAMLConf(yaml);\n        }\n        toml::value conf = parseToml(prefdata, global.prefPath);\n        if(!conf.is_uninitialized() && toml::find_or<int>(conf, \"version\", 0))\n            return readTOMLConf(conf);\n    }\n    catch (YAML::Exception &e)\n    {\n        //ignore yaml parse error\n    }\n    catch (toml::exception &e)\n    {\n        //ignore toml parse error\n        writeLog(0, e.what(), LOG_LEVEL_DEBUG);\n    }\n\n    INIReader ini;\n    ini.allow_dup_section_titles = true;\n    //ini.do_utf8_to_gbk = true;\n    int retVal = ini.ParseFile(global.prefPath);\n    if(retVal != INIREADER_EXCEPTION_NONE)\n    {\n        //std::cerr<<\"Unable to load preference settings. Reason: \"<<ini.GetLastError()<<\"\\n\";\n        writeLog(0, \"Unable to load preference settings. Reason: \" + ini.GetLastError(), LOG_LEVEL_FATAL);\n        return;\n    }\n\n    string_array tempArray;\n\n    ini.EnterSection(\"common\");\n    ini.GetBoolIfExist(\"api_mode\", global.APIMode);\n    ini.GetIfExist(\"api_access_token\", global.accessToken);\n    ini.GetIfExist(\"default_url\", global.defaultUrls);\n    global.enableInsert = ini.Get(\"enable_insert\");\n    ini.GetIfExist(\"insert_url\", global.insertUrls);\n    ini.GetBoolIfExist(\"prepend_insert_url\", global.prependInsert);\n    if(ini.ItemPrefixExist(\"exclude_remarks\"))\n        ini.GetAll(\"exclude_remarks\", global.excludeRemarks);\n    if(ini.ItemPrefixExist(\"include_remarks\"))\n        ini.GetAll(\"include_remarks\", global.includeRemarks);\n    global.filterScript = ini.GetBool(\"enable_filter\") ? ini.Get(\"filter_script\"): \"\";\n    ini.GetIfExist(\"base_path\", global.basePath);\n    ini.GetIfExist(\"clash_rule_base\", global.clashBase);\n    ini.GetIfExist(\"surge_rule_base\", global.surgeBase);\n    ini.GetIfExist(\"surfboard_rule_base\", global.surfboardBase);\n    ini.GetIfExist(\"mellow_rule_base\", global.mellowBase);\n    ini.GetIfExist(\"quan_rule_base\", global.quanBase);\n    ini.GetIfExist(\"quanx_rule_base\", global.quanXBase);\n    ini.GetIfExist(\"loon_rule_base\", global.loonBase);\n    ini.GetIfExist(\"default_external_config\", global.defaultExtConfig);\n    ini.GetBoolIfExist(\"append_proxy_type\", global.appendType);\n    ini.GetIfExist(\"proxy_config\", global.proxyConfig);\n    ini.GetIfExist(\"proxy_ruleset\", global.proxyRuleset);\n    ini.GetIfExist(\"proxy_subscription\", global.proxySubscription);\n\n    if(ini.SectionExist(\"surge_external_proxy\"))\n    {\n        ini.EnterSection(\"surge_external_proxy\");\n        ini.GetIfExist(\"surge_ssr_path\", global.surgeSSRPath);\n        ini.GetBoolIfExist(\"resolve_hostname\", global.surgeResolveHostname);\n    }\n\n    if(ini.SectionExist(\"node_pref\"))\n    {\n        ini.EnterSection(\"node_pref\");\n        /*\n        ini.GetBoolIfExist(\"udp_flag\", udp_flag);\n        ini.GetBoolIfExist(\"tcp_fast_open_flag\", tfo_flag);\n        ini.GetBoolIfExist(\"skip_cert_verify_flag\", scv_flag);\n        */\n        global.UDPFlag.set(ini.Get(\"udp_flag\"));\n        global.TFOFlag.set(ini.Get(\"tcp_fast_open_flag\"));\n        global.skipCertVerify.set(ini.Get(\"skip_cert_verify_flag\"));\n        global.TLS13Flag.set(ini.Get(\"tls13_flag\"));\n        ini.GetBoolIfExist(\"sort_flag\", global.enableSort);\n        global.sortScript = ini.Get(\"sort_script\");\n        ini.GetBoolIfExist(\"filter_deprecated_nodes\", global.filterDeprecated);\n        ini.GetBoolIfExist(\"append_sub_userinfo\", global.appendUserinfo);\n        ini.GetBoolIfExist(\"clash_use_new_field_name\", global.clashUseNewField);\n        ini.GetIfExist(\"clash_proxies_style\", global.clashProxiesStyle);\n        if(ini.ItemPrefixExist(\"rename_node\"))\n        {\n            ini.GetAll(\"rename_node\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"@\");\n            safe_set_renames(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    if(ini.SectionExist(\"userinfo\"))\n    {\n        ini.EnterSection(\"userinfo\");\n        if(ini.ItemPrefixExist(\"stream_rule\"))\n        {\n            ini.GetAll(\"stream_rule\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_streams(configs);\n            eraseElements(tempArray);\n        }\n        if(ini.ItemPrefixExist(\"time_rule\"))\n        {\n            ini.GetAll(\"time_rule\", tempArray);\n            importItems(tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_times(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    ini.EnterSection(\"managed_config\");\n    ini.GetBoolIfExist(\"write_managed_config\", global.writeManagedConfig);\n    ini.GetIfExist(\"managed_config_prefix\", global.managedConfigPrefix);\n    ini.GetIntIfExist(\"config_update_interval\", global.updateInterval);\n    ini.GetBoolIfExist(\"config_update_strict\", global.updateStrict);\n    ini.GetIfExist(\"quanx_device_id\", global.quanXDevID);\n\n    ini.EnterSection(\"emojis\");\n    ini.GetBoolIfExist(\"add_emoji\", global.addEmoji);\n    ini.GetBoolIfExist(\"remove_old_emoji\", global.removeEmoji);\n    if(ini.ItemPrefixExist(\"rule\"))\n    {\n        ini.GetAll(\"rule\", tempArray);\n        importItems(tempArray, false);\n        auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \",\");\n        safe_set_emojis(configs);\n        eraseElements(tempArray);\n    }\n\n    if(ini.SectionExist(\"rulesets\"))\n        ini.EnterSection(\"rulesets\");\n    else\n        ini.EnterSection(\"ruleset\");\n    global.enableRuleGen = ini.GetBool(\"enabled\");\n    if(global.enableRuleGen)\n    {\n        ini.GetBoolIfExist(\"overwrite_original_rules\", global.overwriteOriginalRules);\n        ini.GetBoolIfExist(\"update_ruleset_on_request\", global.updateRulesetOnRequest);\n        if(ini.ItemPrefixExist(\"ruleset\"))\n        {\n            string_array vArray;\n            ini.GetAll(\"ruleset\", vArray);\n            importItems(vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n        else if(ini.ItemPrefixExist(\"surge_ruleset\"))\n        {\n            string_array vArray;\n            ini.GetAll(\"surge_ruleset\", vArray);\n            importItems(vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n    }\n    else\n    {\n        global.overwriteOriginalRules = false;\n        global.updateRulesetOnRequest = false;\n    }\n\n    if(ini.SectionExist(\"proxy_groups\"))\n        ini.EnterSection(\"proxy_groups\");\n    else\n        ini.EnterSection(\"clash_proxy_group\");\n    if(ini.ItemPrefixExist(\"custom_proxy_group\"))\n    {\n        string_array vArray;\n        ini.GetAll(\"custom_proxy_group\", vArray);\n        importItems(vArray, false);\n        global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n\n    ini.EnterSection(\"template\");\n    ini.GetIfExist(\"template_path\", global.templatePath);\n    string_multimap tempmap;\n    ini.GetItems(tempmap);\n    eraseElements(global.templateVars);\n    for(auto &x : tempmap)\n    {\n        if(x.first == \"template_path\")\n            continue;\n        global.templateVars[x.first] = x.second;\n    }\n    global.templateVars[\"managed_config_prefix\"] = global.managedConfigPrefix;\n\n    if(ini.SectionExist(\"aliases\"))\n    {\n        ini.EnterSection(\"aliases\");\n        ini.GetItems(tempmap);\n        webServer.reset_redirect();\n        for(auto &x : tempmap)\n            webServer.append_redirect(x.first, x.second);\n    }\n\n    if(ini.SectionExist(\"tasks\"))\n    {\n        string_array vArray;\n        ini.EnterSection(\"tasks\");\n        ini.GetAll(\"task\", vArray);\n        importItems(vArray, false);\n        global.enableCron = !vArray.empty();\n        global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);\n        refresh_schedule();\n    }\n\n    ini.EnterSection(\"server\");\n    ini.GetIfExist(\"listen\", global.listenAddress);\n    ini.GetIntIfExist(\"port\", global.listenPort);\n    webServer.serve_file_root = ini.Get(\"serve_file_root\");\n    webServer.serve_file = !webServer.serve_file_root.empty();\n\n    ini.EnterSection(\"advanced\");\n    std::string log_level;\n    ini.GetIfExist(\"log_level\", log_level);\n    ini.GetBoolIfExist(\"print_debug_info\", global.printDbgInfo);\n    if(global.printDbgInfo)\n        global.logLevel = LOG_LEVEL_VERBOSE;\n    else\n    {\n        switch(hash_(log_level))\n        {\n        case \"warn\"_hash:\n            global.logLevel = LOG_LEVEL_WARNING;\n            break;\n        case \"error\"_hash:\n            global.logLevel = LOG_LEVEL_ERROR;\n            break;\n        case \"fatal\"_hash:\n            global.logLevel = LOG_LEVEL_FATAL;\n            break;\n        case \"verbose\"_hash:\n            global.logLevel = LOG_LEVEL_VERBOSE;\n            break;\n        case \"debug\"_hash:\n            global.logLevel = LOG_LEVEL_DEBUG;\n            break;\n        default:\n            global.logLevel = LOG_LEVEL_INFO;\n        }\n    }\n    ini.GetIntIfExist(\"max_pending_connections\", global.maxPendingConns);\n    ini.GetIntIfExist(\"max_concurrent_threads\", global.maxConcurThreads);\n    ini.GetNumberIfExist(\"max_allowed_rulesets\", global.maxAllowedRulesets);\n    ini.GetNumberIfExist(\"max_allowed_rules\", global.maxAllowedRules);\n    ini.GetNumberIfExist(\"max_allowed_download_size\", global.maxAllowedDownloadSize);\n    if(ini.ItemExist(\"enable_cache\"))\n    {\n        if(ini.GetBool(\"enable_cache\"))\n        {\n            ini.GetIntIfExist(\"cache_subscription\", global.cacheSubscription);\n            ini.GetIntIfExist(\"cache_config\", global.cacheConfig);\n            ini.GetIntIfExist(\"cache_ruleset\", global.cacheRuleset);\n            ini.GetBoolIfExist(\"serve_cache_on_fetch_fail\", global.serveCacheOnFetchFail);\n        }\n        else\n        {\n            global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; //disable cache\n            global.serveCacheOnFetchFail = false;\n        }\n    }\n    ini.GetBoolIfExist(\"script_clean_context\", global.scriptCleanContext);\n    ini.GetBoolIfExist(\"async_fetch_ruleset\", global.asyncFetchRuleset);\n    ini.GetBoolIfExist(\"skip_failed_links\", global.skipFailedLinks);\n\n    //std::cerr<<\"Read preference settings completed.\"<<std::endl;\n    writeLog(0, \"Read preference settings completed.\", LOG_LEVEL_INFO);\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 32577227885896929679341211947091619621,
        "size": 285,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "int addNodes(std::string link, std::vector<Proxy> &allNodes, int groupID, parse_settings &parse_set)\n{\n    std::string &proxy = *parse_set.proxy, &subInfo = *parse_set.sub_info;\n    string_array &exclude_remarks = *parse_set.exclude_remarks;\n    string_array &include_remarks = *parse_set.include_remarks;\n    RegexMatchConfigs &stream_rules = *parse_set.stream_rules;\n    RegexMatchConfigs &time_rules = *parse_set.time_rules;\n    string_icase_map *request_headers = parse_set.request_header;\n    bool &authorized = parse_set.authorized;\n\n    ConfType linkType = ConfType::Unknow;\n    std::vector<Proxy> nodes;\n    Proxy node;\n    std::string strSub, extra_headers, custom_group;\n\n    // TODO: replace with startsWith if appropriate\n    link = replaceAllDistinct(link, \"\\\"\", \"\");\n\n    /// script:filepath,arg1,arg2,...\n    script_safe_runner(parse_set.js_runtime, parse_set.js_context, [&](qjs::Context &ctx)\n    {\n        if(startsWith(link, \"script:\")) /// process subscription with script\n        {\n            writeLog(0, \"Found script link. Start running...\", LOG_LEVEL_INFO);\n            string_array args = split(link.substr(7), \",\");\n            if(args.size() >= 1)\n            {\n                std::string script = fileGet(args[0], false);\n                try\n                {\n                    ctx.eval(script);\n                    args.erase(args.begin()); /// remove script path\n                    auto parse = (std::function<std::string(const std::string&, const string_array&)>) ctx.eval(\"parse\");\n                    switch(args.size())\n                    {\n                    case 0:\n                        link = parse(std::string(), string_array());\n                        break;\n                    case 1:\n                        link = parse(args[0], string_array());\n                        break;\n                    default:\n                        {\n                            std::string first = args[0];\n                            args.erase(args.begin());\n                            link = parse(first, args);\n                            break;\n                        }\n                    }\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }\n        }\n    }, global.scriptCleanContext);\n            /*\n            duk_context *ctx = duktape_init();\n            defer(duk_destroy_heap(ctx);)\n            duktape_peval(ctx, script);\n            duk_get_global_string(ctx, \"parse\");\n            for(size_t i = 1; i < args.size(); i++)\n                duk_push_string(ctx, trim(args[i]).c_str());\n            if(duk_pcall(ctx, args.size() - 1) == 0)\n                link = duktape_get_res_str(ctx);\n            else\n            {\n                writeLog(0, \"Error when trying to evaluate script:\\n\" + duktape_get_err_stack(ctx), LOG_LEVEL_ERROR);\n                duk_pop(ctx); /// pop err\n            }\n            */\n\n    /// tag:group_name,link\n    if(startsWith(link, \"tag:\"))\n    {\n        string_size pos = link.find(\",\");\n        if(pos != link.npos)\n        {\n            custom_group = link.substr(4, pos - 4);\n            link.erase(0, pos + 1);\n        }\n    }\n\n    if(link == \"nullnode\")\n    {\n        node.GroupId = 0;\n        writeLog(0, \"Adding node placeholder...\");\n        allNodes.emplace_back(std::move(node));\n        return 0;\n    }\n\n    writeLog(LOG_TYPE_INFO, \"Received Link.\");\n    if(startsWith(link, \"https://t.me/socks\") || startsWith(link, \"tg://socks\"))\n        linkType = ConfType::SOCKS;\n    else if(startsWith(link, \"https://t.me/http\") || startsWith(link, \"tg://http\"))\n        linkType = ConfType::HTTP;\n    else if(isLink(link) || startsWith(link, \"surge:///install-config\"))\n        linkType = ConfType::SUB;\n    else if(startsWith(link, \"Netch://\"))\n        linkType = ConfType::Netch;\n    else if(fileExist(link))\n        linkType = ConfType::Local;\n\n    switch(linkType)\n    {\n    case ConfType::SUB:\n        writeLog(LOG_TYPE_INFO, \"Downloading subscription data...\");\n        if(startsWith(link, \"surge:///install-config\")) //surge config link\n            link = urlDecode(getUrlArg(link, \"url\"));\n        strSub = webGet(link, proxy, global.cacheSubscription, &extra_headers, request_headers);\n        /*\n        if(strSub.size() == 0)\n        {\n            //try to get it again with system proxy\n            writeLog(LOG_TYPE_WARN, \"Cannot download subscription directly. Using system proxy.\");\n            strProxy = getSystemProxy();\n            if(strProxy != \"\")\n            {\n                strSub = webGet(link, strProxy);\n            }\n            else\n                writeLog(LOG_TYPE_WARN, \"No system proxy is set. Skipping.\");\n        }\n        */\n        if(strSub.size())\n        {\n            writeLog(LOG_TYPE_INFO, \"Parsing subscription data...\");\n            if(explodeConfContent(strSub, nodes) == 0)\n            {\n                writeLog(LOG_TYPE_ERROR, \"Invalid subscription: '\" + link + \"'!\");\n                return -1;\n            }\n            if(startsWith(strSub, \"ssd://\"))\n            {\n                getSubInfoFromSSD(strSub, subInfo);\n            }\n            else\n            {\n                if(!getSubInfoFromHeader(extra_headers, subInfo))\n                    getSubInfoFromNodes(nodes, stream_rules, time_rules, subInfo);\n            }\n            filterNodes(nodes, exclude_remarks, include_remarks, groupID);\n            for(Proxy &x : nodes)\n            {\n                x.GroupId = groupID;\n                if(custom_group.size())\n                    x.Group = custom_group;\n            }\n            copyNodes(nodes, allNodes);\n        }\n        else\n        {\n            writeLog(LOG_TYPE_ERROR, \"Cannot download subscription data.\");\n            return -1;\n        }\n        break;\n    case ConfType::Local:\n        if(!authorized)\n            return -1;\n        writeLog(LOG_TYPE_INFO, \"Parsing configuration file data...\");\n        if(explodeConf(link, nodes) == 0)\n        {\n            writeLog(LOG_TYPE_ERROR, \"Invalid configuration file!\");\n            return -1;\n        }\n        if(startsWith(strSub, \"ssd://\"))\n        {\n            getSubInfoFromSSD(strSub, subInfo);\n        }\n        else\n        {\n            getSubInfoFromNodes(nodes, stream_rules, time_rules, subInfo);\n        }\n        filterNodes(nodes, exclude_remarks, include_remarks, groupID);\n        for(Proxy &x : nodes)\n        {\n            x.GroupId = groupID;\n            if(custom_group.size())\n                x.Group = custom_group;\n        }\n        copyNodes(nodes, allNodes);\n        break;\n    default:\n        explode(link, node);\n        if(node.Type == -1)\n        {\n            writeLog(LOG_TYPE_ERROR, \"No valid link found.\");\n            return -1;\n        }\n        node.GroupId = groupID;\n        if(custom_group.size())\n            node.Group = custom_group;\n        allNodes.emplace_back(std::move(node));\n    }\n    return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 104534832612799182649665756982557118996,
        "size": 197,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)\n    {\n        if(ext.remove_emoji)\n            x.Remark = trim(removeEmoji(x.Remark));\n\n        nodeRename(x, ext.rename_array, ext);\n\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size())\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");\n                    auto comparer = [&](const Proxy &a, const Proxy &b)\n                    {\n                        if(a.Type == ProxyType::Unknow)\n                            return 1;\n                        if(b.Type == ProxyType::Unknow)\n                            return 0;\n                        return compare(a, b);\n                    };\n                    std::stable_sort(nodes.begin(), nodes.end(), comparer);\n                    failed = false;\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n        }\n        if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)\n        {\n            return a.Remark < b.Remark;\n        });\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 74194829338717608878538087906995815945,
        "size": 50,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "void readYAMLConf(YAML::Node &node)\n{\n    YAML::Node section = node[\"common\"];\n    std::string strLine;\n    string_array tempArray;\n\n    section[\"api_mode\"] >> global.APIMode;\n    section[\"api_access_token\"] >> global.accessToken;\n    if(section[\"default_url\"].IsSequence())\n    {\n        section[\"default_url\"] >> tempArray;\n        if(tempArray.size())\n        {\n            strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)\n            {\n                return std::move(a) + \"|\" + std::move(b);\n            });\n            global.defaultUrls = strLine;\n            eraseElements(tempArray);\n        }\n    }\n    global.enableInsert = safe_as<std::string>(section[\"enable_insert\"]);\n    if(section[\"insert_url\"].IsSequence())\n    {\n        section[\"insert_url\"] >> tempArray;\n        if(tempArray.size())\n        {\n            strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)\n            {\n                return std::move(a) + \"|\" + std::move(b);\n            });\n            global.insertUrls = strLine;\n            eraseElements(tempArray);\n        }\n    }\n    section[\"prepend_insert_url\"] >> global.prependInsert;\n    if(section[\"exclude_remarks\"].IsSequence())\n        section[\"exclude_remarks\"] >> global.excludeRemarks;\n    if(section[\"include_remarks\"].IsSequence())\n        section[\"include_remarks\"] >> global.includeRemarks;\n    global.filterScript = safe_as<bool>(section[\"enable_filter\"]) ? safe_as<std::string>(section[\"filter_script\"]) : \"\";\n    section[\"base_path\"] >> global.basePath;\n    section[\"clash_rule_base\"] >> global.clashBase;\n    section[\"surge_rule_base\"] >> global.surgeBase;\n    section[\"surfboard_rule_base\"] >> global.surfboardBase;\n    section[\"mellow_rule_base\"] >> global.mellowBase;\n    section[\"quan_rule_base\"] >> global.quanBase;\n    section[\"quanx_rule_base\"] >> global.quanXBase;\n    section[\"loon_rule_base\"] >> global.loonBase;\n    section[\"sssub_rule_base\"] >> global.SSSubBase;\n\n    section[\"default_external_config\"] >> global.defaultExtConfig;\n    section[\"append_proxy_type\"] >> global.appendType;\n    section[\"proxy_config\"] >> global.proxyConfig;\n    section[\"proxy_ruleset\"] >> global.proxyRuleset;\n    section[\"proxy_subscription\"] >> global.proxySubscription;\n\n    if(node[\"userinfo\"].IsDefined())\n    {\n        section = node[\"userinfo\"];\n        if(section[\"stream_rule\"].IsSequence())\n        {\n            readRegexMatch(section[\"stream_rule\"], \"|\", tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_streams(configs);\n            eraseElements(tempArray);\n        }\n        if(section[\"time_rule\"].IsSequence())\n        {\n            readRegexMatch(section[\"time_rule\"], \"|\", tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"|\");\n            safe_set_times(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    if(node[\"node_pref\"].IsDefined())\n    {\n        section = node[\"node_pref\"];\n        /*\n        section[\"udp_flag\"] >> udp_flag;\n        section[\"tcp_fast_open_flag\"] >> tfo_flag;\n        section[\"skip_cert_verify_flag\"] >> scv_flag;\n        */\n        global.UDPFlag.set(safe_as<std::string>(section[\"udp_flag\"]));\n        global.TFOFlag.set(safe_as<std::string>(section[\"tcp_fast_open_flag\"]));\n        global.skipCertVerify.set(safe_as<std::string>(section[\"skip_cert_verify_flag\"]));\n        global.TLS13Flag.set(safe_as<std::string>(section[\"tls13_flag\"]));\n        section[\"sort_flag\"] >> global.enableSort;\n        section[\"sort_script\"] >> global.sortScript;\n        section[\"filter_deprecated_nodes\"] >> global.filterDeprecated;\n        section[\"append_sub_userinfo\"] >> global.appendUserinfo;\n        section[\"clash_use_new_field_name\"] >> global.clashUseNewField;\n        section[\"clash_proxies_style\"] >> global.clashProxiesStyle;\n    }\n\n    if(section[\"rename_node\"].IsSequence())\n    {\n        readRegexMatch(section[\"rename_node\"], \"@\", tempArray, false);\n        auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \"@\");\n        safe_set_renames(configs);\n        eraseElements(tempArray);\n    }\n\n    if(node[\"managed_config\"].IsDefined())\n    {\n        section = node[\"managed_config\"];\n        section[\"write_managed_config\"] >> global.writeManagedConfig;\n        section[\"managed_config_prefix\"] >> global.managedConfigPrefix;\n        section[\"config_update_interval\"] >> global.updateInterval;\n        section[\"config_update_strict\"] >> global.updateStrict;\n        section[\"quanx_device_id\"] >> global.quanXDevID;\n    }\n\n    if(node[\"surge_external_proxy\"].IsDefined())\n    {\n        node[\"surge_external_proxy\"][\"surge_ssr_path\"] >> global.surgeSSRPath;\n        node[\"surge_external_proxy\"][\"resolve_hostname\"] >> global.surgeResolveHostname;\n    }\n\n    if(node[\"emojis\"].IsDefined())\n    {\n        section = node[\"emojis\"];\n        section[\"add_emoji\"] >> global.addEmoji;\n        section[\"remove_old_emoji\"] >> global.removeEmoji;\n        if(section[\"rules\"].IsSequence())\n        {\n            readEmoji(section[\"rules\"], tempArray, false);\n            auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, \",\");\n            safe_set_emojis(configs);\n            eraseElements(tempArray);\n        }\n    }\n\n    const char *rulesets_title = node[\"rulesets\"].IsDefined() ? \"rulesets\" : \"ruleset\";\n    if(node[rulesets_title].IsDefined())\n    {\n        section = node[rulesets_title];\n        section[\"enabled\"] >> global.enableRuleGen;\n        if(!global.enableRuleGen)\n        {\n            global.overwriteOriginalRules = false;\n            global.updateRulesetOnRequest = false;\n        }\n        else\n        {\n            section[\"overwrite_original_rules\"] >> global.overwriteOriginalRules;\n            section[\"update_ruleset_on_request\"] >> global.updateRulesetOnRequest;\n        }\n        const char *ruleset_title = section[\"rulesets\"].IsDefined() ? \"rulesets\" : \"surge_ruleset\";\n        if(section[ruleset_title].IsSequence())\n        {\n            string_array vArray;\n            readRuleset(section[ruleset_title], vArray, false);\n            global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n        }\n    }\n\n    const char *groups_title = node[\"proxy_groups\"].IsDefined() ? \"proxy_groups\" : \"proxy_group\";\n    if(node[groups_title].IsDefined() && node[groups_title][\"custom_proxy_group\"].IsDefined())\n    {\n        string_array vArray;\n        readGroup(node[groups_title][\"custom_proxy_group\"], vArray, false);\n        global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n    }\n\n    if(node[\"template\"].IsDefined())\n    {\n        node[\"template\"][\"template_path\"] >> global.templatePath;\n        if(node[\"template\"][\"globals\"].IsSequence())\n        {\n            eraseElements(global.templateVars);\n            for(size_t i = 0; i < node[\"template\"][\"globals\"].size(); i++)\n            {\n                std::string key, value;\n                node[\"template\"][\"globals\"][i][\"key\"] >> key;\n                node[\"template\"][\"globals\"][i][\"value\"] >> value;\n                global.templateVars[key] = value;\n            }\n        }\n    }\n\n    if(node[\"aliases\"].IsSequence())\n    {\n        webServer.reset_redirect();\n        for(size_t i = 0; i < node[\"aliases\"].size(); i++)\n        {\n            std::string uri, target;\n            node[\"aliases\"][i][\"uri\"] >> uri;\n            node[\"aliases\"][i][\"target\"] >> target;\n            webServer.append_redirect(uri, target);\n        }\n    }\n\n    if(node[\"tasks\"].IsSequence())\n    {\n        string_array vArray;\n        for(size_t i = 0; i < node[\"tasks\"].size(); i++)\n        {\n            std::string name, exp, path, timeout;\n            node[\"tasks\"][i][\"import\"] >> name;\n            if(name.size())\n            {\n                vArray.emplace_back(\"!!import:\" + name);\n                continue;\n            }\n            node[\"tasks\"][i][\"name\"] >> name;\n            node[\"tasks\"][i][\"cronexp\"] >> exp;\n            node[\"tasks\"][i][\"path\"] >> path;\n            node[\"tasks\"][i][\"timeout\"] >> timeout;\n            strLine = name + \"`\" + exp + \"`\" + path + \"`\" + timeout;\n            vArray.emplace_back(std::move(strLine));\n        }\n        importItems(vArray, false);\n        global.enableCron = !vArray.empty();\n        global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);\n        refresh_schedule();\n    }\n\n    if(node[\"server\"].IsDefined())\n    {\n        node[\"server\"][\"listen\"] >> global.listenAddress;\n        node[\"server\"][\"port\"] >> global.listenPort;\n        node[\"server\"][\"serve_file_root\"] >>= webServer.serve_file_root;\n        webServer.serve_file = !webServer.serve_file_root.empty();\n    }\n\n    if(node[\"advanced\"].IsDefined())\n    {\n        std::string log_level;\n        node[\"advanced\"][\"log_level\"] >> log_level;\n        node[\"advanced\"][\"print_debug_info\"] >> global.printDbgInfo;\n        if(global.printDbgInfo)\n            global.logLevel = LOG_LEVEL_VERBOSE;\n        else\n        {\n            switch(hash_(log_level))\n            {\n            case \"warn\"_hash:\n                global.logLevel = LOG_LEVEL_WARNING;\n                break;\n            case \"error\"_hash:\n                global.logLevel = LOG_LEVEL_ERROR;\n                break;\n            case \"fatal\"_hash:\n                global.logLevel = LOG_LEVEL_FATAL;\n                break;\n            case \"verbose\"_hash:\n                global.logLevel = LOG_LEVEL_VERBOSE;\n                break;\n            case \"debug\"_hash:\n                global.logLevel = LOG_LEVEL_DEBUG;\n                break;\n            default:\n                global.logLevel = LOG_LEVEL_INFO;\n            }\n        }\n        node[\"advanced\"][\"max_pending_connections\"] >> global.maxPendingConns;\n        node[\"advanced\"][\"max_concurrent_threads\"] >> global.maxConcurThreads;\n        node[\"advanced\"][\"max_allowed_rulesets\"] >> global.maxAllowedRulesets;\n        node[\"advanced\"][\"max_allowed_rules\"] >> global.maxAllowedRules;\n        node[\"advanced\"][\"max_allowed_download_size\"] >> global.maxAllowedDownloadSize;\n        if(node[\"advanced\"][\"enable_cache\"].IsDefined())\n        {\n            if(safe_as<bool>(node[\"advanced\"][\"enable_cache\"]))\n            {\n                node[\"advanced\"][\"cache_subscription\"] >> global.cacheSubscription;\n                node[\"advanced\"][\"cache_config\"] >> global.cacheConfig;\n                node[\"advanced\"][\"cache_ruleset\"] >> global.cacheRuleset;\n                node[\"advanced\"][\"serve_cache_on_fetch_fail\"] >> global.serveCacheOnFetchFail;\n            }\n            else\n                global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; //disable cache\n        }\n        node[\"advanced\"][\"script_clean_context\"] >> global.scriptCleanContext;\n        node[\"advanced\"][\"async_fetch_ruleset\"] >> global.asyncFetchRuleset;\n        node[\"advanced\"][\"skip_failed_links\"] >> global.skipFailedLinks;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 215023881635728609534581892226161261979,
        "size": 279,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "std::string subconverter(RESPONSE_CALLBACK_ARGS)\n{\n    std::string &argument = request.argument;\n    int *status_code = &response.status_code;\n\n    std::string argTarget = getUrlArg(argument, \"target\"), argSurgeVer = getUrlArg(argument, \"ver\");\n    tribool argClashNewField = getUrlArg(argument, \"new_name\");\n    int intSurgeVer = argSurgeVer.size() ? to_int(argSurgeVer, 3) : 3;\n    if(argTarget == \"auto\")\n        matchUserAgent(request.headers[\"User-Agent\"], argTarget, argClashNewField, intSurgeVer);\n\n    /// don't try to load groups or rulesets when generating simple subscriptions\n    bool lSimpleSubscription = false;\n    switch(hash_(argTarget))\n    {\n    case \"ss\"_hash: case \"ssd\"_hash: case \"ssr\"_hash: case \"sssub\"_hash: case \"v2ray\"_hash: case \"trojan\"_hash: case \"mixed\"_hash:\n        lSimpleSubscription = true;\n        break;\n    case \"clash\"_hash: case \"clashr\"_hash: case \"surge\"_hash: case \"quan\"_hash: case \"quanx\"_hash: case \"loon\"_hash: case \"surfboard\"_hash: case \"mellow\"_hash:\n        break;\n    default:\n        *status_code = 400;\n        return \"Invalid target!\";\n    }\n    //check if we need to read configuration\n    if((!global.APIMode || global.CFWChildProcess) && !global.generatorMode)\n        readConf();\n\n    /// string values\n    std::string argUrl = urlDecode(getUrlArg(argument, \"url\"));\n    std::string argGroupName = urlDecode(getUrlArg(argument, \"group\")), argUploadPath = getUrlArg(argument, \"upload_path\");\n    std::string argIncludeRemark = urlDecode(getUrlArg(argument, \"include\")), argExcludeRemark = urlDecode(getUrlArg(argument, \"exclude\"));\n    std::string argCustomGroups = urlSafeBase64Decode(getUrlArg(argument, \"groups\")), argCustomRulesets = urlSafeBase64Decode(getUrlArg(argument, \"ruleset\")), argExternalConfig = urlDecode(getUrlArg(argument, \"config\"));\n    std::string argDeviceID = getUrlArg(argument, \"dev_id\"), argFilename = urlDecode(getUrlArg(argument, \"filename\")), argUpdateInterval = getUrlArg(argument, \"interval\"), argUpdateStrict = getUrlArg(argument, \"strict\");\n    std::string argRenames = urlDecode(getUrlArg(argument, \"rename\")), argFilterScript = urlDecode(getUrlArg(argument, \"filter_script\"));\n\n    /// switches with default value\n    tribool argUpload = getUrlArg(argument, \"upload\"), argEmoji = getUrlArg(argument, \"emoji\"), argAddEmoji = getUrlArg(argument, \"add_emoji\"), argRemoveEmoji = getUrlArg(argument, \"remove_emoji\");\n    tribool argAppendType = getUrlArg(argument, \"append_type\"), argTFO = getUrlArg(argument, \"tfo\"), argUDP = getUrlArg(argument, \"udp\"), argGenNodeList = getUrlArg(argument, \"list\");\n    tribool argSort = getUrlArg(argument, \"sort\"), argUseSortScript = getUrlArg(argument, \"sort_script\");\n    tribool argGenClashScript = getUrlArg(argument, \"script\"), argEnableInsert = getUrlArg(argument, \"insert\");\n    tribool argSkipCertVerify = getUrlArg(argument, \"scv\"), argFilterDeprecated = getUrlArg(argument, \"fdn\"), argExpandRulesets = getUrlArg(argument, \"expand\"), argAppendUserinfo = getUrlArg(argument, \"append_info\");\n    tribool argPrependInsert = getUrlArg(argument, \"prepend\"), argGenClassicalRuleProvider = getUrlArg(argument, \"classic\"), argTLS13 = getUrlArg(argument, \"tls13\");\n\n    std::string base_content, output_content;\n    ProxyGroupConfigs lCustomProxyGroups = global.customProxyGroups;\n    RulesetConfigs lCustomRulesets = global.customRulesets;\n    string_array lIncludeRemarks = global.includeRemarks, lExcludeRemarks = global.excludeRemarks;\n    std::vector<RulesetContent> lRulesetContent;\n    extra_settings ext;\n    std::string subInfo, dummy;\n    int interval = argUpdateInterval.size() ? to_int(argUpdateInterval, global.updateInterval) : global.updateInterval;\n    bool authorized = !global.APIMode || getUrlArg(argument, \"token\") == global.accessToken, strict = argUpdateStrict.size() ? argUpdateStrict == \"true\" : global.updateStrict;\n\n    if(std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argIncludeRemark) != gRegexBlacklist.cend() || std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argExcludeRemark) != gRegexBlacklist.cend())\n        return \"Invalid request!\";\n\n    /// for external configuration\n    std::string lClashBase = global.clashBase, lSurgeBase = global.surgeBase, lMellowBase = global.mellowBase, lSurfboardBase = global.surfboardBase;\n    std::string lQuanBase = global.quanBase, lQuanXBase = global.quanXBase, lLoonBase = global.loonBase, lSSSubBase = global.SSSubBase;\n\n    /// validate urls\n    argEnableInsert.define(global.enableInsert);\n    if(!argUrl.size() && (!global.APIMode || authorized))\n        argUrl = global.defaultUrls;\n    if((!argUrl.size() && !(global.insertUrls.size() && argEnableInsert)) || !argTarget.size())\n    {\n        *status_code = 400;\n        return \"Invalid request!\";\n    }\n\n    /// load request arguments as template variables\n    string_array req_args = split(argument, \"&\");\n    string_map req_arg_map;\n    for(std::string &x : req_args)\n    {\n        string_size pos = x.find(\"=\");\n        if(pos == x.npos)\n        {\n            req_arg_map[x] = \"\";\n            continue;\n        }\n        if(x.substr(0, pos) == \"token\")\n            continue;\n        req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);\n    }\n    req_arg_map[\"target\"] = argTarget;\n    req_arg_map[\"ver\"] = std::to_string(intSurgeVer);\n\n    /// save template variables\n    template_args tpl_args;\n    tpl_args.global_vars = global.templateVars;\n    tpl_args.request_params = req_arg_map;\n\n    /// check for proxy settings\n    std::string proxy = parseProxy(global.proxySubscription);\n\n    /// check other flags\n    ext.append_proxy_type = argAppendType.get(global.appendType);\n    if((argTarget == \"clash\" || argTarget == \"clashr\") && argGenClashScript.is_undef())\n        argExpandRulesets.define(true);\n\n    ext.clash_proxies_style = global.clashProxiesStyle;\n\n    /// read preference from argument, assign global var if not in argument\n    ext.tfo.define(argTFO).define(global.TFOFlag);\n    ext.udp.define(argUDP).define(global.UDPFlag);\n    ext.skip_cert_verify.define(argSkipCertVerify).define(global.skipCertVerify);\n    ext.tls13.define(argTLS13).define(global.TLS13Flag);\n\n    ext.sort_flag = argSort.get(global.enableSort);\n    argUseSortScript.define(global.sortScript.size() != 0);\n    if(ext.sort_flag && argUseSortScript)\n        ext.sort_script = global.sortScript;\n    ext.filter_deprecated = argFilterDeprecated.get(global.filterDeprecated);\n    ext.clash_new_field_name = argClashNewField.get(global.clashUseNewField);\n    ext.clash_script = argGenClashScript.get();\n    ext.clash_classical_ruleset = argGenClassicalRuleProvider.get();\n    if(!argExpandRulesets)\n        ext.clash_new_field_name = true;\n    else\n        ext.clash_script = false;\n\n    ext.nodelist = argGenNodeList;\n    ext.surge_ssr_path = global.surgeSSRPath;\n    ext.quanx_dev_id = argDeviceID.size() ? argDeviceID : global.quanXDevID;\n    ext.enable_rule_generator = global.enableRuleGen;\n    ext.overwrite_original_rules = global.overwriteOriginalRules;\n    if(!argExpandRulesets)\n        ext.managed_config_prefix = global.managedConfigPrefix;\n\n    /// load external configuration\n    if(argExternalConfig.empty())\n        argExternalConfig = global.defaultExtConfig;\n    if(argExternalConfig.size())\n    {\n        //std::cerr<<\"External configuration file provided. Loading...\\n\";\n        writeLog(0, \"External configuration file provided. Loading...\", LOG_LEVEL_INFO);\n        ExternalConfig extconf;\n        extconf.tpl_args = &tpl_args;\n        if(loadExternalConfig(argExternalConfig, extconf) == 0)\n        {\n            if(!ext.nodelist)\n            {\n                checkExternalBase(extconf.sssub_rule_base, lSSSubBase);\n                if(!lSimpleSubscription)\n                {\n                    checkExternalBase(extconf.clash_rule_base, lClashBase);\n                    checkExternalBase(extconf.surge_rule_base, lSurgeBase);\n                    checkExternalBase(extconf.surfboard_rule_base, lSurfboardBase);\n                    checkExternalBase(extconf.mellow_rule_base, lMellowBase);\n                    checkExternalBase(extconf.quan_rule_base, lQuanBase);\n                    checkExternalBase(extconf.quanx_rule_base, lQuanXBase);\n                    checkExternalBase(extconf.loon_rule_base, lLoonBase);\n\n                    if(extconf.surge_ruleset.size())\n                        lCustomRulesets = extconf.surge_ruleset;\n                    if(extconf.custom_proxy_group.size())\n                        lCustomProxyGroups = extconf.custom_proxy_group;\n                    ext.enable_rule_generator = extconf.enable_rule_generator;\n                    ext.overwrite_original_rules = extconf.overwrite_original_rules;\n                }\n            }\n            if(extconf.rename.size())\n                ext.rename_array = extconf.rename;\n            if(extconf.emoji.size())\n                ext.emoji_array = extconf.emoji;\n            if(extconf.include.size())\n                lIncludeRemarks = extconf.include;\n            if(extconf.exclude.size())\n                lExcludeRemarks = extconf.exclude;\n            argAddEmoji.define(extconf.add_emoji);\n            argRemoveEmoji.define(extconf.remove_old_emoji);\n        }\n    }\n    else\n    {\n        if(!lSimpleSubscription)\n        {\n            /// loading custom groups\n            if(argCustomGroups.size() && !ext.nodelist)\n            {\n                string_array vArray = split(argCustomGroups, \"@\");\n                lCustomProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);\n            }\n\n            /// loading custom rulesets\n            if(argCustomRulesets.size() && !ext.nodelist)\n            {\n                string_array vArray = split(argCustomRulesets, \"@\");\n                lCustomRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);\n            }\n        }\n    }\n    if(ext.enable_rule_generator && !ext.nodelist && !lSimpleSubscription)\n    {\n        if(lCustomRulesets != global.customRulesets)\n            refreshRulesets(lCustomRulesets, lRulesetContent);\n        else\n        {\n            if(global.updateRulesetOnRequest)\n                refreshRulesets(global.customRulesets, global.rulesetsContent);\n            lRulesetContent = global.rulesetsContent;\n        }\n    }\n\n    if(!argEmoji.is_undef())\n    {\n        argAddEmoji.set(argEmoji);\n        argRemoveEmoji.set(true);\n    }\n    ext.add_emoji = argAddEmoji.get(global.addEmoji);\n    ext.remove_emoji = argRemoveEmoji.get(global.removeEmoji);\n    if(ext.add_emoji && ext.emoji_array.empty())\n        ext.emoji_array = safe_get_emojis();\n    if(argRenames.size())\n        ext.rename_array = INIBinding::from<RegexMatchConfig>::from_ini(split(argRenames, \"`\"), \"@\");\n    else if(ext.rename_array.empty())\n        ext.rename_array = safe_get_renames();\n\n    /// check custom include/exclude settings\n    if(argIncludeRemark.size() && regValid(argIncludeRemark))\n        lIncludeRemarks = string_array{argIncludeRemark};\n    if(argExcludeRemark.size() && regValid(argExcludeRemark))\n        lExcludeRemarks = string_array{argExcludeRemark};\n\n    /// initialize script runtime\n    if(authorized && !global.scriptCleanContext)\n    {\n        ext.js_runtime = new qjs::Runtime();\n        script_runtime_init(*ext.js_runtime);\n        ext.js_context = new qjs::Context(*ext.js_runtime);\n        script_context_init(*ext.js_context);\n    }\n\n    //start parsing urls\n    RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();\n\n    //loading urls\n    string_array urls;\n    std::vector<Proxy> nodes, insert_nodes;\n    int groupID = 0;\n\n    parse_settings parse_set;\n    parse_set.proxy = &proxy;\n    parse_set.exclude_remarks = &lExcludeRemarks;\n    parse_set.include_remarks = &lIncludeRemarks;\n    parse_set.stream_rules = &stream_temp;\n    parse_set.time_rules = &time_temp;\n    parse_set.sub_info = &subInfo;\n    parse_set.authorized = authorized;\n    parse_set.request_header = &request.headers;\n    parse_set.js_runtime = ext.js_runtime;\n    parse_set.js_context = ext.js_context;\n\n    if(global.insertUrls.size() && argEnableInsert)\n    {\n        groupID = -1;\n        urls = split(global.insertUrls, \"|\");\n        importItems(urls, true);\n        for(std::string &x : urls)\n        {\n            x = regTrim(x);\n            writeLog(0, \"Fetching node data from url '\" + x + \"'.\", LOG_LEVEL_INFO);\n            if(addNodes(x, insert_nodes, groupID, parse_set) == -1)\n            {\n                if(global.skipFailedLinks)\n                    writeLog(0, \"The following link doesn't contain any valid node info: \" + x, LOG_LEVEL_WARNING);\n                else\n                {\n                    *status_code = 400;\n                    return \"The following link doesn't contain any valid node info: \" + x;\n                }\n            }\n            groupID--;\n        }\n    }\n    urls = split(argUrl, \"|\");\n    importItems(urls, true);\n    groupID = 0;\n    for(std::string &x : urls)\n    {\n        x = regTrim(x);\n        //std::cerr<<\"Fetching node data from url '\"<<x<<\"'.\"<<std::endl;\n        writeLog(0, \"Fetching node data from url '\" + x + \"'.\", LOG_LEVEL_INFO);\n        if(addNodes(x, nodes, groupID, parse_set) == -1)\n        {\n            if(global.skipFailedLinks)\n                writeLog(0, \"The following link doesn't contain any valid node info: \" + x, LOG_LEVEL_WARNING);\n            else\n            {\n                *status_code = 400;\n                return \"The following link doesn't contain any valid node info: \" + x;\n            }\n        }\n        groupID++;\n    }\n    //exit if found nothing\n    if(!nodes.size() && !insert_nodes.size())\n    {\n        *status_code = 400;\n        return \"No nodes were found!\";\n    }\n    if(subInfo.size() && argAppendUserinfo.get(global.appendUserinfo))\n        response.headers.emplace(\"Subscription-UserInfo\", subInfo);\n\n    if(request.method == \"HEAD\")\n        return \"\";\n\n    argPrependInsert.define(global.prependInsert);\n    if(argPrependInsert)\n    {\n        std::move(nodes.begin(), nodes.end(), std::back_inserter(insert_nodes));\n        nodes.swap(insert_nodes);\n    }\n    else\n    {\n        std::move(insert_nodes.begin(), insert_nodes.end(), std::back_inserter(nodes));\n    }\n    //run filter script\n    std::string filterScript = global.filterScript;\n    if(authorized && !argFilterScript.empty())\n        filterScript = argFilterScript;\n    if(filterScript.size())\n    {\n        if(startsWith(filterScript, \"path:\"))\n            filterScript = fileGet(filterScript.substr(5), false);\n        /*\n        duk_context *ctx = duktape_init();\n        if(ctx)\n        {\n            defer(duk_destroy_heap(ctx);)\n            if(duktape_peval(ctx, filterScript) == 0)\n            {\n                auto filter = [&](const Proxy &x)\n                {\n                    duk_get_global_string(ctx, \"filter\");\n                    duktape_push_Proxy(ctx, x);\n                    duk_pcall(ctx, 1);\n                    return !duktape_get_res_bool(ctx);\n                };\n                nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());\n            }\n            else\n            {\n                writeLog(0, \"Error when trying to parse script:\\n\" + duktape_get_err_stack(ctx), LOG_LEVEL_ERROR);\n                duk_pop(ctx); /// pop err\n            }\n        }\n        */\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n        {\n            try\n            {\n                ctx.eval(filterScript);\n                auto filter = (std::function<bool(const Proxy&)>) ctx.eval(\"filter\");\n                nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());\n            }\n            catch(qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n\n    //check custom group name\n    if(argGroupName.size())\n        for(Proxy &x : nodes)\n            x.Group = argGroupName;\n\n    //do pre-process now\n    preprocessNodes(nodes, ext);\n\n    /*\n    //insert node info to template\n    int index = 0;\n    std::string template_node_prefix;\n    for(Proxy &x : nodes)\n    {\n        template_node_prefix = std::to_string(index) + \".\";\n        tpl_args.node_list[template_node_prefix + \"remarks\"] = x.remarks;\n        tpl_args.node_list[template_node_prefix + \"group\"] = x.Group;\n        tpl_args.node_list[template_node_prefix + \"groupid\"] = std::to_string(x.GroupId);\n        index++;\n    }\n    */\n\n    ProxyGroupConfigs dummy_group;\n    std::vector<RulesetContent> dummy_ruleset;\n    std::string managed_url = base64Decode(urlDecode(getUrlArg(argument, \"profile_data\")));\n    if(managed_url.empty())\n        managed_url = global.managedConfigPrefix + \"/sub?\" + argument;\n\n    //std::cerr<<\"Generate target: \";\n    proxy = parseProxy(global.proxyConfig);\n    switch(hash_(argTarget))\n    {\n    case \"clash\"_hash: case \"clashr\"_hash:\n        writeLog(0, argTarget == \"clashr\" ? \"Generate target: ClashR\" : \"Generate target: Clash\", LOG_LEVEL_INFO);\n        tpl_args.local_vars[\"clash.new_field_name\"] = ext.clash_new_field_name ? \"true\" : \"false\";\n        response.headers[\"profile-update-interval\"] = std::to_string(interval / 3600);\n        if(ext.nodelist)\n        {\n            YAML::Node yamlnode;\n            proxyToClash(nodes, yamlnode, dummy_group, argTarget == \"clashr\", ext);\n            output_content = YAML::Dump(yamlnode);\n        }\n        else\n        {\n            if(render_template(fetchFile(lClashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n            output_content = proxyToClash(nodes, base_content, lRulesetContent, lCustomProxyGroups, argTarget == \"clashr\", ext);\n        }\n\n        if(argUpload)\n            uploadGist(argTarget, argUploadPath, output_content, false);\n        break;\n    case \"surge\"_hash:\n\n        writeLog(0, \"Generate target: Surge \" + std::to_string(intSurgeVer), LOG_LEVEL_INFO);\n\n        if(ext.nodelist)\n        {\n            output_content = proxyToSurge(nodes, base_content, dummy_ruleset, dummy_group, intSurgeVer, ext);\n\n            if(argUpload)\n                uploadGist(\"surge\" + argSurgeVer + \"list\", argUploadPath, output_content, true);\n        }\n        else\n        {\n            if(render_template(fetchFile(lSurgeBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n            output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, intSurgeVer, ext);\n\n            if(argUpload)\n                uploadGist(\"surge\" + argSurgeVer, argUploadPath, output_content, true);\n\n            if(global.writeManagedConfig && global.managedConfigPrefix.size())\n                output_content = \"#!MANAGED-CONFIG \" + managed_url + (interval ? \" interval=\" + std::to_string(interval) : \"\") \\\n                 + \" strict=\" + std::string(strict ? \"true\" : \"false\") + \"\\n\\n\" + output_content;\n        }\n        break;\n    case \"surfboard\"_hash:\n        writeLog(0, \"Generate target: Surfboard\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lSurfboardBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, -3, ext);\n        if(argUpload)\n            uploadGist(\"surfboard\", argUploadPath, output_content, true);\n\n        if(global.writeManagedConfig && global.managedConfigPrefix.size())\n            output_content = \"#!MANAGED-CONFIG \" + managed_url + (interval ? \" interval=\" + std::to_string(interval) : \"\") \\\n                 + \" strict=\" + std::string(strict ? \"true\" : \"false\") + \"\\n\\n\" + output_content;\n        break;\n    case \"mellow\"_hash:\n        writeLog(0, \"Generate target: Mellow\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lMellowBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToMellow(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"mellow\", argUploadPath, output_content, true);\n        break;\n    case \"sssub\"_hash:\n        writeLog(0, \"Generate target: SS Subscription\", LOG_LEVEL_INFO);\n\n        if(render_template(fetchFile(lSSSubBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n        {\n            *status_code = 400;\n            return base_content;\n        }\n        output_content = proxyToSSSub(base_content, nodes, ext);\n        if(argUpload)\n            uploadGist(\"sssub\", argUploadPath, output_content, false);\n        break;\n    case \"ss\"_hash:\n        writeLog(0, \"Generate target: SS\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 1, ext);\n        if(argUpload)\n            uploadGist(\"ss\", argUploadPath, output_content, false);\n        break;\n    case \"ssr\"_hash:\n        writeLog(0, \"Generate target: SSR\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 2, ext);\n        if(argUpload)\n            uploadGist(\"ssr\", argUploadPath, output_content, false);\n        break;\n    case \"v2ray\"_hash:\n        writeLog(0, \"Generate target: v2rayN\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 4, ext);\n        if(argUpload)\n            uploadGist(\"v2ray\", argUploadPath, output_content, false);\n        break;\n    case \"trojan\"_hash:\n        writeLog(0, \"Generate target: Trojan\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 8, ext);\n        if(argUpload)\n            uploadGist(\"trojan\", argUploadPath, output_content, false);\n        break;\n    case \"mixed\"_hash:\n        writeLog(0, \"Generate target: Standard Subscription\", LOG_LEVEL_INFO);\n        output_content = proxyToSingle(nodes, 15, ext);\n        if(argUpload)\n            uploadGist(\"sub\", argUploadPath, output_content, false);\n        break;\n    case \"quan\"_hash:\n        writeLog(0, \"Generate target: Quantumult\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lQuanBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToQuan(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"quan\", argUploadPath, output_content, false);\n        break;\n    case \"quanx\"_hash:\n        writeLog(0, \"Generate target: Quantumult X\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lQuanXBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToQuanX(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"quanx\", argUploadPath, output_content, false);\n        break;\n    case \"loon\"_hash:\n        writeLog(0, \"Generate target: Loon\", LOG_LEVEL_INFO);\n        if(!ext.nodelist)\n        {\n            if(render_template(fetchFile(lLoonBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)\n            {\n                *status_code = 400;\n                return base_content;\n            }\n        }\n\n        output_content = proxyToLoon(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);\n\n        if(argUpload)\n            uploadGist(\"loon\", argUploadPath, output_content, false);\n        break;\n    case \"ssd\"_hash:\n        writeLog(0, \"Generate target: SSD\", LOG_LEVEL_INFO);\n        output_content = proxyToSSD(nodes, argGroupName, subInfo, ext);\n        if(argUpload)\n            uploadGist(\"ssd\", argUploadPath, output_content, false);\n        break;\n    default:\n        writeLog(0, \"Generate target: Unspecified\", LOG_LEVEL_INFO);\n        *status_code = 500;\n        return \"Unrecognized target\";\n    }\n    writeLog(0, \"Generate completed.\", LOG_LEVEL_INFO);\n    if(argFilename.size())\n        response.headers.emplace(\"Content-Disposition\", \"attachment; filename=\\\"\" + argFilename + \"\\\"; filename*=utf-8''\" + urlEncode(argFilename));\n    return output_content;\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 146419312071086040181952170683831056300,
        "size": 583,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "void readTOMLConf(toml::value &root)\n{\n    const auto &section_common = toml::find(root, \"common\");\n    string_array default_url, insert_url;\n\n    find_if_exist(section_common, \"default_url\", default_url, \"insert_url\", insert_url);\n    global.defaultUrls = join(default_url, \"|\");\n    global.insertUrls = join(insert_url, \"|\");\n\n    bool filter = false;\n    find_if_exist(section_common,\n                  \"api_mode\", global.APIMode,\n                  \"api_access_token\", global.accessToken,\n                  \"exclude_remarks\", global.excludeRemarks,\n                  \"include_remarks\", global.includeRemarks,\n                  \"enable_insert\", global.enableInsert,\n                  \"prepend_insert_url\", global.prependInsert,\n                  \"enable_filter\", filter,\n                  \"default_external_config\", global.defaultExtConfig,\n                  \"base_path\", global.basePath,\n                  \"clash_rule_base\", global.clashBase,\n                  \"surge_rule_base\", global.surgeBase,\n                  \"surfboard_rule_base\", global.surfboardBase,\n                  \"mellow_rule_base\", global.mellowBase,\n                  \"quan_rule_base\", global.quanBase,\n                  \"quanx_rule_base\", global.quanXBase,\n                  \"loon_rule_base\", global.loonBase,\n                  \"proxy_config\", global.proxyConfig,\n                  \"proxy_ruleset\", global.proxyRuleset,\n                  \"proxy_subscription\", global.proxySubscription,\n                  \"append_proxy_type\", global.appendType\n    );\n\n    if(filter)\n        find_if_exist(section_common, \"filter_script\", global.filterScript);\n    else\n        global.filterScript.clear();\n\n    safe_set_streams(toml::find_or<RegexMatchConfigs>(root, \"userinfo\", \"stream_rule\", RegexMatchConfigs{}));\n    safe_set_times(toml::find_or<RegexMatchConfigs>(root, \"userinfo\", \"time_rule\", RegexMatchConfigs{}));\n\n    const auto &section_node_pref = toml::find(root, \"node_pref\");\n\n    find_if_exist(section_node_pref,\n                  \"udp_flag\", global.UDPFlag,\n                  \"tcp_fast_open_flag\", global.TFOFlag,\n                  \"skip_cert_verify_flag\", global.skipCertVerify,\n                  \"tls13_flag\", global.TLS13Flag,\n                  \"sort_flag\", global.enableSort,\n                  \"sort_script\", global.sortScript,\n                  \"filter_deprecated_nodes\", global.filterDeprecated,\n                  \"append_sub_userinfo\", global.appendUserinfo,\n                  \"clash_use_new_field_name\", global.clashUseNewField,\n                  \"clash_proxies_style\", global.clashProxiesStyle\n    );\n\n    auto renameconfs = toml::find_or<std::vector<toml::value>>(section_node_pref, \"rename_node\", {});\n    importItems(renameconfs, \"rename_node\", false);\n    safe_set_renames(toml::get<RegexMatchConfigs>(toml::value(renameconfs)));\n\n    const auto &section_managed = toml::find(root, \"managed_config\");\n\n    find_if_exist(section_managed,\n                  \"write_managed_config\", global.writeManagedConfig,\n                  \"managed_config_prefix\", global.managedConfigPrefix,\n                  \"config_update_interval\", global.updateInterval,\n                  \"config_update_strict\", global.updateStrict,\n                  \"quanx_device_id\", global.quanXDevID\n    );\n\n    const auto &section_surge_external = toml::find(root, \"surge_external_proxy\");\n    find_if_exist(section_surge_external,\n                  \"surge_ssr_path\", global.surgeSSRPath,\n                  \"resolve_hostname\", global.surgeResolveHostname\n    );\n\n    const auto &section_emojis = toml::find(root, \"emojis\");\n\n    find_if_exist(section_emojis,\n                  \"add_emoji\", global.addEmoji,\n                  \"remove_old_emoji\", global.removeEmoji\n    );\n\n    auto emojiconfs = toml::find_or<std::vector<toml::value>>(section_emojis, \"emoji\", {});\n    importItems(emojiconfs, \"emoji\", false);\n    safe_set_emojis(toml::get<RegexMatchConfigs>(toml::value(emojiconfs)));\n\n    auto groups = toml::find_or<std::vector<toml::value>>(root, \"custom_groups\", {});\n    importItems(groups, \"custom_groups\", false);\n    global.customProxyGroups = toml::get<ProxyGroupConfigs>(toml::value(groups));\n\n    const auto &section_ruleset = toml::find(root, \"ruleset\");\n\n    find_if_exist(section_ruleset,\n                  \"enabled\", global.enableRuleGen,\n                  \"overwrite_original_rules\", global.overwriteOriginalRules,\n                  \"update_ruleset_on_request\", global.updateRulesetOnRequest\n    );\n\n    auto rulesets = toml::find_or<std::vector<toml::value>>(root, \"rulesets\", {});\n    importItems(rulesets, \"rulesets\", false);\n    global.customRulesets = toml::get<RulesetConfigs>(toml::value(rulesets));\n\n    const auto &section_template = toml::find(root, \"template\");\n\n    global.templatePath = toml::find_or(section_template, \"template_path\", \"template\");\n\n    eraseElements(global.templateVars);\n    operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section_template, \"globals\", {}), \"key\", \"value\", [&](const toml::value &key, const toml::value &value)\n    {\n        global.templateVars[key.as_string()] = value.as_string();\n    });\n\n    webServer.reset_redirect();\n    operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(root, \"aliases\", {}), \"uri\", \"target\", [&](const toml::value &key, const toml::value &value)\n    {\n        webServer.append_redirect(key.as_string(), value.as_string());\n    });\n\n    auto tasks = toml::find_or<std::vector<toml::value>>(root, \"tasks\", {});\n    importItems(tasks, \"tasks\", false);\n    global.cronTasks = toml::get<CronTaskConfigs>(toml::value(tasks));\n\n    const auto &section_server = toml::find(root, \"server\");\n\n    find_if_exist(section_server,\n                  \"listen\", global.listenAddress,\n                  \"port\", global.listenPort,\n                  \"serve_file_root\", webServer.serve_file_root\n    );\n    webServer.serve_file = !webServer.serve_file_root.empty();\n\n    const auto &section_advanced = toml::find(root, \"advanced\");\n\n    std::string log_level;\n    bool enable_cache = true;\n    int cache_subscription = global.cacheSubscription, cache_config = global.cacheConfig, cache_ruleset = global.cacheRuleset;\n\n    find_if_exist(section_advanced,\n                  \"log_level\", log_level,\n                  \"print_debug_info\", global.printDbgInfo,\n                  \"max_pending_connections\", global.maxPendingConns,\n                  \"max_concurrent_threads\", global.maxConcurThreads,\n                  \"max_allowed_rulesets\", global.maxAllowedRulesets,\n                  \"max_allowed_rules\", global.maxAllowedRules,\n                  \"max_allowed_download_size\", global.maxAllowedDownloadSize,\n                  \"enable_cache\", enable_cache,\n                  \"cache_subscription\", cache_subscription,\n                  \"cache_config\", cache_config,\n                  \"cache_ruleset\", cache_ruleset,\n                  \"script_clean_context\", global.scriptCleanContext,\n                  \"async_fetch_ruleset\", global.asyncFetchRuleset,\n                  \"skip_failed_links\", global.skipFailedLinks\n    );\n\n    if(global.printDbgInfo)\n        global.logLevel = LOG_LEVEL_VERBOSE;\n    else\n    {\n        switch(hash_(log_level))\n        {\n        case \"warn\"_hash:\n            global.logLevel = LOG_LEVEL_WARNING;\n            break;\n        case \"error\"_hash:\n            global.logLevel = LOG_LEVEL_ERROR;\n            break;\n        case \"fatal\"_hash:\n            global.logLevel = LOG_LEVEL_FATAL;\n            break;\n        case \"verbose\"_hash:\n            global.logLevel = LOG_LEVEL_VERBOSE;\n            break;\n        case \"debug\"_hash:\n            global.logLevel = LOG_LEVEL_DEBUG;\n            break;\n        default:\n            global.logLevel = LOG_LEVEL_INFO;\n        }\n    }\n\n    if(enable_cache)\n    {\n        global.cacheSubscription = cache_subscription;\n        global.cacheConfig = cache_config;\n        global.cacheRuleset = cache_ruleset;\n    }\n    else\n    {\n        global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-434",
            "CWE-94"
        ],
        "project": "subconverter",
        "commit_id": "ce8d2bd0f13f05fcbd2ed90755d097f402393dd3",
        "hash": 125666967401527443803123736859372853420,
        "size": 192,
        "message": "Enhancements\n\nAdd authorization check before loading scripts.\nAdd detailed logs when loading preference settings."
    },
    {
        "func": "static int zipfileCommit(sqlite3_vtab *pVtab){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;\n  if( pTab->pWriteFd ){\n    i64 iOffset = pTab->szCurrent;\n    ZipfileEntry *p;\n    ZipfileEOCD eocd;\n    int nEntry = 0;\n\n    /* Write out all entries */\n    for(p=pTab->pFirstEntry; rc==SQLITE_OK && p; p=p->pNext){\n      int n = zipfileSerializeCDS(p, pTab->aBuffer);\n      rc = zipfileAppendData(pTab, pTab->aBuffer, n);\n      nEntry++;\n    }\n\n    /* Write out the EOCD record */\n    eocd.iDisk = 0;\n    eocd.iFirstDisk = 0;\n    eocd.nEntry = (u16)nEntry;\n    eocd.nEntryTotal = (u16)nEntry;\n    eocd.nSize = (u32)(pTab->szCurrent - iOffset);\n    eocd.iOffset = (u32)iOffset;\n    rc = zipfileAppendEOCD(pTab, &eocd);\n\n    zipfileCleanupTransaction(pTab);\n  }\n  return rc;\n}",
        "target": 0,
        "cwe": [
            "CWE-434"
        ],
        "project": "sqlite",
        "commit_id": "54d501092d88c0cf89bec4279951f548fb0b8618",
        "hash": 238202112906410375936868449975355361307,
        "size": 29,
        "message": "Fix the zipfile extension so that INSERT works even if the pathname of\nthe file being inserted is a NULL.  Bug discovered by the\nYongheng and Rui fuzzer.\n\nFossilOrigin-Name: a80f84b511231204658304226de3e075a55afc2e3f39ac063716f7a57f585c06"
    },
    {
        "func": "ReadBMP (const gchar  *name,\n         GError      **error)\n{\n  FILE     *fd;\n  guchar    buffer[64];\n  gint      ColormapSize, rowbytes, Maps;\n  gboolean  Grey = FALSE;\n  guchar    ColorMap[256][3];\n  gint32    image_ID;\n  gchar     magick[2];\n  Bitmap_Channel masks[4];\n\n  filename = name;\n  fd = g_fopen (filename, \"rb\");\n\n  if (!fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (name));\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header */\n\n  if (!ReadOK (fd, magick, 2) || !(!strncmp (magick, \"BA\", 2) ||\n     !strncmp (magick, \"BM\", 2) || !strncmp (magick, \"IC\", 2) ||\n     !strncmp (magick, \"PI\", 2) || !strncmp (magick, \"CI\", 2) ||\n     !strncmp (magick, \"CP\", 2)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  while (!strncmp (magick, \"BA\", 2))\n    {\n      if (!ReadOK (fd, buffer, 12))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n      if (!ReadOK (fd, magick, 2))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  if (!ReadOK (fd, buffer, 12))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize    = ToL (&buffer[0x00]);\n  Bitmap_File_Head.zzHotX    = ToS (&buffer[0x04]);\n  Bitmap_File_Head.zzHotY    = ToS (&buffer[0x06]);\n  Bitmap_File_Head.bfOffs    = ToL (&buffer[0x08]);\n\n  if (!ReadOK (fd, buffer, 4))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  Bitmap_File_Head.biSize    = ToL (&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) /* OS/2 1.x ? */\n    {\n      if (!ReadOK (fd, buffer, 8))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToS (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  = ToS (&buffer[0x02]);       /* 14 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x06]);       /* 18 */\n      Bitmap_Head.biCompr   = 0;\n      Bitmap_Head.biSizeIm  = 0;\n      Bitmap_Head.biXPels   = Bitmap_Head.biYPels = 0;\n      Bitmap_Head.biClrUsed = 0;\n      Bitmap_Head.biClrImp  = 0;\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      memset(masks, 0, sizeof(masks));\n      Maps = 3;\n    }\n  else if (Bitmap_File_Head.biSize == 40) /* Windows 3.x */\n    {\n      if (!ReadOK (fd, buffer, 36))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToL (&buffer[0x00]);      /* 12 */\n      Bitmap_Head.biHeight  = ToL (&buffer[0x04]);      /* 16 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x0A]);      /* 1C */\n      Bitmap_Head.biCompr   = ToL (&buffer[0x0C]);      /* 1E */\n      Bitmap_Head.biSizeIm  = ToL (&buffer[0x10]);      /* 22 */\n      Bitmap_Head.biXPels   = ToL (&buffer[0x14]);      /* 26 */\n      Bitmap_Head.biYPels   = ToL (&buffer[0x18]);      /* 2A */\n      Bitmap_Head.biClrUsed = ToL (&buffer[0x1C]);      /* 2E */\n      Bitmap_Head.biClrImp  = ToL (&buffer[0x20]);      /* 32 */\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      Maps = 4;\n      memset(masks, 0, sizeof(masks));\n\n      if (Bitmap_Head.biCompr == BI_BITFIELDS)\n        {\n          if (!ReadOK (fd, buffer, 3 * sizeof (guint32)))\n            {\n              g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                           _(\"Error reading BMP file header from '%s'\"),\n                           gimp_filename_to_utf8 (filename));\n              return -1;\n            }\n\n          Bitmap_Head.masks[0] = ToL(&buffer[0x00]);\n          Bitmap_Head.masks[1] = ToL(&buffer[0x04]);\n          Bitmap_Head.masks[2] = ToL(&buffer[0x08]);\n         ReadChannelMasks (&Bitmap_Head.masks[0], masks, 3);\n        }\n      else\n        switch (Bitmap_Head.biBitCnt)\n          {\n          case 32:\n            masks[0].mask     = 0x00ff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x0000ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x000000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0xff000000;\n            masks[3].shiftin  = 24;\n            masks[3].max_value= (gfloat)255.0;\n            break;\n         case 24:\n            masks[0].mask     = 0xff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x00ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x0000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         case 16:\n            masks[0].mask     = 0x7c00;\n            masks[0].shiftin  = 10;\n            masks[0].max_value= (gfloat)31.0;\n            masks[1].mask     = 0x03e0;\n            masks[1].shiftin  = 5;\n            masks[1].max_value= (gfloat)31.0;\n            masks[2].mask     = 0x001f;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)31.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         default:\n            break;\n         }\n    }\n  else if (Bitmap_File_Head.biSize >= 56 && Bitmap_File_Head.biSize <= 64)\n    /* enhanced Windows format with bit masks */\n    {\n      if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   =ToL (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  =ToL (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biPlanes  =ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  =ToS (&buffer[0x0A]);       /* 1C */\n      Bitmap_Head.biCompr   =ToL (&buffer[0x0C]);       /* 1E */\n      Bitmap_Head.biSizeIm  =ToL (&buffer[0x10]);       /* 22 */\n      Bitmap_Head.biXPels   =ToL (&buffer[0x14]);       /* 26 */\n      Bitmap_Head.biYPels   =ToL (&buffer[0x18]);       /* 2A */\n      Bitmap_Head.biClrUsed =ToL (&buffer[0x1C]);       /* 2E */\n      Bitmap_Head.biClrImp  =ToL (&buffer[0x20]);       /* 32 */\n      Bitmap_Head.masks[0]  =ToL (&buffer[0x24]);       /* 36 */\n      Bitmap_Head.masks[1]  =ToL (&buffer[0x28]);       /* 3A */\n      Bitmap_Head.masks[2]  =ToL (&buffer[0x2C]);       /* 3E */\n      Bitmap_Head.masks[3]  =ToL (&buffer[0x30]);       /* 42 */\n\n      Maps = 4;\n      ReadChannelMasks (&Bitmap_Head.masks[0], masks, 4);\n    }\n  else\n    {\n      GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\n      if (pixbuf)\n        {\n          gint32 layer_ID;\n\n          image_ID = gimp_image_new (gdk_pixbuf_get_width (pixbuf),\n                                     gdk_pixbuf_get_height (pixbuf),\n                                     GIMP_RGB);\n\n          layer_ID = gimp_layer_new_from_pixbuf (image_ID, _(\"Background\"),\n                                                 pixbuf,\n                                                 100.,\n                                                 GIMP_NORMAL_MODE, 0, 0);\n          g_object_unref (pixbuf);\n\n          gimp_image_set_filename (image_ID, filename);\n          gimp_image_add_layer (image_ID, layer_ID, -1);\n\n          return image_ID;\n        }\n      else\n        {\n\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  /* Valid bitpdepthis 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize =\n    (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biWidth < 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biPlanes != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biClrUsed > 256)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes= ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf (\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, \"\n          \"Comp: %u, Zeile: %u\\n\",\n          Bitmap_File_Head.bfSize,\n          Bitmap_Head.biClrUsed,\n          Bitmap_Head.biBitCnt,\n          Bitmap_Head.biWidth,\n          Bitmap_Head.biHeight,\n          Bitmap_Head.biCompr,\n          rowbytes);\n#endif\n\n  if (Bitmap_Head.biBitCnt <= 8)\n    {\n#ifdef DEBUG\n      printf (\"Colormap read\\n\");\n#endif\n      /* Get the Colormap */\n      if (!ReadColorMap (fd, ColorMap, ColormapSize, Maps, &Grey))\n        return -1;\n    }\n\n  fseek (fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error*/\n  image_ID = ReadImage (fd,\n                        Bitmap_Head.biWidth,\n                        ABS (Bitmap_Head.biHeight),\n                        ColorMap,\n                        Bitmap_Head.biClrUsed,\n                        Bitmap_Head.biBitCnt,\n                        Bitmap_Head.biCompr,\n                        rowbytes,\n                        Grey,\n                        masks,\n                        error);\n\n  if (image_ID < 0)\n    return -1;\n\n  if (Bitmap_Head.biXPels > 0 && Bitmap_Head.biYPels > 0)\n    {\n      /* Fixed up from scott@asofyet's changes last year, njl195 */\n      gdouble xresolution;\n      gdouble yresolution;\n\n      /* I don't agree with scott's feeling that Gimp should be\n       * trying to \"fix\" metric resolution translations, in the\n       * long term Gimp should be SI (metric) anyway, but we\n       * haven't told the Americans that yet  */\n\n      xresolution = Bitmap_Head.biXPels * 0.0254;\n      yresolution = Bitmap_Head.biYPels * 0.0254;\n\n      gimp_image_set_resolution (image_ID, xresolution, yresolution);\n    }\n\n  if (Bitmap_Head.biHeight < 0)\n    gimp_image_flip (image_ID, GIMP_ORIENTATION_VERTICAL);\n\n  return image_ID;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "gimp",
        "commit_id": "e3afc99b2fa7aeddf0dba4778663160a5bc682d3",
        "hash": 89349128805997676424554363261593483732,
        "size": 381,
        "message": "Harden the BMP plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-1570. Fixes bug #600484."
    },
    {
        "func": "read_header_block (PSDimage  *img_a,\n                   FILE      *f,\n                   GError   **error)\n{\n  guint16  version;\n  gchar    sig[4];\n  gchar    buf[6];\n\n  if (fread (sig, 4, 1, f) < 1\n      || fread (&version, 2, 1, f) < 1\n      || fread (buf, 6, 1, f) < 1\n      || fread (&img_a->channels, 2, 1, f) < 1\n      || fread (&img_a->rows, 4, 1, f) < 1\n      || fread (&img_a->columns, 4, 1, f) < 1\n      || fread (&img_a->bps, 2, 1, f) < 1\n      || fread (&img_a->color_mode, 2, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  version = GUINT16_FROM_BE (version);\n  img_a->channels = GUINT16_FROM_BE (img_a->channels);\n  img_a->rows = GUINT32_FROM_BE (img_a->rows);\n  img_a->columns = GUINT32_FROM_BE (img_a->columns);\n  img_a->bps = GUINT16_FROM_BE (img_a->bps);\n  img_a->color_mode = GUINT16_FROM_BE (img_a->color_mode);\n\n  IFDBG(1) g_debug (\"\\n\\n\\tSig: %.4s\\n\\tVer: %d\\n\\tChannels: \"\n                    \"%d\\n\\tSize: %dx%d\\n\\tBPS: %d\\n\\tMode: %d\\n\",\n                    sig, version, img_a->channels,\n                    img_a->columns, img_a->rows,\n                    img_a->bps, img_a->color_mode);\n\n  if (memcmp (sig, \"8BPS\", 4) != 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Not a valid photoshop document file\"));\n      return -1;\n    }\n\n  if (version != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported file format version: %d\"), version);\n      return -1;\n    }\n\n  if (img_a->channels > MAX_CHANNELS)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Too many channels in file: %d\"), img_a->channels);\n      return -1;\n    }\n\n    /* Photoshop CS (version 8) supports 300000 x 300000, but this\n       is currently larger than GIMP_MAX_IMAGE_SIZE */\n\n  if (img_a->rows < 1 || img_a->rows > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image height: %d\"),\n                  img_a->rows);\n      return -1;\n    }\n\n  if (img_a->columns < 1 || img_a->columns > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image width: %d\"),\n                  img_a->columns);\n      return -1;\n    }\n\n  if (img_a->color_mode != PSD_BITMAP\n      && img_a->color_mode != PSD_GRAYSCALE\n      && img_a->color_mode != PSD_INDEXED\n      && img_a->color_mode != PSD_RGB\n      && img_a->color_mode != PSD_DUOTONE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported color mode: %s\"),\n                   get_psd_color_mode_name (img_a->color_mode));\n      return -1;\n    }\n\n  /* Warnings for format conversions */\n  switch (img_a->bps)\n    {\n      case 16:\n        IFDBG(3) g_debug (\"16 Bit Data\");\n        if (CONVERSION_WARNINGS)\n          g_message (_(\"Warning:\\n\"\n                       \"The image you are loading has 16 bits per channel. GIMP \"\n                       \"can only handle 8 bit, so it will be converted for you. \"\n                       \"Information will be lost because of this conversion.\"));\n        break;\n\n      case 8:\n        IFDBG(3) g_debug (\"8 Bit Data\");\n        break;\n\n      case 1:\n        IFDBG(3) g_debug (\"1 Bit Data\");\n        break;\n\n      default:\n        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                    _(\"Unsupported bit depth: %d\"), img_a->bps);\n        return -1;\n        break;\n    }\n\n  return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "gimp",
        "commit_id": "88eccea84aa375197cc04a2a0e2e29debb56bfa5",
        "hash": 282961803047843709486882215060328863536,
        "size": 114,
        "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)"
    },
    {
        "func": "read_layer_block (PSDimage  *img_a,\n                  FILE      *f,\n                  GError   **error)\n{\n  PSDlayer **lyr_a;\n  guint32    block_len;\n  guint32    block_end;\n  guint32    block_rem;\n  gint32     read_len;\n  gint32     write_len;\n  gint       lidx;                  /* Layer index */\n  gint       cidx;                  /* Channel index */\n\n  if (fread (&block_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      img_a->num_layers = -1;\n      return NULL;\n    }\n  img_a->mask_layer_len = GUINT32_FROM_BE (block_len);\n\n  IFDBG(1) g_debug (\"Layer and mask block size = %d\", img_a->mask_layer_len);\n\n  img_a->transparency = FALSE;\n  img_a->layer_data_len = 0;\n\n  if (!img_a->mask_layer_len)\n    {\n      img_a->num_layers = 0;\n      return NULL;\n    }\n  else\n    {\n      img_a->mask_layer_start = ftell (f);\n      block_end = img_a->mask_layer_start + img_a->mask_layer_len;\n\n      /* Get number of layers */\n      if (fread (&block_len, 4, 1, f) < 1\n          || fread (&img_a->num_layers, 2, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          img_a->num_layers = -1;\n          return NULL;\n        }\n      img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);\n      IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n      if (img_a->num_layers < 0)\n        {\n          img_a->transparency = TRUE;\n          img_a->num_layers = -img_a->num_layers;\n        }\n\n      if (img_a->num_layers)\n        {\n          /* Read layer records */\n          PSDlayerres           res_a;\n\n          /* Create pointer array for the layer records */\n          lyr_a = g_new (PSDlayer *, img_a->num_layers);\n          for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n            {\n              /* Allocate layer record */\n              lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );\n\n              /* Initialise record */\n              lyr_a[lidx]->drop = FALSE;\n              lyr_a[lidx]->id = 0;\n\n              if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->left, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->right, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              lyr_a[lidx]->top = GINT32_FROM_BE (lyr_a[lidx]->top);\n              lyr_a[lidx]->left = GINT32_FROM_BE (lyr_a[lidx]->left);\n              lyr_a[lidx]->bottom = GINT32_FROM_BE (lyr_a[lidx]->bottom);\n              lyr_a[lidx]->right = GINT32_FROM_BE (lyr_a[lidx]->right);\n              lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n\n              if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Too many channels in layer: %d\"),\n                              lyr_a[lidx]->num_channels);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer height: %d\"),\n                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer width: %d\"),\n                              lyr_a[lidx]->right - lyr_a[lidx]->left);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n                                 lyr_a[lidx]->num_channels);\n\n              lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);\n              for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n                {\n                  if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1\n                      || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                  lyr_a[lidx]->chn_info[cidx].channel_id =\n                    GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);\n                  lyr_a[lidx]->chn_info[cidx].data_len =\n                    GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);\n                  img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;\n                  IFDBG(3) g_debug (\"Channel ID %d, data len %d\",\n                                     lyr_a[lidx]->chn_info[cidx].channel_id,\n                                     lyr_a[lidx]->chn_info[cidx].data_len);\n                }\n\n              if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1\n                  || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              if (memcmp (lyr_a[lidx]->mode_key, \"8BIM\", 4) != 0)\n                {\n                  IFDBG(1) g_debug (\"Incorrect layer mode signature %.4s\",\n                                    lyr_a[lidx]->mode_key);\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"The file is corrupt!\"));\n                  return NULL;\n                }\n\n              lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;\n              lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;\n              if (lyr_a[lidx]->flags & 8)\n                lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;\n              else\n                lyr_a[lidx]->layer_flags.irrelevant = FALSE;\n\n              lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);\n              block_rem = lyr_a[lidx]->extra_len;\n              IFDBG(2) g_debug (\"\\n\\tLayer mode sig: %.4s\\n\\tBlend mode: %.4s\\n\\t\"\n                                \"Opacity: %d\\n\\tClipping: %d\\n\\tExtra data len: %d\\n\\t\"\n                                \"Alpha lock: %d\\n\\tVisible: %d\\n\\tIrrelevant: %d\",\n                                    lyr_a[lidx]->mode_key,\n                                    lyr_a[lidx]->blend_mode,\n                                    lyr_a[lidx]->opacity,\n                                    lyr_a[lidx]->clipping,\n                                    lyr_a[lidx]->extra_len,\n                                    lyr_a[lidx]->layer_flags.trans_prot,\n                                    lyr_a[lidx]->layer_flags.visible,\n                                    lyr_a[lidx]->layer_flags.irrelevant);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Layer mask data */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              lyr_a[lidx]->layer_mask_extra.top = 0;\n              lyr_a[lidx]->layer_mask_extra.left = 0;\n              lyr_a[lidx]->layer_mask_extra.bottom = 0;\n              lyr_a[lidx]->layer_mask_extra.right = 0;\n              lyr_a[lidx]->layer_mask.top = 0;\n              lyr_a[lidx]->layer_mask.left = 0;\n              lyr_a[lidx]->layer_mask.bottom = 0;\n              lyr_a[lidx]->layer_mask.right = 0;\n              lyr_a[lidx]->layer_mask.def_color = 0;\n              lyr_a[lidx]->layer_mask.extra_def_color = 0;\n              lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;\n\n              switch (block_len)\n                {\n                  case 0:\n                    break;\n\n                  case 20:\n                    if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n                  case 36: /* If we have a 36 byte mask record assume second data set is correct */\n                    if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask_extra.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                    lyr_a[lidx]->layer_mask_extra.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                    lyr_a[lidx]->layer_mask_extra.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                    lyr_a[lidx]->layer_mask_extra.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n\n                  default:\n                    IFDBG(1) g_debug (\"Unknown layer mask record size ... skipping\");\n                    if (fseek (f, block_len, SEEK_CUR) < 0)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                }\n\n              IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                lyr_a[lidx]->layer_mask.left,\n                                lyr_a[lidx]->layer_mask.top,\n                                lyr_a[lidx]->layer_mask.right,\n                                lyr_a[lidx]->layer_mask.bottom,\n                                lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n\n              IFDBG(3) g_debug (\"Default mask color, %d, %d\",\n                                lyr_a[lidx]->layer_mask.def_color,\n                                lyr_a[lidx]->layer_mask.extra_def_color);\n\n              /* Layer blending ranges */           /* FIXME  */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n              if (block_len > 0)\n                {\n                  if (fseek (f, block_len, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n\n              lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,\n                                                       4, f, error);\n              if (*error)\n                return NULL;\n              block_rem -= read_len;\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Adjustment layer info */           /* FIXME */\n\n              while (block_rem > 7)\n                {\n                  if (get_layer_resource_header (&res_a, f, error) < 0)\n                    return NULL;\n                  block_rem -= 12;\n\n                  if (res_a.data_len > block_rem)\n                    {\n                      IFDBG(1) g_debug (\"Unexpected end of layer resource data\");\n                      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                  _(\"The file is corrupt!\"));\n                      return NULL;\n                    }\n\n                  if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)\n                    return NULL;\n                  block_rem -= res_a.data_len;\n                }\n              if (block_rem > 0)\n                {\n                  if (fseek (f, block_rem, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n            }\n\n          img_a->layer_data_start = ftell(f);\n          if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n\n          IFDBG(1) g_debug (\"Layer image data block size %d\",\n                             img_a->layer_data_len);\n        }\n      else\n        lyr_a = NULL;\n\n      /* Read global layer mask record */       /* FIXME */\n\n      /* Skip to end of block */\n      if (fseek (f, block_end, SEEK_SET) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n    }\n\n  return lyr_a;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "gimp",
        "commit_id": "88eccea84aa375197cc04a2a0e2e29debb56bfa5",
        "hash": 260725452923966576703518123623386000173,
        "size": 370,
        "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)"
    },
    {
        "func": "read_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n/*      FIXME check for over-run\n            if (ftell (f) + rle_pack_len[i] > block_end)\n              {\n                psd_set_error (TRUE, errno, error);\n                return -1;\n              }\n*/\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            /* FIXME check for errors returned from decode packbits */\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n\n  /* Convert channel data to GIMP format */\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n\n  g_free (raw_data);\n\n  return 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "gimp",
        "commit_id": "88eccea84aa375197cc04a2a0e2e29debb56bfa5",
        "hash": 234229337346220140972110148929764355215,
        "size": 80,
        "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)"
    },
    {
        "func": "add_layers (const gint32  image_id,\n            PSDimage     *img_a,\n            PSDlayer    **lyr_a,\n            FILE         *f,\n            GError      **error)\n{\n  PSDchannel          **lyr_chn;\n  guchar               *pixels;\n  guint16               alpha_chn;\n  guint16               user_mask_chn;\n  guint16               layer_channels;\n  guint16               channel_idx[MAX_CHANNELS];\n  guint16              *rle_pack_len;\n  gint32                l_x;                   /* Layer x */\n  gint32                l_y;                   /* Layer y */\n  gint32                l_w;                   /* Layer width */\n  gint32                l_h;                   /* Layer height */\n  gint32                lm_x;                  /* Layer mask x */\n  gint32                lm_y;                  /* Layer mask y */\n  gint32                lm_w;                  /* Layer mask width */\n  gint32                lm_h;                  /* Layer mask height */\n  gint32                layer_size;\n  gint32                layer_id = -1;\n  gint32                mask_id = -1;\n  gint                  lidx;                  /* Layer index */\n  gint                  cidx;                  /* Channel index */\n  gint                  rowi;                  /* Row index */\n  gint                  coli;                  /* Column index */\n  gint                  i;\n  gboolean              alpha;\n  gboolean              user_mask;\n  gboolean              empty;\n  gboolean              empty_mask;\n  GimpDrawable         *drawable;\n  GimpPixelRgn          pixel_rgn;\n  GimpImageType         image_type;\n  GimpLayerModeEffects  layer_mode;\n\n\n  IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n  if (img_a->num_layers == 0)\n    {\n      IFDBG(2) g_debug (\"No layers to process\");\n      return 0;\n    }\n\n  /* Layered image - Photoshop 3 style */\n  if (fseek (f, img_a->layer_data_start, SEEK_SET) < 0)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n  for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n    {\n      IFDBG(2) g_debug (\"Process Layer No %d.\", lidx);\n\n      if (lyr_a[lidx]->drop)\n        {\n          IFDBG(2) g_debug (\"Drop layer %d\", lidx);\n\n          /* Step past layer data */\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (fseek (f, lyr_a[lidx]->chn_info[cidx].data_len, SEEK_CUR) < 0)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return -1;\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n          g_free (lyr_a[lidx]->name);\n        }\n\n      else\n        {\n          /* Empty layer */\n          if (lyr_a[lidx]->bottom - lyr_a[lidx]->top == 0\n              || lyr_a[lidx]->right - lyr_a[lidx]->left == 0)\n              empty = TRUE;\n          else\n              empty = FALSE;\n\n          /* Empty mask */\n          if (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top == 0\n              || lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left == 0)\n              empty_mask = TRUE;\n          else\n              empty_mask = FALSE;\n\n          IFDBG(3) g_debug (\"Empty mask %d, size %d %d\", empty_mask,\n                            lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top,\n                            lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);\n\n          /* Load layer channel data */\n          IFDBG(2) g_debug (\"Number of channels: %d\", lyr_a[lidx]->num_channels);\n          /* Create pointer array for the channel records */\n          lyr_chn = g_new (PSDchannel *, lyr_a[lidx]->num_channels);\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              guint16 comp_mode = PSD_COMP_RAW;\n\n              /* Allocate channel record */\n              lyr_chn[cidx] = g_malloc (sizeof (PSDchannel) );\n\n              lyr_chn[cidx]->id = lyr_a[lidx]->chn_info[cidx].channel_id;\n              lyr_chn[cidx]->rows = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n              lyr_chn[cidx]->columns = lyr_a[lidx]->right - lyr_a[lidx]->left;\n\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  /* Works around a bug in panotools psd files where the layer mask\n                     size is given as 0 but data exists. Set mask size to layer size.\n                  */\n                  if (empty_mask && lyr_a[lidx]->chn_info[cidx].data_len - 2 > 0)\n                    {\n                      empty_mask = FALSE;\n                      if (lyr_a[lidx]->layer_mask.top == lyr_a[lidx]->layer_mask.bottom)\n                        {\n                          lyr_a[lidx]->layer_mask.top = lyr_a[lidx]->top;\n                          lyr_a[lidx]->layer_mask.bottom = lyr_a[lidx]->bottom;\n                        }\n                      if (lyr_a[lidx]->layer_mask.right == lyr_a[lidx]->layer_mask.left)\n                        {\n                          lyr_a[lidx]->layer_mask.right = lyr_a[lidx]->right;\n                          lyr_a[lidx]->layer_mask.left = lyr_a[lidx]->left;\n                        }\n                    }\n                  lyr_chn[cidx]->rows = (lyr_a[lidx]->layer_mask.bottom -\n                                        lyr_a[lidx]->layer_mask.top);\n                  lyr_chn[cidx]->columns = (lyr_a[lidx]->layer_mask.right -\n                                           lyr_a[lidx]->layer_mask.left);\n                }\n\n              IFDBG(3) g_debug (\"Channel id %d, %dx%d\",\n                                lyr_chn[cidx]->id,\n                                lyr_chn[cidx]->columns,\n                                lyr_chn[cidx]->rows);\n\n              /* Only read channel data if there is any channel\n               * data. Note that the channel data can contain a\n               * compression method but no actual data.\n               */\n              if (lyr_a[lidx]->chn_info[cidx].data_len >= COMP_MODE_SIZE)\n                {\n                  if (fread (&comp_mode, COMP_MODE_SIZE, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return -1;\n                    }\n                  comp_mode = GUINT16_FROM_BE (comp_mode);\n                  IFDBG(3) g_debug (\"Compression mode: %d\", comp_mode);\n                }\n              if (lyr_a[lidx]->chn_info[cidx].data_len > COMP_MODE_SIZE)\n                {\n                  switch (comp_mode)\n                    {\n                      case PSD_COMP_RAW:        /* Planar raw data */\n                        IFDBG(3) g_debug (\"Raw data length: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2);\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RAW, NULL, f, error) < 1)\n                          return -1;\n                        break;\n\n                      case PSD_COMP_RLE:        /* Packbits */\n                        IFDBG(3) g_debug (\"RLE channel length %d, RLE length data: %d, \"\n                                          \"RLE data block: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2,\n                                          lyr_chn[cidx]->rows * 2,\n                                          (lyr_a[lidx]->chn_info[cidx].data_len - 2 -\n                                           lyr_chn[cidx]->rows * 2));\n                        rle_pack_len = g_malloc (lyr_chn[cidx]->rows * 2);\n                        for (rowi = 0; rowi < lyr_chn[cidx]->rows; ++rowi)\n                          {\n                            if (fread (&rle_pack_len[rowi], 2, 1, f) < 1)\n                              {\n                                psd_set_error (feof (f), errno, error);\n                                return -1;\n                              }\n                                rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);\n                          }\n\n                        IFDBG(3) g_debug (\"RLE decode - data\");\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RLE, rle_pack_len, f, error) < 1)\n                          return -1;\n\n                        g_free (rle_pack_len);\n                        break;\n\n                      case PSD_COMP_ZIP:                 /* ? */\n                      case PSD_COMP_ZIP_PRED:\n                      default:\n                        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                    _(\"Unsupported compression mode: %d\"), comp_mode);\n                        return -1;\n                        break;\n                    }\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n\n          /* Draw layer */\n\n          alpha = FALSE;\n          alpha_chn = -1;\n          user_mask = FALSE;\n          user_mask_chn = -1;\n          layer_channels = 0;\n          l_x = 0;\n          l_y = 0;\n          l_w = img_a->columns;\n          l_h = img_a->rows;\n\n          IFDBG(3) g_debug (\"Re-hash channel indices\");\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  user_mask = TRUE;\n                  user_mask_chn = cidx;\n                }\n              else if (lyr_chn[cidx]->id == PSD_CHANNEL_ALPHA)\n                {\n                  alpha = TRUE;\n                  alpha_chn = cidx;\n                }\n              else\n                {\n                  channel_idx[layer_channels] = cidx;   /* Assumes in sane order */\n                  layer_channels++;                     /* RGB, Lab, CMYK etc.   */\n                }\n            }\n          if (alpha)\n            {\n              channel_idx[layer_channels] = alpha_chn;\n              layer_channels++;\n            }\n\n          if (empty)\n            {\n              IFDBG(2) g_debug (\"Create blank layer\");\n              image_type = get_gimp_image_type (img_a->base_type, TRUE);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name,\n                                         img_a->columns, img_a->rows,\n                                         image_type, 0, GIMP_NORMAL_MODE);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_drawable_fill (drawable->drawable_id, GIMP_TRANSPARENT_FILL);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              if (lyr_a[lidx]->layer_flags.irrelevant)\n                gimp_drawable_set_visible (drawable->drawable_id, FALSE);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n            }\n          else\n            {\n              l_x = lyr_a[lidx]->left;\n              l_y = lyr_a[lidx]->top;\n              l_w = lyr_a[lidx]->right - lyr_a[lidx]->left;\n              l_h = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n\n              IFDBG(3) g_debug (\"Draw layer\");\n              image_type = get_gimp_image_type (img_a->base_type, alpha);\n              IFDBG(3) g_debug (\"Layer type %d\", image_type);\n              layer_size = l_w * l_h;\n              pixels = g_malloc (layer_size * layer_channels);\n              for (cidx = 0; cidx < layer_channels; ++cidx)\n                {\n                  IFDBG(3) g_debug (\"Start channel %d\", channel_idx[cidx]);\n                  for (i = 0; i < layer_size; ++i)\n                    pixels[(i * layer_channels) + cidx] = lyr_chn[channel_idx[cidx]]->data[i];\n                  g_free (lyr_chn[channel_idx[cidx]]->data);\n                }\n\n              layer_mode = psd_to_gimp_blend_mode (lyr_a[lidx]->blend_mode);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name, l_w, l_h,\n                                         image_type, lyr_a[lidx]->opacity * 100 / 255,\n                                         layer_mode);\n              IFDBG(3) g_debug (\"Layer tattoo: %d\", layer_id);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              gimp_layer_set_offsets (layer_id, l_x, l_y);\n              gimp_layer_set_lock_alpha  (layer_id, lyr_a[lidx]->layer_flags.trans_prot);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0,\n                                   drawable->width, drawable->height, TRUE, FALSE);\n              gimp_pixel_rgn_set_rect (&pixel_rgn, pixels,\n                                       0, 0, drawable->width, drawable->height);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n              g_free (pixels);\n            }\n\n          /* Layer mask */\n          if (user_mask)\n            {\n              if (empty_mask)\n                {\n                  IFDBG(3) g_debug (\"Create empty mask\");\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                }\n              else\n                {\n                  /* Load layer mask data */\n                  if (lyr_a[lidx]->layer_mask.mask_flags.relative_pos)\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left;\n                      lm_y = lyr_a[lidx]->layer_mask.top;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  else\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left - l_x;\n                      lm_y = lyr_a[lidx]->layer_mask.top - l_y;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  IFDBG(3) g_debug (\"Mask channel index %d\", user_mask_chn);\n                  IFDBG(3) g_debug (\"Relative pos %d\",\n                                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n                  layer_size = lm_w * lm_h;\n                  pixels = g_malloc (layer_size);\n                  IFDBG(3) g_debug (\"Allocate Pixels %d\", layer_size);\n                  /* Crop mask at layer boundry */\n                  IFDBG(3) g_debug (\"Original Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n                  if (lm_x < 0\n                      || lm_y < 0\n                      || lm_w + lm_x > l_w\n                      || lm_h + lm_y > l_h)\n                    {\n                      if (CONVERSION_WARNINGS)\n                        g_message (\"Warning\\n\"\n                                   \"The layer mask is partly outside the \"\n                                   \"layer boundary. The mask will be \"\n                                   \"cropped which may result in data loss.\");\n                      i = 0;\n                      for (rowi = 0; rowi < lm_h; ++rowi)\n                        {\n                          if (rowi + lm_y >= 0 && rowi + lm_y < l_h)\n                            {\n                              for (coli = 0; coli < lm_w; ++coli)\n                                {\n                                  if (coli + lm_x >= 0 && coli + lm_x < l_w)\n                                    {\n                                      pixels[i] =\n                                        lyr_chn[user_mask_chn]->data[(rowi * lm_w) + coli];\n                                      i++;\n                                    }\n                                }\n                            }\n                        }\n                      if (lm_x < 0)\n                        {\n                          lm_w += lm_x;\n                          lm_x = 0;\n                        }\n                      if (lm_y < 0)\n                        {\n                          lm_h += lm_y;\n                          lm_y = 0;\n                        }\n                      if (lm_w + lm_x > l_w)\n                        lm_w = l_w - lm_x;\n                      if (lm_h + lm_y > l_h)\n                        lm_h = l_h - lm_y;\n                    }\n                  else\n                    memcpy (pixels, lyr_chn[user_mask_chn]->data, layer_size);\n                  g_free (lyr_chn[user_mask_chn]->data);\n                  /* Draw layer mask data */\n                  IFDBG(3) g_debug (\"Layer %d %d %d %d\", l_x, l_y, l_w, l_h);\n                  IFDBG(3) g_debug (\"Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n\n                  IFDBG(3) g_debug (\"New layer mask %d\", mask_id);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  drawable = gimp_drawable_get (mask_id);\n                  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0 , 0,\n                                       drawable->width, drawable->height, TRUE, FALSE);\n                  gimp_pixel_rgn_set_rect (&pixel_rgn, pixels, lm_x, lm_y, lm_w, lm_h);\n                  gimp_drawable_flush (drawable);\n                  gimp_drawable_detach (drawable);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                  g_free (pixels);\n                }\n            }\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            if (lyr_chn[cidx])\n              g_free (lyr_chn[cidx]);\n          g_free (lyr_chn);\n        }\n      g_free (lyr_a[lidx]);\n    }\n  g_free (lyr_a);\n\n  return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "gimp",
        "commit_id": "88eccea84aa375197cc04a2a0e2e29debb56bfa5",
        "hash": 100548926281788437485573729336082276267,
        "size": 418,
        "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)"
    },
    {
        "func": "read_layer_block (PSDimage  *img_a,\n                  FILE      *f,\n                  GError   **error)\n{\n  PSDlayer **lyr_a;\n  guint32    block_len;\n  guint32    block_end;\n  guint32    block_rem;\n  gint32     read_len;\n  gint32     write_len;\n  gint       lidx;                  /* Layer index */\n  gint       cidx;                  /* Channel index */\n\n  if (fread (&block_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      img_a->num_layers = -1;\n      return NULL;\n    }\n  img_a->mask_layer_len = GUINT32_FROM_BE (block_len);\n\n  IFDBG(1) g_debug (\"Layer and mask block size = %d\", img_a->mask_layer_len);\n\n  img_a->transparency = FALSE;\n  img_a->layer_data_len = 0;\n\n  if (!img_a->mask_layer_len)\n    {\n      img_a->num_layers = 0;\n      return NULL;\n    }\n  else\n    {\n      img_a->mask_layer_start = ftell (f);\n      block_end = img_a->mask_layer_start + img_a->mask_layer_len;\n\n      /* Get number of layers */\n      if (fread (&block_len, 4, 1, f) < 1\n          || fread (&img_a->num_layers, 2, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          img_a->num_layers = -1;\n          return NULL;\n        }\n      img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);\n      IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n      if (img_a->num_layers < 0)\n        {\n          img_a->transparency = TRUE;\n          img_a->num_layers = -img_a->num_layers;\n        }\n\n      if (img_a->num_layers)\n        {\n          /* Read layer records */\n          PSDlayerres           res_a;\n\n          /* Create pointer array for the layer records */\n          lyr_a = g_new (PSDlayer *, img_a->num_layers);\n          for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n            {\n              /* Allocate layer record */\n              lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );\n\n              /* Initialise record */\n              lyr_a[lidx]->drop = FALSE;\n              lyr_a[lidx]->id = 0;\n\n              if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->left, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->right, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              lyr_a[lidx]->top = GUINT32_FROM_BE (lyr_a[lidx]->top);\n              lyr_a[lidx]->left = GUINT32_FROM_BE (lyr_a[lidx]->left);\n              lyr_a[lidx]->bottom = GUINT32_FROM_BE (lyr_a[lidx]->bottom);\n              lyr_a[lidx]->right = GUINT32_FROM_BE (lyr_a[lidx]->right);\n              lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n\n              if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Too many channels in layer: %d\"),\n                              lyr_a[lidx]->num_channels);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer height: %d\"),\n                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer width: %d\"),\n                              lyr_a[lidx]->right - lyr_a[lidx]->left);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n                                 lyr_a[lidx]->num_channels);\n\n              lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);\n              for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n                {\n                  if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1\n                      || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                  lyr_a[lidx]->chn_info[cidx].channel_id =\n                    GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);\n                  lyr_a[lidx]->chn_info[cidx].data_len =\n                    GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);\n                  img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;\n                  IFDBG(3) g_debug (\"Channel ID %d, data len %d\",\n                                     lyr_a[lidx]->chn_info[cidx].channel_id,\n                                     lyr_a[lidx]->chn_info[cidx].data_len);\n                }\n\n              if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1\n                  || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              if (memcmp (lyr_a[lidx]->mode_key, \"8BIM\", 4) != 0)\n                {\n                  IFDBG(1) g_debug (\"Incorrect layer mode signature %.4s\",\n                                    lyr_a[lidx]->mode_key);\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"The file is corrupt!\"));\n                  return NULL;\n                }\n\n              lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;\n              lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;\n              if (lyr_a[lidx]->flags & 8)\n                lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;\n              else\n                lyr_a[lidx]->layer_flags.irrelevant = FALSE;\n\n              lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);\n              block_rem = lyr_a[lidx]->extra_len;\n              IFDBG(2) g_debug (\"\\n\\tLayer mode sig: %.4s\\n\\tBlend mode: %.4s\\n\\t\"\n                                \"Opacity: %d\\n\\tClipping: %d\\n\\tExtra data len: %d\\n\\t\"\n                                \"Alpha lock: %d\\n\\tVisible: %d\\n\\tIrrelevant: %d\",\n                                    lyr_a[lidx]->mode_key,\n                                    lyr_a[lidx]->blend_mode,\n                                    lyr_a[lidx]->opacity,\n                                    lyr_a[lidx]->clipping,\n                                    lyr_a[lidx]->extra_len,\n                                    lyr_a[lidx]->layer_flags.trans_prot,\n                                    lyr_a[lidx]->layer_flags.visible,\n                                    lyr_a[lidx]->layer_flags.irrelevant);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Layer mask data */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              lyr_a[lidx]->layer_mask_extra.top = 0;\n              lyr_a[lidx]->layer_mask_extra.left = 0;\n              lyr_a[lidx]->layer_mask_extra.bottom = 0;\n              lyr_a[lidx]->layer_mask_extra.right = 0;\n              lyr_a[lidx]->layer_mask.top = 0;\n              lyr_a[lidx]->layer_mask.left = 0;\n              lyr_a[lidx]->layer_mask.bottom = 0;\n              lyr_a[lidx]->layer_mask.right = 0;\n              lyr_a[lidx]->layer_mask.def_color = 0;\n              lyr_a[lidx]->layer_mask.extra_def_color = 0;\n              lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;\n\n              switch (block_len)\n                {\n                  case 0:\n                    break;\n\n                  case 20:\n                    if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n                  case 36: /* If we have a 36 byte mask record assume second data set is correct */\n                    if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask_extra.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                    lyr_a[lidx]->layer_mask_extra.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                    lyr_a[lidx]->layer_mask_extra.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                    lyr_a[lidx]->layer_mask_extra.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                    lyr_a[lidx]->layer_mask.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n\n                  default:\n                    IFDBG(1) g_debug (\"Unknown layer mask record size ... skipping\");\n                    if (fseek (f, block_len, SEEK_CUR) < 0)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                }\n\n              IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                lyr_a[lidx]->layer_mask.left,\n                                lyr_a[lidx]->layer_mask.top,\n                                lyr_a[lidx]->layer_mask.right,\n                                lyr_a[lidx]->layer_mask.bottom,\n                                lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n\n              IFDBG(3) g_debug (\"Default mask color, %d, %d\",\n                                lyr_a[lidx]->layer_mask.def_color,\n                                lyr_a[lidx]->layer_mask.extra_def_color);\n\n              /* Layer blending ranges */           /* FIXME  */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n              if (block_len > 0)\n                {\n                  if (fseek (f, block_len, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n\n              lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,\n                                                       4, f, error);\n              if (*error)\n                return NULL;\n              block_rem -= read_len;\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Adjustment layer info */           /* FIXME */\n\n              while (block_rem > 7)\n                {\n                  if (get_layer_resource_header (&res_a, f, error) < 0)\n                    return NULL;\n                  block_rem -= 12;\n\n                  if (res_a.data_len > block_rem)\n                    {\n                      IFDBG(1) g_debug (\"Unexpected end of layer resource data\");\n                      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                  _(\"The file is corrupt!\"));\n                      return NULL;\n                    }\n\n                  if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)\n                    return NULL;\n                  block_rem -= res_a.data_len;\n                }\n              if (block_rem > 0)\n                {\n                  if (fseek (f, block_rem, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n            }\n\n          img_a->layer_data_start = ftell(f);\n          if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n\n          IFDBG(1) g_debug (\"Layer image data block size %d\",\n                             img_a->layer_data_len);\n        }\n      else\n        lyr_a = NULL;\n\n      /* Read global layer mask record */       /* FIXME */\n\n      /* Skip to end of block */\n      if (fseek (f, block_end, SEEK_SET) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n    }\n\n  return lyr_a;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "gimp",
        "commit_id": "687ec47914ec08d6e460918cb641c196d80140a3",
        "hash": 237808740532293787917512914830501835922,
        "size": 370,
        "message": "Fix the PSD structs to use signed ints for bounding box coordinates.\n(cherry picked from commit 0e440cb6d4d6ee029667363d244aff61b154c33c)"
    },
    {
        "func": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\n\nerr_out:\n\tkfree(rule_buf);\n\n\treturn ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "linux-2.6",
        "commit_id": "db048b69037e7fa6a7d9e95a1271a50dc08ae233",
        "hash": 256352693318403322664792307490650702760,
        "size": 44,
        "message": "ethtool: Fix potential kernel buffer overflow in ETHTOOL_GRXCLSRLALL\n\nOn a 32-bit machine, info.rule_cnt >= 0x40000000 leads to integer\noverflow and the buffer may be smaller than needed.  Since\nETHTOOL_GRXCLSRLALL is unprivileged, this can presumably be used for at\nleast denial of service.\n\nSigned-off-by: Ben Hutchings <bhutchings@solarflare.com>\nCc: stable@kernel.org\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * AKPM: should this return a partial result if some of the IOs were\n\t * successfully submitted?\n\t */\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "linux-2.6",
        "commit_id": "75e1c70fc31490ef8a373ea2a4bea2524099b478",
        "hash": 116941780762916302517059243532906886363,
        "size": 47,
        "message": "aio: check for multiplication overflow in do_io_submit\n\nTavis Ormandy pointed out that do_io_submit does not do proper bounds\nchecking on the passed-in iocb array:\n\n\u00a0 \u00a0 \u00a0 \u00a0if (unlikely(nr < 0))\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return -EINVAL;\n\n\u00a0 \u00a0 \u00a0 \u00a0if (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(iocbpp)))))\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return -EFAULT; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0^^^^^^^^^^^^^^^^^^\n\nThe attached patch checks for overflow, and if it is detected, the\nnumber of iocbs submitted is scaled down to a number that will fit in\nthe long. \u00a0This is an ok thing to do, as sys_io_submit is documented as\nreturning the number of iocbs submitted, so callers should handle a\nreturn value of less than the 'nr' argument passed in.\n\nReported-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nSigned-off-by: Jeff Moyer <jmoyer@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE         *fd;\n  GimpDrawable *drawable;\n  GimpPixelRgn  pixel_rgn;\n  guint16       offset_x, offset_y, bytesperline;\n  gint32        width, height;\n  gint32        image, layer;\n  guchar       *dest, cmap[768];\n  guint8        header_buf[128];\n\n  fd = g_fopen (filename, \"rb\");\n\n  if (! fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (fread (header_buf, 128, 1, fd) == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  pcx_header_from_buffer (header_buf);\n\n  if (pcx_header.manufacturer != 10)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a PCX file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  offset_x     = GUINT16_FROM_LE (pcx_header.x1);\n  offset_y     = GUINT16_FROM_LE (pcx_header.y1);\n  width        = GUINT16_FROM_LE (pcx_header.x2) - offset_x + 1;\n  height       = GUINT16_FROM_LE (pcx_header.y2) - offset_y + 1;\n  bytesperline = GUINT16_FROM_LE (pcx_header.bytesperline);\n\n  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image width: %d\"), width);\n      return -1;\n    }\n  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image height: %d\"), height);\n      return -1;\n    }\n  if (bytesperline < (width * pcx_header.bpp) / 8)\n    {\n      g_message (_(\"Invalid number of bytes per line in PCX header\"));\n      return -1;\n    }\n\n  /* Shield against potential buffer overflows in load_*() functions. */\n  if (G_MAXSIZE / width / height < 3)\n    {\n      g_message (_(\"Image dimensions too large: width %d x height %d\"), width, height);\n      return -1;\n    }\n\n  if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      image= gimp_image_new (width, height, GIMP_RGB);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  else\n    {\n      image= gimp_image_new (width, height, GIMP_INDEXED);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_INDEXED_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  gimp_image_set_filename (image, filename);\n  gimp_image_add_layer (image, layer, 0);\n  gimp_layer_set_offsets (layer, offset_x, offset_y);\n  drawable = gimp_drawable_get (layer);\n\n  if (pcx_header.planes == 1 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_1 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, mono, 2);\n    }\n  else if (pcx_header.planes == 4 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_4 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, pcx_header.colormap, 16);\n    }\n  else if (pcx_header.planes == 1 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height);\n      load_8 (fd, width, height, dest, bytesperline);\n      fseek (fd, -768L, SEEK_END);\n      fread (cmap, 768, 1, fd);\n      gimp_image_set_colormap (image, cmap, 256);\n    }\n  else if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height * 3);\n      load_24 (fd, width, height, dest, bytesperline);\n    }\n  else\n    {\n      g_message (_(\"Unusual PCX flavour, giving up\"));\n      return -1;\n    }\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0, width, height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest, 0, 0, width, height);\n\n  g_free (dest);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n\n  return image;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "gimp",
        "commit_id": "a9671395f6573e90316a9d748588c5435216f6ce",
        "hash": 261174846129512730748696924830237687262,
        "size": 130,
        "message": "PCX: Avoid allocation overflows.\n\nMultiplying gint values may overflow unless cast into a larger type."
    },
    {
        "func": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\ttemp = bridge->current_size;\n\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\t/* The generic routines can't deal with 2 level gatt's */\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t/* The generic routines know nothing of memory types */\n\t\treturn -EINVAL;\n\t}\n\n\t/* AK: could wrap */\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t/* PCI Posting. */\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "linux-2.6",
        "commit_id": "194b3da873fd334ef183806db751473512af29ce",
        "hash": 72727758750257646094934694257758895550,
        "size": 80,
        "message": "agp: fix arbitrary kernel memory writes\n\npg_start is copied from userspace on AGPIOC_BIND and AGPIOC_UNBIND ioctl\ncmds of agp_ioctl() and passed to agpioc_bind_wrap().  As said in the\ncomment, (pg_start + mem->page_count) may wrap in case of AGPIOC_BIND,\nand it is not checked at all in case of AGPIOC_UNBIND.  As a result, user\nwith sufficient privileges (usually \"video\" group) may generate either\nlocal DoS or privilege escalation.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>"
    },
    {
        "func": "int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tsize_t i;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t/* The generic routines know nothing of memory types */\n\t\treturn -EINVAL;\n\t}\n\n\t/* AK: bogus, should encode addresses > 4GB */\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\n\t\twritel(bridge->scratch_page, bridge->gatt_table+i);\n\t}\n\treadl(bridge->gatt_table+i-1);\t/* PCI Posting. */\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "linux-2.6",
        "commit_id": "194b3da873fd334ef183806db751473512af29ce",
        "hash": 120249293960309952088651463032722813488,
        "size": 31,
        "message": "agp: fix arbitrary kernel memory writes\n\npg_start is copied from userspace on AGPIOC_BIND and AGPIOC_UNBIND ioctl\ncmds of agp_ioctl() and passed to agpioc_bind_wrap().  As said in the\ncomment, (pg_start + mem->page_count) may wrap in case of AGPIOC_BIND,\nand it is not checked at all in case of AGPIOC_UNBIND.  As a result, user\nwith sufficient privileges (usually \"video\" group) may generate either\nlocal DoS or privilege escalation.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>"
    },
    {
        "func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE            *ifp;\n  gint             depth, bpp;\n  gint32           image_ID;\n  L_XWDFILEHEADER  xwdhdr;\n  L_XWDCOLOR      *xwdcolmap = NULL;\n\n  ifp = g_fopen (filename, \"rb\");\n  if (!ifp)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  read_xwd_header (ifp, &xwdhdr);\n  if (xwdhdr.l_file_version != 7)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read XWD header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      fclose (ifp);\n      return -1;\n    }\n\n#ifdef XWD_COL_WAIT_DEBUG\n  {\n    int k = 1;\n\n    while (k)\n      k = k;\n  }\n#endif\n\n  /* Position to start of XWDColor structures */\n  fseek (ifp, (long)xwdhdr.l_header_size, SEEK_SET);\n\n  if (xwdhdr.l_colormap_entries > 0)\n    {\n      xwdcolmap = g_new (L_XWDCOLOR, xwdhdr.l_colormap_entries);\n\n      read_xwd_cols (ifp, &xwdhdr, xwdcolmap);\n\n#ifdef XWD_COL_DEBUG\n      {\n        int j;\n        printf (\"File %s\\n\",filename);\n        for (j = 0; j < xwdhdr.l_colormap_entries; j++)\n          printf (\"Entry 0x%08lx: 0x%04lx,  0x%04lx, 0x%04lx, %d\\n\",\n                  (long)xwdcolmap[j].l_pixel,(long)xwdcolmap[j].l_red,\n                  (long)xwdcolmap[j].l_green,(long)xwdcolmap[j].l_blue,\n                  (int)xwdcolmap[j].l_flags);\n      }\n#endif\n\n      if (xwdhdr.l_file_version != 7)\n        {\n          g_message (_(\"Can't read color entries\"));\n          g_free (xwdcolmap);\n          fclose (ifp);\n          return (-1);\n        }\n    }\n\n  if (xwdhdr.l_pixmap_width <= 0)\n    {\n      g_message (_(\"'%s':\\nNo image width specified\"),\n                 gimp_filename_to_utf8 (filename));\n      g_free (xwdcolmap);\n      fclose (ifp);\n      return (-1);\n    }\n\n  if (xwdhdr.l_pixmap_width > GIMP_MAX_IMAGE_SIZE\n      || xwdhdr.l_bytes_per_line > GIMP_MAX_IMAGE_SIZE * 3)\n    {\n      g_message (_(\"'%s':\\nImage width is larger than GIMP can handle\"),\n                 gimp_filename_to_utf8 (filename));\n      g_free (xwdcolmap);\n      fclose (ifp);\n      return (-1);\n    }\n\n  if (xwdhdr.l_pixmap_height <= 0)\n    {\n      g_message (_(\"'%s':\\nNo image height specified\"),\n                 gimp_filename_to_utf8 (filename));\n      g_free (xwdcolmap);\n      fclose (ifp);\n      return (-1);\n    }\n\n  if (xwdhdr.l_pixmap_height > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_message (_(\"'%s':\\nImage height is larger than GIMP can handle\"),\n                 gimp_filename_to_utf8 (filename));\n      g_free (xwdcolmap);\n      fclose (ifp);\n      return (-1);\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  depth = xwdhdr.l_pixmap_depth;\n  bpp   = xwdhdr.l_bits_per_pixel;\n\n  image_ID = -1;\n  switch (xwdhdr.l_pixmap_format)\n    {\n    case 0:    /* Single plane bitmap */\n      if ((depth == 1) && (bpp == 1))\n        { /* Can be performed by format 2 loader */\n          image_ID = load_xwd_f2_d1_b1 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      break;\n\n    case 1:    /* Single plane pixmap */\n      if ((depth <= 24) && (bpp == 1))\n        {\n          image_ID = load_xwd_f1_d24_b1 (filename, ifp, &xwdhdr, xwdcolmap,\n                                         error);\n        }\n      break;\n\n    case 2:    /* Multiplane pixmaps */\n      if ((depth == 1) && (bpp == 1))\n        {\n          image_ID = load_xwd_f2_d1_b1 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      else if ((depth <= 8) && (bpp == 8))\n        {\n          image_ID = load_xwd_f2_d8_b8 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      else if ((depth <= 16) && (bpp == 16))\n        {\n          image_ID = load_xwd_f2_d16_b16 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      else if ((depth <= 24) && ((bpp == 24) || (bpp == 32)))\n        {\n          image_ID = load_xwd_f2_d24_b32 (filename, ifp, &xwdhdr, xwdcolmap,\n                                          error);\n        }\n      else if ((depth <= 32) && (bpp == 32))\n        {\n          image_ID = load_xwd_f2_d32_b32 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      break;\n    }\n  gimp_progress_update (1.0);\n\n  fclose (ifp);\n\n  if (xwdcolmap)\n    g_free (xwdcolmap);\n\n  if (image_ID == -1 && ! (error && *error))\n    g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                 _(\"XWD-file %s has format %d, depth %d and bits per pixel %d. \"\n                   \"Currently this is not supported.\"),\n                 gimp_filename_to_utf8 (filename),\n                 (gint) xwdhdr.l_pixmap_format, depth, bpp);\n\n  return image_ID;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "gimp",
        "commit_id": "32ae0f83e5748299641cceaabe3f80f1b3afd03e",
        "hash": 78291565493492617923788649847050533751,
        "size": 168,
        "message": "file-xwd: sanity check colormap size (CVE-2013-1913)"
    },
    {
        "func": "int qcow2_alloc_clusters_at(BlockDriverState *bs, uint64_t offset,\n    int nb_clusters)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint64_t cluster_index;\n    uint64_t old_free_cluster_index;\n    uint64_t i;\n    int refcount, ret;\n\n    assert(nb_clusters >= 0);\n    if (nb_clusters == 0) {\n        return 0;\n    }\n\n    /* Check how many clusters there are free */\n    cluster_index = offset >> s->cluster_bits;\n    for(i = 0; i < nb_clusters; i++) {\n        refcount = get_refcount(bs, cluster_index++);\n\n        if (refcount < 0) {\n            return refcount;\n        } else if (refcount != 0) {\n            break;\n        }\n    }\n\n    /* And then allocate them */\n    old_free_cluster_index = s->free_cluster_index;\n    s->free_cluster_index = cluster_index + i;\n\n    ret = update_refcount(bs, offset, i << s->cluster_bits, 1,\n                          QCOW2_DISCARD_NEVER);\n    if (ret < 0) {\n        return ret;\n    }\n\n    s->free_cluster_index = old_free_cluster_index;\n\n    return i;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "qemu",
        "commit_id": "b106ad9185f35fc4ad669555ad0e79e276083bd7",
        "hash": 256241999865330909261110959622789893971,
        "size": 40,
        "message": "qcow2: Don't rely on free_cluster_index in alloc_refcount_block() (CVE-2014-0147)\n\nfree_cluster_index is only correct if update_refcount() was called from\nan allocation function, and even there it's brittle because it's used to\nprotect unfinished allocations which still have a refcount of 0 - if it\nmoves in the wrong place, the unfinished allocation can be corrupted.\n\nSo not using it any more seems to be a good idea. Instead, use the\nfirst requested cluster to do the calculations. Return -EAGAIN if\nunfinished allocations could become invalid and let the caller restart\nits search for some free clusters.\n\nThe context of creating a snapsnot is one situation where\nupdate_refcount() is called outside of a cluster allocation. For this\ncase, the change fixes a buffer overflow if a cluster is referenced in\nan L2 table that cannot be represented by an existing refcount block.\n(new_table[refcount_table_index] was out of bounds)\n\n[Bump the qemu-iotests 026 refblock_alloc.write leak count from 10 to\n11.\n--Stefan]\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>"
    },
    {
        "func": "int64_t qcow2_alloc_clusters(BlockDriverState *bs, int64_t size)\n{\n    int64_t offset;\n    int ret;\n\n    BLKDBG_EVENT(bs->file, BLKDBG_CLUSTER_ALLOC);\n    offset = alloc_clusters_noref(bs, size);\n    if (offset < 0) {\n        return offset;\n    }\n\n    ret = update_refcount(bs, offset, size, 1, QCOW2_DISCARD_NEVER);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return offset;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "qemu",
        "commit_id": "b106ad9185f35fc4ad669555ad0e79e276083bd7",
        "hash": 69740997061613159079402948338021505226,
        "size": 18,
        "message": "qcow2: Don't rely on free_cluster_index in alloc_refcount_block() (CVE-2014-0147)\n\nfree_cluster_index is only correct if update_refcount() was called from\nan allocation function, and even there it's brittle because it's used to\nprotect unfinished allocations which still have a refcount of 0 - if it\nmoves in the wrong place, the unfinished allocation can be corrupted.\n\nSo not using it any more seems to be a good idea. Instead, use the\nfirst requested cluster to do the calculations. Return -EAGAIN if\nunfinished allocations could become invalid and let the caller restart\nits search for some free clusters.\n\nThe context of creating a snapsnot is one situation where\nupdate_refcount() is called outside of a cluster allocation. For this\ncase, the change fixes a buffer overflow if a cluster is referenced in\nan L2 table that cannot be represented by an existing refcount block.\n(new_table[refcount_table_index] was out of bounds)\n\n[Bump the qemu-iotests 026 refblock_alloc.write leak count from 10 to\n11.\n--Stefan]\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>"
    },
    {
        "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    }\n\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader *header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n        return ret;\n    }\n\n    bs = NULL;\n    ret = bdrv_open(&bs, filename, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL,\n                    NULL, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n        return ret;\n    }\n\n    /* Write the header */\n    QEMU_BUILD_BUG_ON((1 << MIN_CLUSTER_BITS) < sizeof(*header));\n    header = g_malloc0(cluster_size);\n    *header = (QCowHeader) {\n        .magic                      = cpu_to_be32(QCOW_MAGIC),\n        .version                    = cpu_to_be32(version),\n        .cluster_bits               = cpu_to_be32(cluster_bits),\n        .size                       = cpu_to_be64(0),\n        .l1_table_offset            = cpu_to_be64(0),\n        .l1_size                    = cpu_to_be32(0),\n        .refcount_table_offset      = cpu_to_be64(cluster_size),\n        .refcount_table_clusters    = cpu_to_be32(1),\n        .refcount_order             = cpu_to_be32(3 + REFCOUNT_SHIFT),\n        .header_length              = cpu_to_be32(sizeof(*header)),\n    };\n\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header->crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header->crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    }\n\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header->compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    }\n\n    ret = bdrv_pwrite(bs, 0, header, cluster_size);\n    g_free(header);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n        goto out;\n    }\n\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n        goto out;\n    }\n\n    bdrv_unref(bs);\n    bs = NULL;\n\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n    ret = bdrv_open(&bs, filename, NULL, NULL,\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n        goto out;\n\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    }\n\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n        goto out;\n    }\n\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n            goto out;\n        }\n    }\n\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n            goto out;\n        }\n    }\n\n    bdrv_unref(bs);\n    bs = NULL;\n\n    /* Reopen the image without BDRV_O_NO_FLUSH to flush it before returning */\n    ret = bdrv_open(&bs, filename, NULL, NULL,\n                    BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_BACKING,\n                    drv, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    ret = 0;\nout:\n    if (bs) {\n        bdrv_unref(bs);\n    }\n    return ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "qemu",
        "commit_id": "b106ad9185f35fc4ad669555ad0e79e276083bd7",
        "hash": 227872669087975385977803120590601618156,
        "size": 169,
        "message": "qcow2: Don't rely on free_cluster_index in alloc_refcount_block() (CVE-2014-0147)\n\nfree_cluster_index is only correct if update_refcount() was called from\nan allocation function, and even there it's brittle because it's used to\nprotect unfinished allocations which still have a refcount of 0 - if it\nmoves in the wrong place, the unfinished allocation can be corrupted.\n\nSo not using it any more seems to be a good idea. Instead, use the\nfirst requested cluster to do the calculations. Return -EAGAIN if\nunfinished allocations could become invalid and let the caller restart\nits search for some free clusters.\n\nThe context of creating a snapsnot is one situation where\nupdate_refcount() is called outside of a cluster allocation. For this\ncase, the change fixes a buffer overflow if a cluster is referenced in\nan L2 table that cannot be represented by an existing refcount block.\n(new_table[refcount_table_index] was out of bounds)\n\n[Bump the qemu-iotests 026 refblock_alloc.write leak count from 10 to\n11.\n--Stefan]\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>"
    },
    {
        "func": "static int alloc_refcount_block(BlockDriverState *bs,\n    int64_t cluster_index, uint16_t **refcount_block)\n{\n    BDRVQcowState *s = bs->opaque;\n    unsigned int refcount_table_index;\n    int ret;\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n    /* Find the refcount block for the given cluster */\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t refcount_block_offset =\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n        /* If it's already there, we're done */\n        if (refcount_block_offset) {\n             return load_refcount_block(bs, refcount_block_offset,\n                 (void**) refcount_block);\n        }\n    }\n\n    /*\n     * If we came here, we need to allocate something. Something is at least\n     * a cluster for the new refcount block. It may also include a new refcount\n     * table if the old refcount table is too small.\n     *\n     * Note that allocating clusters here needs some special care:\n     *\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n     *   increase the refcount and very likely we would end up with an endless\n     *   recursion. Instead we must place the refcount blocks in a way that\n     *   they can describe them themselves.\n     *\n     * - We need to consider that at this point we are inside update_refcounts\n     *   and doing the initial refcount increase. This means that some clusters\n     *   have already been allocated by the caller, but their refcount isn't\n     *   accurate yet. free_cluster_index tells us where this allocation ends\n     *   as long as we don't overwrite it by freeing clusters.\n     *\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n     *   refcount block into the cache\n     */\n\n    *refcount_block = NULL;\n\n    /* We write to the refcount table, so we might depend on L2 tables */\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n    if (ret < 0) {\n        return ret;\n    }\n\n    /* Allocate the refcount block itself and mark it as used */\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n    if (new_block < 0) {\n        return new_block;\n    }\n\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n        \" at %\" PRIx64 \"\\n\",\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n#endif\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n        /* Zero the new refcount block before updating it */\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n            (void**) refcount_block);\n        if (ret < 0) {\n            goto fail_block;\n        }\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n        /* The block describes itself, need to update the cache */\n        int block_index = (new_block >> s->cluster_bits) &\n            ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n        (*refcount_block)[block_index] = cpu_to_be16(1);\n    } else {\n        /* Described somewhere else. This can recurse at most twice before we\n         * arrive at a block that describes itself. */\n        ret = update_refcount(bs, new_block, s->cluster_size, 1,\n                              QCOW2_DISCARD_NEVER);\n        if (ret < 0) {\n            goto fail_block;\n        }\n\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n        if (ret < 0) {\n            goto fail_block;\n        }\n\n        /* Initialize the new refcount block only after updating its refcount,\n         * update_refcount uses the refcount cache itself */\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n            (void**) refcount_block);\n        if (ret < 0) {\n            goto fail_block;\n        }\n\n        memset(*refcount_block, 0, s->cluster_size);\n    }\n\n    /* Now the new refcount block needs to be written to disk */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail_block;\n    }\n\n    /* If the refcount table is big enough, just hook the block up there */\n    if (refcount_table_index < s->refcount_table_size) {\n        uint64_t data64 = cpu_to_be64(new_block);\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n        ret = bdrv_pwrite_sync(bs->file,\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n            &data64, sizeof(data64));\n        if (ret < 0) {\n            goto fail_block;\n        }\n\n        s->refcount_table[refcount_table_index] = new_block;\n        return 0;\n    }\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n    if (ret < 0) {\n        goto fail_block;\n    }\n\n    /*\n     * If we come here, we need to grow the refcount table. Again, a new\n     * refcount table needs some space and we can't simply allocate to avoid\n     * endless recursion.\n     *\n     * Therefore let's grab new refcount blocks at the end of the image, which\n     * will describe themselves and the new refcount table. This way we can\n     * reference them only in the new table and do the switch to the new\n     * refcount table at once without producing an inconsistent state in\n     * between.\n     */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n    /* Calculate the number of refcount blocks needed so far */\n    uint64_t refcount_block_clusters = 1 << (s->cluster_bits - REFCOUNT_SHIFT);\n    uint64_t blocks_used = (s->free_cluster_index +\n        refcount_block_clusters - 1) / refcount_block_clusters;\n\n    /* And now we need at least one block more for the new metadata */\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n    uint64_t last_table_size;\n    uint64_t blocks_clusters;\n    do {\n        uint64_t table_clusters =\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n        blocks_clusters = 1 +\n            ((table_clusters + refcount_block_clusters - 1)\n            / refcount_block_clusters);\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n        last_table_size = table_size;\n        table_size = next_refcount_table_size(s, blocks_used +\n            ((meta_clusters + refcount_block_clusters - 1)\n            / refcount_block_clusters));\n\n    } while (last_table_size != table_size);\n\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n        s->refcount_table_size, table_size);\n#endif\n\n    /* Create the new refcount table and blocks */\n    uint64_t meta_offset = (blocks_used * refcount_block_clusters) *\n        s->cluster_size;\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n    uint16_t *new_blocks = g_malloc0(blocks_clusters * s->cluster_size);\n    uint64_t *new_table = g_malloc0(table_size * sizeof(uint64_t));\n\n    assert(meta_offset >= (s->free_cluster_index * s->cluster_size));\n\n    /* Fill the new refcount table */\n    memcpy(new_table, s->refcount_table,\n        s->refcount_table_size * sizeof(uint64_t));\n    new_table[refcount_table_index] = new_block;\n\n    int i;\n    for (i = 0; i < blocks_clusters; i++) {\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n    }\n\n    /* Fill the refcount blocks */\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n    int block = 0;\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n        new_blocks[block++] = cpu_to_be16(1);\n    }\n\n    /* Write refcount blocks to disk */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n        blocks_clusters * s->cluster_size);\n    g_free(new_blocks);\n    if (ret < 0) {\n        goto fail_table;\n    }\n\n    /* Write refcount table to disk */\n    for(i = 0; i < table_size; i++) {\n        cpu_to_be64s(&new_table[i]);\n    }\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n        table_size * sizeof(uint64_t));\n    if (ret < 0) {\n        goto fail_table;\n    }\n\n    for(i = 0; i < table_size; i++) {\n        be64_to_cpus(&new_table[i]);\n    }\n\n    /* Hook up the new refcount table in the qcow2 header */\n    uint8_t data[12];\n    cpu_to_be64w((uint64_t*)data, table_offset);\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n        data, sizeof(data));\n    if (ret < 0) {\n        goto fail_table;\n    }\n\n    /* And switch it in memory */\n    uint64_t old_table_offset = s->refcount_table_offset;\n    uint64_t old_table_size = s->refcount_table_size;\n\n    g_free(s->refcount_table);\n    s->refcount_table = new_table;\n    s->refcount_table_size = table_size;\n    s->refcount_table_offset = table_offset;\n\n    /* Free old table. Remember, we must not change free_cluster_index */\n    uint64_t old_free_cluster_index = s->free_cluster_index;\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_OTHER);\n    s->free_cluster_index = old_free_cluster_index;\n\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return 0;\n\nfail_table:\n    g_free(new_table);\nfail_block:\n    if (*refcount_block != NULL) {\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n    }\n    return ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-190"
        ],
        "project": "qemu",
        "commit_id": "b106ad9185f35fc4ad669555ad0e79e276083bd7",
        "hash": 96331514894509596479087081466416015272,
        "size": 267,
        "message": "qcow2: Don't rely on free_cluster_index in alloc_refcount_block() (CVE-2014-0147)\n\nfree_cluster_index is only correct if update_refcount() was called from\nan allocation function, and even there it's brittle because it's used to\nprotect unfinished allocations which still have a refcount of 0 - if it\nmoves in the wrong place, the unfinished allocation can be corrupted.\n\nSo not using it any more seems to be a good idea. Instead, use the\nfirst requested cluster to do the calculations. Return -EAGAIN if\nunfinished allocations could become invalid and let the caller restart\nits search for some free clusters.\n\nThe context of creating a snapsnot is one situation where\nupdate_refcount() is called outside of a cluster allocation. For this\ncase, the change fixes a buffer overflow if a cluster is referenced in\nan L2 table that cannot be represented by an existing refcount block.\n(new_table[refcount_table_index] was out of bounds)\n\n[Bump the qemu-iotests 026 refblock_alloc.write leak count from 10 to\n11.\n--Stefan]\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>"
    },
    {
        "func": "xmlBufAttrSerializeTxtContent(xmlBufPtr buf, xmlDocPtr doc,\n                              xmlAttrPtr attr, const xmlChar * string)\n{\n    xmlChar *base, *cur;\n\n    if (string == NULL)\n        return;\n    base = cur = (xmlChar *) string;\n    while (*cur != 0) {\n        if (*cur == '\\n') {\n            if (base != cur)\n                xmlBufAdd(buf, base, cur - base);\n            xmlBufAdd(buf, BAD_CAST \"&#10;\", 5);\n            cur++;\n            base = cur;\n        } else if (*cur == '\\r') {\n            if (base != cur)\n                xmlBufAdd(buf, base, cur - base);\n            xmlBufAdd(buf, BAD_CAST \"&#13;\", 5);\n            cur++;\n            base = cur;\n        } else if (*cur == '\\t') {\n            if (base != cur)\n                xmlBufAdd(buf, base, cur - base);\n            xmlBufAdd(buf, BAD_CAST \"&#9;\", 4);\n            cur++;\n            base = cur;\n        } else if (*cur == '\"') {\n            if (base != cur)\n                xmlBufAdd(buf, base, cur - base);\n            xmlBufAdd(buf, BAD_CAST \"&quot;\", 6);\n            cur++;\n            base = cur;\n        } else if (*cur == '<') {\n            if (base != cur)\n                xmlBufAdd(buf, base, cur - base);\n            xmlBufAdd(buf, BAD_CAST \"&lt;\", 4);\n            cur++;\n            base = cur;\n        } else if (*cur == '>') {\n            if (base != cur)\n                xmlBufAdd(buf, base, cur - base);\n            xmlBufAdd(buf, BAD_CAST \"&gt;\", 4);\n            cur++;\n            base = cur;\n        } else if (*cur == '&') {\n            if (base != cur)\n                xmlBufAdd(buf, base, cur - base);\n            xmlBufAdd(buf, BAD_CAST \"&amp;\", 5);\n            cur++;\n            base = cur;\n        } else if ((*cur >= 0x80) && ((doc == NULL) ||\n                                      (doc->encoding == NULL))) {\n            /*\n             * We assume we have UTF-8 content.\n             */\n            unsigned char tmp[12];\n            int val = 0, l = 1;\n\n            if (base != cur)\n                xmlBufAdd(buf, base, cur - base);\n            if (*cur < 0xC0) {\n                xmlSaveErr(XML_SAVE_NOT_UTF8, (xmlNodePtr) attr, NULL);\n                if (doc != NULL)\n                    doc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n\t\txmlSerializeHexCharRef(tmp, *cur);\n                xmlBufAdd(buf, (xmlChar *) tmp, -1);\n                cur++;\n                base = cur;\n                continue;\n            } else if (*cur < 0xE0) {\n                val = (cur[0]) & 0x1F;\n                val <<= 6;\n                val |= (cur[1]) & 0x3F;\n                l = 2;\n            } else if (*cur < 0xF0) {\n                val = (cur[0]) & 0x0F;\n                val <<= 6;\n                val |= (cur[1]) & 0x3F;\n                val <<= 6;\n                val |= (cur[2]) & 0x3F;\n                l = 3;\n            } else if (*cur < 0xF8) {\n                val = (cur[0]) & 0x07;\n                val <<= 6;\n                val |= (cur[1]) & 0x3F;\n                val <<= 6;\n                val |= (cur[2]) & 0x3F;\n                val <<= 6;\n                val |= (cur[3]) & 0x3F;\n                l = 4;\n            }\n            if ((l == 1) || (!IS_CHAR(val))) {\n                xmlSaveErr(XML_SAVE_CHAR_INVALID, (xmlNodePtr) attr, NULL);\n                if (doc != NULL)\n                    doc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n\n\t\txmlSerializeHexCharRef(tmp, *cur);\n                xmlBufAdd(buf, (xmlChar *) tmp, -1);\n                cur++;\n                base = cur;\n                continue;\n            }\n            /*\n             * We could do multiple things here. Just save\n             * as a char ref\n             */\n\t    xmlSerializeHexCharRef(tmp, val);\n            xmlBufAdd(buf, (xmlChar *) tmp, -1);\n            cur += l;\n            base = cur;\n        } else {\n            cur++;\n        }\n    }\n    if (base != cur)\n        xmlBufAdd(buf, base, cur - base);\n}",
        "target": 1,
        "cwe": [
            "CWE-502"
        ],
        "project": "libxml2",
        "commit_id": "c97750d11bb8b6f3303e7131fe526a61ac65bcfd",
        "hash": 87461720637616042225074595986736068185,
        "size": 118,
        "message": "Avoid an out of bound access when serializing malformed strings\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=766414\n\n* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value\n  is not UTF-8 be more careful when serializing it as we may do an\n  out of bound access as a result."
    },
    {
        "func": "static HashTable *com_properties_get(zval *object)\n{\n\t/* TODO: use type-info to get all the names and values ?\n\t * DANGER: if we do that, there is a strong possibility for\n\t * infinite recursion when the hash is displayed via var_dump().\n\t * Perhaps it is best to leave it un-implemented.\n\t */\n\treturn NULL;\n}",
        "target": 1,
        "cwe": [
            "CWE-502"
        ],
        "project": "php-src",
        "commit_id": "115ee49b0be12e3df7d2c7027609fbe1a1297e42",
        "hash": 293067926654452130350087451855864368286,
        "size": 9,
        "message": "Fix #77177: Serializing or unserializing COM objects crashes\n\nFirstly, we avoid returning NULL from the get_property handler, but\ninstead return an empty HashTable, which already prevents the crashes.\nSecondly, since (de-)serialization obviously makes no sense for COM,\nDOTNET and VARIANT objects (at least with the current implementation),\nwe prohibit it right away."
    },
    {
        "func": "PHP_MINIT_FUNCTION(com_dotnet)\n{\n\tzend_class_entry ce, *tmp;\n\n\tphp_com_wrapper_minit(INIT_FUNC_ARGS_PASSTHRU);\n\tphp_com_persist_minit(INIT_FUNC_ARGS_PASSTHRU);\n\n\tINIT_CLASS_ENTRY(ce, \"com_exception\", NULL);\n\tphp_com_exception_class_entry = zend_register_internal_class_ex(&ce, zend_ce_exception);\n\tphp_com_exception_class_entry->ce_flags |= ZEND_ACC_FINAL;\n/*\tphp_com_exception_class_entry->constructor->common.fn_flags |= ZEND_ACC_PROTECTED; */\n\n\tINIT_CLASS_ENTRY(ce, \"com_safearray_proxy\", NULL);\n\tphp_com_saproxy_class_entry = zend_register_internal_class(&ce);\n\tphp_com_saproxy_class_entry->ce_flags |= ZEND_ACC_FINAL;\n/*\tphp_com_saproxy_class_entry->constructor->common.fn_flags |= ZEND_ACC_PROTECTED; */\n\tphp_com_saproxy_class_entry->get_iterator = php_com_saproxy_iter_get;\n\n\tINIT_CLASS_ENTRY(ce, \"variant\", NULL);\n\tce.create_object = php_com_object_new;\n\tphp_com_variant_class_entry = zend_register_internal_class(&ce);\n\tphp_com_variant_class_entry->get_iterator = php_com_iter_get;\n\n\tINIT_CLASS_ENTRY(ce, \"com\", NULL);\n\tce.create_object = php_com_object_new;\n\ttmp = zend_register_internal_class_ex(&ce, php_com_variant_class_entry);\n\ttmp->get_iterator = php_com_iter_get;\n\n\tzend_ts_hash_init(&php_com_typelibraries, 0, NULL, php_com_typelibrary_dtor, 1);\n\n#if HAVE_MSCOREE_H\n\tINIT_CLASS_ENTRY(ce, \"dotnet\", NULL);\n\tce.create_object = php_com_object_new;\n\ttmp = zend_register_internal_class_ex(&ce, php_com_variant_class_entry);\n\ttmp->get_iterator = php_com_iter_get;\n#endif\n\n\tREGISTER_INI_ENTRIES();\n\n#define COM_CONST(x) REGISTER_LONG_CONSTANT(#x, x, CONST_CS|CONST_PERSISTENT)\n\n#define COM_ERR_CONST(x) { \\\n\tzend_long __tmp; \\\n\tULongToIntPtr(x, &__tmp); \\\n\tREGISTER_LONG_CONSTANT(#x, __tmp, CONST_CS|CONST_PERSISTENT); \\\n}\n\n\tCOM_CONST(CLSCTX_INPROC_SERVER);\n\tCOM_CONST(CLSCTX_INPROC_HANDLER);\n\tCOM_CONST(CLSCTX_LOCAL_SERVER);\n\tCOM_CONST(CLSCTX_REMOTE_SERVER);\n\tCOM_CONST(CLSCTX_SERVER);\n\tCOM_CONST(CLSCTX_ALL);\n\n#if 0\n\tCOM_CONST(DISPATCH_METHOD);\n\tCOM_CONST(DISPATCH_PROPERTYGET);\n\tCOM_CONST(DISPATCH_PROPERTYPUT);\n#endif\n\n\tCOM_CONST(VT_NULL);\n\tCOM_CONST(VT_EMPTY);\n\tCOM_CONST(VT_UI1);\n\tCOM_CONST(VT_I1);\n\tCOM_CONST(VT_UI2);\n\tCOM_CONST(VT_I2);\n\tCOM_CONST(VT_UI4);\n\tCOM_CONST(VT_I4);\n\tCOM_CONST(VT_R4);\n\tCOM_CONST(VT_R8);\n\tCOM_CONST(VT_BOOL);\n\tCOM_CONST(VT_ERROR);\n\tCOM_CONST(VT_CY);\n\tCOM_CONST(VT_DATE);\n\tCOM_CONST(VT_BSTR);\n\tCOM_CONST(VT_DECIMAL);\n\tCOM_CONST(VT_UNKNOWN);\n\tCOM_CONST(VT_DISPATCH);\n\tCOM_CONST(VT_VARIANT);\n\tCOM_CONST(VT_INT);\n\tCOM_CONST(VT_UINT);\n\tCOM_CONST(VT_ARRAY);\n\tCOM_CONST(VT_BYREF);\n\n\tCOM_CONST(CP_ACP);\n\tCOM_CONST(CP_MACCP);\n\tCOM_CONST(CP_OEMCP);\n\tCOM_CONST(CP_UTF7);\n\tCOM_CONST(CP_UTF8);\n\tCOM_CONST(CP_SYMBOL);\n\tCOM_CONST(CP_THREAD_ACP);\n\n\tCOM_CONST(VARCMP_LT);\n\tCOM_CONST(VARCMP_EQ);\n\tCOM_CONST(VARCMP_GT);\n\tCOM_CONST(VARCMP_NULL);\n\n\tCOM_CONST(NORM_IGNORECASE);\n\tCOM_CONST(NORM_IGNORENONSPACE);\n\tCOM_CONST(NORM_IGNORESYMBOLS);\n\tCOM_CONST(NORM_IGNOREWIDTH);\n\tCOM_CONST(NORM_IGNOREKANATYPE);\n#ifdef NORM_IGNOREKASHIDA\n\tCOM_CONST(NORM_IGNOREKASHIDA);\n#endif\n\tCOM_ERR_CONST(DISP_E_DIVBYZERO);\n\tCOM_ERR_CONST(DISP_E_OVERFLOW);\n\tCOM_ERR_CONST(DISP_E_BADINDEX);\n\tCOM_ERR_CONST(MK_E_UNAVAILABLE);\n\n#if SIZEOF_ZEND_LONG == 8\n\tCOM_CONST(VT_UI8);\n\tCOM_CONST(VT_I8);\n#endif\n\treturn SUCCESS;\n}",
        "target": 1,
        "cwe": [
            "CWE-502"
        ],
        "project": "php-src",
        "commit_id": "115ee49b0be12e3df7d2c7027609fbe1a1297e42",
        "hash": 124252779686604850939097983445114699279,
        "size": 116,
        "message": "Fix #77177: Serializing or unserializing COM objects crashes\n\nFirstly, we avoid returning NULL from the get_property handler, but\ninstead return an empty HashTable, which already prevents the crashes.\nSecondly, since (de-)serialization obviously makes no sense for COM,\nDOTNET and VARIANT objects (at least with the current implementation),\nwe prohibit it right away."
    },
    {
        "func": "void CPINLINE swoole_mini_memcpy(void *dst, const void *src, size_t len)\n{\n    register unsigned char *dd = (unsigned char*) dst + len;\n    register const unsigned char *ss = (const unsigned char*) src + len;\n    switch (len)\n    {\n        case 68: *((int*) (dd - 68)) = *((int*) (ss - 68));\n        /* no break */\n        case 64: *((int*) (dd - 64)) = *((int*) (ss - 64));\n        /* no break */\n        case 60: *((int*) (dd - 60)) = *((int*) (ss - 60));\n        /* no break */\n        case 56: *((int*) (dd - 56)) = *((int*) (ss - 56));\n        /* no break */\n        case 52: *((int*) (dd - 52)) = *((int*) (ss - 52));\n        /* no break */\n        case 48: *((int*) (dd - 48)) = *((int*) (ss - 48));\n        /* no break */\n        case 44: *((int*) (dd - 44)) = *((int*) (ss - 44));\n        /* no break */\n        case 40: *((int*) (dd - 40)) = *((int*) (ss - 40));\n        /* no break */\n        case 36: *((int*) (dd - 36)) = *((int*) (ss - 36));\n        /* no break */\n        case 32: *((int*) (dd - 32)) = *((int*) (ss - 32));\n        /* no break */\n        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));\n        /* no break */\n        case 24: *((int*) (dd - 24)) = *((int*) (ss - 24));\n        /* no break */\n        case 20: *((int*) (dd - 20)) = *((int*) (ss - 20));\n        /* no break */\n        case 16: *((int*) (dd - 16)) = *((int*) (ss - 16));\n        /* no break */\n        case 12: *((int*) (dd - 12)) = *((int*) (ss - 12));\n        /* no break */\n        case 8: *((int*) (dd - 8)) = *((int*) (ss - 8));\n        /* no break */\n        case 4: *((int*) (dd - 4)) = *((int*) (ss - 4));\n            break;\n        case 67: *((int*) (dd - 67)) = *((int*) (ss - 67));\n        /* no break */\n        case 63: *((int*) (dd - 63)) = *((int*) (ss - 63));\n        /* no break */\n        case 59: *((int*) (dd - 59)) = *((int*) (ss - 59));\n        /* no break */\n        case 55: *((int*) (dd - 55)) = *((int*) (ss - 55));\n        /* no break */\n        case 51: *((int*) (dd - 51)) = *((int*) (ss - 51));\n        /* no break */\n        case 47: *((int*) (dd - 47)) = *((int*) (ss - 47));\n        /* no break */\n        case 43: *((int*) (dd - 43)) = *((int*) (ss - 43));\n        /* no break */\n        case 39: *((int*) (dd - 39)) = *((int*) (ss - 39));\n        /* no break */\n        case 35: *((int*) (dd - 35)) = *((int*) (ss - 35));\n        /* no break */\n        case 31: *((int*) (dd - 31)) = *((int*) (ss - 31));\n        /* no break */\n        case 27: *((int*) (dd - 27)) = *((int*) (ss - 27));\n        /* no break */\n        case 23: *((int*) (dd - 23)) = *((int*) (ss - 23));\n        /* no break */\n        case 19: *((int*) (dd - 19)) = *((int*) (ss - 19));\n        /* no break */\n        case 15: *((int*) (dd - 15)) = *((int*) (ss - 15));\n        /* no break */\n        case 11: *((int*) (dd - 11)) = *((int*) (ss - 11));\n        /* no break */\n        case 7: *((int*) (dd - 7)) = *((int*) (ss - 7));\n            *((int*) (dd - 4)) = *((int*) (ss - 4));\n            break;\n        case 3: *((short*) (dd - 3)) = *((short*) (ss - 3));\n            dd[-1] = ss[-1];\n            break;\n        case 66: *((int*) (dd - 66)) = *((int*) (ss - 66));\n        /* no break */\n        case 62: *((int*) (dd - 62)) = *((int*) (ss - 62));\n        /* no break */\n        case 58: *((int*) (dd - 58)) = *((int*) (ss - 58));\n        /* no break */\n        case 54: *((int*) (dd - 54)) = *((int*) (ss - 54));\n        /* no break */\n        case 50: *((int*) (dd - 50)) = *((int*) (ss - 50));\n        /* no break */\n        case 46: *((int*) (dd - 46)) = *((int*) (ss - 46));\n        /* no break */\n        case 42: *((int*) (dd - 42)) = *((int*) (ss - 42));\n        /* no break */\n        case 38: *((int*) (dd - 38)) = *((int*) (ss - 38));\n        /* no break */\n        case 34: *((int*) (dd - 34)) = *((int*) (ss - 34));\n        /* no break */\n        case 30: *((int*) (dd - 30)) = *((int*) (ss - 30));\n        /* no break */\n        case 26: *((int*) (dd - 26)) = *((int*) (ss - 26));\n        /* no break */\n        case 22: *((int*) (dd - 22)) = *((int*) (ss - 22));\n        /* no break */\n        case 18: *((int*) (dd - 18)) = *((int*) (ss - 18));\n        /* no break */\n        case 14: *((int*) (dd - 14)) = *((int*) (ss - 14));\n        /* no break */\n        case 10: *((int*) (dd - 10)) = *((int*) (ss - 10));\n        /* no break */\n        case 6: *((int*) (dd - 6)) = *((int*) (ss - 6));\n        /* no break */\n        case 2: *((short*) (dd - 2)) = *((short*) (ss - 2));\n            break;\n        case 65: *((int*) (dd - 65)) = *((int*) (ss - 65));\n        /* no break */\n        case 61: *((int*) (dd - 61)) = *((int*) (ss - 61));\n        /* no break */\n        case 57: *((int*) (dd - 57)) = *((int*) (ss - 57));\n        /* no break */\n        case 53: *((int*) (dd - 53)) = *((int*) (ss - 53));\n        /* no break */\n        case 49: *((int*) (dd - 49)) = *((int*) (ss - 49));\n        /* no break */\n        case 45: *((int*) (dd - 45)) = *((int*) (ss - 45));\n        /* no break */\n        case 41: *((int*) (dd - 41)) = *((int*) (ss - 41));\n        /* no break */\n        case 37: *((int*) (dd - 37)) = *((int*) (ss - 37));\n        /* no break */\n        case 33: *((int*) (dd - 33)) = *((int*) (ss - 33));\n        /* no break */\n        case 29: *((int*) (dd - 29)) = *((int*) (ss - 29));\n        /* no break */\n        case 25: *((int*) (dd - 25)) = *((int*) (ss - 25));\n        /* no break */\n        case 21: *((int*) (dd - 21)) = *((int*) (ss - 21));\n        /* no break */\n        case 17: *((int*) (dd - 17)) = *((int*) (ss - 17));\n        /* no break */\n        case 13: *((int*) (dd - 13)) = *((int*) (ss - 13));\n        /* no break */\n        case 9: *((int*) (dd - 9)) = *((int*) (ss - 9));\n        /* no break */\n        case 5: *((int*) (dd - 5)) = *((int*) (ss - 5));\n        /* no break */\n        case 1: dd[-1] = ss[-1];\n            break;\n        case 0:\n        default: break;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-502"
        ],
        "project": "swoole-src",
        "commit_id": "4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76",
        "hash": 108920098356654194692466907452384063189,
        "size": 148,
        "message": "add buffer end check"
    },
    {
        "func": "static void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue)\n{\n    zval *data;\n    zend_string *key;\n    zend_ulong index;\n    swPoolstr *swStr = NULL;\n    zend_uchar is_pack = zvalue->u.flags & HASH_FLAG_PACKED;\n\n    ZEND_HASH_FOREACH_KEY_VAL(zvalue, index, key, data)\n    {\n        SBucketType type = {0};\n        type.data_type = Z_TYPE_P(data);\n        //start point\n        size_t p = buffer->offset;\n\n        if (is_pack && zvalue->nNextFreeElement == zvalue->nNumOfElements)\n        {\n            type.key_type = KEY_TYPE_INDEX;\n            type.key_len = 0;\n            SERIA_SET_ENTRY_TYPE(buffer, type);\n        }\n        else\n        {\n            //seria key\n            if (key)\n            {\n                type.key_type = KEY_TYPE_STRING;\n                if ((swStr = swoole_mini_filter_find(key)))\n                {\n                    type.key_len = 3; //means use same string\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    if (swStr->offset & 4)\n                    {\n                        SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);\n                    }\n                    else\n                    {\n                        SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);\n                    }\n                }\n                else\n                {\n                    if (key->len <= 0xff)\n                    {\n                        type.key_len = 1;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 1);\n                        SERIA_SET_ENTRY_TYPE(buffer, key->len);\n                        swoole_string_cpy(buffer, key->val, key->len);\n                    }\n                    else if (key->len <= 0xffff)\n                    {//if more than this  don't need optimize\n                        type.key_len = 2;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 2);\n                        SERIA_SET_ENTRY_SHORT(buffer, key->len);\n                        swoole_string_cpy(buffer, key->val, key->len);\n                    }\n                    else\n                    {\n                        type.key_len = 0;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 3);\n                        swoole_string_cpy(buffer, key + XtOffsetOf(zend_string, len), sizeof (size_t) + key->len);\n                    }\n                }\n            }\n            else\n            {\n                type.key_type = KEY_TYPE_INDEX;\n                if (index <= 0xff)\n                {\n                    type.key_len = 1;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_TYPE(buffer, index);\n                }\n                else if (index <= 0xffff)\n                {\n                    type.key_len = 2;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_SHORT(buffer, index);\n                }\n                else\n                {\n                    type.key_len = 3;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_ULONG(buffer, index);\n                }\n\n            }\n        }\n        //seria data\ntry_again:\n        switch (Z_TYPE_P(data))\n        {\n            case IS_STRING:\n            {\n                if ((swStr = swoole_mini_filter_find(Z_STR_P(data))))\n                {\n                    ((SBucketType*) (buffer->buffer + p))->data_len = 3; //means use same string\n                    if (swStr->offset & 4)\n                    {\n                        SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);\n                    }\n                    else\n                    {\n                        SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);\n                    }\n                }\n                else\n                {\n                    if (Z_STRLEN_P(data) <= 0xff)\n                    {\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 1;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 1);\n                        SERIA_SET_ENTRY_TYPE(buffer, Z_STRLEN_P(data));\n                        swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));\n                    }\n                    else if (Z_STRLEN_P(data) <= 0xffff)\n                    {\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 2;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 2);\n                        SERIA_SET_ENTRY_SHORT(buffer, Z_STRLEN_P(data));\n                        swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));\n                    }\n                    else\n                    {//if more than this  don't need optimize\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 0;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 3);\n                        swoole_string_cpy(buffer, (char*) Z_STR_P(data) + XtOffsetOf(zend_string, len), sizeof (size_t) + Z_STRLEN_P(data));\n                    }\n                }\n                break;\n            }\n            case IS_LONG:\n            {\n                SBucketType* long_type = (SBucketType*) (buffer->buffer + p);\n                swoole_serialize_long(buffer, data, long_type);\n                break;\n            }\n            case IS_DOUBLE:\n                swoole_set_zend_value(buffer, &(data->value));\n                break;\n            case IS_REFERENCE:\n                data = Z_REFVAL_P(data);\n                ((SBucketType*) (buffer->buffer + p))->data_type = Z_TYPE_P(data);\n                goto try_again;\n                break;\n            case IS_ARRAY:\n            {\n                zend_array *ht = Z_ARRVAL_P(data);\n\n                if (GC_IS_RECURSIVE(ht))\n                {\n                    ((SBucketType*) (buffer->buffer + p))->data_type = IS_NULL;//reset type null\n                    php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the array has cycle ref\");\n                }\n                else\n                {\n                    seria_array_type(ht, buffer, p, buffer->offset);\n                    if (ZEND_HASH_APPLY_PROTECTION(ht))\n                    {\n                        GC_PROTECT_RECURSION(ht);\n                        swoole_serialize_arr(buffer, ht);\n                        GC_UNPROTECT_RECURSION(ht);\n                    }\n                    else\n                    {\n                        swoole_serialize_arr(buffer, ht);\n                    }\n\n                }\n                break;\n            }\n                //object propterty table is this type\n            case IS_INDIRECT:\n                data = Z_INDIRECT_P(data);\n                zend_uchar type = Z_TYPE_P(data);\n                ((SBucketType*) (buffer->buffer + p))->data_type = (type == IS_UNDEF ? IS_NULL : type);\n                goto try_again;\n                break;\n            case IS_OBJECT:\n            {\n                /*\n                 * layout\n                 * type | key | namelen | name | bucket len |buckets\n                 */\n                ((SBucketType*) (buffer->buffer + p))->data_type = IS_UNDEF;\n\n                if (ZEND_HASH_APPLY_PROTECTION(Z_OBJPROP_P(data)))\n                {\n                    GC_PROTECT_RECURSION(Z_OBJPROP_P(data));\n                    swoole_serialize_object(buffer, data, p);\n                    GC_UNPROTECT_RECURSION(Z_OBJPROP_P(data));\n                }\n                else\n                {\n                    swoole_serialize_object(buffer, data, p);\n                }\n\n                break;\n            }\n            default://\n                break;\n\n        }\n\n    }\n    ZEND_HASH_FOREACH_END();\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-502"
        ],
        "project": "swoole-src",
        "commit_id": "4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76",
        "hash": 285185724787123411971509614067608333837,
        "size": 210,
        "message": "add buffer end check"
    },
    {
        "func": "static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfElements, long flag)\n{\n    //Initialize zend array\n    zend_ulong h, nIndex, max_index = 0;\n    uint32_t size = cp_zend_hash_check_size(nNumOfElements);\n    if (!size)\n    {\n        return NULL;\n    }\n    if (!buffer)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    ZVAL_NEW_ARR(zvalue);\n    //Initialize buckets\n    zend_array *ht = Z_ARR_P(zvalue);\n    ht->nTableSize = size;\n    ht->nNumUsed = nNumOfElements;\n    ht->nNumOfElements = nNumOfElements;\n    ht->nNextFreeElement = 0;\n#ifdef HASH_FLAG_APPLY_PROTECTION\n    ht->u.flags = HASH_FLAG_APPLY_PROTECTION;\n#endif\n    ht->nTableMask = -(ht->nTableSize);\n    ht->pDestructor = ZVAL_PTR_DTOR;\n\n    GC_SET_REFCOUNT(ht, 1);\n    GC_TYPE_INFO(ht) = IS_ARRAY;\n    // if (ht->nNumUsed)\n    //{\n    //    void *arData = ecalloc(1, len);\n    HT_SET_DATA_ADDR(ht, emalloc(HT_SIZE(ht)));\n    ht->u.flags |= HASH_FLAG_INITIALIZED;\n    int ht_hash_size = HT_HASH_SIZE((ht)->nTableMask);\n    if (ht_hash_size <= 0)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    HT_HASH_RESET(ht);\n    //}\n\n\n    int idx;\n    Bucket *p;\n    for(idx = 0; idx < nNumOfElements; idx++)\n    {\n        if (!buffer)\n        {\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal array unserialize data\");\n            return NULL;\n        }\n        SBucketType type = *((SBucketType*) buffer);\n        buffer += sizeof (SBucketType);\n        p = ht->arData + idx;\n        /* Initialize key */\n        if (type.key_type == KEY_TYPE_STRING)\n        {\n            size_t key_len;\n            if (type.key_len == 3)\n            {//read the same mem\n                void *str_pool_addr = get_pack_string_len_addr(&buffer, &key_len);\n                p->key = zend_string_init((char*) str_pool_addr, key_len, 0);\n                h = zend_inline_hash_func((char*) str_pool_addr, key_len);\n                p->key->h = p->h = h;\n            }\n            else\n            {//move step\n                if (type.key_len == 1)\n                {\n                    key_len = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.key_len == 2)\n                {\n                    key_len = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    key_len = *((size_t*) buffer);\n                    buffer += sizeof (size_t);\n                }\n                p->key = zend_string_init((char*) buffer, key_len, 0);\n                //           h = zend_inline_hash_func((char*) buffer, key_len);\n                h = zend_inline_hash_func((char*) buffer, key_len);\n                buffer += key_len;\n                p->key->h = p->h = h;\n            }\n        }\n        else\n        {\n            if (type.key_len == 0)\n            {\n                //means pack\n                h = p->h = idx;\n                p->key = NULL;\n                max_index = p->h + 1;\n                //                ht->u.flags |= HASH_FLAG_PACKED;\n            }\n            else\n            {\n                if (type.key_len == 1)\n                {\n                    h = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.key_len == 2)\n                {\n                    h = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    h = *((zend_ulong*) buffer);\n                    buffer += sizeof (zend_ulong);\n                }\n                p->h = h;\n                p->key = NULL;\n                if (h >= max_index)\n                {\n                    max_index = h + 1;\n                }\n            }\n        }\n        /* Initialize hash */\n        nIndex = h | ht->nTableMask;\n        Z_NEXT(p->val) = HT_HASH(ht, nIndex);\n        HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\n        /* Initialize data type */\n        p->val.u1.v.type = type.data_type;\n        Z_TYPE_FLAGS(p->val) = 0;\n\n        /* Initialize data */\n        if (type.data_type == IS_STRING)\n        {\n            size_t data_len;\n            if (type.data_len == 3)\n            {//read the same mem\n                void *str_pool_addr = get_pack_string_len_addr(&buffer, &data_len);\n                p->val.value.str = zend_string_init((char*) str_pool_addr, data_len, 0);\n            }\n            else\n            {\n                if (type.data_len == 1)\n                {\n                    data_len = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.data_len == 2)\n                {\n                    data_len = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    data_len = *((size_t*) buffer);\n                    buffer += sizeof (size_t);\n                }\n                p->val.value.str = zend_string_init((char*) buffer, data_len, 0);\n                buffer += data_len;\n            }\n            Z_TYPE_INFO(p->val) = IS_STRING_EX;\n        }\n        else if (type.data_type == IS_ARRAY)\n        {\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            buffer = swoole_unserialize_arr(buffer, &p->val, num, flag);\n        }\n        else if (type.data_type == IS_LONG)\n        {\n            buffer = swoole_unserialize_long(buffer, &p->val, type);\n        }\n        else if (type.data_type == IS_DOUBLE)\n        {\n            p->val.value = *((zend_value*) buffer);\n            buffer += sizeof (zend_value);\n        }\n        else if (type.data_type == IS_UNDEF)\n        {\n            buffer = swoole_unserialize_object(buffer, &p->val, type.data_len, NULL, flag);\n            Z_TYPE_INFO(p->val) = IS_OBJECT_EX;\n        }\n\n    }\n    ht->nNextFreeElement = max_index;\n\n    return buffer;\n\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-502"
        ],
        "project": "swoole-src",
        "commit_id": "4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76",
        "hash": 3560812140245258937539728325930103789,
        "size": 193,
        "message": "add buffer end check"
    },
    {
        "func": "PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)\n{\n    SBucketType type = *(SBucketType*) (buffer);\n    zend_uchar real_type = type.data_type;\n    buffer += sizeof (SBucketType);\n    switch (real_type)\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_LONG:\n            swoole_unserialize_long(buffer, return_value, type);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_DOUBLE:\n            swoole_unserialize_raw(buffer, return_value);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_STRING:\n            len -= sizeof (SBucketType);\n            zend_string *str = swoole_unserialize_string(buffer, len);\n            ZVAL_STR(return_value, str);\n            break;\n        case IS_ARRAY:\n        {\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            if (!swoole_unserialize_arr(buffer, return_value, num, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        }\n        case IS_UNDEF:\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n            return SW_FALSE;\n    }\n\n    return SW_TRUE;\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-502"
        ],
        "project": "swoole-src",
        "commit_id": "4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76",
        "hash": 302526459005259259657976442187091352888,
        "size": 60,
        "message": "add buffer end check"
    },
    {
        "func": "static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag)\n{\n    zval property;\n    uint32_t arr_num = 0;\n    size_t name_len = *((unsigned short*) buffer);\n    if (!name_len)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    buffer += 2;\n    zend_string *class_name;\n    if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS) \n    {\n        class_name = swoole_string_init(ZEND_STRL(\"StdClass\"));\n    } \n    else \n    {\n        class_name = swoole_string_init((char*) buffer, name_len);\n    }\n    buffer += name_len;\n    zend_class_entry *ce = swoole_try_get_ce(class_name);\n    swoole_string_release(class_name);\n\n    if (!ce)\n    {\n        return NULL;\n    }\n\n    buffer = get_array_real_len(buffer, bucket_len, &arr_num);\n    buffer = swoole_unserialize_arr(buffer, &property, arr_num, flag);\n\n    object_init_ex(return_value, ce);\n\n    zval *data,*d;\n    zend_string *key;\n    zend_ulong index;\n\n    \n    ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data)\n    {\n        const char *prop_name, *tmp;\n        size_t prop_len;\n        if (key)\n        {\n\n            if ((d = zend_hash_find(Z_OBJPROP_P(return_value), key)) != NULL)\n            {\n                if (Z_TYPE_P(d) == IS_INDIRECT)\n                {\n                    d = Z_INDIRECT_P(d);\n                }\n                zval_dtor(d);\n                ZVAL_COPY(d, data);\n            }\n            else\n            {\n                zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len);\n                zend_update_property(ce, return_value, prop_name, prop_len, data);\n            }\n//            zend_hash_update(Z_OBJPROP_P(return_value),key,data);\n//            zend_update_property(ce, return_value, ZSTR_VAL(key), ZSTR_LEN(key), data);\n        }\n        else\n        {\n            zend_hash_next_index_insert(Z_OBJPROP_P(return_value), data);\n        }\n    }\n    ZEND_HASH_FOREACH_END();\n    zval_dtor(&property);\n\n    if (ce->constructor)\n    {\n        //        zend_fcall_info fci = {0};\n        //        zend_fcall_info_cache fcc = {0};\n        //        fci.size = sizeof (zend_fcall_info);\n        //        zval retval;\n        //        ZVAL_UNDEF(&fci.function_name);\n        //        fci.retval = &retval;\n        //        fci.param_count = 0;\n        //        fci.params = NULL;\n        //        fci.no_separation = 1;\n        //        fci.object = Z_OBJ_P(return_value);\n        //\n        //        zend_fcall_info_args_ex(&fci, ce->constructor, args);\n        //\n        //        fcc.initialized = 1;\n        //        fcc.function_handler = ce->constructor;\n        //        //        fcc.calling_scope = EG(scope);\n        //        fcc.called_scope = Z_OBJCE_P(return_value);\n        //        fcc.object = Z_OBJ_P(return_value);\n        //\n        //        if (zend_call_function(&fci, &fcc) == FAILURE)\n        //        {\n        //            zend_throw_exception_ex(NULL, 0, \"could not call class constructor\");\n        //        }\n        //        zend_fcall_info_args_clear(&fci, 1);\n    }\n\n\n    //call object __wakeup\n    if (zend_hash_str_exists(&ce->function_table, ZEND_STRL(\"__wakeup\")))\n    {\n        zval ret, wakeup;\n        zend_string *fname = swoole_string_init(ZEND_STRL(\"__wakeup\"));\n        Z_STR(wakeup) = fname;\n        Z_TYPE_INFO(wakeup) = IS_STRING_EX;\n        call_user_function_ex(CG(function_table), return_value, &wakeup, &ret, 0, NULL, 1, NULL);\n        swoole_string_release(fname);\n        zval_ptr_dtor(&ret);\n    }\n\n    return buffer;\n\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-502"
        ],
        "project": "swoole-src",
        "commit_id": "4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76",
        "hash": 9471244567604289362287086484095700814,
        "size": 115,
        "message": "add buffer end check"
    },
    {
        "func": "static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    //user class , do not support incomplete class now\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    // try call unserialize callback and retry lookup\n    zval user_func, args[1], retval;\n\n    /* Check for unserialize callback */\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    \n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n\n    swoole_string_release(fname);\n\n    //user class , do not support incomplete class now\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-502"
        ],
        "project": "swoole-src",
        "commit_id": "4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76",
        "hash": 159072570498175273275838589749895521508,
        "size": 39,
        "message": "add buffer end check"
    },
    {
        "func": "static int php_var_unserialize_internal(UNSERIALIZE_PARAMETER)\n{\n\tconst unsigned char *cursor, *limit, *marker, *start;\n\tzval *rval_ref;\n\n\tlimit = max;\n\tcursor = *p;\n\n\tif (YYCURSOR >= YYLIMIT) {\n\t\treturn 0;\n\t}\n\n\tif (var_hash && (*p)[0] != 'R') {\n\t\tvar_push(var_hash, rval);\n\t}\n\n\tstart = cursor;\n\n\n#line 554 \"ext/standard/var_unserializer.c\"\n{\n\tYYCTYPE yych;\n\tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t128, 128, 128, 128, 128, 128, 128, 128, \n\t\t128, 128,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n\tyych = *YYCURSOR;\n\tswitch (yych) {\n\tcase 'C':\n\tcase 'O':\tgoto yy13;\n\tcase 'N':\tgoto yy5;\n\tcase 'R':\tgoto yy2;\n\tcase 'S':\tgoto yy10;\n\tcase 'a':\tgoto yy11;\n\tcase 'b':\tgoto yy6;\n\tcase 'd':\tgoto yy8;\n\tcase 'i':\tgoto yy7;\n\tcase 'o':\tgoto yy12;\n\tcase 'r':\tgoto yy4;\n\tcase 's':\tgoto yy9;\n\tcase '}':\tgoto yy14;\n\tdefault:\tgoto yy16;\n\t}\nyy2:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy95;\nyy3:\n#line 884 \"ext/standard/var_unserializer.re\"\n\t{ return 0; }\n#line 580 \"ext/standard/var_unserializer.c\"\nyy4:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy89;\n\tgoto yy3;\nyy5:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy87;\n\tgoto yy3;\nyy6:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy83;\n\tgoto yy3;\nyy7:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy77;\n\tgoto yy3;\nyy8:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy53;\n\tgoto yy3;\nyy9:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy46;\n\tgoto yy3;\nyy10:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy39;\n\tgoto yy3;\nyy11:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy32;\n\tgoto yy3;\nyy12:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy25;\n\tgoto yy3;\nyy13:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy17;\n\tgoto yy3;\nyy14:\n\t++YYCURSOR;\n#line 878 \"ext/standard/var_unserializer.re\"\n\t{\n\t/* this is the case where we have less data than planned */\n\tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n\treturn 0; /* not sure if it should be 0 or 1 here? */\n}\n#line 629 \"ext/standard/var_unserializer.c\"\nyy16:\n\tyych = *++YYCURSOR;\n\tgoto yy3;\nyy17:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tif (yych == '+') goto yy19;\nyy18:\n\tYYCURSOR = YYMARKER;\n\tgoto yy3;\nyy19:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tgoto yy18;\nyy20:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tif (yych != ':') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 733 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, len2, len3, maxlen;\n\tzend_long elements;\n\tchar *str;\n\tzend_string *class_name;\n\tzend_class_entry *ce;\n\tint incomplete_class = 0;\n\n\tint custom_object = 0;\n\n\tzval user_func;\n\tzval retval;\n\tzval args[1];\n\n    if (!var_hash) return 0;\n\tif (*start == 'C') {\n\t\tcustom_object = 1;\n\t}\n\n\tlen2 = len = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len || len == 0) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tstr = (char*)YYCURSOR;\n\n\tYYCURSOR += len;\n\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\tif (*(YYCURSOR+1) != ':') {\n\t\t*p = YYCURSOR+1;\n\t\treturn 0;\n\t}\n\n\tlen3 = strspn(str, \"0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\\");\n\tif (len3 != len)\n\t{\n\t\t*p = YYCURSOR + len3 - len;\n\t\treturn 0;\n\t}\n\n\tclass_name = zend_string_init(str, len, 0);\n\n\tdo {\n\t\tif(!unserialize_allowed_class(class_name, classes)) {\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Try to find class directly */\n\t\tBG(serialize_lock)++;\n\t\tce = zend_lookup_class(class_name);\n\t\tif (ce) {\n\t\t\tBG(serialize_lock)--;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_string_release(class_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tBG(serialize_lock)--;\n\n\t\tif (EG(exception)) {\n\t\t\tzend_string_release(class_name);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Check for unserialize callback */\n\t\tif ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0')) {\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Call unserialize callback */\n\t\tZVAL_STRING(&user_func, PG(unserialize_callback_func));\n\n\t\tZVAL_STR_COPY(&args[0], class_name);\n\t\tBG(serialize_lock)++;\n\t\tif (call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL) != SUCCESS) {\n\t\t\tBG(serialize_lock)--;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_string_release(class_name);\n\t\t\t\tzval_ptr_dtor(&user_func);\n\t\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tphp_error_docref(NULL, E_WARNING, \"defined (%s) but not found\", Z_STRVAL(user_func));\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tzval_ptr_dtor(&user_func);\n\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\tbreak;\n\t\t}\n\t\tBG(serialize_lock)--;\n\t\tzval_ptr_dtor(&retval);\n\t\tif (EG(exception)) {\n\t\t\tzend_string_release(class_name);\n\t\t\tzval_ptr_dtor(&user_func);\n\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* The callback function may have defined the class */\n\t\tif ((ce = zend_lookup_class(class_name)) == NULL) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Function %s() hasn't defined the class it was called for\", Z_STRVAL(user_func));\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t}\n\n\t\tzval_ptr_dtor(&user_func);\n\t\tzval_ptr_dtor(&args[0]);\n\t\tbreak;\n\t} while (1);\n\n\t*p = YYCURSOR;\n\n\tif (custom_object) {\n\t\tint ret;\n\n\t\tret = object_custom(UNSERIALIZE_PASSTHRU, ce);\n\n\t\tif (ret && incomplete_class) {\n\t\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n\t\t}\n\t\tzend_string_release(class_name);\n\t\treturn ret;\n\t}\n\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ce);\n\n\tif (incomplete_class) {\n\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n\t}\n\tzend_string_release(class_name);\n\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 804 \"ext/standard/var_unserializer.c\"\nyy25:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy26;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy27;\n\t\tgoto yy18;\n\t}\nyy26:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy27:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy27;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 726 \"ext/standard/var_unserializer.re\"\n\t{\n    if (!var_hash) return 0;\n\n\treturn object_common2(UNSERIALIZE_PASSTHRU,\n\t\t\tobject_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR));\n}\n#line 836 \"ext/standard/var_unserializer.c\"\nyy32:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy33;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tgoto yy18;\nyy33:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy34:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '{') goto yy18;\n\t++YYCURSOR;\n#line 702 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements = parse_iv(start + 2);\n\t/* use iv() not uiv() in order to check data range */\n\t*p = YYCURSOR;\n    if (!var_hash) return 0;\n\n\tif (elements < 0) {\n\t\treturn 0;\n\t}\n\n\tarray_init_size(rval, elements);\n\tif (elements) {\n\t\t/* we can't convert from packed to hash during unserialization, because\n\t\t   reference to some zvals might be keept in var_hash (to support references) */\n\t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}\n#line 881 \"ext/standard/var_unserializer.c\"\nyy39:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy40;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy41;\n\tgoto yy18;\nyy40:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy41:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy41;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 668 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tzend_string *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR) != '\"') {\n\t\tzend_string_free(str);\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\tefree(str);\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STR(rval, str);\n\treturn 1;\n}\n#line 936 \"ext/standard/var_unserializer.c\"\nyy46:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy47;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy48;\n\tgoto yy18;\nyy47:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy48:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy48;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 636 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tchar *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tstr = (char*)YYCURSOR;\n\n\tYYCURSOR += len;\n\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STRINGL(rval, str, len);\n\treturn 1;\n}\n#line 989 \"ext/standard/var_unserializer.c\"\nyy53:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych <= ',') {\n\t\t\tif (yych == '+') goto yy57;\n\t\t\tgoto yy18;\n\t\t} else {\n\t\t\tif (yych <= '-') goto yy55;\n\t\t\tif (yych <= '.') goto yy60;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'I') {\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tif (yych <= 'H') goto yy18;\n\t\t\tgoto yy56;\n\t\t} else {\n\t\t\tif (yych != 'N') goto yy18;\n\t\t}\n\t}\n\tyych = *++YYCURSOR;\n\tif (yych == 'A') goto yy76;\n\tgoto yy18;\nyy55:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych == '.') goto yy60;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '9') goto yy58;\n\t\tif (yych != 'I') goto yy18;\n\t}\nyy56:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy72;\n\tgoto yy18;\nyy57:\n\tyych = *++YYCURSOR;\n\tif (yych == '.') goto yy60;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy58:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ':') {\n\t\tif (yych <= '.') {\n\t\t\tif (yych <= '-') goto yy18;\n\t\t\tgoto yy70;\n\t\t} else {\n\t\t\tif (yych <= '/') goto yy18;\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= ';') goto yy63;\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy60:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy61:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy61;\n\t\tif (yych <= ':') goto yy18;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy63:\n\t++YYCURSOR;\n#line 627 \"ext/standard/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\nuse_double:\n#endif\n\t*p = YYCURSOR;\n\tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n\treturn 1;\n}\n#line 1086 \"ext/standard/var_unserializer.c\"\nyy65:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy66;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy67;\n\t\tgoto yy18;\n\t}\nyy66:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy69;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy69;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych >= ':') goto yy18;\n\t}\nyy67:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy67;\n\tif (yych == ';') goto yy63;\n\tgoto yy18;\nyy69:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy67;\n\tgoto yy18;\nyy70:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy70;\n\t\tif (yych <= ':') goto yy18;\n\t\tgoto yy63;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy72:\n\tyych = *++YYCURSOR;\n\tif (yych != 'F') goto yy18;\nyy73:\n\tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 611 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n\t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_inf());\n\t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {\n\t\tZVAL_DOUBLE(rval, -php_get_inf());\n\t} else {\n\t\tZVAL_NULL(rval);\n\t}\n\n\treturn 1;\n}\n#line 1161 \"ext/standard/var_unserializer.c\"\nyy76:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy73;\n\tgoto yy18;\nyy77:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy78;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy79;\n\t\tgoto yy18;\n\t}\nyy78:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy79:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy79;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 585 \"ext/standard/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\n\tint digits = YYCURSOR - start - 3;\n\n\tif (start[2] == '-' || start[2] == '+') {\n\t\tdigits--;\n\t}\n\n\t/* Use double for large zend_long values that were serialized on a 64-bit system */\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n\n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n\t\t\t\tgoto use_double;\n\t\t\t}\n\t\t} else {\n\t\t\tgoto use_double;\n\t\t}\n\t}\n#endif\n\t*p = YYCURSOR;\n\tZVAL_LONG(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1214 \"ext/standard/var_unserializer.c\"\nyy83:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= '2') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 579 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1228 \"ext/standard/var_unserializer.c\"\nyy87:\n\t++YYCURSOR;\n#line 573 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_NULL(rval);\n\treturn 1;\n}\n#line 1237 \"ext/standard/var_unserializer.c\"\nyy89:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy90;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy91;\n\t\tgoto yy18;\n\t}\nyy90:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy91:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy91;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 548 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (rval_ref == rval) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n\t}\n\n\tZVAL_COPY(rval, rval_ref);\n\n\treturn 1;\n}\n#line 1285 \"ext/standard/var_unserializer.c\"\nyy95:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy96;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy97;\n\t\tgoto yy18;\n\t}\nyy96:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy97:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy97;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 522 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tzval_ptr_dtor(rval);\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n\t}\n\tif (Z_ISREF_P(rval_ref)) {\n\t\tZVAL_COPY(rval, rval_ref);\n\t} else {\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n\t\tZVAL_COPY(rval, rval_ref);\n\t}\n\n\treturn 1;\n}\n#line 1334 \"ext/standard/var_unserializer.c\"\n}\n#line 886 \"ext/standard/var_unserializer.re\"\n\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-502"
        ],
        "project": "php-src",
        "commit_id": "20ce2fe8e3c211a42fee05a461a5881be9a8790e",
        "hash": 85445687196252319799392122779740934817,
        "size": 842,
        "message": "Fix bug #72663 - destroy broken object when unserializing\n\n(cherry picked from commit 448c9be157f4147e121f1a2a524536c75c9c6059)"
    },
    {
        "func": "xmlDtdDumpOutput(xmlSaveCtxtPtr ctxt, xmlDtdPtr dtd) {\n    xmlOutputBufferPtr buf;\n    int format, level;\n    xmlDocPtr doc;\n\n    if (dtd == NULL) return;\n    if ((ctxt == NULL) || (ctxt->buf == NULL))\n        return;\n    buf = ctxt->buf;\n    xmlOutputBufferWrite(buf, 10, \"<!DOCTYPE \");\n    xmlOutputBufferWriteString(buf, (const char *)dtd->name);\n    if (dtd->ExternalID != NULL) {\n\txmlOutputBufferWrite(buf, 8, \" PUBLIC \");\n\txmlBufWriteQuotedString(buf->buffer, dtd->ExternalID);\n\txmlOutputBufferWrite(buf, 1, \" \");\n\txmlBufWriteQuotedString(buf->buffer, dtd->SystemID);\n    }  else if (dtd->SystemID != NULL) {\n\txmlOutputBufferWrite(buf, 8, \" SYSTEM \");\n\txmlBufWriteQuotedString(buf->buffer, dtd->SystemID);\n    }\n    if ((dtd->entities == NULL) && (dtd->elements == NULL) &&\n        (dtd->attributes == NULL) && (dtd->notations == NULL) &&\n\t(dtd->pentities == NULL)) {\n\txmlOutputBufferWrite(buf, 1, \">\");\n\treturn;\n    }\n    xmlOutputBufferWrite(buf, 3, \" [\\n\");\n    /*\n     * Dump the notations first they are not in the DTD children list\n     * Do this only on a standalone DTD or on the internal subset though.\n     */\n    if ((dtd->notations != NULL) && ((dtd->doc == NULL) ||\n        (dtd->doc->intSubset == dtd))) {\n        xmlBufDumpNotationTable(buf->buffer,\n                                (xmlNotationTablePtr) dtd->notations);\n    }\n    format = ctxt->format;\n    level = ctxt->level;\n    doc = ctxt->doc;\n    ctxt->format = 0;\n    ctxt->level = -1;\n    ctxt->doc = dtd->doc;\n    xmlNodeListDumpOutput(ctxt, dtd->children);\n    ctxt->format = format;\n    ctxt->level = level;\n    ctxt->doc = doc;\n    xmlOutputBufferWrite(buf, 2, \"]>\");\n}",
        "target": 0,
        "cwe": [
            "CWE-502"
        ],
        "project": "libxml2",
        "commit_id": "c97750d11bb8b6f3303e7131fe526a61ac65bcfd",
        "hash": 173633235495072400608767747680405442185,
        "size": 48,
        "message": "Avoid an out of bound access when serializing malformed strings\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=766414\n\n* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value\n  is not UTF-8 be more careful when serializing it as we may do an\n  out of bound access as a result."
    },
    {
        "func": "xmlNsDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlNsPtr cur) {\n    xmlNsDumpOutput(ctxt->buf, cur, ctxt);\n}",
        "target": 0,
        "cwe": [
            "CWE-502"
        ],
        "project": "libxml2",
        "commit_id": "c97750d11bb8b6f3303e7131fe526a61ac65bcfd",
        "hash": 327485752435392517914859156191502908946,
        "size": 3,
        "message": "Avoid an out of bound access when serializing malformed strings\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=766414\n\n* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value\n  is not UTF-8 be more careful when serializing it as we may do an\n  out of bound access as a result."
    },
    {
        "func": "xmlDocDumpMemoryEnc(xmlDocPtr out_doc, xmlChar **doc_txt_ptr,\n\t            int * doc_txt_len, const char * txt_encoding) {\n    xmlDocDumpFormatMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len,\n\t                      txt_encoding, 0);\n}",
        "target": 0,
        "cwe": [
            "CWE-502"
        ],
        "project": "libxml2",
        "commit_id": "c97750d11bb8b6f3303e7131fe526a61ac65bcfd",
        "hash": 275434947370723175725370301994833582053,
        "size": 5,
        "message": "Avoid an out of bound access when serializing malformed strings\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=766414\n\n* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value\n  is not UTF-8 be more careful when serializing it as we may do an\n  out of bound access as a result."
    },
    {
        "func": "xmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size) {\n    xmlDocDumpFormatMemoryEnc(cur, mem, size, NULL, 0);\n}",
        "target": 0,
        "cwe": [
            "CWE-502"
        ],
        "project": "libxml2",
        "commit_id": "c97750d11bb8b6f3303e7131fe526a61ac65bcfd",
        "hash": 330049722521896373424370009918274104493,
        "size": 3,
        "message": "Avoid an out of bound access when serializing malformed strings\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=766414\n\n* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value\n  is not UTF-8 be more careful when serializing it as we may do an\n  out of bound access as a result."
    },
    {
        "func": "xmlEscapeEntities(unsigned char* out, int *outlen,\n                 const xmlChar* in, int *inlen) {\n    unsigned char* outstart = out;\n    const unsigned char* base = in;\n    unsigned char* outend = out + *outlen;\n    const unsigned char* inend;\n    int val;\n\n    inend = in + (*inlen);\n\n    while ((in < inend) && (out < outend)) {\n\tif (*in == '<') {\n\t    if (outend - out < 4) break;\n\t    *out++ = '&';\n\t    *out++ = 'l';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t    in++;\n\t    continue;\n\t} else if (*in == '>') {\n\t    if (outend - out < 4) break;\n\t    *out++ = '&';\n\t    *out++ = 'g';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t    in++;\n\t    continue;\n\t} else if (*in == '&') {\n\t    if (outend - out < 5) break;\n\t    *out++ = '&';\n\t    *out++ = 'a';\n\t    *out++ = 'm';\n\t    *out++ = 'p';\n\t    *out++ = ';';\n\t    in++;\n\t    continue;\n\t} else if (((*in >= 0x20) && (*in < 0x80)) ||\n\t           (*in == '\\n') || (*in == '\\t')) {\n\t    /*\n\t     * default case, just copy !\n\t     */\n\t    *out++ = *in++;\n\t    continue;\n\t} else if (*in >= 0x80) {\n\t    /*\n\t     * We assume we have UTF-8 input.\n\t     */\n\t    if (outend - out < 11) break;\n\n\t    if (*in < 0xC0) {\n\t\txmlSaveErr(XML_SAVE_NOT_UTF8, NULL, NULL);\n\t\tin++;\n\t\tgoto error;\n\t    } else if (*in < 0xE0) {\n\t\tif (inend - in < 2) break;\n\t\tval = (in[0]) & 0x1F;\n\t\tval <<= 6;\n\t\tval |= (in[1]) & 0x3F;\n\t\tin += 2;\n\t    } else if (*in < 0xF0) {\n\t\tif (inend - in < 3) break;\n\t\tval = (in[0]) & 0x0F;\n\t\tval <<= 6;\n\t\tval |= (in[1]) & 0x3F;\n\t\tval <<= 6;\n\t\tval |= (in[2]) & 0x3F;\n\t\tin += 3;\n\t    } else if (*in < 0xF8) {\n\t\tif (inend - in < 4) break;\n\t\tval = (in[0]) & 0x07;\n\t\tval <<= 6;\n\t\tval |= (in[1]) & 0x3F;\n\t\tval <<= 6;\n\t\tval |= (in[2]) & 0x3F;\n\t\tval <<= 6;\n\t\tval |= (in[3]) & 0x3F;\n\t\tin += 4;\n\t    } else {\n\t\txmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);\n\t\tin++;\n\t\tgoto error;\n\t    }\n\t    if (!IS_CHAR(val)) {\n\t\txmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);\n\t\tin++;\n\t\tgoto error;\n\t    }\n\n\t    /*\n\t     * We could do multiple things here. Just save as a char ref\n\t     */\n\t    out = xmlSerializeHexCharRef(out, val);\n\t} else if (IS_BYTE_CHAR(*in)) {\n\t    if (outend - out < 6) break;\n\t    out = xmlSerializeHexCharRef(out, *in++);\n\t} else {\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlEscapeEntities : char out of range\\n\");\n\t    in++;\n\t    goto error;\n\t}\n    }\n    *outlen = out - outstart;\n    *inlen = in - base;\n    return(0);\nerror:\n    *outlen = out - outstart;\n    *inlen = in - base;\n    return(-1);\n}",
        "target": 0,
        "cwe": [
            "CWE-502"
        ],
        "project": "libxml2",
        "commit_id": "c97750d11bb8b6f3303e7131fe526a61ac65bcfd",
        "hash": 169496431677785860864381272192388630335,
        "size": 110,
        "message": "Avoid an out of bound access when serializing malformed strings\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=766414\n\n* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value\n  is not UTF-8 be more careful when serializing it as we may do an\n  out of bound access as a result."
    },
    {
        "func": "xmlAttrDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {\n    xmlOutputBufferPtr buf;\n\n    if (cur == NULL) return;\n    buf = ctxt->buf;\n    if (buf == NULL) return;\n    if (ctxt->format == 2)\n        xmlOutputBufferWriteWSNonSig(ctxt, 2);\n    else\n        xmlOutputBufferWrite(buf, 1, \" \");\n    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);\n\txmlOutputBufferWrite(buf, 1, \":\");\n    }\n    xmlOutputBufferWriteString(buf, (const char *)cur->name);\n    xmlOutputBufferWrite(buf, 2, \"=\\\"\");\n    xmlAttrSerializeContent(buf, cur);\n    xmlOutputBufferWrite(buf, 1, \"\\\"\");\n}",
        "target": 0,
        "cwe": [
            "CWE-502"
        ],
        "project": "libxml2",
        "commit_id": "c97750d11bb8b6f3303e7131fe526a61ac65bcfd",
        "hash": 293285782559540989433822783444439924510,
        "size": 19,
        "message": "Avoid an out of bound access when serializing malformed strings\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=766414\n\n* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value\n  is not UTF-8 be more careful when serializing it as we may do an\n  out of bound access as a result."
    },
    {
        "func": "struct sctp_transport *sctp_assoc_add_peer(struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_addr *addr,\n\t\t\t\t\t   const gfp_t gfp,\n\t\t\t\t\t   const int peer_state)\n{\n\tstruct sctp_transport *peer;\n\tstruct sctp_sock *sp;\n\tunsigned short port;\n\n\tsp = sctp_sk(asoc->base.sk);\n\n\t/* AF_INET and AF_INET6 share common port field. */\n\tport = ntohs(addr->v4.sin_port);\n\n\tSCTP_DEBUG_PRINTK_IPADDR(\"sctp_assoc_add_peer:association %p addr: \",\n\t\t\t\t \" port: %d state:%d\\n\",\n\t\t\t\t asoc,\n\t\t\t\t addr,\n\t\t\t\t port,\n\t\t\t\t peer_state);\n\n\t/* Set the port if it has not been set yet.  */\n\tif (0 == asoc->peer.port)\n\t\tasoc->peer.port = port;\n\n\t/* Check to see if this is a duplicate. */\n\tpeer = sctp_assoc_lookup_paddr(asoc, addr);\n\tif (peer) {\n\t\tif (peer->state == SCTP_UNKNOWN) {\n\t\t\tif (peer_state == SCTP_ACTIVE)\n\t\t\t\tpeer->state = SCTP_ACTIVE;\n\t\t\tif (peer_state == SCTP_UNCONFIRMED)\n\t\t\t\tpeer->state = SCTP_UNCONFIRMED;\n\t\t}\n\t\treturn peer;\n\t}\n\n\tpeer = sctp_transport_new(addr, gfp);\n\tif (!peer)\n\t\treturn NULL;\n\n\tsctp_transport_set_owner(peer, asoc);\n\n\t/* Initialize the peer's heartbeat interval based on the\n\t * association configured value.\n\t */\n\tpeer->hbinterval = asoc->hbinterval;\n\n\t/* Set the path max_retrans.  */\n\tpeer->pathmaxrxt = asoc->pathmaxrxt;\n\n\t/* Initialize the peer's SACK delay timeout based on the\n\t * association configured value.\n\t */\n\tpeer->sackdelay = asoc->sackdelay;\n\tpeer->sackfreq = asoc->sackfreq;\n\n\t/* Enable/disable heartbeat, SACK delay, and path MTU discovery\n\t * based on association setting.\n\t */\n\tpeer->param_flags = asoc->param_flags;\n\n\t/* Initialize the pmtu of the transport. */\n\tif (peer->param_flags & SPP_PMTUD_ENABLE)\n\t\tsctp_transport_pmtu(peer);\n\telse if (asoc->pathmtu)\n\t\tpeer->pathmtu = asoc->pathmtu;\n\telse\n\t\tpeer->pathmtu = SCTP_DEFAULT_MAXSEGMENT;\n\n\t/* If this is the first transport addr on this association,\n\t * initialize the association PMTU to the peer's PMTU.\n\t * If not and the current association PMTU is higher than the new\n\t * peer's PMTU, reset the association PMTU to the new peer's PMTU.\n\t */\n\tif (asoc->pathmtu)\n\t\tasoc->pathmtu = min_t(int, peer->pathmtu, asoc->pathmtu);\n\telse\n\t\tasoc->pathmtu = peer->pathmtu;\n\n\tSCTP_DEBUG_PRINTK(\"sctp_assoc_add_peer:association %p PMTU set to \"\n\t\t\t  \"%d\\n\", asoc, asoc->pathmtu);\n\tpeer->pmtu_pending = 0;\n\n\tasoc->frag_point = sctp_frag_point(sp, asoc->pathmtu);\n\n\t/* The asoc->peer.port might not be meaningful yet, but\n\t * initialize the packet structure anyway.\n\t */\n\tsctp_packet_init(&peer->packet, peer, asoc->base.bind_addr.port,\n\t\t\t asoc->peer.port);\n\n\t/* 7.2.1 Slow-Start\n\t *\n\t * o The initial cwnd before DATA transmission or after a sufficiently\n\t *   long idle period MUST be set to\n\t *      min(4*MTU, max(2*MTU, 4380 bytes))\n\t *\n\t * o The initial value of ssthresh MAY be arbitrarily high\n\t *   (for example, implementations MAY use the size of the\n\t *   receiver advertised window).\n\t */\n\tpeer->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));\n\n\t/* At this point, we may not have the receiver's advertised window,\n\t * so initialize ssthresh to the default value and it will be set\n\t * later when we process the INIT.\n\t */\n\tpeer->ssthresh = SCTP_DEFAULT_MAXWINDOW;\n\n\tpeer->partial_bytes_acked = 0;\n\tpeer->flight_size = 0;\n\n\t/* Set the transport's RTO.initial value */\n\tpeer->rto = asoc->rto_initial;\n\n\t/* Set the peer's active state. */\n\tpeer->state = peer_state;\n\n\t/* Attach the remote transport to our asoc.  */\n\tlist_add_tail(&peer->transports, &asoc->peer.transport_addr_list);\n\tasoc->peer.transport_count++;\n\n\t/* If we do not yet have a primary path, set one.  */\n\tif (!asoc->peer.primary_path) {\n\t\tsctp_assoc_set_primary(asoc, peer);\n\t\tasoc->peer.retran_path = peer;\n\t}\n\n\tif (asoc->peer.active_path == asoc->peer.retran_path) {\n\t\tasoc->peer.retran_path = peer;\n\t}\n\n\treturn peer;\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "linux-2.6",
        "commit_id": "add52379dde2e5300e2d574b172e62c6cf43b3d3",
        "hash": 254469762198362921631583286657499741004,
        "size": 135,
        "message": "sctp: Fix oops when INIT-ACK indicates that peer doesn't support AUTH\n\nIf INIT-ACK is received with SupportedExtensions parameter which\nindicates that the peer does not support AUTH, the packet will be\nsilently ignore, and sctp_process_init() do cleanup all of the\ntransports in the association.\nWhen T1-Init timer is expires, OOPS happen while we try to choose\na different init transport.\n\nThe solution is to only clean up the non-active transports, i.e\nthe ones that the peer added.  However, that introduces a problem\nwith sctp_connectx(), because we don't mark the proper state for\nthe transports provided by the user.  So, we'll simply mark\nuser-provided transports as ACTIVE.  That will allow INIT\nretransmissions to work properly in the sctp_connectx() context\nand prevent the crash.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "int sctp_process_init(struct sctp_association *asoc, sctp_cid_t cid,\n\t\t      const union sctp_addr *peer_addr,\n\t\t      sctp_init_chunk_t *peer_init, gfp_t gfp)\n{\n\tunion sctp_params param;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tchar *cookie;\n\n\t/* We must include the address that the INIT packet came from.\n\t * This is the only address that matters for an INIT packet.\n\t * When processing a COOKIE ECHO, we retrieve the from address\n\t * of the INIT from the cookie.\n\t */\n\n\t/* This implementation defaults to making the first transport\n\t * added as the primary transport.  The source address seems to\n\t * be a a better choice than any of the embedded addresses.\n\t */\n\tif (peer_addr) {\n\t\tif(!sctp_assoc_add_peer(asoc, peer_addr, gfp, SCTP_ACTIVE))\n\t\t\tgoto nomem;\n\t}\n\n\t/* Process the initialization parameters.  */\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\n\t\tif (!sctp_process_param(asoc, param, peer_addr, gfp))\n\t\t\tgoto clean_up;\n\t}\n\n\t/* AUTH: After processing the parameters, make sure that we\n\t * have all the required info to potentially do authentications.\n\t */\n\tif (asoc->peer.auth_capable && (!asoc->peer.peer_random ||\n\t\t\t\t\t!asoc->peer.peer_hmacs))\n\t\tasoc->peer.auth_capable = 0;\n\n\t/* In a non-backward compatible mode, if the peer claims\n\t * support for ADD-IP but not AUTH,  the ADD-IP spec states\n\t * that we MUST ABORT the association. Section 6.  The section\n\t * also give us an option to silently ignore the packet, which\n\t * is what we'll do here.\n\t */\n\tif (!sctp_addip_noauth &&\n\t     (asoc->peer.asconf_capable && !asoc->peer.auth_capable)) {\n\t\tasoc->peer.addip_disabled_mask |= (SCTP_PARAM_ADD_IP |\n\t\t\t\t\t\t  SCTP_PARAM_DEL_IP |\n\t\t\t\t\t\t  SCTP_PARAM_SET_PRIMARY);\n\t\tasoc->peer.asconf_capable = 0;\n\t\tgoto clean_up;\n\t}\n\n\t/* Walk list of transports, removing transports in the UNKNOWN state. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state == SCTP_UNKNOWN) {\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t}\n\t}\n\n\t/* The fixed INIT headers are always in network byte\n\t * order.\n\t */\n\tasoc->peer.i.init_tag =\n\t\tntohl(peer_init->init_hdr.init_tag);\n\tasoc->peer.i.a_rwnd =\n\t\tntohl(peer_init->init_hdr.a_rwnd);\n\tasoc->peer.i.num_outbound_streams =\n\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\tasoc->peer.i.num_inbound_streams =\n\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\tasoc->peer.i.initial_tsn =\n\t\tntohl(peer_init->init_hdr.initial_tsn);\n\n\t/* Apply the upper bounds for output streams based on peer's\n\t * number of inbound streams.\n\t */\n\tif (asoc->c.sinit_num_ostreams  >\n\t    ntohs(peer_init->init_hdr.num_inbound_streams)) {\n\t\tasoc->c.sinit_num_ostreams =\n\t\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\t}\n\n\tif (asoc->c.sinit_max_instreams >\n\t    ntohs(peer_init->init_hdr.num_outbound_streams)) {\n\t\tasoc->c.sinit_max_instreams =\n\t\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\t}\n\n\t/* Copy Initiation tag from INIT to VT_peer in cookie.   */\n\tasoc->c.peer_vtag = asoc->peer.i.init_tag;\n\n\t/* Peer Rwnd   : Current calculated value of the peer's rwnd.  */\n\tasoc->peer.rwnd = asoc->peer.i.a_rwnd;\n\n\t/* Copy cookie in case we need to resend COOKIE-ECHO. */\n\tcookie = asoc->peer.cookie;\n\tif (cookie) {\n\t\tasoc->peer.cookie = kmemdup(cookie, asoc->peer.cookie_len, gfp);\n\t\tif (!asoc->peer.cookie)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* RFC 2960 7.2.1 The initial value of ssthresh MAY be arbitrarily\n\t * high (for example, implementations MAY use the size of the receiver\n\t * advertised window).\n\t */\n\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\ttransport->ssthresh = asoc->peer.i.a_rwnd;\n\t}\n\n\t/* Set up the TSN tracking pieces.  */\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_SIZE,\n\t\t\t asoc->peer.i.initial_tsn);\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * The stream sequence number in all the streams shall start\n\t * from 0 when the association is established.  Also, when the\n\t * stream sequence number reaches the value 65535 the next\n\t * stream sequence number shall be set to 0.\n\t */\n\n\t/* Allocate storage for the negotiated streams if it is not a temporary\n\t * association.\n\t */\n\tif (!asoc->temp) {\n\t\tint error;\n\n\t\tasoc->ssnmap = sctp_ssnmap_new(asoc->c.sinit_max_instreams,\n\t\t\t\t\t       asoc->c.sinit_num_ostreams, gfp);\n\t\tif (!asoc->ssnmap)\n\t\t\tgoto clean_up;\n\n\t\terror = sctp_assoc_set_id(asoc, gfp);\n\t\tif (error)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* ADDIP Section 4.1 ASCONF Chunk Procedures\n\t *\n\t * When an endpoint has an ASCONF signaled change to be sent to the\n\t * remote endpoint it should do the following:\n\t * ...\n\t * A2) A serial number should be assigned to the Chunk. The serial\n\t * number should be a monotonically increasing number. All serial\n\t * numbers are defined to be initialized at the start of the\n\t * association to the same value as the Initial TSN.\n\t */\n\tasoc->peer.addip_serial = asoc->peer.i.initial_tsn - 1;\n\treturn 1;\n\nclean_up:\n\t/* Release the transport structures. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_init(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\n\tasoc->peer.transport_count = 0;\n\nnomem:\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "linux-2.6",
        "commit_id": "add52379dde2e5300e2d574b172e62c6cf43b3d3",
        "hash": 305211551040565709564271610567068325470,
        "size": 167,
        "message": "sctp: Fix oops when INIT-ACK indicates that peer doesn't support AUTH\n\nIf INIT-ACK is received with SupportedExtensions parameter which\nindicates that the peer does not support AUTH, the packet will be\nsilently ignore, and sctp_process_init() do cleanup all of the\ntransports in the association.\nWhen T1-Init timer is expires, OOPS happen while we try to choose\na different init transport.\n\nThe solution is to only clean up the non-active transports, i.e\nthe ones that the peer added.  However, that introduces a problem\nwith sctp_connectx(), because we don't mark the proper state for\nthe transports provided by the user.  So, we'll simply mark\nuser-provided transports as ACTIVE.  That will allow INIT\nretransmissions to work properly in the sctp_connectx() context\nand prevent the crash.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static void krb5_save_ccname_done(struct tevent_req *req)\n{\n    struct krb5_auth_state *state = tevent_req_data(req, struct krb5_auth_state);\n    struct krb5child_req *kr = state->kr;\n    struct pam_data *pd = state->pd;\n    int ret;\n    char *password = NULL;\n\n    if (kr->is_offline) {\n        if (dp_opt_get_bool(kr->krb5_ctx->opts,KRB5_STORE_PASSWORD_IF_OFFLINE)) {\n            krb5_pam_handler_cache_auth_step(req);\n            return;\n        }\n\n        DEBUG(4, (\"Backend is marked offline, retry later!\\n\"));\n        state->pam_status = PAM_AUTHINFO_UNAVAIL;\n        state->dp_err = DP_ERR_OFFLINE;\n        ret = EOK;\n        goto done;\n    }\n\n    if (state->be_ctx->domain->cache_credentials == TRUE) {\n\n        /* password caching failures are not fatal errors */\n        state->pam_status = PAM_SUCCESS;\n        state->dp_err = DP_ERR_OK;\n\n        switch(pd->cmd) {\n            case SSS_PAM_AUTHENTICATE:\n            case SSS_CMD_RENEW:\n            case SSS_PAM_CHAUTHTOK_PRELIM:\n                password = talloc_size(state, pd->authtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->authtok, pd->authtok_size);\n                    password[pd->authtok_size] = '\\0';\n                }\n                break;\n            case SSS_PAM_CHAUTHTOK:\n                password = talloc_size(state, pd->newauthtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->newauthtok, pd->newauthtok_size);\n                    password[pd->newauthtok_size] = '\\0';\n                }\n                break;\n            default:\n                DEBUG(0, (\"unsupported PAM command [%d].\\n\", pd->cmd));\n        }\n\n        if (password == NULL) {\n            DEBUG(0, (\"password not available, offline auth may not work.\\n\"));\n            ret = EOK; /* password caching failures are not fatal errors */\n            goto done;\n        }\n\n        talloc_set_destructor((TALLOC_CTX *)password, password_destructor);\n\n        ret = sysdb_cache_password(state, state->be_ctx->sysdb,\n                                   state->be_ctx->domain, pd->user,\n                                   password);\n        if (ret) {\n            DEBUG(2, (\"Failed to cache password, offline auth may not work.\"\n                      \" (%d)[%s]!?\\n\", ret, strerror(ret)));\n        }\n    }\n\n    state->pam_status = PAM_SUCCESS;\n    state->dp_err = DP_ERR_OK;\n    ret = EOK;\n\ndone:\n    if (ret == EOK) {\n        tevent_req_done(req);\n    } else {\n        tevent_req_error(req, ret);\n    }\n\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "sssd",
        "commit_id": "fffdae81651b460f3d2c119c56d5caa09b4de42a",
        "hash": 293438735683713689247994784502674443815,
        "size": 77,
        "message": "Fix bad password caching when using automatic TGT renewal\n\nFixes CVE-2011-1758, https://fedorahosted.org/sssd/ticket/856"
    },
    {
        "func": "static void cmd_list(char *arg1, char *arg2)\n{\n    if (!arg1)\n\targ1 = \"active\";\n    else\n\tlcase(arg1);\n\n    if (!strcmp(arg1, \"active\")) {\n\tchar pattern[MAX_MAILBOX_BUFFER];\n\tstruct list_rock lrock;\n\tstruct enum_rock erock;\n\n\tif (!arg2) arg2 = \"*\";\n\n\terock.cmd = \"ACTIVE\";\n\terock.wild = xstrdup(arg2); /* make a copy before we munge it */\n\n\tlrock.proc = do_active;\n\tlrock.wild = split_wildmats(arg2); /* split the list of wildmats */\n\n\t/* xxx better way to determine a size for this table? */\n\tconstruct_hash_table(&lrock.server_table, 10, 1);\n\n\tprot_printf(nntp_out, \"215 List of newsgroups follows:\\r\\n\");\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tlist_cb(NULL, 0, 0, NULL);\n\tmboxlist_findall(NULL, pattern, 0, nntp_userid, nntp_authstate,\n\t\t\t list_cb, &lrock);\n\n\t/* proxy to the backends */\n\thash_enumerate(&lrock.server_table, list_proxy, &erock);\n\n\tprot_printf(nntp_out, \".\\r\\n\");\n\n\t/* free the hash table */\n\tfree_hash_table(&lrock.server_table, NULL);\n\n\t/* free the wildmats */\n\tfree_wildmats(lrock.wild);\n\tfree(erock.wild);\n\n\tif (group_state)\n\t    index_close(&group_state);\n    }\n    else if (!(nntp_capa & MODE_READ)) {\n\tprot_printf(nntp_out, \"502 Permission denied\\r\\n\");\n\treturn;\n    }\n    else if (!nntp_userid && !allowanonymous) {\n\tprot_printf(nntp_out, \"480 Authentication required\\r\\n\");\n\treturn;\n    }\n    else if (!strcmp(arg1, \"headers\")) {\n\tif (arg2 && strcmp(arg2, \"msgid\") && strcmp(arg2, \"range\")) {\n\t    prot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\t    return;\n\t}\n\n\tprot_printf(nntp_out, \"215 Header and metadata list follows:\\r\\n\");\n\tprot_printf(nntp_out, \":\\r\\n\"); /* all headers */\n\tprot_printf(nntp_out, \":bytes\\r\\n\");\n\tprot_printf(nntp_out, \":lines\\r\\n\");\n\tprot_printf(nntp_out, \".\\r\\n\");\n    }\n    else if (!strcmp(arg1, \"newsgroups\")) {\n\tchar pattern[MAX_MAILBOX_BUFFER];\n\tstruct list_rock lrock;\n\tstruct enum_rock erock;\n\n\tif (!arg2) arg2 = \"*\";\n\n\terock.cmd = \"NEWSGROUPS\";\n\terock.wild = xstrdup(arg2); /* make a copy before we munge it */\n\n\tlrock.proc = do_newsgroups;\n\tlrock.wild = split_wildmats(arg2); /* split the list of wildmats */\n\n\t/* xxx better way to determine a size for this table? */\n\tconstruct_hash_table(&lrock.server_table, 10, 1);\n\n\tprot_printf(nntp_out, \"215 List of newsgroups follows:\\r\\n\");\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tlist_cb(NULL, 0, 0, NULL);\n\tmboxlist_findall(NULL, pattern, 0, nntp_userid, nntp_authstate,\n\t\t\t list_cb, &lrock);\n\n\t/* proxy to the backends */\n\thash_enumerate(&lrock.server_table, list_proxy, &erock);\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tannotatemore_findall(pattern, \"/comment\",\n\t\t\t     newsgroups_cb, lrock.wild, NULL);\n\n\tprot_printf(nntp_out, \".\\r\\n\");\n\n\t/* free the hash table */\n\tfree_hash_table(&lrock.server_table, NULL);\n\n\t/* free the wildmats */\n\tfree_wildmats(lrock.wild);\n\tfree(erock.wild);\n    }\n    else if (!strcmp(arg1, \"overview.fmt\")) {\n\tif (arg2) {\n\t    prot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\t    return;\n\t}\n\n\tprot_printf(nntp_out, \"215 Order of overview fields follows:\\r\\n\");\n\tprot_printf(nntp_out, \"Subject:\\r\\n\");\n\tprot_printf(nntp_out, \"From:\\r\\n\");\n\tprot_printf(nntp_out, \"Date:\\r\\n\");\n\tprot_printf(nntp_out, \"Message-ID:\\r\\n\");\n\tprot_printf(nntp_out, \"References:\\r\\n\");\n\tif (did_capabilities) {\n\t    /* new OVER format */\n\t    prot_printf(nntp_out, \":bytes\\r\\n\");\n\t    prot_printf(nntp_out, \":lines\\r\\n\");\n\t} else {\n\t    /* old XOVER format */\n\t    prot_printf(nntp_out, \"Bytes:\\r\\n\");\n\t    prot_printf(nntp_out, \"Lines:\\r\\n\");\n\t}\n\tprot_printf(nntp_out, \"Xref:full\\r\\n\");\n\tprot_printf(nntp_out, \".\\r\\n\");\n    }\n    else if (!strcmp(arg1, \"active.times\") || !strcmp(arg1, \"distributions\") ||\n\t     !strcmp(arg1, \"distrib.pats\")) {\n\tprot_printf(nntp_out, \"503 Unsupported LIST command\\r\\n\");\n    }\n    else {\n\tprot_printf(nntp_out, \"501 Unrecognized LIST command\\r\\n\");\n    }\n    prot_flush(nntp_out);\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "cyrus-imapd",
        "commit_id": "77903669e04c9788460561dd0560b9c916519594",
        "hash": 262829870405379205714105131971351152198,
        "size": 140,
        "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."
    },
    {
        "func": "static int deliver(message_data_t *msg)\n{\n    int n, r = 0, myrights;\n    char *rcpt = NULL, *local_rcpt = NULL, *server, *acl;\n    unsigned long uid;\n    struct body *body = NULL;\n    struct dest *dlist = NULL;\n    duplicate_key_t dkey = {msg->id, NULL, msg->date};\n\n    /* check ACLs of all mailboxes */\n    for (n = 0; n < msg->rcpt_num; n++) {\n\trcpt = msg->rcpt[n];\n\n\t/* look it up */\n\tr = mlookup(rcpt, &server, &acl, NULL);\n\tdkey.to = rcpt;\n\tif (r) return IMAP_MAILBOX_NONEXISTENT;\n\n\tif (!(acl && (myrights = cyrus_acl_myrights(nntp_authstate, acl)) &&\n\t      (myrights & ACL_POST)))\n\t    return IMAP_PERMISSION_DENIED;\n\n\tif (server) {\n\t    /* remote group */\n\t    proxy_adddest(&dlist, NULL, 0, server, \"\");\n\t}\n\telse {\n\t    /* local group */\n\t    struct appendstate as;\n\n\t    if (msg->id && \n\t\tduplicate_check(&dkey)) {\n\t\t/* duplicate message */\n\t\tduplicate_log(&dkey, \"nntp delivery\");\n\t\tcontinue;\n\t    }\n\n\t    r = append_setup(&as, rcpt, nntp_userid, nntp_authstate, ACL_POST, 0);\n\n\t    if (!r) {\n\t\tprot_rewind(msg->data);\n\t\tif (stage) {\n\t\t    r = append_fromstage(&as, &body, stage, 0,\n\t\t\t\t\t (const char **) NULL, 0, !singleinstance);\n\t\t} else {\n\t\t    /* XXX should never get here */\n\t\t    r = append_fromstream(&as, &body, msg->data, msg->size, 0,\n\t\t\t\t\t  (const char **) NULL, 0);\n\t\t}\n\t\tif (r || ( msg->id && duplicate_check(&dkey) ) ) {    \n\t\t    append_abort(&as);\n                   \n\t\t    if (!r) {\n\t\t\t/* duplicate message */\n\t\t\tduplicate_log(&dkey, \"nntp delivery\");\n\t\t\tcontinue;\n\t\t    }            \n\t\t}                \n\t\telse {           \n\t\t    r = append_commit(&as, 0, NULL, &uid, NULL, NULL);\n\t\t}\n\t    }\n\n\t    if (!r && msg->id)\n\t\tduplicate_mark(&dkey, time(NULL), uid);\n\n\t    if (r) return r;\n\n\t    local_rcpt = rcpt;\n\t}\n    }\n\n    if (body) {\n\tmessage_free_body(body);\n\tfree(body);\n    }\n\n    if (dlist) {\n\tstruct dest *d;\n\n\t/* run the txns */\n\tr = deliver_remote(msg, dlist);\n\n\t/* free the destination list */\n\td = dlist;\n\twhile (d) {\n\t    struct dest *nextd = d->next;\n\t    free(d);\n\t    d = nextd;\n\t}\n    }\n\n    return r;\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "cyrus-imapd",
        "commit_id": "77903669e04c9788460561dd0560b9c916519594",
        "hash": 73523236888191683254465221268238259471,
        "size": 94,
        "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."
    },
    {
        "func": "static void cmdloop(void)\n{\n    int c, r = 0, mode;\n    static struct buf cmd, arg1, arg2, arg3, arg4;\n    char *p, *result, buf[1024];\n    const char *err;\n    uint32_t uid, last;\n    struct backend *be;\n    char curgroup[MAX_MAILBOX_BUFFER] = \"\";\n\n    allowanonymous = config_getswitch(IMAPOPT_ALLOWANONYMOUSLOGIN);\n\n    for (;;) {\n\t/* Flush any buffered output */\n\tprot_flush(nntp_out);\n\tif (backend_current) prot_flush(backend_current->out);\n\n\t/* Check for shutdown file */\n\tif (shutdown_file(buf, sizeof(buf)) ||\n\t    (nntp_userid &&\n\t     userdeny(nntp_userid, config_ident, buf, sizeof(buf)))) {\n\t    prot_printf(nntp_out, \"400 %s\\r\\n\", buf);\n\t    shut_down(0);\n\t}\n\n\tsignals_poll();\n\n\tif (!proxy_check_input(protin, nntp_in, nntp_out,\n\t\t\t       backend_current ? backend_current->in : NULL,\n\t\t\t       NULL, 0)) {\n\t    /* No input from client */\n\t    continue;\n\t}\n\n\tif (group_state &&\n\t    config_getswitch(IMAPOPT_DISCONNECT_ON_VANISHED_MAILBOX)) {\n\t    if (group_state->mailbox->i.options & OPT_MAILBOX_DELETED) {\n\t\t/* Mailbox has been (re)moved */\n\t\tsyslog(LOG_WARNING,\n\t\t       \"Newsgroup %s has been (re)moved out from under client\",\n\t\t       group_state->mailbox->name);\n\t\tprot_printf(nntp_out,\n\t\t\t    \"400 Newsgroup has been (re)moved\\r\\n\");\n\t\tshut_down(0);\n\t    }\n\t}\n\n\t/* Parse command name */\n\tc = getword(nntp_in, &cmd);\n\tif (c == EOF) {\n\t    if ((err = prot_error(nntp_in)) != NULL\n\t\t && strcmp(err, PROT_EOF_STRING)) {\n\t\tsyslog(LOG_WARNING, \"%s, closing connection\", err);\n\t\tprot_printf(nntp_out, \"400 %s\\r\\n\", err);\n\t    }\n\t    return;\n\t}\n\tif (!cmd.s[0]) {\n\t    prot_printf(nntp_out, \"501 Empty command\\r\\n\");\n\t    eatline(nntp_in, c);\n\t    continue;\n\t}\n\tif (Uislower(cmd.s[0])) \n\t    cmd.s[0] = toupper((unsigned char) cmd.s[0]);\n\tfor (p = &cmd.s[1]; *p; p++) {\n\t    if (Uisupper(*p)) *p = tolower((unsigned char) *p);\n\t}\n\n\t/* Ihave/Takethis only allowed for feeders */\n\tif (!(nntp_capa & MODE_FEED) &&\n\t    strchr(\"IT\", cmd.s[0])) goto noperm;\n    \n\t/* Body/Date/Group/Newgroups/Newnews/Next/Over/Post/Xhdr/Xover/Xpat\n\t   only allowed for readers */\n\tif (!(nntp_capa & MODE_READ) &&\n\t    strchr(\"BDGNOPX\", cmd.s[0])) goto noperm;\n    \n\t/* Only Authinfo/Capabilities/Check/Head/Help/Ihave/List Active/\n\t   Mode/Quit/Starttls/Stat/Takethis allowed when not logged in */\n\tif (!nntp_userid && !allowanonymous &&\n\t    !strchr(\"ACHILMQST\", cmd.s[0])) goto nologin;\n\n\t/* In case a [LIST]GROUP fails or\n\t   a retrieval by msgid makes us switch groups */\n\tstrcpy(curgroup, group_state ? group_state->mailbox->name : \"\");\n\n\tswitch (cmd.s[0]) {\n\tcase 'A':\n\t    if (!strcmp(cmd.s, \"Authinfo\")) {\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* subcommand */\n\t\tif (c == EOF) goto missingargs;\n\n\t\tlcase(arg1.s);\n\n\t\tif (!strcmp(arg1.s, \"user\") || !strcmp(arg1.s, \"pass\")) {\n\t\t    if (c != ' ') goto missingargs;\n\t\t    c = getuserpass(nntp_in, &arg2); /* user/pass */\n\t\t    if (c == EOF) goto missingargs;\n\n\t\t    if (c == '\\r') c = prot_getc(nntp_in);\n\t\t    if (c != '\\n') goto extraargs;\n\n\t\t    if (arg1.s[0] == 'u')\n\t\t\tcmd_authinfo_user(arg2.s);\n\t\t    else\n\t\t\tcmd_authinfo_pass(arg2.s);\n\t\t}\n\t\telse if (!strcmp(arg1.s, \"sasl\") || !strcmp(arg1.s, \"generic\")) {\n\t\t    arg2.len = arg3.len = 0;\n\n\t\t    /* mech name required for SASL but not GENERIC */\n\t\t    if ((arg1.s[0] == 's') && (c != ' ')) goto missingargs;\n\n\t\t    if (c == ' ') {\n\t\t\tc = getword(nntp_in, &arg2); /* mech name */\n\t\t\tif (c == EOF) goto missingargs;\n\n\t\t\tif (c == ' ') {\n\t\t\t    c = getword(nntp_in, &arg3); /* init response */\n\t\t\t    if (c == EOF) goto missingargs;\n\t\t\t}\n\t\t    }\n\n\t\t    if (c == '\\r') c = prot_getc(nntp_in);\n\t\t    if (c != '\\n') goto extraargs;\n\n\t\t    cmd_authinfo_sasl(arg1.s, arg2.len ? arg2.s : NULL,\n\t\t\t\t      arg3.len ? arg3.s : NULL);\n\t\t}\n\t\telse\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"501 Unrecognized AUTHINFO command\\r\\n\");\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Article\")) {\n\t\tchar *msgid;\n\n\t\tmode = ARTICLE_ALL;\n\n\t      article:\n\t\tif (arg1.s) *arg1.s = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* number/msgid (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg1.s, &uid, NULL, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg1.s && *arg1.s)\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s\\r\\n\", cmd.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"22\", 2) &&\n\t\t\t\tmode != ARTICLE_STAT) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_article(mode, msgid, uid);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'B':\n\t    if (!strcmp(cmd.s, \"Body\")) {\n\t\tmode = ARTICLE_BODY;\n\t\tgoto article;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'C':\n\t    if (!strcmp(cmd.s, \"Capabilities\")) {\n\t\targ1.len = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* keyword (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_capabilities(arg1.s);\n\t    }\n\t    else if (!(nntp_capa & MODE_FEED)) goto noperm;\n\t    else if (!strcmp(cmd.s, \"Check\")) {\n\t\tmode = POST_CHECK;\n\t\tgoto ihave;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'D':\n\t    if (!strcmp(cmd.s, \"Date\")) {\n\t\ttime_t now = time(NULL);\n\t\tstruct tm *my_tm = gmtime(&now);\n\t\tchar buf[15];\n\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tstrftime(buf, sizeof(buf), \"%Y%m%d%H%M%S\", my_tm);\n\t\tprot_printf(nntp_out, \"111 %s\\r\\n\", buf);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'G':\n\t    if (!strcmp(cmd.s, \"Group\")) {\n\t\targ2.len = 0; /* GROUP command (no range) */\n\n\t      group:\n#define LISTGROUP (arg2.len)\n\n\t\tif (!LISTGROUP && c != ' ') goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* group */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (LISTGROUP && c == ' ') {\n\t\t    c = getword(nntp_in, &arg2); /* range (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tbe = backend_current;\n\t\tif (arg1.len &&\n\t\t    (!is_newsgroup(arg1.s) ||\n\t\t     (r = open_group(arg1.s, 1, &be, NULL)))) goto nogroup;\n\t\telse if (be) {\n\t\t    prot_printf(be->out, \"%s\", cmd.s);\n\t\t    if (arg1.len) {\n\t\t\tprot_printf(be->out, \" %s\", arg1.s);\n\t\t\t  if (LISTGROUP) prot_printf(be->out, \" %s\", arg2.s);\n\t\t    }\n\t\t    prot_printf(be->out, \"\\r\\n\");\n\n\t\t    r = read_response(be, 0, &result);\n\t\t    if (r) goto nogroup;\n\n\t\t    prot_printf(nntp_out, \"%s\", result);\n\n\t\t    if (!strncmp(result, \"211\", 3)) {\n\t\t\tif (LISTGROUP) pipe_to_end_of_response(be, 0);\n\n\t\t\tif (backend_current && backend_current != be) {\n\t\t\t    /* remove backend_current from the protgroup */\n\t\t\t    protgroup_delete(protin, backend_current->in);\n\t\t\t}\n\t\t\tbackend_current = be;\n\n\t\t\t/* add backend_current to the protgroup */\n\t\t\tprotgroup_insert(protin, backend_current->in);\n\t\t    }\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (LISTGROUP &&\n\t\t\t parserange(arg2.s, &uid, &last, NULL, NULL) != 0) {\n\t\t    /* parserange() will handle error code -- do nothing */\n\t\t}\n\t\telse {\n\t\t    if (backend_current) {\n\t\t\t/* remove backend_current from the protgroup */\n\t\t\tprotgroup_delete(protin, backend_current->in);\n\t\t    }\n\t\t    backend_current = NULL;\n\n\t\t    nntp_exists = group_state->exists;\n\t\t    nntp_current = nntp_exists > 0;\n\n\t\t    prot_printf(nntp_out, \"211 %u %lu %lu %s\\r\\n\",\n\t\t\t\tnntp_exists,\n\t\t\t\tnntp_exists ? index_getuid(group_state, 1) :\n\t\t\t\tgroup_state->last_uid+1,\n\t\t\t\tnntp_exists ? index_getuid(group_state, nntp_exists) :\n\t\t\t\tgroup_state->last_uid,\n\t\t\t\tgroup_state->mailbox->name + strlen(newsprefix));\n\n\t\t    if (LISTGROUP) {\n\t\t\tint msgno, last_msgno;\n\n\t\t\tmsgno = index_finduid(group_state, uid);\n\t\t\tif (!msgno || index_getuid(group_state, msgno) != uid) {\n\t\t\t    msgno++;\n\t\t\t}\n\t\t\tlast_msgno = index_finduid(group_state, last);\n\n\t\t\tfor (; msgno <= last_msgno; msgno++) {\n\t\t\t    prot_printf(nntp_out, \"%u\\r\\n\",\n\t\t\t\t\tindex_getuid(group_state, msgno));\n\t\t\t}\n\t\t\tprot_printf(nntp_out, \".\\r\\n\");\n\t\t    }\n\t\t}\n#undef LISTGROUP\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'H':\n\t    if (!strcmp(cmd.s, \"Head\")) {\n\t\tmode = ARTICLE_HEAD;\n\t\tgoto article;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Help\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_help();\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Hdr\")) {\n\t\tchar *msgid;\n\n\t      hdr:\n\t\tif (arg2.s) *arg2.s = 0;\n\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* header */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg2); /* range (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg2.s, &uid, &last, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg2.s && *arg2.s)\n\t\t\t    prot_printf(be->out, \"%s %s %s\\r\\n\",\n\t\t\t\t\tcmd.s, arg1.s, arg2.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"22\", 2)) { /* 221 or 225 */\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_hdr(cmd.s, arg1.s, NULL, msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'I':\n\t    if (!strcmp(cmd.s, \"Ihave\")) {\n\t\tmode = POST_IHAVE;\n\n\t      ihave:\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* msgid */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_post(arg1.s, mode);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'L':\n\t    if (!strcmp(cmd.s, \"List\")) {\n\t\targ1.len = arg2.len = 0;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* subcommand (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t    if (c == ' ') {\n\t\t\tc = getword(nntp_in, &arg2); /* argument (optional) */\n\t\t\tif (c == EOF) goto missingargs;\n\t\t    }\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_list(arg1.len ? arg1.s : NULL, arg2.len ? arg2.s : NULL);\n\n\t\tgoto prevgroup;  /* In case we did LIST [ACTIVE] */\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Last\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (backend_current) {\n\t\t    prot_printf(backend_current->out, \"LAST\\r\\n\");\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (!nntp_current) goto nocurrent;\n\t\telse if (nntp_current == 1) {\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"422 No previous article in this group\\r\\n\");\n\t\t}\n\t\telse {\n\t\t    char *msgid = index_get_msgid(group_state, --nntp_current);\n\n\t\t    prot_printf(nntp_out, \"223 %u %s\\r\\n\",\n\t\t\t\tindex_getuid(group_state, nntp_current),\n\t\t\t\tmsgid ? msgid : \"<0>\");\n\n\t\t    if (msgid) free(msgid);\n\t\t}\n\t    }\n\t    else if (!strcmp(cmd.s, \"Listgroup\")) {\n\t\targ1.len = 0;   \t   /* group is optional */\n\t\tbuf_setcstr(&arg2, \"1-\");  /* default range is all */\n\t\tbuf_cstring(&arg2);\t   /* appends a '\\0' */\n\t\tgoto group;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'M':\n\t    if (!strcmp(cmd.s, \"Mode\")) {\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* mode */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_mode(arg1.s);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'N':\n\t    if (!strcmp(cmd.s, \"Newgroups\")) {\n\t\ttime_t tstamp;\n\n\t\targ3.len = 0;\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* date */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg2); /* time */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg3); /* \"GMT\" (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif ((tstamp = parse_datetime(arg1.s, arg2.s,\n\t\t\t\t\t     arg3.len ? arg3.s : NULL)) < 0)\n\t\t    goto baddatetime;\n\n\t\tcmd_newgroups(tstamp);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Newnews\")) {\n\t\ttime_t tstamp;\n\n\t\tif (!config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t\t    goto cmddisabled;\n\n\t\targ4.len = 0;\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* wildmat */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg2); /* date */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg3); /* time */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg4); /* \"GMT\" (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif ((tstamp = parse_datetime(arg2.s, arg3.s,\n\t\t\t\t\t     arg4.len ? arg4.s : NULL)) < 0)\n\t\t    goto baddatetime;\n\n\t\tcmd_newnews(arg1.s, tstamp);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Next\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (backend_current) {\n\t\t    prot_printf(backend_current->out, \"NEXT\\r\\n\");\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (!nntp_current) goto nocurrent;\n\t\telse if (nntp_current == nntp_exists) {\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"421 No next article in this group\\r\\n\");\n\t\t}\n\t\telse {\n\t\t    char *msgid = index_get_msgid(group_state, ++nntp_current);\n\n\t\t    prot_printf(nntp_out, \"223 %u %s\\r\\n\",\n\t\t\t\tindex_getuid(group_state, nntp_current),\n\t\t\t\tmsgid ? msgid : \"<0>\");\n\n\t\t    if (msgid) free(msgid);\n\t\t}\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'O':\n\t    if (!strcmp(cmd.s, \"Over\")) {\n\t\tchar *msgid;\n\n\t      over:\n\t\tif (arg1.s) *arg1.s = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* range/msgid (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tmsgid = NULL;\n\t\tif (parserange(arg1.s, &uid, &last,\n\t\t\t       /* XOVER doesn't accept message-id */\n\t\t\t       (cmd.s[0] == 'X' ? NULL : &msgid), &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg1.s && *arg1.s)\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s\\r\\n\", cmd.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"224\", 3)) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_over(msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'P':\n\t    if (!strcmp(cmd.s, \"Post\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_post(NULL, POST_POST);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'Q':\n\t    if (!strcmp(cmd.s, \"Quit\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tprot_printf(nntp_out, \"205 Connection closing\\r\\n\");\n\t\treturn;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'S':\n\t    if (!strcmp(cmd.s, \"Starttls\") && tls_enabled()) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\t/* XXX  discard any input pipelined after STARTTLS */\n\t\tprot_flush(nntp_in);\n\n\t\tcmd_starttls(0);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Stat\")) {\n\t\tmode = ARTICLE_STAT;\n\t\tgoto article;\n\t    }\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Slave\")) {\t\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tprot_printf(nntp_out, \"202 Slave status noted\\r\\n\");\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'T':\n\t    if (!strcmp(cmd.s, \"Takethis\")) {\n\t\tmode = POST_TAKETHIS;\n\t\tgoto ihave;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'X':\n\t    if (!strcmp(cmd.s, \"Xhdr\")) {\n\t\tgoto hdr;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Xover\")) {\n\t\tgoto over;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Xpat\")) {\n\t\tchar *msgid;\n\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* header */\n\t\tif (c != ' ') goto missingargs;\n\n\t\t/* gobble extra whitespace (hack for Mozilla) */\n\t\twhile ((c = prot_getc(nntp_in)) == ' ');\n\t\tprot_ungetc(c, nntp_in);\n\n\t\tc = getword(nntp_in, &arg2); /* range */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg3); /* wildmat */\n\t\tif (c == EOF) goto missingargs;\n\n\t\t/* XXX per RFC 2980, we can have multiple patterns */\n\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg2.s, &uid, &last, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tprot_printf(be->out, \"%s %s %s %s\\r\\n\",\n\t\t\t\t    cmd.s, arg1.s, arg2.s, arg3.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"221\", 3)) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_hdr(cmd.s, arg1.s, arg3.s, msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tdefault:\n\t  badcmd:\n\t    prot_printf(nntp_out, \"500 Unrecognized command\\r\\n\");\n\t    eatline(nntp_in, c);\n\t}\n\n\tcontinue;\n\n      noperm:\n\tprot_printf(nntp_out, \"502 Permission denied\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      nologin:\n\tprot_printf(nntp_out, \"480 Authentication required\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      cmddisabled:\n\tprot_printf(nntp_out, \"503 \\\"%s\\\" disabled\\r\\n\", cmd.s);\n\teatline(nntp_in, c);\n\tcontinue;\n\n      extraargs:\n\tprot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      missingargs:\n\tprot_printf(nntp_out, \"501 Missing argument\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      baddatetime:\n\tprot_printf(nntp_out, \"501 Bad date/time\\r\\n\");\n\tcontinue;\n\n      nogroup:\n\tprot_printf(nntp_out, \"411 No such newsgroup (%s)\\r\\n\",\n\t\t    error_message(r));\n\n      prevgroup:\n\t/* Return to previously selected group */\n\tif (*curgroup &&\n\t    (!group_state || strcmp(curgroup, group_state->mailbox->name))) {\n\t    open_group(curgroup, 1, NULL, NULL);\n\t}\n\n\tcontinue;\n\n      noopengroup:\n\tprot_printf(nntp_out, \"412 No newsgroup selected\\r\\n\");\n\tcontinue;\n\n      nocurrent:\n\tprot_printf(nntp_out, \"420 Current article number is invalid\\r\\n\");\n\tcontinue;\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "cyrus-imapd",
        "commit_id": "77903669e04c9788460561dd0560b9c916519594",
        "hash": 36227003234558718820707382185223272427,
        "size": 735,
        "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."
    },
    {
        "func": "static void cmd_capabilities(char *keyword __attribute__((unused)))\n{\n    const char *mechlist;\n    int mechcount = 0;\n\n    prot_printf(nntp_out, \"101 Capability list follows:\\r\\n\");\n    prot_printf(nntp_out, \"VERSION 2\\r\\n\");\n    if (nntp_authstate || (config_serverinfo == IMAP_ENUM_SERVERINFO_ON)) {\n\tprot_printf(nntp_out,\n\t\t    \"IMPLEMENTATION Cyrus NNTP%s %s\\r\\n\",\n\t\t    config_mupdate_server ? \" Murder\" : \"\", cyrus_version());\n    }\n\n    /* add STARTTLS */\n    if (tls_enabled() && !nntp_starttls_done && !nntp_authstate)\n\tprot_printf(nntp_out, \"STARTTLS\\r\\n\");\n\n    /* check for SASL mechs */\n    sasl_listmech(nntp_saslconn, NULL, \"SASL \", \" \", \"\\r\\n\",\n\t\t  &mechlist, NULL, &mechcount);\n\n    /* add the AUTHINFO variants */\n    if (!nntp_authstate) {\n\tprot_printf(nntp_out, \"AUTHINFO%s%s\\r\\n\",\n\t\t    (nntp_starttls_done || (extprops_ssf > 1) ||\n\t\t     config_getswitch(IMAPOPT_ALLOWPLAINTEXT)) ?\n\t\t    \" USER\" : \"\", mechcount ? \" SASL\" : \"\");\n    }\n\n    /* add the SASL mechs */\n    if (mechcount) prot_printf(nntp_out, \"%s\", mechlist);\n\n    /* add the reader capabilities/extensions */\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"READER\\r\\n\");\n\tprot_printf(nntp_out, \"POST\\r\\n\");\n\tif (config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t    prot_printf(nntp_out, \"NEWNEWS\\r\\n\");\n\tprot_printf(nntp_out, \"HDR\\r\\n\");\n\tprot_printf(nntp_out, \"OVER\\r\\n\");\n\tprot_printf(nntp_out, \"XPAT\\r\\n\");\n    }\n\n    /* add the feeder capabilities/extensions */\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"IHAVE\\r\\n\");\n\tprot_printf(nntp_out, \"STREAMING\\r\\n\");\n    }\n\n    /* add the LIST variants */\n    prot_printf(nntp_out, \"LIST ACTIVE%s\\r\\n\",\n\t\t((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) ?\n\t\t\" HEADERS NEWSGROUPS OVERVIEW.FMT\" : \"\");\n\n    prot_printf(nntp_out, \".\\r\\n\");\n\n    did_capabilities = 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "cyrus-imapd",
        "commit_id": "77903669e04c9788460561dd0560b9c916519594",
        "hash": 133562615154800421751785701788830534417,
        "size": 58,
        "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."
    },
    {
        "func": "static int open_group(char *name, int has_prefix, struct backend **ret,\n\t\t      int *postable /* used for LIST ACTIVE only */)\n{\n    char mailboxname[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    char *acl, *newserver;\n    struct backend *backend_next = NULL;\n\n    /* close local group */\n    if (group_state) \n\tindex_close(&group_state);\n\n    if (!has_prefix) {\n\tsnprintf(mailboxname, sizeof(mailboxname), \"%s%s\", newsprefix, name);\n\tname = mailboxname;\n    }\n\n    if (!r) r = mlookup(name, &newserver, &acl, NULL);\n\n    if (!r && acl) {\n\tint myrights = cyrus_acl_myrights(nntp_authstate, acl);\n\n\tif (postable) *postable = myrights & ACL_POST;\n\tif (!postable && /* allow limited 'r' for LIST ACTIVE */\n\t    !(myrights & ACL_READ)) {\n\t    r = (myrights & ACL_LOOKUP) ?\n\t\tIMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n\t}\n    }\n\n    if (r) return r;\n\n    if (newserver) {\n\t/* remote group */\n\tbackend_next = proxy_findserver(newserver, &nntp_protocol,\n\t\t\t\t\tnntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t\t\t&backend_cached, &backend_current,\n\t\t\t\t\tNULL, nntp_in);\n\tif (!backend_next) return IMAP_SERVER_UNAVAILABLE;\n\n\t*ret = backend_next;\n    }\n    else {\n\t/* local group */\n\tstruct index_init init;\n\tmemset(&init, 0, sizeof(struct index_init));\n\tinit.userid = nntp_userid;\n\tinit.authstate = nntp_authstate;\n\tr = index_open(name, &init, &group_state);\n\tif (r) return r;\n\n\tif (ret) *ret = NULL;\n    }\n\n    syslog(LOG_DEBUG, \"open: user %s opened %s\",\n\t   nntp_userid ? nntp_userid : \"anonymous\", name);\n\n    return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "cyrus-imapd",
        "commit_id": "77903669e04c9788460561dd0560b9c916519594",
        "hash": 101058133821341039396945456621239447854,
        "size": 59,
        "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."
    },
    {
        "func": "static void cmd_help(void)\n{\n    prot_printf(nntp_out, \"100 Supported commands:\\r\\n\");\n\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tARTICLE [ message-id | number ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve entirety of the specified article.\\r\\n\");\n    }\n    if (!nntp_authstate) {\n\tif (!nntp_userid) {\n\t    prot_printf(nntp_out, \"\\tAUTHINFO SASL mechanism [initial-response]\\r\\n\"\n\t\t\t\"\\t\\tPerform an authentication exchange using the specified\\r\\n\"\n\t\t\t\"\\t\\tSASL mechanism.\\r\\n\");\n\t    prot_printf(nntp_out, \"\\tAUTHINFO USER username\\r\\n\"\n\t\t\t\"\\t\\tPresent username for authentication.\\r\\n\");\n\t}\n\tprot_printf(nntp_out, \"\\tAUTHINFO PASS password\\r\\n\"\n\t\t    \"\\t\\tPresent clear-text password for authentication.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tBODY [ message-id | number ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve body of the specified article.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tCAPABILITIES\\r\\n\"\n\t\t\"\\t\\tList the current server capabilities.\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tCHECK message-id\\r\\n\"\n\t\t    \"\\t\\tCheck if the server wants the specified article.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tDATE\\r\\n\"\n\t\t    \"\\t\\tRequest the current server UTC date and time.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tGROUP group\\r\\n\"\n\t\t    \"\\t\\tSelect a newsgroup for article retrieval.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tHDR header [ message-id | range ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve the specified header/metadata from the\\r\\n\"\n\t\t    \"\\t\\tspecified article(s).\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tHEAD [ message-id | number ]\\r\\n\"\n\t\t\"\\t\\tRetrieve the headers of the specified article.\\r\\n\");\n    prot_printf(nntp_out, \"\\tHELP\\r\\n\"\n\t\t\"\\t\\tRequest command summary (this text).\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tIHAVE message-id\\r\\n\"\n\t\t    \"\\t\\tPresent/transfer the specified article to the server.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tLAST\\r\\n\"\n\t\t    \"\\t\\tSelect the previous article.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tLIST [ ACTIVE wildmat ]\\r\\n\"\n\t\t\"\\t\\tList the (subset of) valid newsgroups.\\r\\n\");\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tLIST HEADERS [ MSGID | RANGE ]\\r\\n\"\n\t\t    \"\\t\\tList the headers and metadata items available via HDR.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLIST NEWSGROUPS [wildmat]\\r\\n\"\n\t\t    \"\\t\\tList the descriptions of the specified newsgroups.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLIST OVERVIEW.FMT\\r\\n\"\n\t\t    \"\\t\\tList the headers and metadata items available via OVER.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLISTGROUP [group [range]]\\r\\n\"\n\t\t    \"\\t\\tList the article numbers in the specified newsgroup.\\r\\n\");\n\tif (config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t    prot_printf(nntp_out, \"\\tNEWNEWS wildmat date time [GMT]\\r\\n\"\n\t\t\t\"\\t\\tList the newly arrived articles in the specified newsgroup(s)\\r\\n\"\n\t\t\t\"\\t\\tsince the specified date and time.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tNEXT\\r\\n\"\n\t\t    \"\\t\\tSelect the next article.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tOVER [ message-id | range ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve the overview information for the specified article(s).\\r\\n\");\n\tprot_printf(nntp_out, \"\\tPOST\\r\\n\"\n\t\t    \"\\t\\tPost an article to the server.\\r\\n\");\n    }\n\n    prot_printf(nntp_out, \"\\tQUIT\\r\\n\"\n\t\t\"\\t\\tTerminate the session.\\r\\n\");\n    if (tls_enabled() && !nntp_starttls_done && !nntp_authstate) {\n\tprot_printf(nntp_out, \"\\tSTARTTLS\\r\\n\"\n\t\t    \"\\t\\tStart a TLS negotiation.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tSTAT [ message-id | number ]\\r\\n\"\n\t\t\"\\t\\tCheck if the specified article exists.\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tTAKETHIS message-id\\r\\n\"\n\t\t    \"\\t\\tTransfer the specified article to the server.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tXPAT header message-id|range wildmat\\r\\n\"\n\t\t    \"\\t\\tList the specified article(s) in which the contents\\r\\n\"\n\t\t    \"\\t\\tof the specified header/metadata matches the wildmat.\\r\\n\");\n    }\n    prot_printf(nntp_out, \".\\r\\n\");\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "cyrus-imapd",
        "commit_id": "77903669e04c9788460561dd0560b9c916519594",
        "hash": 9050074142561425211240293024801633762,
        "size": 92,
        "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."
    },
    {
        "func": "void list_proxy(char *server, void *data __attribute__((unused)), void *rock)\n{\n    struct enum_rock *erock = (struct enum_rock *) rock;\n    struct backend *be;\n    int r;\n    char *result;\n\n    be = proxy_findserver(server, &nntp_protocol,\n\t\t\t  nntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t  &backend_cached, &backend_current, NULL, nntp_in);\n    if (!be) return;\n\n    prot_printf(be->out, \"LIST %s %s\\r\\n\", erock->cmd, erock->wild);\n\n    r = read_response(be, 0, &result);\n    if (!r && !strncmp(result, \"215 \", 4)) {\n\twhile (!(r = read_response(be, 0, &result)) && result[0] != '.') {\n\t    prot_printf(nntp_out, \"%s\", result);\n\t}\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "cyrus-imapd",
        "commit_id": "77903669e04c9788460561dd0560b9c916519594",
        "hash": 46710401755731243678308512642778795833,
        "size": 21,
        "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."
    },
    {
        "func": "static int deliver_remote(message_data_t *msg, struct dest *dlist)\n{\n    struct dest *d;\n\n    /* run the txns */\n    for (d = dlist; d; d = d->next) {\n\tstruct backend *be;\n\tchar buf[4096];\n\n\tbe = proxy_findserver(d->server, &nntp_protocol,\n\t\t\t      nntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t      &backend_cached, &backend_current,\n\t\t\t      NULL, nntp_in);\n\tif (!be) return IMAP_SERVER_UNAVAILABLE;\n\n\t/* tell the backend about our new article */\n\tprot_printf(be->out, \"IHAVE %s\\r\\n\", msg->id);\n\tprot_flush(be->out);\n\n\tif (!prot_fgets(buf, sizeof(buf), be->in) ||\n\t    strncmp(\"335\", buf, 3)) {\n\t    syslog(LOG_NOTICE, \"backend doesn't want article %s\", msg->id);\n\t    continue;\n\t}\n\n\t/* send the article */\n\trewind(msg->f);\n\twhile (fgets(buf, sizeof(buf), msg->f)) {\n\t    if (buf[0] == '.') prot_putc('.', be->out);\n\t    do {\n\t\tprot_printf(be->out, \"%s\", buf);\n\t    } while (buf[strlen(buf)-1] != '\\n' &&\n\t\t     fgets(buf, sizeof(buf), msg->f));\n\t}\n\n\t/* Protect against messages not ending in CRLF */\n\tif (buf[strlen(buf)-1] != '\\n') prot_printf(be->out, \"\\r\\n\");\n\n\tprot_printf(be->out, \".\\r\\n\");\n\n\tif (!prot_fgets(buf, sizeof(buf), be->in) ||\n\t    strncmp(\"235\", buf, 3)) {\n\t    syslog(LOG_WARNING, \"article %s transfer to backend failed\",\n\t\t   msg->id);\n\t    return NNTP_FAIL_TRANSFER;\n\t}\n    }\n\n    return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "cyrus-imapd",
        "commit_id": "77903669e04c9788460561dd0560b9c916519594",
        "hash": 264092106153686132595554193253021243579,
        "size": 50,
        "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."
    },
    {
        "func": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}",
        "target": 1,
        "cwe": [
            "CWE-287",
            "CWE-284"
        ],
        "project": "linux",
        "commit_id": "e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "hash": 49493140253401948512040042947756909182,
        "size": 9,
        "message": "af_netlink: force credentials passing [CVE-2012-3520]\n\nPablo Neira Ayuso discovered that avahi and\npotentially NetworkManager accept spoofed Netlink messages because of a\nkernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data\nto the receiver if the sender did not provide such data, instead of not\nincluding any such data at all or including the correct data from the\npeer (as it is the case with AF_UNIX).\n\nThis bug was introduced in commit 16e572626961\n(af_unix: dont send SCM_CREDENTIALS by default)\n\nThis patch forces passing credentials for netlink, as\nbefore the regression.\n\nAnother fix would be to not add SCM_CREDENTIALS in\nnetlink messages if not provided by the sender, but it\nmight break some programs.\n\nWith help from Florian Weimer & Petr Matousek\n\nThis issue is designated as CVE-2012-3520\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Florian Weimer <fweimer@redhat.com>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &scm;\n\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "target": 1,
        "cwe": [
            "CWE-287",
            "CWE-284"
        ],
        "project": "linux",
        "commit_id": "e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "hash": 149780959227096190802600942644008510919,
        "size": 77,
        "message": "af_netlink: force credentials passing [CVE-2012-3520]\n\nPablo Neira Ayuso discovered that avahi and\npotentially NetworkManager accept spoofed Netlink messages because of a\nkernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data\nto the receiver if the sender did not provide such data, instead of not\nincluding any such data at all or including the correct data from the\npeer (as it is the case with AF_UNIX).\n\nThis bug was introduced in commit 16e572626961\n(af_unix: dont send SCM_CREDENTIALS by default)\n\nThis patch forces passing credentials for netlink, as\nbefore the regression.\n\nAnother fix would be to not add SCM_CREDENTIALS in\nnetlink messages if not provided by the sender, but it\nmight break some programs.\n\nWith help from Florian Weimer & Petr Matousek\n\nThis issue is designated as CVE-2012-3520\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Florian Weimer <fweimer@redhat.com>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr = msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned int hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\tint max_level;\n\tint data_len = 0;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr\n\t    && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tif (len > SKB_MAX_ALLOC)\n\t\tdata_len = min_t(size_t,\n\t\t\t\t len - SKB_MAX_ALLOC,\n\t\t\t\t MAX_SKB_FRAGS * PAGE_SIZE);\n\n\tskb = sock_alloc_send_pskb(sk, len - data_len, data_len,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = unix_scm_to_skb(siocb->scm, skb, true);\n\tif (err < 0)\n\t\tgoto out_free;\n\tmax_level = err + 1;\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_put(skb, len - data_len);\n\tskb->data_len = data_len;\n\tskb->len = len;\n\terr = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tif (sk_filter(other, skb) < 0) {\n\t\t/* Toss the packet but do not return any error to the sender */\n\t\terr = len;\n\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk) = NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tif (sock_flag(other, SOCK_RCVTSTAMP))\n\t\t__net_timestamp(skb);\n\tmaybe_add_creds(skb, sock, other);\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tif (max_level > unix_sk(other)->recursion_level)\n\t\tunix_sk(other)->recursion_level = max_level;\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "target": 1,
        "cwe": [
            "CWE-287",
            "CWE-284"
        ],
        "project": "linux",
        "commit_id": "e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "hash": 270083099153892850893712055207554748767,
        "size": 172,
        "message": "af_netlink: force credentials passing [CVE-2012-3520]\n\nPablo Neira Ayuso discovered that avahi and\npotentially NetworkManager accept spoofed Netlink messages because of a\nkernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data\nto the receiver if the sender did not provide such data, instead of not\nincluding any such data at all or including the correct data from the\npeer (as it is the case with AF_UNIX).\n\nThis bug was introduced in commit 16e572626961\n(af_unix: dont send SCM_CREDENTIALS by default)\n\nThis patch forces passing credentials for netlink, as\nbefore the regression.\n\nAnother fix would be to not add SCM_CREDENTIALS in\nnetlink messages if not provided by the sender, but it\nmight break some programs.\n\nWith help from Florian Weimer & Petr Matousek\n\nThis issue is designated as CVE-2012-3520\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Florian Weimer <fweimer@redhat.com>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tint err, size;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tstruct scm_cookie tmp_scm;\n\tbool fds_sent = false;\n\tint max_level;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile (sent < len) {\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,\n\t\t\t\t\t  &err);\n\n\t\tif (skb == NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\n\t\t/* Only send the fds in the first buffer */\n\t\terr = unix_scm_to_skb(siocb->scm, skb, !fds_sent);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\t\tmax_level = err + 1;\n\t\tfds_sent = true;\n\n\t\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tmaybe_add_creds(skb, sock, other);\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tif (max_level > unix_sk(other)->recursion_level)\n\t\t\tunix_sk(other)->recursion_level = max_level;\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent += size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}",
        "target": 1,
        "cwe": [
            "CWE-287",
            "CWE-284"
        ],
        "project": "linux",
        "commit_id": "e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "hash": 304269967883880316933926029049574746616,
        "size": 119,
        "message": "af_netlink: force credentials passing [CVE-2012-3520]\n\nPablo Neira Ayuso discovered that avahi and\npotentially NetworkManager accept spoofed Netlink messages because of a\nkernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data\nto the receiver if the sender did not provide such data, instead of not\nincluding any such data at all or including the correct data from the\npeer (as it is the case with AF_UNIX).\n\nThis bug was introduced in commit 16e572626961\n(af_unix: dont send SCM_CREDENTIALS by default)\n\nThis patch forces passing credentials for netlink, as\nbefore the regression.\n\nAnother fix would be to not add SCM_CREDENTIALS in\nnetlink messages if not provided by the sender, but it\nmight break some programs.\n\nWith help from Florian Weimer & Petr Matousek\n\nThis issue is designated as CVE-2012-3520\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Florian Weimer <fweimer@redhat.com>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "conn *conn_new(const int sfd, enum conn_states init_state,\n                const int event_flags,\n                const int read_buffer_size, enum network_transport transport,\n                struct event_base *base) {\n    conn *c = conn_from_freelist();\n\n    if (NULL == c) {\n        if (!(c = (conn *)calloc(1, sizeof(conn)))) {\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            fprintf(stderr, \"Failed to allocate connection object\\n\");\n            return NULL;\n        }\n        MEMCACHED_CONN_CREATE(c);\n\n        c->rbuf = c->wbuf = 0;\n        c->ilist = 0;\n        c->suffixlist = 0;\n        c->iov = 0;\n        c->msglist = 0;\n        c->hdrbuf = 0;\n\n        c->rsize = read_buffer_size;\n        c->wsize = DATA_BUFFER_SIZE;\n        c->isize = ITEM_LIST_INITIAL;\n        c->suffixsize = SUFFIX_LIST_INITIAL;\n        c->iovsize = IOV_LIST_INITIAL;\n        c->msgsize = MSG_LIST_INITIAL;\n        c->hdrsize = 0;\n\n        c->rbuf = (char *)malloc((size_t)c->rsize);\n        c->wbuf = (char *)malloc((size_t)c->wsize);\n        c->ilist = (item **)malloc(sizeof(item *) * c->isize);\n        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);\n        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);\n        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);\n\n        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||\n                c->msglist == 0 || c->suffixlist == 0) {\n            conn_free(c);\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            fprintf(stderr, \"Failed to allocate buffers for connection\\n\");\n            return NULL;\n        }\n\n        STATS_LOCK();\n        stats.conn_structs++;\n        STATS_UNLOCK();\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    /* unix socket mode doesn't need this, so zeroed out.  but why\n     * is this done for every command?  presumably for UDP\n     * mode.  */\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            fprintf(stderr, \"<%d server listening (%s)\\n\", sfd,\n                prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            fprintf(stderr, \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            fprintf(stderr, \"<%d new auto-negotiating client connection\\n\",\n                    sfd);\n        } else if (c->protocol == ascii_prot) {\n            fprintf(stderr, \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            fprintf(stderr, \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            fprintf(stderr, \"<%d new unknown (%d) client connection\\n\",\n                sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (event_add(&c->event, 0) == -1) {\n        if (conn_add_to_freelist(c)) {\n            conn_free(c);\n        }\n        perror(\"event_add\");\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.curr_conns++;\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    return c;\n}",
        "target": 1,
        "cwe": [
            "CWE-287"
        ],
        "project": "memcached",
        "commit_id": "87c1cf0f20be20608d3becf854e9cf0910f4ad32",
        "hash": 158189747449452684365226999090928597129,
        "size": 128,
        "message": "explicitly record sasl auth states\n\nIt was previously possible to bypass authentication due to implicit\nstate management.  Now we explicitly consider ourselves\nunauthenticated on any new connections and authentication attempts.\n\nbug316\n\nSigned-off-by: Dustin Sallings <dustin@spy.net>"
    },
    {
        "func": "int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint i, pending_vec, max_bits;\n\tstruct descriptor_table dt;\n\n\tvcpu_load(vcpu);\n\n\tdt.limit = sregs->idt.limit;\n\tdt.base = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.limit = sregs->gdt.limit;\n\tdt.base = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= vcpu->arch.cr3 != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.shadow_efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\n\tmmu_reset_needed |= vcpu->arch.cr0 != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= vcpu->arch.cr4 != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu))\n\t\tload_pdptrs(vcpu, vcpu->arch.cr3);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tmemcpy(vcpu->arch.irq_pending, sregs->interrupt_bitmap,\n\t\t       sizeof vcpu->arch.irq_pending);\n\t\tvcpu->arch.irq_summary = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i)\n\t\t\tif (vcpu->arch.irq_pending[i])\n\t\t\t\t__set_bit(i, &vcpu->arch.irq_summary);\n\t} else {\n\t\tmax_bits = (sizeof sregs->interrupt_bitmap) << 3;\n\t\tpending_vec = find_first_bit(\n\t\t\t(const unsigned long *)sregs->interrupt_bitmap,\n\t\t\tmax_bits);\n\t\t/* Only pending external irq is handled here */\n\t\tif (pending_vec < max_bits) {\n\t\t\tkvm_x86_ops->set_irq(vcpu, pending_vec);\n\t\t\tpr_debug(\"Set back pending irq %d\\n\",\n\t\t\t\t pending_vec);\n\t\t}\n\t\tkvm_pic_clear_isr_ack(vcpu->kvm);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (vcpu->vcpu_id == 0 && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !(vcpu->arch.cr0 & X86_CR0_PE))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tvcpu_put(vcpu);\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "linux-2.6",
        "commit_id": "59839dfff5eabca01cc4e20b45797a60a80af8cb",
        "hash": 78960916356791946972283405912542599855,
        "size": 81,
        "message": "KVM: x86: check for cr3 validity in ioctl_set_sregs\n\nMatt T. Yourst notes that kvm_arch_vcpu_ioctl_set_sregs lacks validity\nchecking for the new cr3 value:\n\n\"Userspace callers of KVM_SET_SREGS can pass a bogus value of cr3 to\nthe kernel. This will trigger a NULL pointer access in gfn_to_rmap()\nwhen userspace next tries to call KVM_RUN on the affected VCPU and kvm\nattempts to activate the new non-existent page table root.\n\nThis happens since kvm only validates that cr3 points to a valid guest\nphysical memory page when code *inside* the guest sets cr3. However, kvm\ncurrently trusts the userspace caller (e.g. QEMU) on the host machine to\nalways supply a valid page table root, rather than properly validating\nit along with the rest of the reloaded guest state.\"\n\nhttp://sourceforge.net/tracker/?func=detail&atid=893831&aid=2687641&group_id=180599\n\nCheck for a valid cr3 address in kvm_arch_vcpu_ioctl_set_sregs, triple\nfault in case of failure.\n\nCc: stable@kernel.org\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>"
    },
    {
        "func": "int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\t__be16 dport;\n\tu8  tos;\n\tint err;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/* \n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags&MSG_OOB)\t/* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tipc.opt = NULL;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t \t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n \t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address. \n\t */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in * usin = (struct sockaddr_in*)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->daddr;\n\t\tdport = inet->dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n  \t}\n\tipc.addr = inet->saddr;\n\n\tipc.oif = sk->sk_bound_dev_if;\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t\tconnected = 0;\n\t}\n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->faddr;\n\t\tconnected = 0;\n\t}\n\ttos = RT_TOS(inet->tos);\n\tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n\t    (msg->msg_flags & MSG_DONTROUTE) || \n\t    (ipc.opt && ipc.opt->is_strictroute)) {\n\t\ttos |= RTO_ONLINK;\n\t\tconnected = 0;\n\t}\n\n\tif (MULTICAST(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t\tconnected = 0;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable*)sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct flowi fl = { .oif = ipc.oif,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = faddr,\n\t\t\t\t\t\t.saddr = saddr,\n\t\t\t\t\t\t.tos = tos } },\n\t\t\t\t    .proto = IPPROTO_UDP,\n\t\t\t\t    .uli_u = { .ports =\n\t\t\t\t\t       { .sport = inet->sport,\n\t\t\t\t\t\t .dport = dport } } };\n\t\tsecurity_sk_classify_flow(sk, &fl);\n\t\terr = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->u.dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = rt->rt_src;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = rt->rt_dst;\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tinet->cork.fl.fl4_dst = daddr;\n\tinet->cork.fl.fl_ip_dport = dport;\n\tinet->cork.fl.fl4_src = saddr;\n\tinet->cork.fl.fl_ip_sport = inet->sport;\n\tup->pending = AF_INET;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, ulen, \n\t\t\tsizeof(struct udphdr), &ipc, rt, \n\t\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk, up);\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS);\n\t\treturn len;\n\t}\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_SNDBUFERRORS);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->u.dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "linux-2.6",
        "commit_id": "1e0c14f49d6b393179f423abbac47f85618d3d46",
        "hash": 183549476359794434211501967710560191803,
        "size": 201,
        "message": "[UDP]: Fix MSG_PROBE crash\n\nUDP tracks corking status through the pending variable.  The\nIP layer also tracks it through the socket write queue.  It\nis possible for the two to get out of sync when MSG_PROBE is\nused.\n\nThis patch changes UDP to check the write queue to ensure\nthat the two stay in sync.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk, \n\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) msg->msg_name;\n\tstruct in6_addr *daddr, *final_p = NULL, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi fl;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\tint connected = 0;\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!up->pending) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &np->daddr;\n\t} else \n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_type(daddr) == IPV6_ADDR_MAPPED) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\tif (__ipv6_only_sock(sk))\n\t\t\t\treturn -ENETUNREACH;\n\t\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\t\t}\n\t}\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_build_xmit\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\t\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(&fl, 0, sizeof(fl));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl.fl_ip_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl.fl6_flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl.fl6_flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl.fl6_flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdaddr = &flowlabel->dst;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &np->daddr))\n\t\t\tdaddr = &np->daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    ipv6_addr_type(daddr)&IPV6_ADDR_LINKLOCAL)\n\t\t\tfl.oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl.fl_ip_dport = inet->dport;\n\t\tdaddr = &np->daddr;\n\t\tfl.fl6_flowlabel = np->flow_label;\n\t\tconnected = 1;\n\t}\n\n\tif (!fl.oif)\n\t\tfl.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\n\t\terr = datagram_send_ctl(msg, &fl, opt, &hlimit, &tclass);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl.fl6_flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl.fl6_flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (opt == NULL)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl.proto = IPPROTO_UDP;\n\tipv6_addr_copy(&fl.fl6_dst, daddr);\n\tif (ipv6_addr_any(&fl.fl6_src) && !ipv6_addr_any(&np->saddr))\n\t\tipv6_addr_copy(&fl.fl6_src, &np->saddr);\n\tfl.fl_ip_sport = inet->sport;\n\t\n\t/* merge ip6_build_xmit from ip6_output */\n\tif (opt && opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) opt->srcrt;\n\t\tipv6_addr_copy(&final, &fl.fl6_dst);\n\t\tipv6_addr_copy(&fl.fl6_dst, rt0->addr);\n\t\tfinal_p = &final;\n\t\tconnected = 0;\n\t}\n\n\tif (!fl.oif && ipv6_addr_is_multicast(&fl.fl6_dst)) {\n\t\tfl.oif = np->mcast_oif;\n\t\tconnected = 0;\n\t}\n\n\tsecurity_sk_classify_flow(sk, &fl);\n\n\terr = ip6_sk_dst_lookup(sk, &dst, &fl);\n\tif (err)\n\t\tgoto out;\n\tif (final_p)\n\t\tipv6_addr_copy(&fl.fl6_dst, final_p);\n\n\tif ((err = xfrm_lookup(&dst, &fl, sk, 0)) < 0)\n\t\tgoto out;\n\n\tif (hlimit < 0) {\n\t\tif (ipv6_addr_is_multicast(&fl.fl6_dst))\n\t\t\thlimit = np->mcast_hops;\n\t\telse\n\t\t\thlimit = np->hop_limit;\n\t\tif (hlimit < 0)\n\t\t\thlimit = dst_metric(dst, RTAX_HOPLIMIT);\n\t\tif (hlimit < 0)\n\t\t\thlimit = ipv6_get_hoplimit(dst->dev);\n\t}\n\n\tif (tclass < 0) {\n\t\ttclass = np->tclass;\n\t\tif (tclass < 0)\n\t\t\ttclass = 0;\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tup->pending = AF_INET6;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip6_append_data(sk, ip_generic_getfrag, msg->msg_iov, ulen,\n\t\tsizeof(struct udphdr), hlimit, tclass, opt, &fl,\n\t\t(struct rt6_info*)dst,\n\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk, up);\n\n\tif (dst) {\n\t\tif (connected) {\n\t\t\tip6_dst_store(sk, dst,\n\t\t\t\t      ipv6_addr_equal(&fl.fl6_dst, &np->daddr) ?\n\t\t\t\t      &np->daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\t      ipv6_addr_equal(&fl.fl6_src, &np->saddr) ?\n\t\t\t\t      &np->saddr :\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t}\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\nout:\n\tfl6_sock_release(flowlabel);\n\tif (!err) {\n\t\tUDP6_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS);\n\t\treturn len;\n\t}\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS_USER(UDP_MIB_SNDBUFERRORS);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "linux-2.6",
        "commit_id": "1e0c14f49d6b393179f423abbac47f85618d3d46",
        "hash": 45650607618055855236058038580909481118,
        "size": 279,
        "message": "[UDP]: Fix MSG_PROBE crash\n\nUDP tracks corking status through the pending variable.  The\nIP layer also tracks it through the socket write queue.  It\nis possible for the two to get out of sync when MSG_PROBE is\nused.\n\nThis patch changes UDP to check the write queue to ensure\nthat the two stay in sync.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\n\tme = current;\n\twrite_lock_irq(&tasklist_lock);\n\n\tparent = me->real_parent;\n\tret = -EPERM;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\n\t/* the keyrings must have the same UID */\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\n\t/* if there's an already pending keyring replacement, then we replace\n\t * that */\n\toldcred = parent->replacement_session_keyring;\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\n\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n\n#else /* !TIF_NOTIFY_RESUME */\n\t/*\n\t * To be removed when TIF_NOTIFY_RESUME has been implemented on\n\t * m68k/xtensa\n\t */\n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif /* !TIF_NOTIFY_RESUME */\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "linux-2.6",
        "commit_id": "9d1ac65a9698513d00e5608d93fca0c53f536c14",
        "hash": 212709001616641305112452556235346262714,
        "size": 96,
        "message": "KEYS: Fix RCU no-lock warning in keyctl_session_to_parent()\n\nThere's an protected access to the parent process's credentials in the middle\nof keyctl_session_to_parent().  This results in the following RCU warning:\n\n  ===================================================\n  [ INFO: suspicious rcu_dereference_check() usage. ]\n  ---------------------------------------------------\n  security/keys/keyctl.c:1291 invoked rcu_dereference_check() without protection!\n\n  other info that might help us debug this:\n\n  rcu_scheduler_active = 1, debug_locks = 0\n  1 lock held by keyctl-session-/2137:\n   #0:  (tasklist_lock){.+.+..}, at: [<ffffffff811ae2ec>] keyctl_session_to_parent+0x60/0x236\n\n  stack backtrace:\n  Pid: 2137, comm: keyctl-session- Not tainted 2.6.36-rc2-cachefs+ #1\n  Call Trace:\n   [<ffffffff8105606a>] lockdep_rcu_dereference+0xaa/0xb3\n   [<ffffffff811ae379>] keyctl_session_to_parent+0xed/0x236\n   [<ffffffff811af77e>] sys_keyctl+0xb4/0xb6\n   [<ffffffff81001eab>] system_call_fastpath+0x16/0x1b\n\nThe code should take the RCU read lock to make sure the parents credentials\ndon't go away, even though it's holding a spinlock and has IRQ disabled.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tparent = me->real_parent;\n\tret = -EPERM;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\n\t/* the keyrings must have the same UID */\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\n\t/* if there's an already pending keyring replacement, then we replace\n\t * that */\n\toldcred = parent->replacement_session_keyring;\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\n\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n\n#else /* !TIF_NOTIFY_RESUME */\n\t/*\n\t * To be removed when TIF_NOTIFY_RESUME has been implemented on\n\t * m68k/xtensa\n\t */\n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif /* !TIF_NOTIFY_RESUME */\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "linux-2.6",
        "commit_id": "3d96406c7da1ed5811ea52a3b0905f4f0e295376",
        "hash": 32494453156495132678173766772202466555,
        "size": 99,
        "message": "KEYS: Fix bug in keyctl_session_to_parent() if parent has no session keyring\n\nFix a bug in keyctl_session_to_parent() whereby it tries to check the ownership\nof the parent process's session keyring whether or not the parent has a session\nkeyring [CVE-2010-2960].\n\nThis results in the following oops:\n\n  BUG: unable to handle kernel NULL pointer dereference at 00000000000000a0\n  IP: [<ffffffff811ae4dd>] keyctl_session_to_parent+0x251/0x443\n  ...\n  Call Trace:\n   [<ffffffff811ae2f3>] ? keyctl_session_to_parent+0x67/0x443\n   [<ffffffff8109d286>] ? __do_fault+0x24b/0x3d0\n   [<ffffffff811af98c>] sys_keyctl+0xb4/0xb8\n   [<ffffffff81001eab>] system_call_fastpath+0x16/0x1b\n\nif the parent process has no session keyring.\n\nIf the system is using pam_keyinit then it mostly protected against this as all\nprocesses derived from a login will have inherited the session keyring created\nby pam_keyinit during the log in procedure.\n\nTo test this, pam_keyinit calls need to be commented out in /etc/pam.d/.\n\nReported-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\n{\n\tstruct kmem_cache *slab;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(slab_name_fmt, sizeof(slab_name_fmt), fmt, args);\n\tva_end(args);\n\n\tslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\n\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn slab;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "linux-2.6",
        "commit_id": "8ed030dd0aa400d18c63861c2c6deb7c38f4edde",
        "hash": 320108053811713184042279588874244274126,
        "size": 13,
        "message": "dccp: fix bug in cache allocation\n\nThis fixes a bug introduced in commit de4ef86cfce60d2250111f34f8a084e769f23b16\n(\"dccp: fix dccp rmmod when kernel configured to use slub\", 17 Jan): the\nvsnprintf used sizeof(slab_name_fmt), which became truncated to 4 bytes, since\nslab_name_fmt is now a 4-byte pointer and no longer a 32-character array.\n\nThis lead to error messages such as\n FATAL: Error inserting dccp: No buffer space available\n\n >> kernel: [ 1456.341501] kmem_cache_create: duplicate cache cci\ngenerated due to the truncation after the 3rd character.\n\nFixed for the moment by introducing a symbolic constant. Tested to fix the bug.\n\nSigned-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\"fits_decode_header: Not enough memory\", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \"SIMPLE  \", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \"XTENSION\", 8) == 0);\n if (hdulist->used.xtension)\n {\n   fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);\n   strcpy (hdulist->xtension, fdat->fstring);\n }\n\n FITS_DECODE_CARD (hdr, \"NAXIS\", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \"BITPIX\", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \"fits_decode_header: Invalid BITPIX-value\");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \"GCOUNT\", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \"PCOUNT\", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"GROUPS\", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \"EXTEND\", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \"fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \"NAXIS%-3d\", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \"fits_decode_header: Negative value in NAXISn\");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \"fits_decode_header: Random groups with NAXIS1 != 0\");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \"fits_decode_card: Not enough NAXISn-cards\");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \"BLANK\", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"DATAMIN\", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"DATAMAX\", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \"BZERO\", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"BSCALE\", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \"IMAGE\", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \"fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \"fits_decode_header: missing/invalid %s card\", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "gimp",
        "commit_id": "ace45631595e8781a1420842582d67160097163c",
        "hash": 151347541772924469029553648583479601544,
        "size": 187,
        "message": "Bug 676804 - file handling DoS for fit file format\n\nApply patch from joe@reactionis.co.uk which fixes a buffer overflow on\nbroken/malicious fits files."
    },
    {
        "func": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        goto cleanup;\n\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n\n    retval = 0;\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "krb5",
        "commit_id": "f249555301940c6df3a2cdda13b56b5674eebc2e",
        "hash": 17463996038393372793304480820087230473,
        "size": 35,
        "message": "PKINIT null pointer deref [CVE-2013-1415]\n\nDon't dereference a null pointer when cleaning up.\n\nThe KDC plugin for PKINIT can dereference a null pointer when a\nmalformed packet causes processing to terminate early, leading to\na crash of the KDC process.  An attacker would need to have a valid\nPKINIT certificate or have observed a successful PKINIT authentication,\nor an unauthenticated attacker could execute the attack if anonymous\nPKINIT is enabled.\n\nCVSSv2 vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:P/RL:O/RC:C\n\nThis is a minimal commit for pullup; style fixes in a followup.\n[kaduk@mit.edu: reformat and edit commit message]\n\n(cherry picked from commit c773d3c775e9b2d88bcdff5f8a8ba88d7ec4e8ed)\n\nticket: 7570\nversion_fixed: 1.11.1\nstatus: resolved"
    },
    {
        "func": "pkinit_server_return_padata(krb5_context context,\n                            krb5_pa_data * padata,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_kdc_rep * reply,\n                            krb5_keyblock * encrypting_key,\n                            krb5_pa_data ** send_pa,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_modreq modreq)\n{\n    krb5_error_code retval = 0;\n    krb5_data scratch = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    int i = 0;\n\n    unsigned char *subjectPublicKey = NULL;\n    unsigned char *dh_pubkey = NULL, *server_key = NULL;\n    unsigned int subjectPublicKey_len = 0;\n    unsigned int server_key_len = 0, dh_pubkey_len = 0;\n\n    krb5_kdc_dh_key_info dhkey_info;\n    krb5_data *encoded_dhkey_info = NULL;\n    krb5_pa_pk_as_rep *rep = NULL;\n    krb5_pa_pk_as_rep_draft9 *rep9 = NULL;\n    krb5_data *out_data = NULL;\n    krb5_octet_data secret;\n\n    krb5_enctype enctype = -1;\n\n    krb5_reply_key_pack *key_pack = NULL;\n    krb5_reply_key_pack_draft9 *key_pack9 = NULL;\n    krb5_data *encoded_key_pack = NULL;\n\n    pkinit_kdc_context plgctx;\n    pkinit_kdc_req_context reqctx;\n\n    int fixed_keypack = 0;\n\n    *send_pa = NULL;\n    if (padata->pa_type == KRB5_PADATA_PKINIT_KX) {\n        return return_pkinit_kx(context, request, reply,\n                                encrypting_key, send_pa);\n    }\n    if (padata->length <= 0 || padata->contents == NULL)\n        return 0;\n\n    if (modreq == NULL) {\n        pkiDebug(\"missing request context \\n\");\n        return EINVAL;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        pkiDebug(\"Unable to locate correct realm context\\n\");\n        return ENOENT;\n    }\n\n    pkiDebug(\"pkinit_return_padata: entered!\\n\");\n    reqctx = (pkinit_kdc_req_context)modreq;\n\n    if (encrypting_key->contents) {\n        free(encrypting_key->contents);\n        encrypting_key->length = 0;\n        encrypting_key->contents = NULL;\n    }\n\n    for(i = 0; i < request->nktypes; i++) {\n        enctype = request->ktype[i];\n        if (!krb5_c_valid_enctype(enctype))\n            continue;\n        else {\n            pkiDebug(\"KDC picked etype = %d\\n\", enctype);\n            break;\n        }\n    }\n\n    if (i == request->nktypes) {\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n\n    switch((int)reqctx->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        init_krb5_pa_pk_as_rep(&rep);\n        if (rep == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        /* let's assume it's RSA. we'll reset it to DH if needed */\n        rep->choice = choice_pa_pk_as_rep_encKeyPack;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        init_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (rep9 == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n        break;\n    default:\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n\n    if (reqctx->rcv_auth_pack != NULL &&\n        reqctx->rcv_auth_pack->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.length;\n        rep->choice = choice_pa_pk_as_rep_dhInfo;\n    } else if (reqctx->rcv_auth_pack9 != NULL &&\n               reqctx->rcv_auth_pack9->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.length;\n        rep9->choice = choice_pa_pk_as_rep_draft9_dhSignedData;\n    }\n\n    /* if this DH, then process finish computing DH key */\n    if (rep != NULL && (rep->choice == choice_pa_pk_as_rep_dhInfo ||\n                        rep->choice == choice_pa_pk_as_rep_draft9_dhSignedData)) {\n        pkiDebug(\"received DH key delivery AS REQ\\n\");\n        retval = server_process_dh(context, plgctx->cryptoctx,\n                                   reqctx->cryptoctx, plgctx->idctx, subjectPublicKey,\n                                   subjectPublicKey_len, &dh_pubkey, &dh_pubkey_len,\n                                   &server_key, &server_key_len);\n        if (retval) {\n            pkiDebug(\"failed to process/create dh paramters\\n\");\n            goto cleanup;\n        }\n    }\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /*\n         * This is DH, so don't generate the key until after we\n         * encode the reply, because the encoded reply is needed\n         * to generate the key in some cases.\n         */\n\n        dhkey_info.subjectPublicKey.length = dh_pubkey_len;\n        dhkey_info.subjectPublicKey.data = dh_pubkey;\n        dhkey_info.nonce = request->nonce;\n        dhkey_info.dhKeyExpiration = 0;\n\n        retval = k5int_encode_krb5_kdc_dh_key_info(&dhkey_info,\n                                                   &encoded_dhkey_info);\n        if (retval) {\n            pkiDebug(\"encode_krb5_kdc_dh_key_info failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_dhkey_info->data,\n                         encoded_dhkey_info->length,\n                         \"/tmp/kdc_dh_key_info\");\n#endif\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_SERVER, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep->u.dh_Info.dhSignedData.data,\n                                           &rep->u.dh_Info.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep9->u.dhSignedData.data,\n                                           &rep9->u.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        }\n\n    } else {\n        pkiDebug(\"received RSA key delivery AS REQ\\n\");\n\n        retval = krb5_c_make_random_key(context, enctype, encrypting_key);\n        if (retval) {\n            pkiDebug(\"unable to make a session key\\n\");\n            goto cleanup;\n        }\n\n        /* check if PA_TYPE of 132 is present which means the client is\n         * requesting that a checksum is send back instead of the nonce\n         */\n        for (i = 0; request->padata[i] != NULL; i++) {\n            pkiDebug(\"%s: Checking pa_type 0x%08x\\n\",\n                     __FUNCTION__, request->padata[i]->pa_type);\n            if (request->padata[i]->pa_type == 132)\n                fixed_keypack = 1;\n        }\n        pkiDebug(\"%s: return checksum instead of nonce = %d\\n\",\n                 __FUNCTION__, fixed_keypack);\n\n        /* if this is an RFC reply or draft9 client requested a checksum\n         * in the reply instead of the nonce, create an RFC-style keypack\n         */\n        if ((int)padata->pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack) {\n            init_krb5_reply_key_pack(&key_pack);\n            if (key_pack == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n\n            retval = krb5_c_make_checksum(context, 0,\n                                          encrypting_key, KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                          req_pkt, &key_pack->asChecksum);\n            if (retval) {\n                pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size = %d\\n\", req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"checksum size = %d\\n\", key_pack->asChecksum.length);\n            print_buffer(key_pack->asChecksum.contents,\n                         key_pack->asChecksum.length);\n            pkiDebug(\"encrypting key (%d)\\n\", encrypting_key->length);\n            print_buffer(encrypting_key->contents, encrypting_key->length);\n#endif\n\n            krb5_copy_keyblock_contents(context, encrypting_key,\n                                        &key_pack->replyKey);\n\n            retval = k5int_encode_krb5_reply_key_pack(key_pack,\n                                                      &encoded_key_pack);\n            if (retval) {\n                pkiDebug(\"failed to encode reply_key_pack\\n\");\n                goto cleanup;\n            }\n        }\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            rep->choice = choice_pa_pk_as_rep_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep->u.encKeyPack.data, &rep->u.encKeyPack.length);\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            /* if the request is from the broken draft9 client that\n             * expects back a nonce, create it now\n             */\n            if (!fixed_keypack) {\n                init_krb5_reply_key_pack_draft9(&key_pack9);\n                if (key_pack9 == NULL) {\n                    retval = ENOMEM;\n                    goto cleanup;\n                }\n                key_pack9->nonce = reqctx->rcv_auth_pack9->pkAuthenticator.nonce;\n                krb5_copy_keyblock_contents(context, encrypting_key,\n                                            &key_pack9->replyKey);\n\n                retval = k5int_encode_krb5_reply_key_pack_draft9(key_pack9,\n                                                                 &encoded_key_pack);\n                if (retval) {\n                    pkiDebug(\"failed to encode reply_key_pack\\n\");\n                    goto cleanup;\n                }\n            }\n\n            rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep9->u.encKeyPack.data, &rep9->u.encKeyPack.length);\n            break;\n        }\n        if (retval) {\n            pkiDebug(\"failed to create pkcs7 enveloped data: %s\\n\",\n                     error_message(retval));\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_key_pack->data,\n                         encoded_key_pack->length,\n                         \"/tmp/kdc_key_pack\");\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            print_buffer_bin(rep->u.encKeyPack.data,\n                             rep->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            print_buffer_bin(rep9->u.encKeyPack.data,\n                             rep9->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        }\n#endif\n    }\n\n    if ((rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo) &&\n        ((reqctx->rcv_auth_pack != NULL &&\n          reqctx->rcv_auth_pack->supportedKDFs != NULL))) {\n\n        /* If using the alg-agility KDF, put the algorithm in the reply\n         * before encoding it.\n         */\n        if (reqctx->rcv_auth_pack != NULL &&\n            reqctx->rcv_auth_pack->supportedKDFs != NULL) {\n            retval = pkinit_pick_kdf_alg(context, reqctx->rcv_auth_pack->supportedKDFs,\n                                         &(rep->u.dh_Info.kdfID));\n            if (retval) {\n                pkiDebug(\"pkinit_pick_kdf_alg failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_encode_krb5_pa_pk_as_rep(rep, &out_data);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_encode_krb5_pa_pk_as_rep_draft9(rep9, &out_data);\n        break;\n    }\n    if (retval) {\n        pkiDebug(\"failed to encode AS_REP\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    if (out_data != NULL)\n        print_buffer_bin((unsigned char *)out_data->data, out_data->length,\n                         \"/tmp/kdc_as_rep\");\n#endif\n\n    /* If this is DH, we haven't computed the key yet, so do it now. */\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /* If mutually supported KDFs were found, use the alg agility KDF */\n        if (rep->u.dh_Info.kdfID) {\n            secret.data = server_key;\n            secret.length = server_key_len;\n\n            retval = pkinit_alg_agility_kdf(context, &secret,\n                                            rep->u.dh_Info.kdfID,\n                                            request->client, request->server,\n                                            enctype,\n                                            (krb5_octet_data *)req_pkt,\n                                            (krb5_octet_data *)out_data,\n                                            encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_alg_agility_kdf failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n\n            /* Otherwise, use the older octetstring2key() function */\n        } else {\n            retval = pkinit_octetstring2key(context, enctype, server_key,\n                                            server_key_len, encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_octetstring2key failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    *send_pa = malloc(sizeof(krb5_pa_data));\n    if (*send_pa == NULL) {\n        retval = ENOMEM;\n        free(out_data->data);\n        free(out_data);\n        out_data = NULL;\n        goto cleanup;\n    }\n    (*send_pa)->magic = KV5M_PA_DATA;\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP;\n        break;\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP_OLD;\n        break;\n    }\n    (*send_pa)->length = out_data->length;\n    (*send_pa)->contents = (krb5_octet *) out_data->data;\n\ncleanup:\n    pkinit_fini_kdc_req_context(context, reqctx);\n    free(scratch.data);\n    free(out_data);\n    if (encoded_dhkey_info != NULL)\n        krb5_free_data(context, encoded_dhkey_info);\n    if (encoded_key_pack != NULL)\n        krb5_free_data(context, encoded_key_pack);\n    free(dh_pubkey);\n    free(server_key);\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free_krb5_pa_pk_as_rep(&rep);\n        free_krb5_reply_key_pack(&key_pack);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n        free_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (!fixed_keypack)\n            free_krb5_reply_key_pack_draft9(&key_pack9);\n        else\n            free_krb5_reply_key_pack(&key_pack);\n        break;\n    }\n\n    if (retval)\n        pkiDebug(\"pkinit_verify_padata failure\");\n\n    return retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "krb5",
        "commit_id": "db64ca25d661a47b996b4e2645998b5d7f0eb52c",
        "hash": 294524456664462837780427533642006267159,
        "size": 443,
        "message": "PKINIT (draft9) null ptr deref [CVE-2012-1016]\n\nDon't check for an agility KDF identifier in the non-draft9 reply\nstructure when we're building a draft9 reply, because it'll be NULL.\n\nThe KDC plugin for PKINIT can dereference a null pointer when handling\na draft9 request, leading to a crash of the KDC process.  An attacker\nwould need to have a valid PKINIT certificate, or an unauthenticated\nattacker could execute the attack if anonymous PKINIT is enabled.\n\nCVSSv2 vector: AV:N/AC:M/Au:N/C:N/I:N/A:P/E:P/RL:O/RC:C\n\n[tlyu@mit.edu: reformat comment and edit log message]\n\n(back ported from commit cd5ff932c9d1439c961b0cf9ccff979356686aff)\n\nticket: 7527 (new)\nversion_fixed: 1.10.4\nstatus: resolved"
    },
    {
        "func": "prep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH;\n    char **realms, **cpp, *temp_buf=NULL;\n    krb5_data *comp1 = NULL, *comp2 = NULL;\n    char *comp1_str = NULL;\n\n    /* By now we know that server principal name is unknown.\n     * If CANONICALIZE flag is set in the request\n     * If req is not U2U authn. req\n     * the requested server princ. has exactly two components\n     * either\n     *      the name type is NT-SRV-HST\n     *      or name type is NT-UNKNOWN and\n     *         the 1st component is listed in conf file under host_based_services\n     * the 1st component is not in a list in conf under \"no_host_referral\"\n     * the 2d component looks like fully-qualified domain name (FQDN)\n     * If all of these conditions are satisfied - try mapping the FQDN and\n     * re-process the request as if client had asked for cross-realm TGT.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE) &&\n        !isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY) &&\n        krb5_princ_size(kdc_context, request->server) == 2) {\n\n        comp1 = krb5_princ_component(kdc_context, request->server, 0);\n        comp2 = krb5_princ_component(kdc_context, request->server, 1);\n\n        comp1_str = calloc(1,comp1->length+1);\n        if (!comp1_str) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        strlcpy(comp1_str,comp1->data,comp1->length+1);\n\n        if ((krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_HST ||\n             krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_INST ||\n             (krb5_princ_type(kdc_context, request->server) == KRB5_NT_UNKNOWN &&\n              kdc_active_realm->realm_host_based_services != NULL &&\n              (krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         comp1_str) == TRUE ||\n               krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         KRB5_CONF_ASTERISK) == TRUE))) &&\n            (kdc_active_realm->realm_no_host_referral == NULL ||\n             (krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        KRB5_CONF_ASTERISK) == FALSE &&\n              krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        comp1_str) == FALSE))) {\n\n            if (memchr(comp2->data, '.', comp2->length) == NULL)\n                goto cleanup;\n            temp_buf = calloc(1, comp2->length+1);\n            if (!temp_buf) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n            strlcpy(temp_buf, comp2->data,comp2->length+1);\n            retval = krb5int_get_domain_realm_mapping(kdc_context, temp_buf, &realms);\n            free(temp_buf);\n            if (retval) {\n                /* no match found */\n                kdc_err(kdc_context, retval, \"unable to find realm of host\");\n                goto cleanup;\n            }\n            if (realms == 0) {\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Don't return a referral to the null realm or the service\n             * realm. */\n            if (realms[0] == 0 ||\n                data_eq_string(request->server->realm, realms[0])) {\n                free(realms[0]);\n                free(realms);\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Modify request.\n             * Construct cross-realm tgt :  krbtgt/REMOTE_REALM@LOCAL_REALM\n             * and use it as a principal in this req.\n             */\n            retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                          (*request->server).realm.length,\n                                          (*request->server).realm.data,\n                                          \"krbtgt\", realms[0], (char *)0);\n            for (cpp = realms; *cpp; cpp++)\n                free(*cpp);\n        }\n    }\ncleanup:\n    free(comp1_str);\n\n    return retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-476",
            "CWE-119"
        ],
        "project": "krb5",
        "commit_id": "8ee70ec63931d1e38567905387ab9b1d45734d81",
        "hash": 276397861067898738547287107829639614722,
        "size": 93,
        "message": "KDC TGS-REQ null deref [CVE-2013-1416]\n\nBy sending an unusual but valid TGS-REQ, an authenticated remote\nattacker can cause the KDC process to crash by dereferencing a null\npointer.\n\nprep_reprocess_req() can cause a null pointer dereference when\nprocessing a service principal name.  Code in this function can\ninappropriately pass a null pointer to strlcpy().  Unmodified client\nsoftware can trivially trigger this vulnerability, but the attacker\nmust have already authenticated and received a valid Kerberos ticket.\n\nThe vulnerable code was introduced by the implementation of new\nservice principal realm referral functionality in krb5-1.7, but was\ncorrected as a side effect of the KDC refactoring in krb5-1.11.\n\nCVSSv2 vector: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:H/RL:O/RC:C\n\nticket: 7600 (new)\nversion_fixed: 1.10.5\nstatus: resolved"
    },
    {
        "func": "static apr_status_t modsecurity_request_body_store_memory(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    *error_msg = NULL;\n\n    /* Would storing this chunk mean going over the limit? */\n    if ((msr->msc_reqbody_spilltodisk)\n        && (msr->msc_reqbody_length + length > (apr_size_t)msr->txcfg->reqbody_inmemory_limit))\n    {\n        msc_data_chunk **chunks;\n        unsigned int disklen = 0;\n        int i;\n\n        msr_log(msr, 4, \"Input filter: Request too large to store in memory, switching to disk.\");\n\n        /* NOTE Must use modsecurity_request_body_store_disk() here\n         *      to prevent data to be sent to the streaming\n         *      processors again.\n         */\n\n        /* Initialise disk storage */\n        msr->msc_reqbody_storage = MSC_REQBODY_DISK;\n        if (modsecurity_request_body_start_init(msr, error_msg) < 0) return -1;\n\n        /* Write the data we keep in memory */\n        chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n            disklen += chunks[i]->length;\n\n            if (modsecurity_request_body_store_disk(msr, chunks[i]->data, chunks[i]->length, error_msg) < 0) {\n                return -1;\n            }\n\n            free(chunks[i]->data);\n            chunks[i]->data = NULL;\n        }\n\n        /* Clear the memory pool as we no longer need the bits. */\n\n        /* IMP1 But since we only used apr_pool_clear memory might\n         * not be released back to the OS straight away?\n         */\n        msr->msc_reqbody_chunks = NULL;\n        apr_pool_clear(msr->msc_reqbody_mp);\n\n        msr_log(msr, 4, \"Input filter: Wrote %u bytes from memory to disk.\", disklen);\n\n        /* Continue with disk storage from now on */\n        return modsecurity_request_body_store_disk(msr, data, length, error_msg);\n    }\n\n    /* If we're here that means we are not over the\n     * request body in-memory limit yet.\n     */\n    {\n        unsigned long int bucket_offset, bucket_left;\n\n        bucket_offset = 0;\n        bucket_left = length;\n\n        /* Although we store the request body in chunks we don't\n         * want to use the same chunk sizes as the incoming memory\n         * buffers. They are often of very small sizes and that\n         * would make us waste a lot of memory. That's why we\n         * use our own chunks of CHUNK_CAPACITY sizes.\n         */\n\n        /* Loop until we empty this bucket into our chunks. */\n        while(bucket_left > 0) {\n            /* Allocate a new chunk if we have to. */\n            if (msr->msc_reqbody_chunk_current == NULL) {\n                msr->msc_reqbody_chunk_current = (msc_data_chunk *)\n                    apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n                if (msr->msc_reqbody_chunk_current == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %lu bytes \"\n                        \"for request body chunk.\", (unsigned long)sizeof(msc_data_chunk));\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->data = malloc(CHUNK_CAPACITY);\n                if (msr->msc_reqbody_chunk_current->data == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %d bytes \"\n                        \"for request body chunk data.\", CHUNK_CAPACITY);\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->length = 0;\n                msr->msc_reqbody_chunk_current->is_permanent = 1;\n\n                *(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks)\n                    = msr->msc_reqbody_chunk_current;\n            }\n\n            if (bucket_left < (CHUNK_CAPACITY - msr->msc_reqbody_chunk_current->length)) {\n                /* There's enough space in the current chunk. */\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, bucket_left);\n                msr->msc_reqbody_chunk_current->length += bucket_left;\n                bucket_left = 0;\n            } else {\n                /* Fill the existing chunk. */\n                unsigned long int copy_length = CHUNK_CAPACITY -\n                    msr->msc_reqbody_chunk_current->length;\n\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, copy_length);\n                bucket_offset += copy_length;\n                bucket_left -= copy_length;\n                msr->msc_reqbody_chunk_current->length += copy_length;\n\n                /* We're done with this chunk. Setting the pointer\n                 * to NULL is going to force a new chunk to be allocated\n                 * on the next go.\n                 */\n                msr->msc_reqbody_chunk_current = NULL;\n            }\n        }\n\n        msr->msc_reqbody_length += length;\n    }\n\n    return 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "ModSecurity",
        "commit_id": "0840b13612a0b7ef1ce7441cf811dcfc6b463fba",
        "hash": 95274627580981523202820140827991029609,
        "size": 123,
        "message": "Fixed: chuck null pointer when unknown CT is sent and over in-memory limit"
    },
    {
        "func": "void credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)\n{\n\tint length;\n\n\tlength = credssp_skip_ts_password_creds(credssp);\n\n\t/* TSPasswordCreds (SEQUENCE) */\n\tlength = ber_get_content_length(length);\n\tber_write_sequence_tag(s, length);\n\n\t/* [0] domainName (OCTET STRING) */\n\tber_write_contextual_tag(s, 0, credssp->identity.DomainLength * 2 + 2, TRUE);\n\tber_write_octet_string(s, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);\n\n\t/* [1] userName (OCTET STRING) */\n\tber_write_contextual_tag(s, 1, credssp->identity.UserLength * 2 + 2, TRUE);\n\tber_write_octet_string(s, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);\n\n\t/* [2] password (OCTET STRING) */\n\tber_write_contextual_tag(s, 2, credssp->identity.PasswordLength * 2 + 2, TRUE);\n\tber_write_octet_string(s, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "FreeRDP",
        "commit_id": "0dc22d5a30a1c7d146b2a835b2032668127c33e9",
        "hash": 305315726435241119258403736483377281783,
        "size": 22,
        "message": "Fixed a range of BER boundary encoding bugs which would occur when any NLA packet hit the 127 character mark. Removed ber#get_content_length as it was not behaving deterministically."
    },
    {
        "func": "int credssp_skip_ts_credentials(rdpCredssp* credssp)\n{\n\tint length;\n\tint ts_password_creds_length;\n\tint ts_credentials_length = 0;\n\n\tlength = ber_skip_integer(0);\n\tlength += ber_skip_contextual_tag(length);\n\tts_credentials_length += length;\n\n\tts_password_creds_length = credssp_skip_ts_password_creds(credssp);\n\tlength = ber_skip_octet_string(ts_password_creds_length);\n\tlength += ber_skip_contextual_tag(length);\n\tts_credentials_length += length;\n\n\tlength = ber_skip_sequence(ts_credentials_length);\n\n\treturn length;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "FreeRDP",
        "commit_id": "0dc22d5a30a1c7d146b2a835b2032668127c33e9",
        "hash": 169894807870186687086425668721475346336,
        "size": 19,
        "message": "Fixed a range of BER boundary encoding bugs which would occur when any NLA packet hit the 127 character mark. Removed ber#get_content_length as it was not behaving deterministically."
    },
    {
        "func": "int credssp_skip_auth_info(int length)\n{\n\tlength = ber_skip_octet_string(length);\n\tlength += ber_skip_contextual_tag(length);\n\treturn length;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "FreeRDP",
        "commit_id": "0dc22d5a30a1c7d146b2a835b2032668127c33e9",
        "hash": 330256248638008053892513803195715466430,
        "size": 6,
        "message": "Fixed a range of BER boundary encoding bugs which would occur when any NLA packet hit the 127 character mark. Removed ber#get_content_length as it was not behaving deterministically."
    },
    {
        "func": "int _ber_skip_length(int length)\n{\n\tif (length > 0x80)\n\t\treturn 3;\n\telse\n\t\treturn 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "FreeRDP",
        "commit_id": "0dc22d5a30a1c7d146b2a835b2032668127c33e9",
        "hash": 141920442151598610019259549059450167986,
        "size": 7,
        "message": "Fixed a range of BER boundary encoding bugs which would occur when any NLA packet hit the 127 character mark. Removed ber#get_content_length as it was not behaving deterministically."
    },
    {
        "func": "int ber_skip_contextual_tag(int length)\n{\n\treturn _ber_skip_length(length) + 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-476"
        ],
        "project": "FreeRDP",
        "commit_id": "0dc22d5a30a1c7d146b2a835b2032668127c33e9",
        "hash": 280924585747336345392601046327376120658,
        "size": 4,
        "message": "Fixed a range of BER boundary encoding bugs which would occur when any NLA packet hit the 127 character mark. Removed ber#get_content_length as it was not behaving deterministically."
    },
    {
        "func": "static tool_rc key_import(ESYS_CONTEXT *ectx, TPM2B_PUBLIC *parent_pub,\n        TPM2B_SENSITIVE *privkey, TPM2B_PUBLIC *pubkey,\n        TPM2B_ENCRYPTED_SECRET *encrypted_seed,\n        TPM2B_PRIVATE **imported_private) {\n\n    TPMI_ALG_HASH name_alg = pubkey->publicArea.nameAlg;\n\n    TPM2B_DIGEST *seed = &privkey->sensitiveArea.seedValue;\n\n    /*\n     * Create the protection encryption key that gets encrypted with the parents public key.\n     */\n    TPM2B_DATA enc_sensitive_key = {\n        .size = parent_pub->publicArea.parameters.rsaDetail.symmetric.keyBits.sym / 8\n    };\n    memset(enc_sensitive_key.buffer, 0xFF, enc_sensitive_key.size);\n\n    /*\n     * Calculate the object name.\n     */\n    TPM2B_NAME pubname = TPM2B_TYPE_INIT(TPM2B_NAME, name);\n    bool res = tpm2_identity_create_name(pubkey, &pubname);\n    if (!res) {\n        return false;\n    }\n\n    TPM2B_MAX_BUFFER hmac_key;\n    TPM2B_MAX_BUFFER enc_key;\n    tpm2_identity_util_calc_outer_integrity_hmac_key_and_dupsensitive_enc_key(\n            parent_pub, &pubname, seed, &hmac_key, &enc_key);\n\n    TPM2B_MAX_BUFFER encrypted_inner_integrity = TPM2B_EMPTY_INIT;\n    tpm2_identity_util_calculate_inner_integrity(name_alg, privkey, &pubname,\n            &enc_sensitive_key,\n            &parent_pub->publicArea.parameters.rsaDetail.symmetric,\n            &encrypted_inner_integrity);\n\n    TPM2B_DIGEST outer_hmac = TPM2B_EMPTY_INIT;\n    TPM2B_MAX_BUFFER encrypted_duplicate_sensitive = TPM2B_EMPTY_INIT;\n    tpm2_identity_util_calculate_outer_integrity(parent_pub->publicArea.nameAlg,\n            &pubname, &encrypted_inner_integrity, &hmac_key, &enc_key,\n            &parent_pub->publicArea.parameters.rsaDetail.symmetric,\n            &encrypted_duplicate_sensitive, &outer_hmac);\n\n    TPM2B_PRIVATE private = TPM2B_EMPTY_INIT;\n    res = create_import_key_private_data(&private, parent_pub->publicArea.nameAlg,\n            &encrypted_duplicate_sensitive, &outer_hmac);\n    if (!res) {\n        return tool_rc_general_error;\n    }\n\n    TPMT_SYM_DEF_OBJECT *sym_alg =\n            &parent_pub->publicArea.parameters.rsaDetail.symmetric;\n\n    if (!ctx.cp_hash_path) {\n        return tpm2_import(ectx, &ctx.parent.object, &enc_sensitive_key, pubkey,\n            &private, encrypted_seed, sym_alg, imported_private, NULL);\n    }\n\n    TPM2B_DIGEST cp_hash = { .size = 0 };\n    tool_rc rc = tpm2_import(ectx, &ctx.parent.object, &enc_sensitive_key, pubkey,\n            &private, encrypted_seed, sym_alg, imported_private, &cp_hash);\n    if (rc != tool_rc_success) {\n        return rc;\n    }\n\n    bool result = files_save_digest(&cp_hash, ctx.cp_hash_path);\n    if (!result) {\n        rc = tool_rc_general_error;\n    }\n    return rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 114458988769440328707750099592417488417,
        "size": 72,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static tool_rc key_import(ESYS_CONTEXT *ectx, TPM2B_PUBLIC *parent_pub,\n        TPM2B_SENSITIVE *privkey, TPM2B_PUBLIC *pubkey,\n        TPM2B_ENCRYPTED_SECRET *encrypted_seed,\n        TPM2B_PRIVATE **imported_private) {\n\n    TPMI_ALG_HASH name_alg = pubkey->publicArea.nameAlg;\n\n    TPM2B_DIGEST *seed = &privkey->sensitiveArea.seedValue;\n\n    /*\n     * Create the protection encryption key that gets encrypted with the parents public key.\n     */\n    TPM2B_DATA enc_sensitive_key = {\n        .size = parent_pub->publicArea.parameters.rsaDetail.symmetric.keyBits.sym / 8\n    };\n\n    if(enc_sensitive_key.size < 16) {\n        LOG_ERR(\"Calculated wrapping keysize is less than 16 bytes, got: %u\", enc_sensitive_key.size);\n        return tool_rc_general_error;\n    }\n\n    int ossl_rc = RAND_bytes(enc_sensitive_key.buffer, enc_sensitive_key.size);\n    if (ossl_rc != 1) {\n        LOG_ERR(\"RAND_bytes failed: %s\", ERR_error_string(ERR_get_error(), NULL));\n        return tool_rc_general_error;\n    }\n\n    /*\n     * Calculate the object name.\n     */\n    TPM2B_NAME pubname = TPM2B_TYPE_INIT(TPM2B_NAME, name);\n    bool res = tpm2_identity_create_name(pubkey, &pubname);\n    if (!res) {\n        return false;\n    }\n\n    TPM2B_MAX_BUFFER hmac_key;\n    TPM2B_MAX_BUFFER enc_key;\n    tpm2_identity_util_calc_outer_integrity_hmac_key_and_dupsensitive_enc_key(\n            parent_pub, &pubname, seed, &hmac_key, &enc_key);\n\n    TPM2B_MAX_BUFFER encrypted_inner_integrity = TPM2B_EMPTY_INIT;\n    tpm2_identity_util_calculate_inner_integrity(name_alg, privkey, &pubname,\n            &enc_sensitive_key,\n            &parent_pub->publicArea.parameters.rsaDetail.symmetric,\n            &encrypted_inner_integrity);\n\n    TPM2B_DIGEST outer_hmac = TPM2B_EMPTY_INIT;\n    TPM2B_MAX_BUFFER encrypted_duplicate_sensitive = TPM2B_EMPTY_INIT;\n    tpm2_identity_util_calculate_outer_integrity(parent_pub->publicArea.nameAlg,\n            &pubname, &encrypted_inner_integrity, &hmac_key, &enc_key,\n            &parent_pub->publicArea.parameters.rsaDetail.symmetric,\n            &encrypted_duplicate_sensitive, &outer_hmac);\n\n    TPM2B_PRIVATE private = TPM2B_EMPTY_INIT;\n    res = create_import_key_private_data(&private, parent_pub->publicArea.nameAlg,\n            &encrypted_duplicate_sensitive, &outer_hmac);\n    if (!res) {\n        return tool_rc_general_error;\n    }\n\n    TPMT_SYM_DEF_OBJECT *sym_alg =\n            &parent_pub->publicArea.parameters.rsaDetail.symmetric;\n\n    if (!ctx.cp_hash_path) {\n        return tpm2_import(ectx, &ctx.parent.object, &enc_sensitive_key, pubkey,\n            &private, encrypted_seed, sym_alg, imported_private, NULL);\n    }\n\n    TPM2B_DIGEST cp_hash = { .size = 0 };\n    tool_rc rc = tpm2_import(ectx, &ctx.parent.object, &enc_sensitive_key, pubkey,\n            &private, encrypted_seed, sym_alg, imported_private, &cp_hash);\n    if (rc != tool_rc_success) {\n        return rc;\n    }\n\n    bool result = files_save_digest(&cp_hash, ctx.cp_hash_path);\n    if (!result) {\n        rc = tool_rc_general_error;\n    }\n    return rc;\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 340013066813219424515003571948033001251,
        "size": 82,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static tool_rc tpm2_tool_onstop(ESYS_CONTEXT *ectx) {\n    UNUSED(ectx);\n\n    if (!ctx.import_tpm) {\n        return tool_rc_success;\n    }\n\n    return tpm2_session_close(&ctx.parent.object.session);\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 110818980950486400821099263736564641827,
        "size": 9,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static tool_rc tpm_import(ESYS_CONTEXT *ectx) {\n\n    TPM2B_DATA enc_key = TPM2B_EMPTY_INIT;\n    TPM2B_PUBLIC public = TPM2B_EMPTY_INIT;\n    TPM2B_PRIVATE duplicate;\n    TPM2B_ENCRYPTED_SECRET encrypted_seed;\n    TPM2B_PRIVATE *imported_private = NULL;\n    TPMT_SYM_DEF_OBJECT sym_alg;\n\n    tool_rc rc;\n    bool result = set_key_algorithm(ctx.key_type, &sym_alg);\n    if (!result) {\n        return tool_rc_general_error;\n    }\n\n    /* Symmetric key */\n    if (ctx.input_enc_key_file) {\n        enc_key.size = 16;\n        result = files_load_bytes_from_path(ctx.input_enc_key_file,\n                enc_key.buffer, &enc_key.size);\n        if (!result) {\n            LOG_ERR(\"Failed to load symmetric encryption key\\\"%s\\\"\",\n                    ctx.input_enc_key_file);\n            return tool_rc_general_error;\n        }\n        if (enc_key.size != 16) {\n            LOG_ERR(\"Invalid AES key size, got %u bytes, expected 16\",\n                    enc_key.size);\n            return tool_rc_general_error;\n        }\n    }\n\n    /* Private key */\n    result = files_load_private(ctx.input_key_file, &duplicate);\n    if (!result) {\n        LOG_ERR(\"Failed to load duplicate \\\"%s\\\"\", ctx.input_key_file);\n        return tool_rc_general_error;\n    }\n\n    /* Encrypted seed */\n    result = files_load_encrypted_seed(ctx.input_seed_file, &encrypted_seed);\n    if (!result) {\n        LOG_ERR(\"Failed to load encrypted seed \\\"%s\\\"\", ctx.input_seed_file);\n        return tool_rc_general_error;\n    }\n\n    /* Public key */\n    result = files_load_public(ctx.public_key_file, &public);\n    if (!result) {\n        LOG_ERR(\":( Failed to load public key \\\"%s\\\"\", ctx.public_key_file);\n        return tool_rc_general_error;\n    }\n\n    if (ctx.policy) {\n        public.publicArea.authPolicy.size =\n            sizeof(public.publicArea.authPolicy.buffer);\n        result = files_load_bytes_from_path(ctx.policy,\n        public.publicArea.authPolicy.buffer,\n        &public.publicArea.authPolicy.size);\n        if (!result) {\n            LOG_ERR(\"Failed to copy over the auth policy to the public data\");\n            return tool_rc_general_error;\n        }\n    }\n\n    if (!ctx.cp_hash_path) {\n        rc = tpm2_import(ectx, &ctx.parent.object, &enc_key, &public, &duplicate,\n            &encrypted_seed, &sym_alg, &imported_private, NULL);\n        if (rc != tool_rc_success) {\n            return rc;\n        }\n\n        assert(imported_private);\n\n        result = files_save_private(imported_private, ctx.private_key_file);\n        free(imported_private);\n        if (!result) {\n            LOG_ERR(\"Failed to save private key into file \\\"%s\\\"\",\n                    ctx.private_key_file);\n            return tool_rc_general_error;\n        }\n        return tool_rc_success;\n    }\n\n    TPM2B_DIGEST cp_hash = { .size = 0 };\n    rc = tpm2_import(ectx, &ctx.parent.object, &enc_key, &public, &duplicate,\n            &encrypted_seed, &sym_alg, &imported_private, &cp_hash);\n    if (rc != tool_rc_success) {\n        return rc;\n    }\n\n    result = files_save_digest(&cp_hash, ctx.cp_hash_path);\n    if (!result) {\n        rc = tool_rc_general_error;\n    }\n    return rc;\n\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 333766084005457820409002298322451792450,
        "size": 98,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static bool tpm2_tool_onstart(tpm2_options **opts) {\n\n    const struct option topts[] = {\n      { \"parent-auth\",        required_argument, NULL, 'P'},\n      { \"key-auth\",           required_argument, NULL, 'p'},\n      { \"key-algorithm\",      required_argument, NULL, 'G'},\n      { \"input\",              required_argument, NULL, 'i'},\n      { \"parent-context\",     required_argument, NULL, 'C'},\n      { \"parent-public\",      required_argument, NULL, 'U'},\n      { \"private\",            required_argument, NULL, 'r'},\n      { \"public\",             required_argument, NULL, 'u'},\n      { \"attributes\",  required_argument, NULL, 'a'},\n      { \"hash-algorithm\",     required_argument, NULL, 'g'},\n      { \"seed\",               required_argument, NULL, 's'},\n      { \"policy\",             required_argument, NULL, 'L'},\n      { \"encryption-key\",     required_argument, NULL, 'k'},\n      { \"passin\",             required_argument, NULL,  0 },\n      { \"cphash\",             required_argument, NULL,  1 },\n    };\n\n    *opts = tpm2_options_new(\"P:p:G:i:C:U:u:r:a:g:s:L:k:\", ARRAY_LEN(topts),\n            topts, on_option, NULL, 0);\n\n    return *opts != NULL;\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 219200317735500633728331009849228529134,
        "size": 25,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static tool_rc openssl_import(ESYS_CONTEXT *ectx) {\n\n    /*\n     * Load the parent public file, or read it from the TPM if not specified.\n     * We need this information for encrypting the protection seed.\n     */\n    bool free_ppub = false;\n    tool_rc tmp_rc;\n    tool_rc rc = tool_rc_general_error;\n    TPM2B_PUBLIC ppub = TPM2B_EMPTY_INIT;\n    TPM2B_PUBLIC *parent_pub = NULL;\n\n    bool result;\n    tmp_rc = tool_rc_general_error;\n    if (ctx.parent_key_public_file) {\n        result = files_load_public(ctx.parent_key_public_file, &ppub);\n        parent_pub = &ppub;\n    } else {\n        tmp_rc = readpublic(ectx, ctx.parent.object.tr_handle, &parent_pub);\n        free_ppub = true;\n        result = tmp_rc == tool_rc_success;\n    }\n    if (!result) {\n        LOG_ERR(\"Failed loading parent key public.\");\n        return tmp_rc;\n    }\n\n    TPM2B_SENSITIVE private = TPM2B_EMPTY_INIT;\n    TPM2B_PUBLIC public = TPM2B_EMPTY_INIT;\n    TPM2B_ENCRYPTED_SECRET encrypted_seed = TPM2B_EMPTY_INIT;\n\n    result = tpm2_openssl_import_keys(\n        parent_pub,\n        &private,\n        &public,\n        &encrypted_seed,\n        ctx.input_key_file,\n        ctx.key_type,\n        ctx.auth_key_file,\n        ctx.policy,\n        ctx.key_auth_str,\n        ctx.attrs,\n        ctx.name_alg\n    );\n    if (!result)\n        goto out;\n\n    TPM2B_PRIVATE *imported_private = NULL;\n    tmp_rc = key_import(ectx, parent_pub, &private, &public, &encrypted_seed,\n            &imported_private);\n    if (tmp_rc != tool_rc_success || ctx.cp_hash_path) {\n        rc = tmp_rc;\n        goto keyout;\n    }\n\n    /*\n     * Save the public and imported_private structure to disk\n     */\n    result = files_save_public(&public, ctx.public_key_file);\n    if (!result) {\n        goto keyout;\n    }\n\n    result = files_save_private(imported_private, ctx.private_key_file);\n    if (!result) {\n        goto keyout;\n    }\n\n    /*\n     * Output the stats on the created object on Success.\n     */\n    tpm2_util_public_to_yaml(&public, NULL);\n\n    rc = tool_rc_success;\n\nkeyout:\n    free(imported_private);\nout:\n    if (free_ppub) {\n        free(parent_pub);\n    }\n\n    return rc;\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 158592714989411981589655076957091453565,
        "size": 84,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static bool create_import_key_private_data(TPM2B_PRIVATE *private,\n        TPMI_ALG_HASH parent_name_alg,\n        TPM2B_MAX_BUFFER *encrypted_duplicate_sensitive,\n        TPM2B_DIGEST *outer_hmac) {\n\n    //UINT16 hash_size = tpm2_alg_util_get_hash_size(ctx.name_alg);\n    UINT16 parent_hash_size = tpm2_alg_util_get_hash_size(parent_name_alg);\n\n    private->size = sizeof(parent_hash_size) + parent_hash_size\n            + encrypted_duplicate_sensitive->size;\n\n    size_t hmac_size_offset = 0;\n    TSS2_RC rval = Tss2_MU_UINT16_Marshal(parent_hash_size, private->buffer,\n            sizeof(parent_hash_size), &hmac_size_offset);\n    if (rval != TPM2_RC_SUCCESS)\n    {\n        LOG_ERR(\"Error serializing parent hash size\");\n        return false;\n    }\n\n    memcpy(private->buffer + hmac_size_offset, outer_hmac->buffer,\n            parent_hash_size);\n    memcpy(private->buffer + hmac_size_offset + parent_hash_size,\n            encrypted_duplicate_sensitive->buffer,\n            encrypted_duplicate_sensitive->size);\n\n    return true;\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 231583505162179933394962615690734198158,
        "size": 28,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static bool set_key_algorithm(TPMI_ALG_PUBLIC alg, TPMT_SYM_DEF_OBJECT * obj) {\n    bool result = true;\n    switch (alg) {\n    case TPM2_ALG_AES:\n        obj->algorithm = TPM2_ALG_AES;\n        obj->keyBits.aes = 128;\n        obj->mode.aes = TPM2_ALG_CFB;\n        break;\n    case TPM2_ALG_NULL:\n        obj->algorithm = TPM2_ALG_NULL;\n        break;\n    default:\n        LOG_ERR(\"The algorithm type input(0x%x) is not supported!\", alg);\n        result = false;\n        break;\n    }\n    return result;\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 248722862933271511543435637002231497855,
        "size": 18,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static tool_rc check_options(void) {\n\n    tool_rc rc = tool_rc_success;\n\n    /* Check the tpm import specific options */\n    if (ctx.import_tpm) {\n        if (!ctx.input_seed_file) {\n            LOG_ERR(\"Expected SymSeed to be specified via \\\"-s\\\",\"\n                    \" missing option.\");\n            rc = tool_rc_option_error;\n        }\n\n        /* If a key file is specified we choose aes else null\n         for symmetricAlgdefinition */\n        if (!ctx.input_enc_key_file) {\n            ctx.key_type = TPM2_ALG_NULL;\n        } else {\n            ctx.key_type = TPM2_ALG_AES;\n        }\n\n        if (ctx.key_auth_str) {\n            LOG_ERR(\"Cannot specify key password when importing a TPM key.\\n\"\n                \"use tpm2_changeauth after import\");\n            rc = tool_rc_option_error;\n        }\n\n    } else { /* Openssl specific option(s) */\n\n        if (!ctx.key_type) {\n            LOG_ERR(\"Expected key type to be specified via \\\"-G\\\",\"\n                    \" missing option.\");\n            rc = tool_rc_option_error;\n        }\n\n        if (ctx.cp_hash_path) {\n            LOG_WARN(\"CAUTION CpHash calculation includes parameters that\"\n                     \"have a derived/random seed!\");\n        }\n    }\n\n    /* Common options */\n    if (!ctx.input_key_file) {\n        LOG_ERR(\"Expected to be imported key data to be specified via \\\"-i\\\",\"\n                \" missing option.\");\n        rc = tool_rc_option_error;\n    }\n\n    if (!ctx.public_key_file) {\n        LOG_ERR(\"Expected output public file missing, specify \\\"-u\\\",\"\n                \" missing option.\");\n        rc = tool_rc_option_error;\n    }\n\n    if (!ctx.private_key_file) {\n        LOG_ERR(\"Expected output private file missing, specify \\\"-r\\\",\"\n                \" missing option.\");\n        rc = tool_rc_option_error;\n    }\n\n    if (!ctx.parent.ctx_path) {\n        LOG_ERR(\"Expected parent key to be specified via \\\"-C\\\",\"\n                \" missing option.\");\n        rc = tool_rc_option_error;\n    }\n\n    return rc;\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 8323635901329901215912545275263286475,
        "size": 67,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static tool_rc readpublic(ESYS_CONTEXT *ectx, ESYS_TR handle,\n        TPM2B_PUBLIC **public) {\n\n    return tpm2_readpublic(ectx, handle, public, NULL, NULL);\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 277056237820795989603496414121406682508,
        "size": 5,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static tool_rc tpm2_tool_onrun(ESYS_CONTEXT *ectx, tpm2_option_flags flags) {\n    UNUSED(flags);\n\n    tool_rc rc = check_options();\n    if (rc != tool_rc_success) {\n        return rc;\n    }\n\n    rc = tpm2_util_object_load_auth(ectx, ctx.parent.ctx_path,\n            ctx.parent.auth_str, &ctx.parent.object, false,\n            TPM2_HANDLE_ALL_W_NV);\n    if (rc != tool_rc_success) {\n        LOG_ERR(\"Invalid parent key authorization\");\n        return rc;\n    }\n\n    return ctx.import_tpm ? tpm_import(ectx) : openssl_import(ectx);\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 61921641635398987351133969976215081416,
        "size": 18,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "static bool on_option(char key, char *value) {\n\n    switch (key) {\n    case 'P':\n        ctx.parent.auth_str = value;\n        break;\n    case 'p':\n        ctx.key_auth_str = value;\n        break;\n    case 'G':\n        ctx.key_type = tpm2_alg_util_from_optarg(value,\n                tpm2_alg_util_flags_asymmetric | tpm2_alg_util_flags_symmetric);\n        if (ctx.key_type == TPM2_ALG_ERROR) {\n            LOG_ERR(\"Unsupported key type\");\n            return false;\n        }\n        return true;\n    case 'i':\n        ctx.input_key_file = value;\n        break;\n    case 'C':\n        ctx.parent.ctx_path = value;\n        break;\n    case 'U':\n        ctx.parent_key_public_file = value;\n        break;\n    case 'k':\n        ctx.import_tpm = true;\n        ctx.input_enc_key_file = value;\n        break;\n    case 'u':\n        ctx.public_key_file = value;\n        break;\n    case 'r':\n        ctx.private_key_file = value;\n        break;\n    case 'a':\n        ctx.attrs = value;\n        break;\n    case 'g':\n        ctx.name_alg = value;\n        break;\n    case 's':\n        ctx.import_tpm = true;\n        ctx.input_seed_file = value;\n        break;\n    case 'L':\n        ctx.policy = value;\n        break;\n    case 0:\n        ctx.auth_key_file = value;\n        break;\n    case 1:\n        ctx.cp_hash_path = value;\n        break;\n    default:\n        LOG_ERR(\"Invalid option\");\n        return false;\n    }\n\n    return true;\n}",
        "target": 0,
        "cwe": [
            "CWE-798"
        ],
        "project": "tpm2-tools",
        "commit_id": "c069e4f179d5e6653a84fb236816c375dca82515",
        "hash": 66512556226839357343159460058194371378,
        "size": 62,
        "message": "tpm2_import: fix fixed AES key CVE-2021-3565\n\ntpm2_import used a fixed AES key for the inner wrapper, which means that\na MITM attack would be able to unwrap the imported key. Even the\nuse of an encrypted session will not prevent this. The TPM only\nencrypts the first parameter which is the fixed symmetric key.\n\nTo fix this, ensure the key size is 16 bytes or bigger and use\nOpenSSL to generate a secure random AES key.\n\nFixes: #2738\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "isdn_net_setcfg(isdn_net_ioctl_cfg * cfg)\n{\n\tisdn_net_dev *p = isdn_net_findif(cfg->name);\n\tulong features;\n\tint i;\n\tint drvidx;\n\tint chidx;\n\tchar drvid[25];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* See if any registered driver supports the features we want */\n\t\tfeatures = ((1 << cfg->l2_proto) << ISDN_FEATURE_L2_SHIFT) |\n\t\t\t((1 << cfg->l3_proto) << ISDN_FEATURE_L3_SHIFT);\n\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\tif (dev->drv[i])\n\t\t\t\tif ((dev->drv[i]->interface->features & features) == features)\n\t\t\t\t\tbreak;\n\t\tif (i == ISDN_MAX_DRIVERS) {\n\t\t\tprintk(KERN_WARNING \"isdn_net: No driver with selected features\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (lp->p_encap != cfg->p_encap){\n#ifdef CONFIG_ISDN_X25\n\t\t\tstruct concap_proto * cprot = p -> cprot;\n#endif\n\t\t\tif (isdn_net_device_started(p)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: cannot change encap when if is up\\n\",\n\t\t\t\t       p->dev->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n#ifdef CONFIG_ISDN_X25\n\t\t\tif( cprot && cprot -> pops )\n\t\t\t\tcprot -> pops -> proto_del ( cprot );\n\t\t\tp -> cprot = NULL;\n\t\t\tlp -> dops = NULL;\n\t\t\t/* ... ,  prepare for configuration of new one ... */\n\t\t\tswitch ( cfg -> p_encap ){\n\t\t\tcase ISDN_NET_ENCAP_X25IFACE:\n\t\t\t\tlp -> dops = &isdn_concap_reliable_dl_dops;\n\t\t\t}\n\t\t\t/* ... and allocate new one ... */\n\t\t\tp -> cprot = isdn_concap_new( cfg -> p_encap );\n\t\t\t/* p -> cprot == NULL now if p_encap is not supported\n\t\t\t   by means of the concap_proto mechanism */\n\t\t\t/* the protocol is not configured yet; this will\n\t\t\t   happen later when isdn_net_reset() is called */\n#endif\n\t\t}\n\t\tswitch ( cfg->p_encap ) {\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n#ifndef CONFIG_ISDN_PPP\n\t\t\tprintk(KERN_WARNING \"%s: SyncPPP support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_PPP;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n\t\t\tp->dev->do_ioctl = isdn_ppp_dev_ioctl;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_X25IFACE:\n#ifndef CONFIG_ISDN_X25\n\t\t\tprintk(KERN_WARNING \"%s: isdn-x25 support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_X25;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tp->dev->do_ioctl = isdn_ciscohdlck_dev_ioctl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif( cfg->p_encap >= 0 &&\n\t\t\t    cfg->p_encap <= ISDN_NET_ENCAP_MAX_ENCAP )\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: encapsulation protocol %d not supported\\n\",\n\t\t\t       p->dev->name, cfg->p_encap);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strlen(cfg->drvid)) {\n\t\t\t/* A bind has been requested ... */\n\t\t\tchar *c,\n\t\t\t*e;\n\n\t\t\tdrvidx = -1;\n\t\t\tchidx = -1;\n\t\t\tstrcpy(drvid, cfg->drvid);\n\t\t\tif ((c = strchr(drvid, ','))) {\n\t\t\t\t/* The channel-number is appended to the driver-Id with a comma */\n\t\t\t\tchidx = (int) simple_strtoul(c + 1, &e, 10);\n\t\t\t\tif (e == c)\n\t\t\t\t\tchidx = -1;\n\t\t\t\t*c = '\\0';\n\t\t\t}\n\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t/* Lookup driver-Id in array */\n\t\t\t\tif (!(strcmp(dev->drvid[i], drvid))) {\n\t\t\t\t\tdrvidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif ((drvidx == -1) || (chidx == -1))\n\t\t\t\t/* Either driver-Id or channel-number invalid */\n\t\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\t/* Parameters are valid, so get them */\n\t\t\tdrvidx = lp->pre_device;\n\t\t\tchidx = lp->pre_channel;\n\t\t}\n\t\tif (cfg->exclusive > 0) {\n\t\t\tunsigned long flags;\n\n\t\t\t/* If binding is exclusive, try to grab the channel */\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((i = isdn_get_free_channel(ISDN_USAGE_NET,\n\t\t\t\tlp->l2_proto, lp->l3_proto, drvidx,\n\t\t\t\tchidx, lp->msn)) < 0) {\n\t\t\t\t/* Grab failed, because desired channel is in use */\n\t\t\t\tlp->exclusive = -1;\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\t/* All went ok, so update isdninfo */\n\t\t\tdev->usage[i] = ISDN_USAGE_EXCLUSIVE;\n\t\t\tisdn_info_update();\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tlp->exclusive = i;\n\t\t} else {\n\t\t\t/* Non-exclusive binding or unbind. */\n\t\t\tlp->exclusive = -1;\n\t\t\tif ((lp->pre_device != -1) && (cfg->exclusive == -1)) {\n\t\t\t\tisdn_unexclusive_channel(lp->pre_device, lp->pre_channel);\n\t\t\t\tisdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);\n\t\t\t\tdrvidx = -1;\n\t\t\t\tchidx = -1;\n\t\t\t}\n\t\t}\n\t\tstrcpy(lp->msn, cfg->eaz);\n\t\tlp->pre_device = drvidx;\n\t\tlp->pre_channel = chidx;\n\t\tlp->onhtime = cfg->onhtime;\n\t\tlp->charge = cfg->charge;\n\t\tlp->l2_proto = cfg->l2_proto;\n\t\tlp->l3_proto = cfg->l3_proto;\n\t\tlp->cbdelay = cfg->cbdelay;\n\t\tlp->dialmax = cfg->dialmax;\n\t\tlp->triggercps = cfg->triggercps;\n\t\tlp->slavedelay = cfg->slavedelay * HZ;\n\t\tlp->pppbind = cfg->pppbind;\n\t\tlp->dialtimeout = cfg->dialtimeout >= 0 ? cfg->dialtimeout * HZ : -1;\n\t\tlp->dialwait = cfg->dialwait * HZ;\n\t\tif (cfg->secure)\n\t\t\tlp->flags |= ISDN_NET_SECURE;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_SECURE;\n\t\tif (cfg->cbhup)\n\t\t\tlp->flags |= ISDN_NET_CBHUP;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_CBHUP;\n\t\tswitch (cfg->callback) {\n\t\t\tcase 0:\n\t\t\t\tlp->flags &= ~(ISDN_NET_CALLBACK | ISDN_NET_CBOUT);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlp->flags |= ISDN_NET_CALLBACK;\n\t\t\t\tlp->flags &= ~ISDN_NET_CBOUT;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlp->flags |= ISDN_NET_CBOUT;\n\t\t\t\tlp->flags &= ~ISDN_NET_CALLBACK;\n\t\t\t\tbreak;\n\t\t}\n\t\tlp->flags &= ~ISDN_NET_DIALMODE_MASK;\t/* first all bits off */\n\t\tif (cfg->dialmode && !(cfg->dialmode & ISDN_NET_DIALMODE_MASK)) {\n\t\t\t/* old isdnctrl version, where only 0 or 1 is given */\n\t\t\tprintk(KERN_WARNING\n\t\t\t     \"Old isdnctrl version detected! Please update.\\n\");\n\t\t\tlp->flags |= ISDN_NET_DM_OFF; /* turn on `off' bit */\n\t\t}\n\t\telse {\n\t\t\tlp->flags |= cfg->dialmode;  /* turn on selected bits */\n\t\t}\n\t\tif (cfg->chargehup)\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_CHARGEHUP;\n\t\tif (cfg->ihup)\n\t\t\tlp->hupflags |= ISDN_INHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_INHUP;\n\t\tif (cfg->chargeint > 10) {\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE;\n\t\t\tlp->chargeint = cfg->chargeint * HZ;\n\t\t}\n\t\tif (cfg->p_encap != lp->p_encap) {\n\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_RAWIP) {\n\t\t\t\tp->dev->header_ops = NULL;\n\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t} else {\n\t\t\t\tp->dev->header_ops = &isdn_header_ops;\n\t\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\t\t\t\tp->dev->flags = IFF_BROADCAST | IFF_MULTICAST;\n\t\t\t\telse\n\t\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t}\n\t\t}\n\t\tlp->p_encap = cfg->p_encap;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "0f13864e5b24d9cbe18d125d41bfa4b726a82e40",
        "hash": 80796293720356790057810511838637183896,
        "size": 215,
        "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "isdn_net_addphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tisdn_net_phone *n;\n\n\tif (p) {\n\t\tif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(n->num, phone->phone);\n\t\tn->next = p->local->phone[phone->outgoing & 1];\n\t\tp->local->phone[phone->outgoing & 1] = n;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "0f13864e5b24d9cbe18d125d41bfa4b726a82e40",
        "hash": 242762251649869568016628227707027738238,
        "size": 15,
        "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "isdn_net_find_icall(int di, int ch, int idx, setup_parm *setup)\n{\n\tchar *eaz;\n\tint si1;\n\tint si2;\n\tint ematch;\n\tint wret;\n\tint swapped;\n\tint sidx = 0;\n\tu_long flags;\n\tisdn_net_dev *p;\n\tisdn_net_phone *n;\n\tchar nr[32];\n\tchar *my_eaz;\n\n\t/* Search name in netdev-chain */\n\tif (!setup->phone[0]) {\n\t\tnr[0] = '0';\n\t\tnr[1] = '\\0';\n\t\tprintk(KERN_INFO \"isdn_net: Incoming call without OAD, assuming '0'\\n\");\n\t} else\n\t\tstrcpy(nr, setup->phone);\n\tsi1 = (int) setup->si1;\n\tsi2 = (int) setup->si2;\n\tif (!setup->eazmsn[0]) {\n\t\tprintk(KERN_WARNING \"isdn_net: Incoming call without CPN, assuming '0'\\n\");\n\t\teaz = \"0\";\n\t} else\n\t\teaz = setup->eazmsn;\n\tif (dev->net_verbose > 1)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s,%d,%d -> %s\\n\", nr, si1, si2, eaz);\n\t/* Accept DATA and VOICE calls at this stage\n\t * local eaz is checked later for allowed call types\n\t */\n\tif ((si1 != 7) && (si1 != 1)) {\n\t\tif (dev->net_verbose > 1)\n\t\t\tprintk(KERN_INFO \"isdn_net: Service-Indicator not 1 or 7, ignored\\n\");\n\t\treturn 0;\n\t}\n\tn = (isdn_net_phone *) 0;\n\tp = dev->netdev;\n\tematch = wret = swapped = 0;\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: di=%d ch=%d idx=%d usg=%d\\n\", di, ch, idx,\n\t\tdev->usage[idx]);\n#endif\n\twhile (p) {\n\t\tint matchret;\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* If last check has triggered as binding-swap, revert it */\n\t\tswitch (swapped) {\n\t\t\tcase 2:\n\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t/* fall through */\n\t\t\tcase 1:\n\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\tbreak;\n\t\t}\n\t\tswapped = 0;\n                /* check acceptable call types for DOV */\n                my_eaz = isdn_map_eaz2msn(lp->msn, di);\n                if (si1 == 1) { /* it's a DOV call, check if we allow it */\n                        if (*my_eaz == 'v' || *my_eaz == 'V' ||\n\t\t\t    *my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                        else\n                                my_eaz = NULL; /* force non match */\n                } else { /* it's a DATA call, check if we allow it */\n                        if (*my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                }\n                if (my_eaz)\n                        matchret = isdn_msncmp(eaz, my_eaz);\n                else\n                        matchret = 1;\n                if (!matchret)\n                        ematch = 1;\n\n\t\t/* Remember if more numbers eventually can match */\n\t\tif (matchret > wret)\n\t\t\twret = matchret;\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\tprintk(KERN_DEBUG \"n_fi: if='%s', l.msn=%s, l.flags=%d, l.dstate=%d\\n\",\n\t\t       p->dev->name, lp->msn, lp->flags, lp->dialstate);\n#endif\n\t\tif ((!matchret) &&                                        /* EAZ is matching   */\n\t\t    (((!(lp->flags & ISDN_NET_CONNECTED)) &&              /* but not connected */\n\t\t      (USG_NONE(dev->usage[idx]))) ||                     /* and ch. unused or */\n\t\t     ((((lp->dialstate == 4) || (lp->dialstate == 12)) && /* if dialing        */\n\t\t       (!(lp->flags & ISDN_NET_CALLBACK)))                /* but no callback   */\n\t\t     )))\n\t\t\t {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match1, pdev=%d pch=%d\\n\",\n\t\t\t       lp->pre_device, lp->pre_channel);\n#endif\n\t\t\tif (dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) {\n\t\t\t\tif ((lp->pre_channel != ch) ||\n\t\t\t\t    (lp->pre_device != di)) {\n\t\t\t\t\t/* Here we got a problem:\n\t\t\t\t\t * If using an ICN-Card, an incoming call is always signaled on\n\t\t\t\t\t * on the first channel of the card, if both channels are\n\t\t\t\t\t * down. However this channel may be bound exclusive. If the\n\t\t\t\t\t * second channel is free, this call should be accepted.\n\t\t\t\t\t * The solution is horribly but it runs, so what:\n\t\t\t\t\t * We exchange the exclusive bindings of the two channels, the\n\t\t\t\t\t * corresponding variables in the interface-structs.\n\t\t\t\t\t */\n\t\t\t\t\tif (ch == 0) {\n\t\t\t\t\t\tsidx = isdn_dc2minor(di, 1);\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: ch is 0\\n\");\n#endif\n\t\t\t\t\t\tif (USG_NONE(dev->usage[sidx])) {\n\t\t\t\t\t\t\t/* Second Channel is free, now see if it is bound\n\t\t\t\t\t\t\t * exclusive too. */\n\t\t\t\t\t\t\tif (dev->usage[sidx] & ISDN_USAGE_EXCLUSIVE) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and bound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* Yes, swap bindings only, if the original\n\t\t\t\t\t\t\t\t * binding is bound to channel 1 of this driver */\n\t\t\t\t\t\t\t\tif ((lp->pre_device == di) &&\n\t\t\t\t\t\t\t\t    (lp->pre_channel == 1)) {\n\t\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\t\tswapped = 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t/* ... else iterate next device */\n\t\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and unbound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* No, swap always and swap excl-usage also */\n\t\t\t\t\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\tswapped = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Now check for exclusive binding again */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check\\n\");\n#endif\n\t\t\t\t\t\t\tif ((dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) &&\n\t\t\t\t\t\t\t    ((lp->pre_channel != ch) ||\n\t\t\t\t\t\t\t     (lp->pre_device != di))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check failed\\n\");\n#endif\n\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* We are already on the second channel, so nothing to do */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: already on 2nd channel\\n\");\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match2\\n\");\n#endif\n\t\t\tn = lp->phone[0];\n\t\t\tif (lp->flags & ISDN_NET_SECURE) {\n\t\t\t\twhile (n) {\n\t\t\t\t\tif (!isdn_msncmp(nr, n->num))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tn = (isdn_net_phone *) n->next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n || (!(lp->flags & ISDN_NET_SECURE))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\tprintk(KERN_DEBUG \"n_fi: match3\\n\");\n#endif\n\t\t\t\t/* matching interface found */\n\n\t\t\t\t/*\n\t\t\t\t * Is the state STOPPED?\n\t\t\t\t * If so, no dialin is allowed,\n\t\t\t\t * so reject actively.\n\t\t\t\t * */\n\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\tprintk(KERN_INFO \"incoming call, interface %s `stopped' -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Is the interface up?\n\t\t\t\t * If not, reject the call actively.\n\t\t\t\t */\n\t\t\t\tif (!isdn_net_device_started(p)) {\n\t\t\t\t\tprintk(KERN_INFO \"%s: incoming call, interface down -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/* Interface is up, now see if it's a slave. If so, see if\n\t\t\t\t * it's master and parent slave is online. If not, reject the call.\n\t\t\t\t */\n\t\t\t\tif (lp->master) {\n\t\t\t\t\tisdn_net_local *mlp = (isdn_net_local *) lp->master->priv;\n\t\t\t\t\tprintk(KERN_DEBUG \"ICALLslv: %s\\n\", p->dev->name);\n\t\t\t\t\tprintk(KERN_DEBUG \"master=%s\\n\", lp->master->name);\n\t\t\t\t\tif (mlp->flags & ISDN_NET_CONNECTED) {\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master online\\n\");\n\t\t\t\t\t\t/* Master is online, find parent-slave (master if first slave) */\n\t\t\t\t\t\twhile (mlp->slave) {\n\t\t\t\t\t\t\tif ((isdn_net_local *) mlp->slave->priv == lp)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tmlp = (isdn_net_local *) mlp->slave->priv;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master offline\\n\");\n\t\t\t\t\t/* Found parent, if it's offline iterate next device */\n\t\t\t\t\tprintk(KERN_DEBUG \"mlpf: %d\\n\", mlp->flags & ISDN_NET_CONNECTED);\n\t\t\t\t\tif (!(mlp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif (lp->flags & ISDN_NET_CALLBACK) {\n\t\t\t\t\tint chi;\n\t\t\t\t\t/*\n\t\t\t\t\t * Is the state MANUAL?\n\t\t\t\t\t * If so, no callback can be made,\n\t\t\t\t\t * so reject actively.\n\t\t\t\t\t * */\n\t\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\t\tprintk(KERN_INFO \"incoming call for callback, interface %s `off' -> rejected\\n\",\n\t\t\t\t\t\t       p->dev->name);\n\t\t\t\t\t\treturn 3;\n\t\t\t\t\t}\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s, start callback\\n\",\n\t\t\t\t\t       p->dev->name, nr, eaz);\n\t\t\t\t\tif (lp->phone[1]) {\n\t\t\t\t\t\t/* Grab a free ISDN-Channel */\n\t\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\t\tif ((chi = \n\t\t\t\t\t\t\tisdn_get_free_channel(\n\t\t\t\t\t\t\t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\t  \tlp->pre_device,\n\t\t\t\t\t\t \t\tlp->pre_channel,\n\t\t\t\t\t\t \t\tlp->msn)\n\t\t\t\t\t\t\t\t) < 0) {\n\n\t\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net_find_icall: No channel for %s\\n\",\n\t\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Setup dialstate. */\n\t\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\t\tlp->dialstate = 11;\n\t\t\t\t\t\t/* Connect interface with channel */\n\t\t\t\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t/* Initiate dialing by returning 2 or 4 */\n\t\t\t\t\t\treturn (lp->flags & ISDN_NET_CBHUP) ? 2 : 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net: %s: No phone number\\n\",\n\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s accepted\\n\",\n\t\t\t\t\t\tp->dev->name, nr, eaz);\n\t\t\t\t\t/* if this interface is dialing, it does it probably on a different\n\t\t\t\t\t   device, so free this device */\n\t\t\t\t\tif ((lp->dialstate == 4) || (lp->dialstate == 12)) {\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_ppp_free(lp);\n#endif\n\t\t\t\t\t\tisdn_net_lp_disconnected(lp);\n\t\t\t\t\t\tisdn_free_channel(lp->isdn_device, lp->isdn_channel,\n\t\t\t\t\t\t\t ISDN_USAGE_NET);\n\t\t\t\t\t}\n\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\tdev->usage[idx] &= ISDN_USAGE_EXCLUSIVE;\n\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_NET;\n\t\t\t\t\tstrcpy(dev->num[idx], nr);\n\t\t\t\t\tisdn_info_update();\n\t\t\t\t\tdev->st_netdev[idx] = lp->netdev;\n\t\t\t\t\tlp->isdn_device = di;\n\t\t\t\t\tlp->isdn_channel = ch;\n\t\t\t\t\tlp->ppp_slot = -1;\n\t\t\t\t\tlp->flags |= ISDN_NET_CONNECTED;\n\t\t\t\t\tlp->dialstate = 7;\n\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\tlp->outgoing = 0;\n\t\t\t\t\tlp->huptimer = 0;\n\t\t\t\t\tlp->hupflags |= ISDN_WAITCHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_HAVECHARGE;\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\t/* If none of configured EAZ/MSN matched and not verbose, be silent */\n\tif (!ematch || dev->net_verbose)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s -> %d %s ignored\\n\", nr, di, eaz);\n\treturn (wret == 2)?5:0;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "0f13864e5b24d9cbe18d125d41bfa4b726a82e40",
        "hash": 322344461636009915251514953321701663520,
        "size": 326,
        "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(inode);\n\tisdn_ctrl c;\n\tint drvidx;\n\tint chidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\t\tcase IIOCGETDVR:\n\t\t\t\treturn (TTY_DV +\n\t\t\t\t\t(NET_DV << 8) +\n\t\t\t\t\t(INF_DV << 16));\n\t\t\tcase IIOCGETCPS:\n\t\t\t\tif (arg) {\n\t\t\t\t\tulong __user *p = argp;\n\t\t\t\t\tint i;\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, p,\n\t\t\t\t\t\t\tsizeof(ulong) * ISDN_MAX_CHANNELS * 2))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n#ifdef CONFIG_NETDEVICES\n\t\t\tcase IIOCNETGPN:\n\t\t\t\t/* Get peer phone number of a connected \n\t\t\t\t * isdn network interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n#endif\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tchidx = isdn_minor2chan(minor);\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefor, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\t\tcase IIOCNETDWRSET:\n\t\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\t\treturn(-EINVAL);\n\t\t\tcase IIOCNETLCR:\n\t\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\t\treturn -ENODEV;\n#ifdef CONFIG_NETDEVICES\n\t\t\tcase IIOCNETAIF:\n\t\t\t\t/* Add a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\ts = name;\n\t\t\t\t} else {\n\t\t\t\t\ts = NULL;\n\t\t\t\t}\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif( ret ) return ret;\n\t\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)){\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\tcase IIOCNETASL:\n\t\t\t\t/* Add a slave to a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif( ret ) return ret;\n\t\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)){\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\tcase IIOCNETDIF:\n\t\t\t\t/* Delete a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETSCF:\n\t\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETGCF:\n\t\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETANM:\n\t\t\t\t/* Add a phone-number to a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETGNM:\n\t\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETDNM:\n\t\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETDIL:\n\t\t\t\t/* Force dialing of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\t\tcase IIOCNETALN:\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_ppp_dial_slave(name);\n\t\t\tcase IIOCNETDLN:\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\t\tcase IIOCNETHUP:\n\t\t\t\t/* Force hangup of a network-interface */\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_hangup(name);\n\t\t\t\tbreak;\n#endif                          /* CONFIG_NETDEVICES */\n\t\t\tcase IIOCSETVER:\n\t\t\t\tdev->net_verbose = arg;\n\t\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSETGST:\n\t\t\t\tif (arg)\n\t\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\t\telse\n\t\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSETBRJ:\n\t\t\t\tdrvidx = -1;\n\t\t\t\tif (arg) {\n\t\t\t\t\tint i;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (iocts.arg)\n\t\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\t\telse\n\t\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSIGPRF:\n\t\t\t\tdev->profd = current;\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase IIOCGETPRF:\n\t\t\t\t/* Get all Modem-Profiles */\n\t\t\t\tif (arg) {\n\t\t\t\t\tchar __user *p = argp;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, argp,\n\t\t\t\t\t(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\n\t\t\t\t\t\t   * ISDN_MAX_CHANNELS))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t      ISDN_MODEM_NUMREG))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\t}\n\t\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase IIOCSETPRF:\n\t\t\t\t/* Set all Modem-Profiles */\n\t\t\t\tif (arg) {\n\t\t\t\t\tchar __user *p = argp;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tif (!access_ok(VERIFY_READ, argp,\n\t\t\t\t\t(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\n\t\t\t\t\t\t   * ISDN_MAX_CHANNELS))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t     ISDN_MODEM_NUMREG))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase IIOCSETMAP:\n\t\t\tcase IIOCGETMAP:\n\t\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\t\tif (arg) {\n\n\t\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdrvidx = 0;\n\t\t\t\t\tif (drvidx == -1)\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tif (!access_ok(VERIFY_READ, p, 1))\n\t\t\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\t\tsprintf(bname, \"%s%s\",\n\t\t\t\t\t\t\t\tstrlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t\tdev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t\t(i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCDBGVAR:\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\t\telse\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tint i;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdrvidx = 0;\n\t\t\t\t\tif (drvidx == -1)\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tc.driver = drvidx;\n\t\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\t\tc.arg = cmd;\n\t\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\t\tret = isdn_command(&c);\n\t\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "eafe1aa37e6ec2d56f14732b5240c4dd09f0613a",
        "hash": 328221509131099860922910070027499343329,
        "size": 446,
        "message": "I4L: fix isdn_ioctl memory overrun vulnerability\n\nFix possible memory overrun issue in the isdn ioctl code.\n\nFound by ADLAB <adlab@venustech.com.cn>\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nCc: ADLAB <adlab@venustech.com.cn>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static unsigned char asn1_oid_decode(struct asn1_ctx *ctx,\n\t\t\t\t     unsigned char *eoc,\n\t\t\t\t     unsigned long **oid,\n\t\t\t\t     unsigned int *len)\n{\n\tunsigned long subid;\n\tunsigned int  size;\n\tunsigned long *optr;\n\n\tsize = eoc - ctx->pointer + 1;\n\t*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\n\tif (*oid == NULL) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(\"OOM in bsalg (%d)\\n\", __LINE__);\n\t\treturn 0;\n\t}\n\n\toptr = *oid;\n\n\tif (!asn1_subid_decode(ctx, &subid)) {\n\t\tkfree(*oid);\n\t\t*oid = NULL;\n\t\treturn 0;\n\t}\n\n\tif (subid < 40) {\n\t\toptr [0] = 0;\n\t\toptr [1] = subid;\n\t} else if (subid < 80) {\n\t\toptr [0] = 1;\n\t\toptr [1] = subid - 40;\n\t} else {\n\t\toptr [0] = 2;\n\t\toptr [1] = subid - 80;\n\t}\n\n\t*len = 2;\n\toptr += 2;\n\n\twhile (ctx->pointer < eoc) {\n\t\tif (++(*len) > size) {\n\t\t\tctx->error = ASN1_ERR_DEC_BADVALUE;\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!asn1_subid_decode(ctx, optr++)) {\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5",
        "hash": 258736852088289996589788699342684506403,
        "size": 55,
        "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "asn1_oid_decode(struct asn1_ctx *ctx,\n\t\tunsigned char *eoc, unsigned long **oid, unsigned int *len)\n{\n\tunsigned long subid;\n\tunsigned int size;\n\tunsigned long *optr;\n\n\tsize = eoc - ctx->pointer + 1;\n\t*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\n\tif (*oid == NULL)\n\t\treturn 0;\n\n\toptr = *oid;\n\n\tif (!asn1_subid_decode(ctx, &subid)) {\n\t\tkfree(*oid);\n\t\t*oid = NULL;\n\t\treturn 0;\n\t}\n\n\tif (subid < 40) {\n\t\toptr[0] = 0;\n\t\toptr[1] = subid;\n\t} else if (subid < 80) {\n\t\toptr[0] = 1;\n\t\toptr[1] = subid - 40;\n\t} else {\n\t\toptr[0] = 2;\n\t\toptr[1] = subid - 80;\n\t}\n\n\t*len = 2;\n\toptr += 2;\n\n\twhile (ctx->pointer < eoc) {\n\t\tif (++(*len) > size) {\n\t\t\tctx->error = ASN1_ERR_DEC_BADVALUE;\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!asn1_subid_decode(ctx, optr++)) {\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5",
        "hash": 24934009460877332029578215926851751208,
        "size": 50,
        "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "asn1_header_decode(struct asn1_ctx *ctx,\n\t\t   unsigned char **eoc,\n\t\t   unsigned int *cls, unsigned int *con, unsigned int *tag)\n{\n\tunsigned int def = 0;\n\tunsigned int len = 0;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5",
        "hash": 100827339625052954108223001238225390166,
        "size": 19,
        "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static unsigned char asn1_header_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned char **eoc,\n\t\t\t\t\tunsigned int *cls,\n\t\t\t\t\tunsigned int *con,\n\t\t\t\t\tunsigned int *tag)\n{\n\tunsigned int def, len;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tdef = len = 0;\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5",
        "hash": 228756596288618045464924038405659988128,
        "size": 21,
        "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static unsigned char asn1_length_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned int *def,\n\t\t\t\t\tunsigned int *len)\n{\n\tunsigned char ch, cnt;\n\n\tif (!asn1_octet_decode(ctx, &ch))\n\t\treturn 0;\n\n\tif (ch == 0x80)\n\t\t*def = 0;\n\telse {\n\t\t*def = 1;\n\n\t\tif (ch < 0x80)\n\t\t\t*len = ch;\n\t\telse {\n\t\t\tcnt = ch & 0x7F;\n\t\t\t*len = 0;\n\n\t\t\twhile (cnt > 0) {\n\t\t\t\tif (!asn1_octet_decode(ctx, &ch))\n\t\t\t\t\treturn 0;\n\t\t\t\t*len <<= 8;\n\t\t\t\t*len |= ch;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5",
        "hash": 214953782388236534754341406713123646165,
        "size": 31,
        "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "asn1_length_decode(struct asn1_ctx *ctx, unsigned int *def, unsigned int *len)\n{\n\tunsigned char ch, cnt;\n\n\tif (!asn1_octet_decode(ctx, &ch))\n\t\treturn 0;\n\n\tif (ch == 0x80)\n\t\t*def = 0;\n\telse {\n\t\t*def = 1;\n\n\t\tif (ch < 0x80)\n\t\t\t*len = ch;\n\t\telse {\n\t\t\tcnt = (unsigned char) (ch & 0x7F);\n\t\t\t*len = 0;\n\n\t\t\twhile (cnt > 0) {\n\t\t\t\tif (!asn1_octet_decode(ctx, &ch))\n\t\t\t\t\treturn 0;\n\t\t\t\t*len <<= 8;\n\t\t\t\t*len |= ch;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5",
        "hash": 188088692906320605891566647399338031473,
        "size": 29,
        "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "linux-2.6",
        "commit_id": "5ac37f87ff18843aabab84cf75b2f8504c2d81fe",
        "hash": 201156650941371891932740762763197038172,
        "size": 15,
        "message": "x86: fix ldt limit for 64 bit\n\nFix size of LDT entries. On x86-64, ldt_desc is a double-sized descriptor.\n\nSigned-off-by: Michael Karcher <kernel@mkarcher.dialup.fu-berlin.de>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"
    },
    {
        "func": "static void file_add_remove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tint diff = REV_TREE_DIFFERENT;\n\n\t/*\n\t * Is it an add of a new file? It means that the old tree\n\t * didn't have it at all, so we will turn \"REV_TREE_SAME\" ->\n\t * \"REV_TREE_NEW\", but leave any \"REV_TREE_DIFFERENT\" alone\n\t * (and if it already was \"REV_TREE_NEW\", we'll keep it\n\t * \"REV_TREE_NEW\" of course).\n\t */\n\tif (addremove == '+') {\n\t\tdiff = tree_difference;\n\t\tif (diff != REV_TREE_SAME)\n\t\t\treturn;\n\t\tdiff = REV_TREE_NEW;\n\t}\n\ttree_difference = diff;\n\tif (tree_difference == REV_TREE_DIFFERENT)\n\t\tDIFF_OPT_SET(options, HAS_CHANGES);\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "git",
        "commit_id": "fd55a19eb1d49ae54008d932a65f79cd6fda45c9",
        "hash": 220776526793639941070950330016667509112,
        "size": 24,
        "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"
    },
    {
        "func": "static int show_modified(struct oneway_unpack_data *cbdata,\n\t\t\t struct cache_entry *old,\n\t\t\t struct cache_entry *new,\n\t\t\t int report_missing,\n\t\t\t int cached, int match_missing)\n{\n\tunsigned int mode, oldmode;\n\tconst unsigned char *sha1;\n\tstruct rev_info *revs = cbdata->revs;\n\n\tif (get_stat_data(new, &sha1, &mode, cached, match_missing, cbdata) < 0) {\n\t\tif (report_missing)\n\t\t\tdiff_index_show_file(revs, \"-\", old,\n\t\t\t\t\t     old->sha1, old->ce_mode);\n\t\treturn -1;\n\t}\n\n\tif (revs->combine_merges && !cached &&\n\t    (hashcmp(sha1, old->sha1) || hashcmp(old->sha1, new->sha1))) {\n\t\tstruct combine_diff_path *p;\n\t\tint pathlen = ce_namelen(new);\n\n\t\tp = xmalloc(combine_diff_path_size(2, pathlen));\n\t\tp->path = (char *) &p->parent[2];\n\t\tp->next = NULL;\n\t\tp->len = pathlen;\n\t\tmemcpy(p->path, new->name, pathlen);\n\t\tp->path[pathlen] = 0;\n\t\tp->mode = mode;\n\t\thashclr(p->sha1);\n\t\tmemset(p->parent, 0, 2 * sizeof(struct combine_diff_parent));\n\t\tp->parent[0].status = DIFF_STATUS_MODIFIED;\n\t\tp->parent[0].mode = new->ce_mode;\n\t\thashcpy(p->parent[0].sha1, new->sha1);\n\t\tp->parent[1].status = DIFF_STATUS_MODIFIED;\n\t\tp->parent[1].mode = old->ce_mode;\n\t\thashcpy(p->parent[1].sha1, old->sha1);\n\t\tshow_combined_diff(p, 2, revs->dense_combined_merges, revs);\n\t\tfree(p);\n\t\treturn 0;\n\t}\n\n\toldmode = old->ce_mode;\n\tif (mode == oldmode && !hashcmp(sha1, old->sha1) &&\n\t    !DIFF_OPT_TST(&revs->diffopt, FIND_COPIES_HARDER))\n\t\treturn 0;\n\n\tdiff_change(&revs->diffopt, oldmode, mode,\n\t\t    old->sha1, sha1, old->name, NULL);\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "git",
        "commit_id": "fd55a19eb1d49ae54008d932a65f79cd6fda45c9",
        "hash": 226800970801831651701634172156640358788,
        "size": 51,
        "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"
    },
    {
        "func": "static int compare_tree_entry(struct tree_desc *t1, struct tree_desc *t2, const char *base, int baselen, struct diff_options *opt)\n{\n\tunsigned mode1, mode2;\n\tconst char *path1, *path2;\n\tconst unsigned char *sha1, *sha2;\n\tint cmp, pathlen1, pathlen2;\n\n\tsha1 = tree_entry_extract(t1, &path1, &mode1);\n\tsha2 = tree_entry_extract(t2, &path2, &mode2);\n\n\tpathlen1 = tree_entry_len(path1, sha1);\n\tpathlen2 = tree_entry_len(path2, sha2);\n\tcmp = base_name_compare(path1, pathlen1, mode1, path2, pathlen2, mode2);\n\tif (cmp < 0) {\n\t\tshow_entry(opt, \"-\", t1, base, baselen);\n\t\treturn -1;\n\t}\n\tif (cmp > 0) {\n\t\tshow_entry(opt, \"+\", t2, base, baselen);\n\t\treturn 1;\n\t}\n\tif (!DIFF_OPT_TST(opt, FIND_COPIES_HARDER) && !hashcmp(sha1, sha2) && mode1 == mode2)\n\t\treturn 0;\n\n\t/*\n\t * If the filemode has changed to/from a directory from/to a regular\n\t * file, we need to consider it a remove and an add.\n\t */\n\tif (S_ISDIR(mode1) != S_ISDIR(mode2)) {\n\t\tshow_entry(opt, \"-\", t1, base, baselen);\n\t\tshow_entry(opt, \"+\", t2, base, baselen);\n\t\treturn 0;\n\t}\n\n\tif (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode1)) {\n\t\tint retval;\n\t\tchar *newbase = malloc_base(base, baselen, path1, pathlen1);\n\t\tif (DIFF_OPT_TST(opt, TREE_IN_RECURSIVE))\n\t\t\topt->change(opt, mode1, mode2,\n\t\t\t\t    sha1, sha2, base, path1);\n\t\tretval = diff_tree_sha1(sha1, sha2, newbase, opt);\n\t\tfree(newbase);\n\t\treturn retval;\n\t}\n\n\topt->change(opt, mode1, mode2, sha1, sha2, base, path1);\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "git",
        "commit_id": "fd55a19eb1d49ae54008d932a65f79cd6fda45c9",
        "hash": 275627253054133418702464627151159595261,
        "size": 48,
        "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"
    },
    {
        "func": "static void diff_index_show_file(struct rev_info *revs,\n\t\t\t\t const char *prefix,\n\t\t\t\t struct cache_entry *ce,\n\t\t\t\t const unsigned char *sha1, unsigned int mode)\n{\n\tdiff_addremove(&revs->diffopt, prefix[0], mode,\n\t\t       sha1, ce->name, NULL);\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "git",
        "commit_id": "fd55a19eb1d49ae54008d932a65f79cd6fda45c9",
        "hash": 30420025918771510190524987331796513235,
        "size": 8,
        "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"
    },
    {
        "func": "void diff_addremove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(mode))\n\t\treturn;\n\n\t/* This may look odd, but it is a preparation for\n\t * feeding \"there are unchanged files which should\n\t * not produce diffs, but when you are doing copy\n\t * detection you would need them, so here they are\"\n\t * entries to the diff-core.  They will be prefixed\n\t * with something like '=' or '*' (I haven't decided\n\t * which but should not make any difference).\n\t * Feeding the same new and old to diff_change()\n\t * also has the same effect.\n\t * Before the final output happens, they are pruned after\n\t * merged into rename/copy pairs as appropriate.\n\t */\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF))\n\t\taddremove = (addremove == '+' ? '-' :\n\t\t\t     addremove == '-' ? '+' : addremove);\n\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\n\tif (addremove != '+')\n\t\tfill_filespec(one, sha1, mode);\n\tif (addremove != '-')\n\t\tfill_filespec(two, sha1, mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}",
        "target": 1,
        "cwe": [
            "CWE-119"
        ],
        "project": "git",
        "commit_id": "fd55a19eb1d49ae54008d932a65f79cd6fda45c9",
        "hash": 121643038194642882186344342235023262689,
        "size": 45,
        "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"
    },
    {
        "func": "int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\t/*\n\t\t\t * can we represent this with the traditional file\n\t\t\t * mode permission bits?\n\t\t\t */\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\tgossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif (inode->i_mode != mode)\n\t\t\t\tSetModeFlag(orangefs_inode);\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\t/*\n\t * Go ahead and set the extended attribute now. NOTE: Suppose acl\n\t * was NULL, then value will be NULL and size will be 0 and that\n\t * will xlate to a removexattr. However, we don't want removexattr\n\t * complain if attributes does not exist.\n\t */\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\n\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 118194066822406382207749634732262632133,
        "size": 75,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 148473809803217047639608320106367645650,
        "size": 46,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 53379414546019983365001815341953092101,
        "size": 59,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\n\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn err;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 232009027515793373692393331276959168853,
        "size": 53,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry, struct inode *inode,\n\t\t\t      const char *name, const void *value,\n\t\t\t      size_t size, int flags)\n{\n\tint retval;\n\tstruct posix_acl *acl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * set the attribute on the remote. Without even looking at the\n\t * xattr value. We leave it to the server to validate\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_xattr_set(dentry, handler->name, value, size,\n\t\t\t\t      flags);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\tif (value) {\n\t\t/* update the cached acl value */\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\telse if (acl) {\n\t\t\tretval = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else\n\t\tacl = NULL;\n\n\tswitch (handler->flags) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err_out;\n\t\t\telse {\n\t\t\t\tstruct iattr iattr;\n\t\t\t\tif (retval == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * ACL can be represented\n\t\t\t\t\t * by the mode bits. So don't\n\t\t\t\t\t * update ACL.\n\t\t\t\t\t */\n\t\t\t\t\tacl = NULL;\n\t\t\t\t\tvalue = NULL;\n\t\t\t\t\tsize = 0;\n\t\t\t\t}\n\t\t\t\t/* Updte the mode bits */\n\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n\t\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t\t/* FIXME should we update ctime ?\n\t\t\t\t * What is the following setxattr update the\n\t\t\t\t * mode ?\n\t\t\t\t */\n\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_xattr_set(dentry, handler->name, value, size, flags);\n\tif (!retval)\n\t\tset_cached_acl(inode, handler->flags, acl);\nerr_out:\n\tposix_acl_release(acl);\n\treturn retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 198783126657039892589722941183797793935,
        "size": 82,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 209866282296680290850175368179926892928,
        "size": 48,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 214691502998266300132808962921465300334,
        "size": 39,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 79965863072438108081675822948057700256,
        "size": 48,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 140379400994076967015901011359921325254,
        "size": 50,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tceph_set_cached_acl(inode, type, acl);\n\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 289936425178769191784934080012335217831,
        "size": 69,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\n\t\tif (mode != inode->i_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\tset_cached_acl(inode, type, acl);\nout:\n\tkfree(data);\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 20638161936924149309441913412248337379,
        "size": 49,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 277505568775144736341700810206705954994,
        "size": 30,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 139995472183508324928745221400457044085,
        "size": 60,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tif (acl) {\n\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\t\tif (error < 0)\n\t\t\t\t\treturn error;\n\t\t\t\telse {\n\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\t\tif (error == 0)\n\t\t\t\t\t\tacl = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-862",
            "CWE-285"
        ],
        "project": "linux",
        "commit_id": "073931017b49d9458aa351605b43a7e34598caef",
        "hash": 282906281609963038567941319932655740948,
        "size": 45,
        "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>"
    },
    {
        "func": "static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\n\treturn 0;\n\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}",
        "target": 1,
        "cwe": [
            "CWE-284",
            "CWE-862"
        ],
        "project": "lxc",
        "commit_id": "16af238036a5464ae8f2420ed3af214f0de875f9",
        "hash": 325759591118093570721283619308594794531,
        "size": 62,
        "message": "CVE-2017-5985: Ensure target netns is caller-owned\n\nBefore this commit, lxc-user-nic could potentially have been tricked into\noperating on a network namespace over which the caller did not hold privilege.\n\nThis commit ensures that the caller is privileged over the network namespace by\ntemporarily dropping privilege.\n\nLaunchpad: https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1654676\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>"
    },
    {
        "func": "int recv_files(int f_in, int f_out, char *local_name)\n{\n\tint fd1,fd2;\n\tSTRUCT_STAT st;\n\tint iflags, xlen;\n\tchar *fname, fbuf[MAXPATHLEN];\n\tchar xname[MAXPATHLEN];\n\tchar fnametmp[MAXPATHLEN];\n\tchar *fnamecmp, *partialptr;\n\tchar fnamecmpbuf[MAXPATHLEN];\n\tuchar fnamecmp_type;\n\tstruct file_struct *file;\n\tint itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;\n\tenum logcode log_code = log_before_transfer ? FLOG : FINFO;\n\tint max_phase = protocol_version >= 29 ? 2 : 1;\n\tint dflt_perms = (ACCESSPERMS & ~orig_umask);\n#ifdef SUPPORT_ACLS\n\tconst char *parent_dirname = \"\";\n#endif\n\tint ndx, recv_ok;\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO, \"recv_files(%d) starting\\n\", cur_flist->used);\n\n\tif (delay_updates)\n\t\tdelayed_bits = bitbag_create(cur_flist->used + 1);\n\n\twhile (1) {\n\t\tcleanup_disable();\n\n\t\t/* This call also sets cur_flist. */\n\t\tndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,\n\t\t\t\t\t xname, &xlen);\n\t\tif (ndx == NDX_DONE) {\n\t\t\tif (!am_server && INFO_GTE(PROGRESS, 2) && cur_flist) {\n\t\t\t\tset_current_file_index(NULL, 0);\n\t\t\t\tend_progress(0);\n\t\t\t}\n\t\t\tif (inc_recurse && first_flist) {\n\t\t\t\tif (read_batch) {\n\t\t\t\t\tndx = first_flist->used + first_flist->ndx_start;\n\t\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t\t}\n\t\t\t\tflist_free(first_flist);\n\t\t\t\tif (first_flist)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (read_batch && first_flist) {\n\t\t\t\tndx = first_flist->used;\n\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t}\n\t\t\tif (++phase > max_phase)\n\t\t\t\tbreak;\n\t\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\t\trprintf(FINFO, \"recv_files phase=%d\\n\", phase);\n\t\t\tif (phase == 2 && delay_updates)\n\t\t\t\thandle_delayed_updates(local_name);\n\t\t\twrite_int(f_out, NDX_DONE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ndx - cur_flist->ndx_start >= 0)\n\t\t\tfile = cur_flist->files[ndx - cur_flist->ndx_start];\n\t\telse\n\t\t\tfile = dir_flist->files[cur_flist->parent_ndx];\n\t\tfname = local_name ? local_name : f_name(file, fbuf);\n\n\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\trprintf(FINFO, \"recv_files(%s)\\n\", fname);\n\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))\n\t\t\trecv_xattr_request(file, f_in);\n#endif\n\n\t\tif (!(iflags & ITEM_TRANSFER)) {\n\t\t\tmaybe_log_item(file, iflags, itemizing, xname);\n#ifdef SUPPORT_XATTRS\n\t\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t\t && !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))\n\t\t\t\tset_file_attrs(fname, file, NULL, fname, 0);\n#endif\n\t\t\tif (iflags & ITEM_IS_NEW) {\n\t\t\t\tstats.created_files++;\n\t\t\t\tif (S_ISREG(file->mode)) {\n\t\t\t\t\t/* Nothing further to count. */\n\t\t\t\t} else if (S_ISDIR(file->mode))\n\t\t\t\t\tstats.created_dirs++;\n#ifdef SUPPORT_LINKS\n\t\t\t\telse if (S_ISLNK(file->mode))\n\t\t\t\t\tstats.created_symlinks++;\n#endif\n\t\t\t\telse if (IS_DEVICE(file->mode))\n\t\t\t\t\tstats.created_devices++;\n\t\t\t\telse\n\t\t\t\t\tstats.created_specials++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (phase == 2) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"got transfer request in phase 2 [%s]\\n\",\n\t\t\t\twho_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (file->flags & FLAG_FILE_SENT) {\n\t\t\tif (csum_length == SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups; /* prevents double backup */\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SUM_LENGTH;\n\t\t\t\tredoing = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (csum_length != SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups;\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SHORT_SUM_LENGTH;\n\t\t\t\tredoing = 0;\n\t\t\t}\n\t\t\tif (iflags & ITEM_IS_NEW)\n\t\t\t\tstats.created_files++;\n\t\t}\n\n\t\tif (!am_server && INFO_GTE(PROGRESS, 1))\n\t\t\tset_current_file_index(file, ndx);\n\t\tstats.xferred_files++;\n\t\tstats.total_transferred_size += F_LENGTH(file);\n\n\t\tcleanup_got_literal = 0;\n\n\t\tif (daemon_filter_list.head\n\t\t    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {\n\t\t\trprintf(FERROR, \"attempt to hack rsync failed.\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (read_batch) {\n\t\t\tint wanted = redoing\n\t\t\t\t   ? we_want_redo(ndx)\n\t\t\t\t   : gen_wants_ndx(ndx, cur_flist->flist_num);\n\t\t\tif (!wanted) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"(Skipping batched update for%s \\\"%s\\\")\\n\",\n\t\t\t\t\tredoing ? \" resend of\" : \"\",\n\t\t\t\t\tfname);\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tremember_initial_stats();\n\n\t\tif (!do_xfers) { /* log the transfer */\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (read_batch)\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tcontinue;\n\t\t}\n\t\tif (write_batch < 0) {\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (!am_server)\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpartialptr = partial_dir ? partial_dir_fname(fname) : fname;\n\n\t\tif (protocol_version >= 29) {\n\t\t\tswitch (fnamecmp_type) {\n\t\t\tcase FNAMECMP_FNAME:\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_PARTIAL_DIR:\n\t\t\t\tfnamecmp = partialptr;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_BACKUP:\n\t\t\t\tfnamecmp = get_backup_name(fname);\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_FUZZY:\n\t\t\t\tif (file->dirname) {\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, file->dirname, xname);\n\t\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\t} else\n\t\t\t\t\tfnamecmp = xname;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fnamecmp_type > FNAMECMP_FUZZY && fnamecmp_type-FNAMECMP_FUZZY <= basis_dir_cnt) {\n\t\t\t\t\tfnamecmp_type -= FNAMECMP_FUZZY + 1;\n\t\t\t\t\tif (file->dirname) {\n\t\t\t\t\t\tstringjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t\t\t   basis_dir[fnamecmp_type], \"/\", file->dirname, \"/\", xname, NULL);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], xname);\n\t\t\t\t} else if (fnamecmp_type >= basis_dir_cnt) {\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\"invalid basis_dir index: %d.\\n\",\n\t\t\t\t\t\tfnamecmp_type);\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t\t} else\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!fnamecmp || (daemon_filter_list.head\n\t\t\t  && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tfnamecmp_type = FNAMECMP_FNAME;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Reminder: --inplace && --partial-dir are never\n\t\t\t * enabled at the same time. */\n\t\t\tif (inplace && make_backups > 0) {\n\t\t\t\tif (!(fnamecmp = get_backup_name(fname)))\n\t\t\t\t\tfnamecmp = fname;\n\t\t\t\telse\n\t\t\t\t\tfnamecmp_type = FNAMECMP_BACKUP;\n\t\t\t} else if (partial_dir && partialptr)\n\t\t\t\tfnamecmp = partialptr;\n\t\t\telse\n\t\t\t\tfnamecmp = fname;\n\t\t}\n\n\t\t/* open the file */\n\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\n\t\tif (fd1 == -1 && protocol_version < 29) {\n\t\t\tif (fnamecmp != fname) {\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\n\t\t\tif (fd1 == -1 && basis_dir[0]) {\n\t\t\t\t/* pre-29 allowed only one alternate basis */\n\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t basis_dir[0], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\t\t}\n\n\t\tupdating_basis_or_equiv = inplace\n\t\t    && (fnamecmp == fname || fnamecmp_type == FNAMECMP_BACKUP);\n\n\t\tif (fd1 == -1) {\n\t\t\tst.st_mode = 0;\n\t\t\tst.st_size = 0;\n\t\t} else if (do_fstat(fd1,&st) != 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"fstat %s failed\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {\n\t\t\t/* this special handling for directories\n\t\t\t * wouldn't be necessary if robust_rename()\n\t\t\t * and the underlying robust_unlink could cope\n\t\t\t * with directories\n\t\t\t */\n\t\t\trprintf(FERROR_XFER, \"recv_files: %s is a directory\\n\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && !S_ISREG(st.st_mode)) {\n\t\t\tclose(fd1);\n\t\t\tfd1 = -1;\n\t\t}\n\n\t\t/* If we're not preserving permissions, change the file-list's\n\t\t * mode based on the local permissions and some heuristics. */\n\t\tif (!preserve_perms) {\n\t\t\tint exists = fd1 != -1;\n#ifdef SUPPORT_ACLS\n\t\t\tconst char *dn = file->dirname ? file->dirname : \".\";\n\t\t\tif (parent_dirname != dn\n\t\t\t && strcmp(parent_dirname, dn) != 0) {\n\t\t\t\tdflt_perms = default_perms_for_dir(dn);\n\t\t\t\tparent_dirname = dn;\n\t\t\t}\n#endif\n\t\t\tfile->mode = dest_mode(file->mode, st.st_mode,\n\t\t\t\t\t       dflt_perms, exists);\n\t\t}\n\n\t\t/* We now check to see if we are writing the file \"inplace\" */\n\t\tif (inplace)  {\n\t\t\tfd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);\n\t\t\tif (fd2 == -1) {\n\t\t\t\trsyserr(FERROR_XFER, errno, \"open %s failed\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t} else if (updating_basis_or_equiv)\n\t\t\t\tcleanup_set(NULL, NULL, file, fd1, fd2);\n\t\t} else {\n\t\t\tfd2 = open_tmpfile(fnametmp, fname, file);\n\t\t\tif (fd2 != -1)\n\t\t\t\tcleanup_set(fnametmp, partialptr, file, fd1, fd2);\n\t\t}\n\n\t\tif (fd2 == -1) {\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tif (fd1 != -1)\n\t\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* log the transfer */\n\t\tif (log_before_transfer)\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\telse if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))\n\t\t\trprintf(FINFO, \"%s\\n\", fname);\n\n\t\t/* recv file data */\n\t\trecv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,\n\t\t\t\t       fname, fd2, F_LENGTH(file));\n\n\t\tlog_item(log_code, file, iflags, NULL);\n\n\t\tif (fd1 != -1)\n\t\t\tclose(fd1);\n\t\tif (close(fd2) < 0) {\n\t\t\trsyserr(FERROR, errno, \"close failed on %s\",\n\t\t\t\tfull_fname(fnametmp));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\n\t\tif ((recv_ok && (!delay_updates || !partialptr)) || inplace) {\n\t\t\tif (partialptr == fname)\n\t\t\t\tpartialptr = NULL;\n\t\t\tif (!finish_transfer(fname, fnametmp, fnamecmp,\n\t\t\t\t\t     partialptr, file, recv_ok, 1))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (fnamecmp == partialptr) {\n\t\t\t\tdo_unlink(partialptr);\n\t\t\t\thandle_partial_dir(partialptr, PDIR_DELETE);\n\t\t\t}\n\t\t} else if (keep_partial && partialptr) {\n\t\t\tif (!handle_partial_dir(partialptr, PDIR_CREATE)) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t    \"Unable to create partial-dir for %s -- discarding %s.\\n\",\n\t\t\t\t    local_name ? local_name : f_name(file, NULL),\n\t\t\t\t    recv_ok ? \"completed file\" : \"partial file\");\n\t\t\t\tdo_unlink(fnametmp);\n\t\t\t\trecv_ok = -1;\n\t\t\t} else if (!finish_transfer(partialptr, fnametmp, fnamecmp, NULL,\n\t\t\t\t\t\t    file, recv_ok, !partial_dir))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (delay_updates && recv_ok) {\n\t\t\t\tbitbag_set_bit(delayed_bits, ndx);\n\t\t\t\trecv_ok = 2;\n\t\t\t} else\n\t\t\t\tpartialptr = NULL;\n\t\t} else\n\t\t\tdo_unlink(fnametmp);\n\n\t\tcleanup_disable();\n\n\t\tif (read_batch)\n\t\t\tfile->flags |= FLAG_FILE_SENT;\n\n\t\tswitch (recv_ok) {\n\t\tcase 2:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (remove_source_files || inc_recurse\n\t\t\t || (preserve_hard_links && F_IS_HLINKED(file)))\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t\tbreak;\n\t\tcase 0: {\n\t\t\tenum logcode msgtype = redoing ? FERROR_XFER : FWARNING;\n\t\t\tif (msgtype == FERROR_XFER || INFO_GTE(NAME, 1)) {\n\t\t\t\tchar *errstr, *redostr, *keptstr;\n\t\t\t\tif (!(keep_partial && partialptr) && !inplace)\n\t\t\t\t\tkeptstr = \"discarded\";\n\t\t\t\telse if (partial_dir)\n\t\t\t\t\tkeptstr = \"put into partial-dir\";\n\t\t\t\telse\n\t\t\t\t\tkeptstr = \"retained\";\n\t\t\t\tif (msgtype == FERROR_XFER) {\n\t\t\t\t\terrstr = \"ERROR\";\n\t\t\t\t\tredostr = \"\";\n\t\t\t\t} else {\n\t\t\t\t\terrstr = \"WARNING\";\n\t\t\t\t\tredostr = read_batch ? \" (may try again)\"\n\t\t\t\t\t\t\t     : \" (will try again)\";\n\t\t\t\t}\n\t\t\t\trprintf(msgtype,\n\t\t\t\t\t\"%s: %s failed verification -- update %s%s.\\n\",\n\t\t\t\t\terrstr, local_name ? f_name(file, NULL) : fname,\n\t\t\t\t\tkeptstr, redostr);\n\t\t\t}\n\t\t\tif (!redoing) {\n\t\t\t\tif (read_batch)\n\t\t\t\t\tflist_ndx_push(&batch_redo_list, ndx);\n\t\t\t\tsend_msg_int(MSG_REDO, ndx);\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t} else if (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t    }\n\t\tcase -1:\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (make_backups < 0)\n\t\tmake_backups = -make_backups;\n\n\tif (phase == 2 && delay_updates) /* for protocol_version < 29 */\n\t\thandle_delayed_updates(local_name);\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO,\"recv_files finished\\n\");\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-862"
        ],
        "project": "rsync",
        "commit_id": "3e06d40029cfdce9d0f73d87cfd4edaf54be9c51",
        "hash": 273331075093136413116381357415413610728,
        "size": 436,
        "message": "Check fname in recv_files sooner."
    },
    {
        "func": "handle_get_connection (GVfsDBusDaemon *object,\n                       GDBusMethodInvocation *invocation,\n                       gpointer user_data)\n{\n  GVfsDaemon *daemon = G_VFS_DAEMON (user_data);\n  GDBusServer *server;\n  GError *error;\n  gchar *address1;\n  NewConnectionData *data;\n  char *socket_dir;\n  gchar *guid;\n  \n  generate_address (&address1, &socket_dir);\n\n  data = g_new (NewConnectionData, 1);\n  data->daemon = daemon;\n  data->socket_dir = socket_dir;\n  data->conn = NULL;\n\n  guid = g_dbus_generate_guid ();\n  error = NULL;\n  server = g_dbus_server_new_sync (address1,\n                                   G_DBUS_SERVER_FLAGS_NONE,\n                                   guid,\n                                   NULL, /* GDBusAuthObserver */\n                                   NULL, /* GCancellable */\n                                   &error);\n  g_free (guid);\n\n  if (server == NULL)\n    {\n      g_dbus_method_invocation_return_gerror (invocation, error);\n      g_printerr (\"daemon: Error creating server at address %s: %s\\n\", address1, error->message);\n      g_error_free (error);\n      goto error_out;\n    }\n\n  g_dbus_server_start (server);\n  data->server = server;\n\n  g_signal_connect (server, \"new-connection\", G_CALLBACK (daemon_new_connection_func), data);\n  \n  gvfs_dbus_daemon_complete_get_connection (object,\n                                            invocation,\n                                            address1,\n                                            \"\");\n\n  g_free (address1);\n  return TRUE;\n\n error_out:\n  new_connection_data_free (data);\n  g_free (address1);\n  return TRUE;\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "gvfs",
        "commit_id": "e3808a1b4042761055b1d975333a8243d67b8bfe",
        "hash": 118403742741540993123905023815401726201,
        "size": 55,
        "message": "gvfsdaemon: Check that the connecting client is the same user\n\nOtherwise, an attacker who learns the abstract socket address from\nnetstat(8) or similar could connect to it and issue D-Bus method\ncalls.\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>"
    },
    {
        "func": "g_vfs_daemon_init (GVfsDaemon *daemon)\n{\n  GError *error;\n  gint max_threads = 1; /* TODO: handle max threads */\n\n  daemon->thread_pool = g_thread_pool_new (job_handler_callback,\n\t\t\t\t\t   daemon,\n\t\t\t\t\t   max_threads,\n\t\t\t\t\t   FALSE, NULL);\n  /* TODO: verify thread_pool != NULL in a nicer way */\n  g_assert (daemon->thread_pool != NULL);\n\n  g_mutex_init (&daemon->lock);\n\n  daemon->mount_counter = 0;\n  \n  daemon->jobs = NULL;\n  daemon->registered_paths =\n    g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t   g_free, (GDestroyNotify)registered_path_free);\n\n  /* This is where we store active client connections so when a new filter is registered,\n   * we re-register them on all active connections */\n  daemon->client_connections =\n    g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL);\n\n  daemon->conn = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  g_assert (daemon->conn != NULL);\n\n  daemon->daemon_skeleton = gvfs_dbus_daemon_skeleton_new ();\n  g_signal_connect (daemon->daemon_skeleton, \"handle-get-connection\", G_CALLBACK (handle_get_connection), daemon);\n  g_signal_connect (daemon->daemon_skeleton, \"handle-cancel\", G_CALLBACK (handle_cancel), daemon);\n  g_signal_connect (daemon->daemon_skeleton, \"handle-list-monitor-implementations\", G_CALLBACK (handle_list_monitor_implementations), daemon);\n  \n  error = NULL;\n  if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton),\n                                         daemon->conn,\n                                         G_VFS_DBUS_DAEMON_PATH,\n                                         &error))\n    {\n      g_warning (\"Error exporting daemon interface: %s (%s, %d)\\n\",\n                  error->message, g_quark_to_string (error->domain), error->code);\n      g_error_free (error);\n    }\n\n  daemon->mountable_skeleton = gvfs_dbus_mountable_skeleton_new ();\n  g_signal_connect (daemon->mountable_skeleton, \"handle-mount\", G_CALLBACK (daemon_handle_mount), daemon);\n  \n  error = NULL;\n  if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton),\n      daemon->conn,\n                                         G_VFS_DBUS_MOUNTABLE_PATH,\n                                         &error))\n    {\n      g_warning (\"Error exporting mountable interface: %s (%s, %d)\\n\",\n                  error->message, g_quark_to_string (error->domain), error->code);\n      g_error_free (error);\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "gvfs",
        "commit_id": "e3808a1b4042761055b1d975333a8243d67b8bfe",
        "hash": 17821737996076359297921099296834849012,
        "size": 59,
        "message": "gvfsdaemon: Check that the connecting client is the same user\n\nOtherwise, an attacker who learns the abstract socket address from\nnetstat(8) or similar could connect to it and issue D-Bus method\ncalls.\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>"
    },
    {
        "func": "g_vfs_daemon_finalize (GObject *object)\n{\n  GVfsDaemon *daemon;\n\n  daemon = G_VFS_DAEMON (object);\n\n  /* There may be some jobs outstanding if we've been force unmounted. */\n  if (daemon->jobs)\n    g_warning (\"daemon->jobs != NULL when finalizing daemon!\");\n\n  if (daemon->name_watcher)\n    g_bus_unwatch_name (daemon->name_watcher);\n  \n  if (daemon->daemon_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));\n      g_object_unref (daemon->daemon_skeleton);\n    }\n  if (daemon->mountable_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));\n      g_object_unref (daemon->mountable_skeleton);\n    }\n  if (daemon->conn != NULL)\n    g_object_unref (daemon->conn);\n  \n  g_hash_table_destroy (daemon->registered_paths);\n  g_hash_table_destroy (daemon->client_connections);\n  g_mutex_clear (&daemon->lock);\n\n  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)\n    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "gvfs",
        "commit_id": "e3808a1b4042761055b1d975333a8243d67b8bfe",
        "hash": 90399487585819130142954234980197672813,
        "size": 33,
        "message": "gvfsdaemon: Check that the connecting client is the same user\n\nOtherwise, an attacker who learns the abstract socket address from\nnetstat(8) or similar could connect to it and issue D-Bus method\ncalls.\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>"
    },
    {
        "func": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "linux",
        "commit_id": "0614e2b73768b502fc32a75349823356d98aae2c",
        "hash": 307665787869946408913963986180448516480,
        "size": 78,
        "message": "ax25: enforce CAP_NET_RAW for raw sockets\n\nWhen creating a raw AF_AX25 socket, CAP_NET_RAW needs to be checked\nfirst.\n\nSigned-off-by: Ori Nimron <orinimron123@gmail.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\n\tsock->ops = ops;\n\n\tsock_init_data(sock, sk);\n\t/* FIXME: sk->sk_destruct */\n\tsk->sk_family = PF_IEEE802154;\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "linux",
        "commit_id": "e69dbd4619e7674c1679cba49afd9dd9ac347eef",
        "hash": 306851075307384729616196281475384551491,
        "size": 56,
        "message": "ieee802154: enforce CAP_NET_RAW for raw sockets\n\nWhen creating a raw AF_IEEE802154 socket, CAP_NET_RAW needs to be\nchecked first.\n\nSigned-off-by: Ori Nimron <orinimron123@gmail.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nAcked-by: Stefan Schmidt <stefan@datenfreihafen.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "linux",
        "commit_id": "6cc03e8aa36c51f3b26a0d21a3c4ce2809c842ac",
        "hash": 249710132060564727071947784645273585121,
        "size": 28,
        "message": "appletalk: enforce CAP_NET_RAW for raw sockets\n\nWhen creating a raw AF_APPLETALK socket, CAP_NET_RAW needs to be checked\nfirst.\n\nSigned-off-by: Ori Nimron <orinimron123@gmail.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "linux",
        "commit_id": "3a359798b176183ef09efb7a3dc59abad1cc7104",
        "hash": 156958787826633462351523734977604260656,
        "size": 23,
        "message": "nfc: enforce CAP_NET_RAW for raw sockets\n\nWhen creating a raw AF_NFC socket, CAP_NET_RAW needs to be checked\nfirst.\n\nSigned-off-by: Ori Nimron <orinimron123@gmail.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-276",
            "CWE-703"
        ],
        "project": "linux",
        "commit_id": "26896f01467a28651f7a536143fe5ac8449d4041",
        "hash": 76158006236225806046621099350006167099,
        "size": 32,
        "message": "net/nfc/rawsock.c: add CAP_NET_RAW check.\n\nWhen creating a raw AF_NFC socket, CAP_NET_RAW needs to be checked first.\n\nSigned-off-by: Qingyu Li <ieatmuttonchuan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "void Server::handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "minetest",
        "commit_id": "3693b6871eba268ecc79b3f52d00d3cefe761131",
        "hash": 199937208238264874164511724916156061054,
        "size": 177,
        "message": "Prevent players accessing inventories of other players (#10341)"
    },
    {
        "func": "static int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\n\t/*\n\t * Protect exec's credential calculations against our interference;\n\t * SUID, SGID and LSM creds get determined differently\n\t * under ptrace.\n\t */\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\n\ttask->ptrace = flags;\n\n\tptrace_link(task, current);\n\n\t/* SEIZE doesn't trap tracee on attach */\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\n\tspin_lock(&task->sighand->siglock);\n\n\t/*\n\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and\n\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING\n\t * will be cleared if the child completes the transition or any\n\t * event which clears the group stop states happens.  We'll wait\n\t * for the transition to complete before returning from this\n\t * function.\n\t *\n\t * This hides STOPPED -> RUNNING -> TRACED transition from the\n\t * attaching thread but a different thread in the same group can\n\t * still observe the transient RUNNING state.  IOW, if another\n\t * thread's WNOHANG wait(2) on the stopped tracee races against\n\t * ATTACH, the wait(2) may fail due to the transient RUNNING.\n\t *\n\t * The following task_is_stopped() test is safe as both transitions\n\t * in and out of STOPPED are protected by siglock.\n\t */\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\n\tspin_unlock(&task->sighand->siglock);\n\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\t/*\n\t\t * We do not bother to change retval or clear JOBCTL_TRAPPING\n\t\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will\n\t\t * not return to user-mode, it will exit and clear this bit in\n\t\t * __ptrace_unlink() if it wasn't already cleared by the tracee;\n\t\t * and until then nobody can ptrace this task.\n\t\t */\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\n\treturn retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-276",
            "CWE-703",
            "CWE-863"
        ],
        "project": "linux",
        "commit_id": "ee1fee900537b5d9560e9f937402de5ddc8412f3",
        "hash": 5385277698898368464207342287484526383,
        "size": 101,
        "message": "ptrace: Check PTRACE_O_SUSPEND_SECCOMP permission on PTRACE_SEIZE\n\nSetting PTRACE_O_SUSPEND_SECCOMP is supposed to be a highly privileged\noperation because it allows the tracee to completely bypass all seccomp\nfilters on kernels with CONFIG_CHECKPOINT_RESTORE=y. It is only supposed to\nbe settable by a process with global CAP_SYS_ADMIN, and only if that\nprocess is not subject to any seccomp filters at all.\n\nHowever, while these permission checks were done on the PTRACE_SETOPTIONS\npath, they were missing on the PTRACE_SEIZE path, which also sets\nuser-specified ptrace flags.\n\nMove the permissions checks out into a helper function and let both\nptrace_attach() and ptrace_setoptions() call it.\n\nCc: stable@kernel.org\nFixes: 13c4a90119d2 (\"seccomp: add ptrace options for suspend/resume\")\nSigned-off-by: Jann Horn <jannh@google.com>\nLink: https://lkml.kernel.org/r/20220319010838.1386861-1-jannh@google.com\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>"
    },
    {
        "func": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Avoid intermediate state when all opts are cleared */\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-276",
            "CWE-703",
            "CWE-863"
        ],
        "project": "linux",
        "commit_id": "ee1fee900537b5d9560e9f937402de5ddc8412f3",
        "hash": 212362199969891296141898541045790445609,
        "size": 28,
        "message": "ptrace: Check PTRACE_O_SUSPEND_SECCOMP permission on PTRACE_SEIZE\n\nSetting PTRACE_O_SUSPEND_SECCOMP is supposed to be a highly privileged\noperation because it allows the tracee to completely bypass all seccomp\nfilters on kernels with CONFIG_CHECKPOINT_RESTORE=y. It is only supposed to\nbe settable by a process with global CAP_SYS_ADMIN, and only if that\nprocess is not subject to any seccomp filters at all.\n\nHowever, while these permission checks were done on the PTRACE_SETOPTIONS\npath, they were missing on the PTRACE_SEIZE path, which also sets\nuser-specified ptrace flags.\n\nMove the permissions checks out into a helper function and let both\nptrace_attach() and ptrace_setoptions() call it.\n\nCc: stable@kernel.org\nFixes: 13c4a90119d2 (\"seccomp: add ptrace options for suspend/resume\")\nSigned-off-by: Jann Horn <jannh@google.com>\nLink: https://lkml.kernel.org/r/20220319010838.1386861-1-jannh@google.com\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>"
    },
    {
        "func": "static const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)\n{\n\tchar *dst = NULL;\n\tu8 *res;\n\n\tres = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);\n\tif (res) data = res;\n\n#define PROBE_OK(_score, _mime) \\\n\t\t*score = _score;\\\n\t\tif (dst) gf_free(dst);\\\n\t\treturn _mime; \\\n\n\n\tif (!strncmp(data, \"WEBVTT\", 6)) {\n\t\tPROBE_OK(GF_FPROBE_SUPPORTED, \"subtitle/vtt\")\n\t}\n\tif (strstr(data, \" --> \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/srt\")\n\t}\n\tif (!strncmp(data, \"FWS\", 3) || !strncmp(data, \"CWS\", 3)) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"application/x-shockwave-flash\")\n\t}\n\n\tif ((data[0]=='{') && strstr(data, \"}{\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/sub\")\n\n\t}\n\t/*XML formats*/\n\tif (!strstr(data, \"?>\") ) {\n\t\tif (dst) gf_free(dst);\n\t\treturn NULL;\n\t}\n\n\tif (strstr(data, \"<x-quicktime-tx3g\") || strstr(data, \"<text3GTrack\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"quicktime/text\")\n\t}\n\tif (strstr(data, \"TextStream\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttxt\")\n\t}\n\tif (strstr(data, \"<tt \") || strstr(data, \":tt \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttml\")\n\t}\n\n\tif (dst) gf_free(dst);\n\treturn NULL;",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "gpac",
        "commit_id": "96699aabae042f8f55cf8a85fa5758e3db752bae",
        "hash": 112426729705997869789852713666738284958,
        "size": 46,
        "message": "fixed #2061"
    },
    {
        "func": "char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr)\n{\n\tu32 unicode_type = 0;\n\t*out_ptr = NULL;\n\n\tif (size>=5) {\n\t\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\t\tif ((data[0]==0xFF) && (data[1]==0xFE)) {\n\t\t\tif (!data[2] && !data[3]) {\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tunicode_type = 2;\n\t\t\t}\n\t\t} else if ((data[0]==0xFE) && (data[1]==0xFF)) {\n\t\t\tif (!data[2] && !data[3]) {\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tunicode_type = 1;\n\t\t\t}\n\t\t} else if ((data[0]==0xEF) && (data[1]==0xBB) && (data[2]==0xBF)) {\n\t\t\treturn data+4;\n\t\t}\n\t}\n\n\tif (!unicode_type) return data;\n\n\tif (size%2) size--;\n\tu16 *str_wc = gf_malloc(size+2);\n\tu16 *srcwc;\n\tchar *dst = gf_malloc(size+2);\n\t*out_ptr = dst;\n\tu32 i;\n\tfor (i=0; i<size; i+=2) {\n\t\tu16 wchar=0;\n\t\tu8 c1 = data[i];\n\t\tu8 c2 = data[i+1];\n\n\t\t/*Little-endian order*/\n\t\tif (unicode_type==2) {\n\t\t\tif (c2) {\n\t\t\t\twchar = c2;\n\t\t\t\twchar <<=8;\n\t\t\t\twchar |= c1;\n\t\t\t}\n\t\t\telse wchar = c1;\n\t\t} else {\n\t\t\twchar = c1;\n\t\t\tif (c2) {\n\t\t\t\twchar <<= 8;\n\t\t\t\twchar |= c2;\n\t\t\t}\n\t\t}\n\t\tstr_wc[i/2] = wchar;\n\t}\n\tstr_wc[i/2] = 0;\n\tsrcwc = str_wc;\n\tgf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);\n\tgf_free(str_wc);\n\n\treturn dst;\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "gpac",
        "commit_id": "96699aabae042f8f55cf8a85fa5758e3db752bae",
        "hash": 320820759548712596355676070369908723375,
        "size": 61,
        "message": "fixed #2061"
    },
    {
        "func": "static const char *ctxload_probe_data(const u8 *probe_data, u32 size, GF_FilterProbeScore *score)\n{\n\tconst char *mime_type = NULL;\n\tchar *dst = NULL;\n\tu8 *res;\n\n\t/* check gzip magic header */\n\tif ((size>2) && (probe_data[0] == 0x1f) && (probe_data[1] == 0x8b)) {\n\t\t*score = GF_FPROBE_EXT_MATCH;\n\t\treturn \"btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz\";\n\t}\n\n\tres = gf_utf_get_utf8_string_from_bom((char *)probe_data, size, &dst);\n\tif (res) probe_data = res;\n\n\t//strip all spaces and \\r\\n\n\twhile (probe_data[0] && strchr(\"\\n\\r\\t \", (char) probe_data[0]))\n\t\tprobe_data ++;\n\n\t//for XML, strip doctype, <?xml and comments\n\twhile (1) {\n\t\tif (!strncmp(probe_data, \"<!DOCTYPE\", 9)) {\n\t\t\tprobe_data = strchr(probe_data, '>');\n\t\t\tif (!probe_data) goto exit;\n\t\t\tprobe_data++;\n\t\t\twhile (probe_data[0] && strchr(\"\\n\\r\\t \", (char) probe_data[0]))\n\t\t\t\tprobe_data ++;\n\t\t}\n\t\t//for XML, strip xml header\n\t\telse if (!strncmp(probe_data, \"<?xml\", 5)) {\n\t\t\tprobe_data = strstr(probe_data, \"?>\");\n\t\t\tif (!probe_data) goto exit;\n\n\t\t\tprobe_data += 2;\n\t\t\twhile (probe_data[0] && strchr(\"\\n\\r\\t \", (char) probe_data[0]))\n\t\t\t\tprobe_data ++;\n\t\t}\n\t\telse if (!strncmp(probe_data, \"<!--\", 4)) {\n\t\t\tprobe_data = strstr(probe_data, \"-->\");\n\t\t\tif (!probe_data) goto exit;\n\t\t\tprobe_data += 3;\n\t\t\twhile (probe_data[0] && strchr(\"\\n\\r\\t \", (char) probe_data[0]))\n\t\t\t\tprobe_data ++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//probe_data is now the first element of the document, if XML\n\t//we should refin by getting the xmlns attribute value rather than searching for its value...\n\n\tif (!strncmp(probe_data, \"<XMT-A\", strlen(\"<XMT-A\"))\n\t\t|| strstr(probe_data, \"urn:mpeg:mpeg4:xmta:schema:2002\")\n\t) {\n\t\tmime_type = \"application/x-xmt\";\n\t} else if (strstr(probe_data, \"<X3D\")\n\t\t|| strstr(probe_data, \"http://www.web3d.org/specifications/x3d-3.0.xsd\")\n\t) {\n\t\tmime_type = \"model/x3d+xml\";\n\t} else if (strstr(probe_data, \"<saf\")\n\t\t|| strstr(probe_data, \"urn:mpeg:mpeg4:SAF:2005\")\n\t\t|| strstr(probe_data, \"urn:mpeg:mpeg4:LASeR:2005\")\n\t) {\n\t\tmime_type = \"application/x-LASeR+xml\";\n\t} else if (!strncmp(probe_data, \"<DIMSStream\", strlen(\"<DIMSStream\") ) ) {\n\t\tmime_type = \"application/dims\";\n\t} else if (!strncmp(probe_data, \"<svg\", 4) || strstr(probe_data, \"http://www.w3.org/2000/svg\") ) {\n\t\tmime_type = \"image/svg+xml\";\n\t} else if (!strncmp(probe_data, \"<widget\", strlen(\"<widget\") ) ) {\n\t\tmime_type = \"application/widget\";\n\t} else if (!strncmp(probe_data, \"<NHNTStream\", strlen(\"<NHNTStream\") ) ) {\n\t\tmime_type = \"application/x-nhml\";\n\t} else if (!strncmp(probe_data, \"<TextStream\", strlen(\"<TextStream\") ) ) {\n\t\tmime_type = \"text/ttxt\";\n\t} else if (!strncmp(probe_data, \"<text3GTrack\", strlen(\"<text3GTrack\") ) ) {\n\t\tmime_type = \"quicktime/text\";\n\t}\n\t//BT/VRML with no doc header\n\telse {\n\t\t//get first keyword\n\t\twhile (1) {\n\t\t\t//strip all spaces and \\r\\n\n\t\t\twhile (probe_data[0] && strchr(\"\\n\\r\\t \", (char) probe_data[0]))\n\t\t\t\tprobe_data ++;\n\n\t\t\t//VRML / XRDV files\n\t\t\tif (!strncmp(probe_data, \"#VRML V2.0\", strlen(\"#VRML V2.0\"))) {\n\t\t\t\tmime_type = \"model/vrml\";\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (!strncmp(probe_data, \"#X3D V3.0\", strlen(\"#X3D V3.0\"))) {\n\t\t\t\tmime_type = \"model/x3d+vrml\";\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\t//skip comment lines and some specific X3D keyword (we want to fetch a group\n\t\t\tif ((probe_data[0] != '#')\n\t\t\t\t&& strncmp(probe_data, \"PROFILE\", strlen(\"PROFILE\"))\n\t\t\t\t&& strncmp(probe_data, \"COMPONENT\", strlen(\"COMPONENT\"))\n\t\t\t\t&& strncmp(probe_data, \"META\", strlen(\"META\"))\n\t\t\t\t&& strncmp(probe_data, \"IMPORT\", strlen(\"IMPORT\"))\n\t\t\t\t&& strncmp(probe_data, \"EXPORT\", strlen(\"EXPORT\"))\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//skip line and go one\n\t\t\tprobe_data = strchr(probe_data, '\\n');\n\t\t\tif (!probe_data) goto exit;\n\t\t}\n\t\t\n\t\tif (!strncmp(probe_data, \"InitialObjectDescriptor\", strlen(\"InitialObjectDescriptor\"))\n\t\t\t|| !strncmp(probe_data, \"EXTERNPROTO\", strlen(\"EXTERNPROTO\"))\n\t\t\t|| !strncmp(probe_data, \"PROTO\", strlen(\"PROTO\"))\n\t\t\t|| !strncmp(probe_data, \"Group\", strlen(\"Group\"))\n\t\t\t|| !strncmp(probe_data, \"OrderedGroup\", strlen(\"OrderedGroup\"))\n\t\t\t|| !strncmp(probe_data, \"Layer2D\", strlen(\"Layer2D\"))\n\t\t\t|| !strncmp(probe_data, \"Layer3D\", strlen(\"Layer3D\"))\n\t\t) {\n\t\t\tif (strstr(probe_data, \"children\"))\n\t\t\t\tmime_type = \"application/x-bt\";\n\t\t}\n\t}\n\n\nexit:\n\n\tif (dst) gf_free(dst);\n\tif (mime_type) {\n\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn mime_type;\n\t}\n\n\t*score = GF_FPROBE_NOT_SUPPORTED;\n\treturn NULL;\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "gpac",
        "commit_id": "96699aabae042f8f55cf8a85fa5758e3db752bae",
        "hash": 53395394904337962381264667205703138095,
        "size": 134,
        "message": "fixed #2061"
    },
    {
        "func": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n\n          process->capabilities = capabilities;\n        }\n\n      // noNewPriviledges will remain `false` if basespec has `false` unless specified\n      // Default is always `true` in generated basespec config\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n\n      exec_opts.process = process;\n    }\n\n  exec_opts.cgroup = exec_options.cgroup;\n\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "crun",
        "commit_id": "1aeeed2e4fdeffb4875c0d0b439915894594c8c6",
        "hash": 67555112620788823184421673030526843273,
        "size": 93,
        "message": "exec: --cap do not set inheritable capabilities\n\nCloses: CVE-2022-27650\n\nSigned-off-by: Giuseppe Scrivano <gscrivan@redhat.com>"
    },
    {
        "func": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\t/*\n\t * Invalidate I/O bitmap if the previous task used it. This prevents\n\t * any possible leakage of an active I/O bitmap.\n\t *\n\t * If the next task has an I/O bitmap it will handle it on exit to\n\t * user mode.\n\t */\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}",
        "target": 1,
        "cwe": [
            "CWE-276"
        ],
        "project": "linux",
        "commit_id": "cadfad870154e14f745ec845708bc17d166065f2",
        "hash": 88881257216085457880326693481037751100,
        "size": 12,
        "message": "x86/ioperm: Fix io bitmap invalidation on Xen PV\n\ntss_invalidate_io_bitmap() wasn't wired up properly through the pvop\nmachinery, so the TSS and Xen's io bitmap would get out of sync\nwhenever disabling a valid io bitmap.\n\nAdd a new pvop for tss_invalidate_io_bitmap() to fix it.\n\nThis is XSA-329.\n\nFixes: 22fe5b0439dd (\"x86/ioperm: Move TSS bitmap update to exit to user work\")\nSigned-off-by: Andy Lutomirski <luto@kernel.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nReviewed-by: Juergen Gross <jgross@suse.com>\nReviewed-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@vger.kernel.org\nLink: https://lkml.kernel.org/r/d53075590e1f91c19f8af705059d3ff99424c020.1595030016.git.luto@kernel.org"
    },
    {
        "func": "void hash_preload(struct mm_struct *mm, unsigned long ea,\n\t\t  unsigned long access, unsigned long trap)\n{\n\tunsigned long vsid;\n\tvoid *pgdir;\n\tpte_t *ptep;\n\tcpumask_t mask;\n\tunsigned long flags;\n\tint local = 0;\n\n\t/* We don't want huge pages prefaulted for now\n\t */\n\tif (unlikely(in_hugepage_area(mm->context, ea)))\n\t\treturn;\n\n\tDBG_LOW(\"hash_preload(mm=%p, mm->pgdir=%p, ea=%016lx, access=%lx,\"\n\t\t\" trap=%lx\\n\", mm, mm->pgd, ea, access, trap);\n\n\t/* Get PTE, VSID, access mask */\n\tpgdir = mm->pgd;\n\tif (pgdir == NULL)\n\t\treturn;\n\tptep = find_linux_pte(pgdir, ea);\n\tif (!ptep)\n\t\treturn;\n\tvsid = get_vsid(mm->context.id, ea);\n\n\t/* Hash it in */\n\tlocal_irq_save(flags);\n\tmask = cpumask_of_cpu(smp_processor_id());\n\tif (cpus_equal(mm->cpu_vm_mask, mask))\n\t\tlocal = 1;\n#ifndef CONFIG_PPC_64K_PAGES\n\t__hash_page_4K(ea, access, vsid, ptep, trap, local);\n#else\n\tif (mmu_ci_restrictions) {\n\t\t/* If this PTE is non-cacheable, switch to 4k */\n\t\tif (mm->context.user_psize == MMU_PAGE_64K &&\n\t\t    (pte_val(*ptep) & _PAGE_NO_CACHE)) {\n\t\t\tmm->context.user_psize = MMU_PAGE_4K;\n\t\t\tmm->context.sllp = SLB_VSID_USER |\n\t\t\t\tmmu_psize_defs[MMU_PAGE_4K].sllp;\n\t\t\tget_paca()->context = mm->context;\n\t\t\tslb_flush_and_rebolt();\n#ifdef CONFIG_SPE_BASE\n\t\t\tspu_flush_all_slbs(mm);\n#endif\n\t\t}\n\t}\n\tif (mm->context.user_psize == MMU_PAGE_64K)\n\t\t__hash_page_64K(ea, access, vsid, ptep, trap, local);\n\telse\n\t\t__hash_page_4K(ea, access, vsid, ptep, trap, local);\n#endif /* CONFIG_PPC_64K_PAGES */\n\tlocal_irq_restore(flags);\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "721151d004dcf01a71b12bb6b893f9160284cf6e",
        "hash": 283712393711387453956188968218825085417,
        "size": 56,
        "message": "[POWERPC] Allow drivers to map individual 4k pages to userspace\n\nSome drivers have resources that they want to be able to map into\nuserspace that are 4k in size.  On a kernel configured with 64k pages\nwe currently end up mapping the 4k we want plus another 60k of\nphysical address space, which could contain anything.  This can\nintroduce security problems, for example in the case of an infiniband\nadaptor where the other 60k could contain registers that some other\nprogram is using for its communications.\n\nThis patch adds a new function, remap_4k_pfn, which drivers can use to\nmap a single 4k page to userspace regardless of whether the kernel is\nusing a 4k or a 64k page size.  Like remap_pfn_range, it would\ntypically be called in a driver's mmap function.  It only maps a\nsingle 4k page, which on a 64k page kernel appears replicated 16 times\nthroughout a 64k page.  On a 4k page kernel it reduces to a call to\nremap_pfn_range.\n\nThe way this works on a 64k kernel is that a new bit, _PAGE_4K_PFN,\ngets set on the linux PTE.  This alters the way that __hash_page_4K\ncomputes the real address to put in the HPTE.  The RPN field of the\nlinux PTE becomes the 4k RPN directly rather than being interpreted as\na 64k RPN.  Since the RPN field is 32 bits, this means that physical\naddresses being mapped with remap_4k_pfn have to be below 2^44,\ni.e. 0x100000000000.\n\nThe patch also factors out the code in arch/powerpc/mm/hash_utils_64.c\nthat deals with demoting a process to use 4k pages into one function\nthat gets called in the various different places where we need to do\nthat.  There were some discrepancies between exactly what was done in\nthe various places, such as a call to spu_flush_all_slbs in one case\nbut not in others.\n\nSigned-off-by: Paul Mackerras <paulus@samba.org>"
    },
    {
        "func": "int hash_page(unsigned long ea, unsigned long access, unsigned long trap)\n{\n\tvoid *pgdir;\n\tunsigned long vsid;\n\tstruct mm_struct *mm;\n\tpte_t *ptep;\n\tcpumask_t tmp;\n\tint rc, user_region = 0, local = 0;\n\tint psize;\n\n\tDBG_LOW(\"hash_page(ea=%016lx, access=%lx, trap=%lx\\n\",\n\t\tea, access, trap);\n\n\tif ((ea & ~REGION_MASK) >= PGTABLE_RANGE) {\n\t\tDBG_LOW(\" out of pgtable range !\\n\");\n \t\treturn 1;\n\t}\n\n\t/* Get region & vsid */\n \tswitch (REGION_ID(ea)) {\n\tcase USER_REGION_ID:\n\t\tuser_region = 1;\n\t\tmm = current->mm;\n\t\tif (! mm) {\n\t\t\tDBG_LOW(\" user region with no mm !\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tvsid = get_vsid(mm->context.id, ea);\n\t\tpsize = mm->context.user_psize;\n\t\tbreak;\n\tcase VMALLOC_REGION_ID:\n\t\tmm = &init_mm;\n\t\tvsid = get_kernel_vsid(ea);\n\t\tif (ea < VMALLOC_END)\n\t\t\tpsize = mmu_vmalloc_psize;\n\t\telse\n\t\t\tpsize = mmu_io_psize;\n\t\tbreak;\n\tdefault:\n\t\t/* Not a valid range\n\t\t * Send the problem up to do_page_fault \n\t\t */\n\t\treturn 1;\n\t}\n\tDBG_LOW(\" mm=%p, mm->pgdir=%p, vsid=%016lx\\n\", mm, mm->pgd, vsid);\n\n\t/* Get pgdir */\n\tpgdir = mm->pgd;\n\tif (pgdir == NULL)\n\t\treturn 1;\n\n\t/* Check CPU locality */\n\ttmp = cpumask_of_cpu(smp_processor_id());\n\tif (user_region && cpus_equal(mm->cpu_vm_mask, tmp))\n\t\tlocal = 1;\n\n\t/* Handle hugepage regions */\n\tif (unlikely(in_hugepage_area(mm->context, ea))) {\n\t\tDBG_LOW(\" -> huge page !\\n\");\n\t\treturn hash_huge_page(mm, access, ea, vsid, local, trap);\n\t}\n\n\t/* Get PTE and page size from page tables */\n\tptep = find_linux_pte(pgdir, ea);\n\tif (ptep == NULL || !pte_present(*ptep)) {\n\t\tDBG_LOW(\" no PTE !\\n\");\n\t\treturn 1;\n\t}\n\n#ifndef CONFIG_PPC_64K_PAGES\n\tDBG_LOW(\" i-pte: %016lx\\n\", pte_val(*ptep));\n#else\n\tDBG_LOW(\" i-pte: %016lx %016lx\\n\", pte_val(*ptep),\n\t\tpte_val(*(ptep + PTRS_PER_PTE)));\n#endif\n\t/* Pre-check access permissions (will be re-checked atomically\n\t * in __hash_page_XX but this pre-check is a fast path\n\t */\n\tif (access & ~pte_val(*ptep)) {\n\t\tDBG_LOW(\" no access !\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Do actual hashing */\n#ifndef CONFIG_PPC_64K_PAGES\n\trc = __hash_page_4K(ea, access, vsid, ptep, trap, local);\n#else\n\tif (mmu_ci_restrictions) {\n\t\t/* If this PTE is non-cacheable, switch to 4k */\n\t\tif (psize == MMU_PAGE_64K &&\n\t\t    (pte_val(*ptep) & _PAGE_NO_CACHE)) {\n\t\t\tif (user_region) {\n\t\t\t\tpsize = MMU_PAGE_4K;\n\t\t\t\tmm->context.user_psize = MMU_PAGE_4K;\n\t\t\t\tmm->context.sllp = SLB_VSID_USER |\n\t\t\t\t\tmmu_psize_defs[MMU_PAGE_4K].sllp;\n\t\t\t} else if (ea < VMALLOC_END) {\n\t\t\t\t/*\n\t\t\t\t * some driver did a non-cacheable mapping\n\t\t\t\t * in vmalloc space, so switch vmalloc\n\t\t\t\t * to 4k pages\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ALERT \"Reducing vmalloc segment \"\n\t\t\t\t       \"to 4kB pages because of \"\n\t\t\t\t       \"non-cacheable mapping\\n\");\n\t\t\t\tpsize = mmu_vmalloc_psize = MMU_PAGE_4K;\n\t\t\t}\n#ifdef CONFIG_SPE_BASE\n\t\t\tspu_flush_all_slbs(mm);\n#endif\n\t\t}\n\t\tif (user_region) {\n\t\t\tif (psize != get_paca()->context.user_psize) {\n\t\t\t\tget_paca()->context = mm->context;\n\t\t\t\tslb_flush_and_rebolt();\n\t\t\t}\n\t\t} else if (get_paca()->vmalloc_sllp !=\n\t\t\t   mmu_psize_defs[mmu_vmalloc_psize].sllp) {\n\t\t\tget_paca()->vmalloc_sllp =\n\t\t\t\tmmu_psize_defs[mmu_vmalloc_psize].sllp;\n\t\t\tslb_flush_and_rebolt();\n\t\t}\n\t}\n\tif (psize == MMU_PAGE_64K)\n\t\trc = __hash_page_64K(ea, access, vsid, ptep, trap, local);\n\telse\n\t\trc = __hash_page_4K(ea, access, vsid, ptep, trap, local);\n#endif /* CONFIG_PPC_64K_PAGES */\n\n#ifndef CONFIG_PPC_64K_PAGES\n\tDBG_LOW(\" o-pte: %016lx\\n\", pte_val(*ptep));\n#else\n\tDBG_LOW(\" o-pte: %016lx %016lx\\n\", pte_val(*ptep),\n\t\tpte_val(*(ptep + PTRS_PER_PTE)));\n#endif\n\tDBG_LOW(\" -> rc=%d\\n\", rc);\n\treturn rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "721151d004dcf01a71b12bb6b893f9160284cf6e",
        "hash": 9811447350898023489441854944582708716,
        "size": 138,
        "message": "[POWERPC] Allow drivers to map individual 4k pages to userspace\n\nSome drivers have resources that they want to be able to map into\nuserspace that are 4k in size.  On a kernel configured with 64k pages\nwe currently end up mapping the 4k we want plus another 60k of\nphysical address space, which could contain anything.  This can\nintroduce security problems, for example in the case of an infiniband\nadaptor where the other 60k could contain registers that some other\nprogram is using for its communications.\n\nThis patch adds a new function, remap_4k_pfn, which drivers can use to\nmap a single 4k page to userspace regardless of whether the kernel is\nusing a 4k or a 64k page size.  Like remap_pfn_range, it would\ntypically be called in a driver's mmap function.  It only maps a\nsingle 4k page, which on a 64k page kernel appears replicated 16 times\nthroughout a 64k page.  On a 4k page kernel it reduces to a call to\nremap_pfn_range.\n\nThe way this works on a 64k kernel is that a new bit, _PAGE_4K_PFN,\ngets set on the linux PTE.  This alters the way that __hash_page_4K\ncomputes the real address to put in the HPTE.  The RPN field of the\nlinux PTE becomes the 4k RPN directly rather than being interpreted as\na 64k RPN.  Since the RPN field is 32 bits, this means that physical\naddresses being mapped with remap_4k_pfn have to be below 2^44,\ni.e. 0x100000000000.\n\nThe patch also factors out the code in arch/powerpc/mm/hash_utils_64.c\nthat deals with demoting a process to use 4k pages into one function\nthat gets called in the various different places where we need to do\nthat.  There were some discrepancies between exactly what was done in\nthe various places, such as a call to spu_flush_all_slbs in one case\nbut not in others.\n\nSigned-off-by: Paul Mackerras <paulus@samba.org>"
    },
    {
        "func": "shmem_alloc_page(gfp_t gfp,struct shmem_inode_info *info, unsigned long idx)\n{\n\treturn alloc_page(gfp | __GFP_ZERO);\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "e84e2e132c9c66d8498e7710d4ea532d1feaaac5",
        "hash": 40898721436560148466228075046362201453,
        "size": 4,
        "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static int shmem_getpage(struct inode *inode, unsigned long idx,\n\t\t\tstruct page **pagep, enum sgp_type sgp, int *type)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tstruct shmem_sb_info *sbinfo;\n\tstruct page *filepage = *pagep;\n\tstruct page *swappage;\n\tswp_entry_t *entry;\n\tswp_entry_t swap;\n\tint error;\n\n\tif (idx >= SHMEM_MAX_INDEX)\n\t\treturn -EFBIG;\n\n\tif (type)\n\t\t*type = 0;\n\n\t/*\n\t * Normally, filepage is NULL on entry, and either found\n\t * uptodate immediately, or allocated and zeroed, or read\n\t * in under swappage, which is then assigned to filepage.\n\t * But shmem_readpage and shmem_write_begin pass in a locked\n\t * filepage, which may be found not uptodate by other callers\n\t * too, and may need to be copied from the swappage read in.\n\t */\nrepeat:\n\tif (!filepage)\n\t\tfilepage = find_lock_page(mapping, idx);\n\tif (filepage && PageUptodate(filepage))\n\t\tgoto done;\n\terror = 0;\n\tif (sgp == SGP_QUICK)\n\t\tgoto failed;\n\n\tspin_lock(&info->lock);\n\tshmem_recalc_inode(inode);\n\tentry = shmem_swp_alloc(info, idx, sgp);\n\tif (IS_ERR(entry)) {\n\t\tspin_unlock(&info->lock);\n\t\terror = PTR_ERR(entry);\n\t\tgoto failed;\n\t}\n\tswap = *entry;\n\n\tif (swap.val) {\n\t\t/* Look it up and read it in.. */\n\t\tswappage = lookup_swap_cache(swap);\n\t\tif (!swappage) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\t/* here we actually do the io */\n\t\t\tif (type && !(*type & VM_FAULT_MAJOR)) {\n\t\t\t\t__count_vm_event(PGMAJFAULT);\n\t\t\t\t*type |= VM_FAULT_MAJOR;\n\t\t\t}\n\t\t\tspin_unlock(&info->lock);\n\t\t\tswappage = shmem_swapin(info, swap, idx);\n\t\t\tif (!swappage) {\n\t\t\t\tspin_lock(&info->lock);\n\t\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\t\tif (IS_ERR(entry))\n\t\t\t\t\terror = PTR_ERR(entry);\n\t\t\t\telse {\n\t\t\t\t\tif (entry->val == swap.val)\n\t\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* We have to do this with page locked to prevent races */\n\t\tif (TestSetPageLocked(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (PageWriteback(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_writeback(swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!PageUptodate(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\terror = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (filepage) {\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tdelete_from_swap_cache(swappage);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tcopy_highpage(filepage, swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tflush_dcache_page(filepage);\n\t\t\tSetPageUptodate(filepage);\n\t\t\tset_page_dirty(filepage);\n\t\t\tswap_free(swap);\n\t\t} else if (!(error = move_from_swap_cache(\n\t\t\t\tswappage, idx, mapping))) {\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = swappage;\n\t\t\tswap_free(swap);\n\t\t} else {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tif (error == -ENOMEM) {\n\t\t\t\t/* let kswapd refresh zone for GFP_ATOMICs */\n\t\t\t\tcongestion_wait(WRITE, HZ/50);\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\t} else if (sgp == SGP_READ && !filepage) {\n\t\tshmem_swp_unmap(entry);\n\t\tfilepage = find_get_page(mapping, idx);\n\t\tif (filepage &&\n\t\t    (!PageUptodate(filepage) || TestSetPageLocked(filepage))) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(filepage);\n\t\t\tpage_cache_release(filepage);\n\t\t\tfilepage = NULL;\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&info->lock);\n\t} else {\n\t\tshmem_swp_unmap(entry);\n\t\tsbinfo = SHMEM_SB(inode->i_sb);\n\t\tif (sbinfo->max_blocks) {\n\t\t\tspin_lock(&sbinfo->stat_lock);\n\t\t\tif (sbinfo->free_blocks == 0 ||\n\t\t\t    shmem_acct_block(info->flags)) {\n\t\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\terror = -ENOSPC;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tsbinfo->free_blocks--;\n\t\t\tinode->i_blocks += BLOCKS_PER_PAGE;\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t} else if (shmem_acct_block(info->flags)) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\terror = -ENOSPC;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!filepage) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = shmem_alloc_page(mapping_gfp_mask(mapping),\n\t\t\t\t\t\t    info,\n\t\t\t\t\t\t    idx);\n\t\t\tif (!filepage) {\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tspin_lock(&info->lock);\n\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\tif (IS_ERR(entry))\n\t\t\t\terror = PTR_ERR(entry);\n\t\t\telse {\n\t\t\t\tswap = *entry;\n\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t}\n\t\t\tif (error || swap.val || 0 != add_to_page_cache_lru(\n\t\t\t\t\tfilepage, mapping, idx, GFP_ATOMIC)) {\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tpage_cache_release(filepage);\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\tfilepage = NULL;\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t}\n\n\t\tinfo->alloced++;\n\t\tspin_unlock(&info->lock);\n\t\tflush_dcache_page(filepage);\n\t\tSetPageUptodate(filepage);\n\t}\ndone:\n\tif (*pagep != filepage) {\n\t\t*pagep = filepage;\n\t\tif (sgp != SGP_FAULT)\n\t\t\tunlock_page(filepage);\n\n\t}\n\treturn 0;\n\nfailed:\n\tif (*pagep != filepage) {\n\t\tunlock_page(filepage);\n\t\tpage_cache_release(filepage);\n\t}\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "e84e2e132c9c66d8498e7710d4ea532d1feaaac5",
        "hash": 337224798820921138280301426323775912767,
        "size": 221,
        "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "shmem_alloc_page(gfp_t gfp, struct shmem_inode_info *info,\n\t\t unsigned long idx)\n{\n\tstruct vm_area_struct pvma;\n\tstruct page *page;\n\n\tmemset(&pvma, 0, sizeof(struct vm_area_struct));\n\tpvma.vm_policy = mpol_shared_policy_lookup(&info->policy, idx);\n\tpvma.vm_pgoff = idx;\n\tpvma.vm_end = PAGE_SIZE;\n\tpage = alloc_page_vma(gfp | __GFP_ZERO, &pvma, 0);\n\tmpol_free(pvma.vm_policy);\n\treturn page;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "e84e2e132c9c66d8498e7710d4ea532d1feaaac5",
        "hash": 209078005530362263064364667908690042525,
        "size": 14,
        "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "82e68f7ffec3800425f2391c8c86277606860442",
        "hash": 216166856109438494603854090593555238735,
        "size": 24,
        "message": "sound: ensure device number is valid in snd_seq_oss_synth_make_info\n\nsnd_seq_oss_synth_make_info() incorrectly reports information\nto userspace without first checking for the validity of the\ndevice number, leading to possible information leak (CVE-2008-3272).\n\nReported-By: Tobias Klein <tk@trapkit.de>\nAcked-and-tested-by: Takashi Iwai <tiwai@suse.de>\nCc: stable@kernel.org\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"
    },
    {
        "func": "static int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_hmacalgo *hmacs;\n\tint err;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\n\thmacs = kmalloc(optlen, GFP_KERNEL);\n\tif (!hmacs)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(hmacs, optval, optlen)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hmacs->shmac_num_idents == 0 ||\n\t    hmacs->shmac_num_idents > SCTP_AUTH_NUM_HMACS) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = sctp_auth_ep_set_hmacs(sctp_sk(sk)->ep, hmacs);\nout:\n\tkfree(hmacs);\n\treturn err;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "d97240552cd98c4b07322f30f66fd9c3ba4171de",
        "hash": 45738712490204003037734475963233535065,
        "size": 33,
        "message": "sctp: fix random memory dereference with SCTP_HMAC_IDENT option.\n\nThe number of identifiers needs to be checked against the option\nlength.  Also, the identifier index provided needs to be verified\nto make sure that it doesn't exceed the bounds of the array.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\n\t/* Scan the list looking for unsupported id.  Also make sure that\n\t * SHA1 is specified.\n\t */\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "d97240552cd98c4b07322f30f66fd9c3ba4171de",
        "hash": 6605163766667127233203332495208446404,
        "size": 29,
        "message": "sctp: fix random memory dereference with SCTP_HMAC_IDENT option.\n\nThe number of identifiers needs to be checked against the option\nlength.  Also, the identifier index provided needs to be verified\nto make sure that it doesn't exceed the bounds of the array.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "28e9fc592cb8c7a43e4d3147b38be6032a0e81bc",
        "hash": 162940012482417068707304431225346770150,
        "size": 40,
        "message": "NET: llc, zero sockaddr_llc struct\n\nsllc_arphrd member of sockaddr_llc might not be changed. Zero sllc\nbefore copying to the above layer's structure.\n\nSigned-off-by: Jiri Slaby <jirislaby@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int irda_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tstruct sockaddr_irda saddr;\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->dtsap_sel;\n\t\tsaddr.sir_addr = self->daddr;\n\t} else {\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->stsap_sel;\n\t\tsaddr.sir_addr = self->saddr;\n\t}\n\n\tIRDA_DEBUG(1, \"%s(), tsap_sel = %#x\\n\", __func__, saddr.sir_lsap_sel);\n\tIRDA_DEBUG(1, \"%s(), addr = %08x\\n\", __func__, saddr.sir_addr);\n\n\t/* uaddr_len come to us uninitialised */\n\t*uaddr_len = sizeof (struct sockaddr_irda);\n\tmemcpy(uaddr, &saddr, *uaddr_len);\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "09384dfc76e526c3993c09c42e016372dc9dd22c",
        "hash": 137437277681922152765597966712881683788,
        "size": 29,
        "message": "irda: Fix irda_getname() leak\n\nirda_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "17ac2e9c58b69a1e25460a568eae1b0dc0188c25",
        "hash": 171509347410498147700914190756677081162,
        "size": 29,
        "message": "rose: Fix rose_getname() leak\n\nrose_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "3d392475c873c10c10d6d96b94d092a34ebd4791",
        "hash": 145062743063925345726381516422441859201,
        "size": 30,
        "message": "appletalk: fix atalk_getname() leak\n\natalk_getname() can leak 8 bytes of kernel memory to user\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&econet_mutex);\n\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\n\tmutex_unlock(&econet_mutex);\n\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "80922bbb12a105f858a8f0abb879cb4302d0ecaa",
        "hash": 123919478075923436811704549621583238322,
        "size": 25,
        "message": "econet: Fix econet_getname() leak\n\neconet_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\n\t*len = sizeof(*addr);\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "e84b90ae5eb3c112d1f208964df1d8156a538289",
        "hash": 110676071555549093176536375393386075142,
        "size": 17,
        "message": "can: Fix raw_getname() leak\n\nraw_getname() can leak 10 bytes of kernel memory to user\n\n(two bytes hole between can_family and can_ifindex,\n8 bytes at the end of sockaddr_can structure)\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Oliver Hartkopp <oliver@hartkopp.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tlock_sock(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 1;\n\t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n\t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n\t\t*uaddr_len = sizeof(struct full_sockaddr_ax25);\n\t} else {\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 0;\n\t\tsax->fsa_ax25.sax25_call   = nr->source_addr;\n\t\t*uaddr_len = sizeof(struct sockaddr_ax25);\n\t}\n\trelease_sock(sk);\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "f6b97b29513950bfbf621a83d85b6f86b39ec8db",
        "hash": 161643334792031893231133400238311118647,
        "size": 28,
        "message": "netrom: Fix nr_getname() leak\n\nnr_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1,
        "cwe": [
            "CWE-200"
        ],
        "project": "linux-2.6",
        "commit_id": "8a47077a0b5aa2649751c46e7a27884e6686ccbf",
        "hash": 68414585300687548128258399723716602705,
        "size": 15,
        "message": "[NETLINK]: Missing padding fields in dumped structures\n\nPlug holes with padding fields and initialized them to zero.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    },
    {
        "func": "static int unix_getpw(UNUSED void *instance, REQUEST *request,\n\t\t      VALUE_PAIR **vp_list)\n{\n\tconst char\t*name;\n\tconst char\t*encrypted_pass;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd\t*spwd = NULL;\n#endif\n#ifdef OSFC2\n\tstruct pr_passwd *pr_pw;\n#else\n\tstruct passwd\t*pwd;\n#endif\n#ifdef HAVE_GETUSERSHELL\n\tchar\t\t*shell;\n#endif\n\tVALUE_PAIR\t*vp;\n\n\t/*\n\t *\tWe can only authenticate user requests which HAVE\n\t *\ta User-Name attribute.\n\t */\n\tif (!request->username) {\n\t\treturn RLM_MODULE_NOOP;\n\t}\n\n\tname = (char *)request->username->vp_strvalue;\n\tencrypted_pass = NULL;\n\n#ifdef OSFC2\n\tif ((pr_pw = getprpwnam(name)) == NULL)\n\t\treturn RLM_MODULE_NOTFOUND;\n\tencrypted_pass = pr_pw->ufld.fd_encrypt;\n\n\t/*\n\t *\tCheck if account is locked.\n\t */\n\tif (pr_pw->uflg.fg_lock!=1) {\n\t\tradlog(L_AUTH, \"rlm_unix: [%s]: account locked\", name);\n\t\treturn RLM_MODULE_USERLOCK;\n\t}\n#else /* OSFC2 */\n\tif ((pwd = getpwnam(name)) == NULL) {\n\t\treturn RLM_MODULE_NOTFOUND;\n\t}\n\tencrypted_pass = pwd->pw_passwd;\n#endif /* OSFC2 */\n\n#ifdef HAVE_GETSPNAM\n\t/*\n\t *      See if there is a shadow password.\n\t *\n\t *\tOnly query the _system_ shadow file if the encrypted\n\t *\tpassword from the passwd file is < 10 characters (i.e.\n\t *\ta valid password would never crypt() to it).  This will\n\t *\tprevents users from using NULL password fields as things\n\t *\tstand right now.\n\t */\n\tif ((encrypted_pass == NULL) || (strlen(encrypted_pass) < 10)) {\n\t\tif ((spwd = getspnam(name)) == NULL) {\n\t\t\treturn RLM_MODULE_NOTFOUND;\n\t\t}\n\t\tencrypted_pass = spwd->sp_pwdp;\n\t}\n#endif\t/* HAVE_GETSPNAM */\n\n/*\n *\tThese require 'pwd != NULL', which isn't true on OSFC2\n */\n#ifndef OSFC2\n#ifdef DENY_SHELL\n\t/*\n\t *\tUsers with a particular shell are denied access\n\t */\n\tif (strcmp(pwd->pw_shell, DENY_SHELL) == 0) {\n\t\tradlog_request(L_AUTH, 0, request,\n\t\t\t       \"rlm_unix: [%s]: invalid shell\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#ifdef HAVE_GETUSERSHELL\n\t/*\n\t *\tCheck /etc/shells for a valid shell. If that file\n\t *\tcontains /RADIUSD/ANY/SHELL then any shell will do.\n\t */\n\twhile ((shell = getusershell()) != NULL) {\n\t\tif (strcmp(shell, pwd->pw_shell) == 0 ||\n\t\t    strcmp(shell, \"/RADIUSD/ANY/SHELL\") == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendusershell();\n\tif (shell == NULL) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: invalid shell [%s]\",\n\t\t       name, pwd->pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp / 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t/*\n\t *\tCheck if password has expired.\n\t */\n\tif ((pwd->pw_expire > 0) &&\n\t    (request->timestamp > pwd->pw_expire)) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n\t/*\n\t *\tWe might have a passwordless account.\n\t *\n\t *\tFIXME: Maybe add Auth-Type := Accept?\n\t */\n\tif (encrypted_pass[0] == 0)\n\t\treturn RLM_MODULE_NOOP;\n\n\tvp = pairmake(\"Crypt-Password\", encrypted_pass, T_OP_SET);\n\tif (!vp) return RLM_MODULE_FAIL;\n\n\tpairmove(vp_list, &vp);\n\tpairfree(&vp);\t\t/* might not be NULL; */\n\n\treturn RLM_MODULE_UPDATED;\n}",
        "target": 1,
        "cwe": [
            "CWE-522",
            "CWE-255"
        ],
        "project": "freeradius-server",
        "commit_id": "1b1ec5ce75e224bd1755650c18ccdaa6dc53e605",
        "hash": 33072459181900288119697976253019899614,
        "size": 139,
        "message": "heck for account and password expiration"
    },
    {
        "func": "kadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, last_pwd;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        new_n_ks_tuple = 1;\n    }\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        ret = decrypt_key_data(handle->context,\n                               kdb->n_key_data, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}",
        "target": 1,
        "cwe": [
            "CWE-522",
            "CWE-255"
        ],
        "project": "krb5",
        "commit_id": "af0ed4df4dfae762ab5fb605f5a0c8f59cb4f6ca",
        "hash": 189963338339526647360646510727521554837,
        "size": 135,
        "message": "Return only new keys in randkey [CVE-2014-5351]\n\nIn kadmind's randkey operation, if a client specifies the keepold\nflag, do not include the preserved old keys in the response.\n\nCVE-2014-5351:\n\nAn authenticated remote attacker can retrieve the current keys for a\nservice principal when generating a new set of keys for that\nprincipal.  The attacker needs to be authenticated as a user who has\nthe elevated privilege for randomizing the keys of other principals.\n\nNormally, when a Kerberos administrator randomizes the keys of a\nservice principal, kadmind returns only the new keys.  This prevents\nan administrator who lacks legitimate privileged access to a service\nfrom forging tickets to authenticate to that service.  If the\n\"keepold\" flag to the kadmin randkey RPC operation is true, kadmind\nretains the old keys in the KDC database as intended, but also\nunexpectedly returns the old keys to the client, which exposes the\nservice to ticket forgery attacks from the administrator.\n\nA mitigating factor is that legitimate clients of the affected service\nwill start failing to authenticate to the service once they begin to\nreceive service tickets encrypted in the new keys.  The affected\nservice will be unable to decrypt the newly issued tickets, possibly\nalerting the legitimate administrator of the affected service.\n\nCVSSv2: AV:N/AC:H/Au:S/C:P/I:N/A:N/E:POC/RL:OF/RC:C\n\n[tlyu@mit.edu: CVE description and CVSS score]\n\nticket: 8018 (new)\ntarget_version: 1.13\ntags: pullup"
    },
    {
        "func": "kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tptr = sshpkt_ptr(ssh, &dlen);\n\tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n\t\treturn r;\n\n\t/* discard packet */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\t/*\n\t * XXX RFC4253 sec 7: \"each side MAY guess\" - currently no supported\n\t * KEX method has the server move first, but a server might be using\n\t * a custom method or one that we otherwise don't support. We should\n\t * be prepared to remember first_kex_follows here so we can eat a\n\t * packet later.\n\t * XXX2 - RFC4253 is kind of ambiguous on what first_kex_follows means\n\t * for cases where the server *doesn't* go first. I guess we should\n\t * ignore it when it is set for these cases, which is what we do now.\n\t */\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t/* first_kex_follows */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* reserved */\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\n\treturn SSH_ERR_INTERNAL_ERROR;\n}",
        "target": 1,
        "cwe": [
            "CWE-522",
            "CWE-399"
        ],
        "project": "openssh-portable",
        "commit_id": "ec165c392ca54317dbe3064a8c200de6531e89ad",
        "hash": 45223840858628081598452730958731567629,
        "size": 50,
        "message": "upstream commit\n\nUnregister the KEXINIT handler after message has been\nreceived. Otherwise an unauthenticated peer can repeat the KEXINIT and cause\nallocation of up to 128MB -- until the connection is closed. Reported by\nshilei-c at 360.cn\n\nUpstream-ID: 43649ae12a27ef94290db16d1a98294588b75c05"
    },
    {
        "func": "static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session )\n{\n    TPM_RC rval;\n    TPM2B_ENCRYPTED_SECRET key;\n    char label[] = \"ATH\";\n    UINT16 bytes;\n    int i;\n\n    key.t.size = 0;\n\n    if( session->nonceOlder.t.size == 0 )\n    {\n        /* this is an internal routine to TSS and should be removed */\n        session->nonceOlder.t.size = GetDigestSize( TPM_ALG_SHA1 );\n        for( i = 0; i < session->nonceOlder.t.size; i++ )\n            session->nonceOlder.t.buffer[i] = 0;\n    }\n\n    session->nonceNewer.t.size = session->nonceOlder.t.size;\n    rval = Tss2_Sys_StartAuthSession( sapi_context, session->tpmKey, session->bind, 0,\n            &( session->nonceOlder ), &( session->encryptedSalt ), session->sessionType,\n            &( session->symmetric ), session->authHash, &( session->sessionHandle ),\n            &( session->nonceNewer ), 0 );\n\n    if( rval == TPM_RC_SUCCESS )\n    {\n        if( session->tpmKey == TPM_RH_NULL )\n            session->salt.t.size = 0;\n        if( session->bind == TPM_RH_NULL )\n            session->authValueBind.t.size = 0;\n\n        if( session->tpmKey == TPM_RH_NULL && session->bind == TPM_RH_NULL )\n        {\n            session->sessionKey.b.size = 0;\n        }\n        else\n        {\n            // Generate the key used as input to the KDF.\n            // Generate the key used as input to the KDF.\n            bool result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->authValueBind.b ) );\n            if (!result)\n            {\n               return TSS2_SYS_RC_BAD_VALUE;\n            }\n\n            result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->salt.b ) );\n            if (!result)\n            {\n                return TSS2_SYS_RC_BAD_VALUE;\n            }\n\n            bytes = GetDigestSize( session->authHash );\n\n            if( key.t.size == 0 )\n            {\n                session->sessionKey.t.size = 0;\n            }\n            else\n            {\n                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                        &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n            }\n\n            if( rval != TPM_RC_SUCCESS )\n            {\n                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );\n            }\n        }\n\n        session->nonceTpmDecrypt.b.size = 0;\n        session->nonceTpmEncrypt.b.size = 0;\n        session->nvNameChanged = 0;\n    }\n\n    return rval;\n}",
        "target": 1,
        "cwe": [
            "CWE-522",
            "CWE-200"
        ],
        "project": "tpm2.0-tools",
        "commit_id": "c5d72beaab1cbbbe68271f4bc4b6670d69985157",
        "hash": 148903942719551296248404916487571745821,
        "size": 76,
        "message": "kdfa: use openssl for hmac not tpm\n\nWhile not reachable in the current code base tools, a potential\nsecurity bug lurked in tpm_kdfa().\n\nIf using that routine for an hmac authorization, the hmac was\ncalculated using the tpm. A user of an object wishing to\nauthenticate via hmac, would expect that the password is never\nsent to the tpm. However, since the hmac calculation relies on\npassword, and is performed by the tpm, the password ends up\nbeing sent in plain text to the tpm.\n\nThe fix is to use openssl to generate the hmac on the host.\n\nFixes: CVE-2017-7524\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n        TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,\n        TPM2B_MAX_BUFFER  *resultKey )\n{\n    TPM2B_DIGEST tmpResult;\n    TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;\n    UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];\n    UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];\n    TPM2B_DIGEST *bufferList[8];\n    UINT32 bitsSwizzled, i_Swizzled;\n    TPM_RC rval;\n    int i, j;\n    UINT16 bytes = bits / 8;\n\n    resultKey->t .size = 0;\n\n    tpm2b_i_2.t.size = 4;\n\n    tpm2bBits.t.size = 4;\n    bitsSwizzled = string_bytes_endian_convert_32( bits );\n    *(UINT32 *)tpm2bBitsPtr = bitsSwizzled;\n\n    for(i = 0; label[i] != 0 ;i++ );\n\n    tpm2bLabel.t.size = i+1;\n    for( i = 0; i < tpm2bLabel.t.size; i++ )\n    {\n        tpm2bLabel.t.buffer[i] = label[i];\n    }\n\n    resultKey->t.size = 0;\n\n    i = 1;\n\n    while( resultKey->t.size < bytes )\n    {\n        // Inner loop\n\n        i_Swizzled = string_bytes_endian_convert_32( i );\n        *(UINT32 *)tpm2b_i_2Ptr = i_Swizzled;\n\n        j = 0;\n        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b);\n        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b);\n        bufferList[j++] = (TPM2B_DIGEST *)contextU;\n        bufferList[j++] = (TPM2B_DIGEST *)contextV;\n        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);\n        bufferList[j++] = (TPM2B_DIGEST *)0;\n        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );\n        if( rval != TPM_RC_SUCCESS )\n        {\n            return( rval );\n        }\n\n        bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));\n        if (!res) {\n            return TSS2_SYS_RC_BAD_VALUE;\n        }\n    }\n\n    // Truncate the result to the desired size.\n    resultKey->t.size = bytes;\n\n    return TPM_RC_SUCCESS;\n}",
        "target": 1,
        "cwe": [
            "CWE-522",
            "CWE-200"
        ],
        "project": "tpm2.0-tools",
        "commit_id": "c5d72beaab1cbbbe68271f4bc4b6670d69985157",
        "hash": 150243078027001026125960285660972277015,
        "size": 65,
        "message": "kdfa: use openssl for hmac not tpm\n\nWhile not reachable in the current code base tools, a potential\nsecurity bug lurked in tpm_kdfa().\n\nIf using that routine for an hmac authorization, the hmac was\ncalculated using the tpm. A user of an object wishing to\nauthenticate via hmac, would expect that the password is never\nsent to the tpm. However, since the hmac calculation relies on\npassword, and is performed by the tpm, the password ends up\nbeing sent in plain text to the tpm.\n\nThe fix is to use openssl to generate the hmac on the host.\n\nFixes: CVE-2017-7524\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>"
    },
    {
        "func": "_rsvg_io_get_file_path (const gchar * filename,\n                        const gchar * base_uri)\n{\n    gchar *absolute_filename;\n\n    if (g_file_test (filename, G_FILE_TEST_EXISTS) || g_path_is_absolute (filename)) {\n        absolute_filename = g_strdup (filename);\n    } else {\n        gchar *tmpcdir;\n        gchar *base_filename;\n\n        if (base_uri) {\n            base_filename = g_filename_from_uri (base_uri, NULL, NULL);\n            if (base_filename != NULL) {\n                tmpcdir = g_path_get_dirname (base_filename);\n                g_free (base_filename);\n            } else \n                return NULL;\n        } else\n            tmpcdir = g_get_current_dir ();\n\n        absolute_filename = g_build_filename (tmpcdir, filename, NULL);\n        g_free (tmpcdir);\n    }\n\n    return absolute_filename;\n}",
        "target": 1,
        "cwe": [
            "CWE-522"
        ],
        "project": "librsvg",
        "commit_id": "f9d69eadd2b16b00d1a1f9f286122123f8e547dd",
        "hash": 112843878791851454807780223875671792554,
        "size": 27,
        "message": "Fixed possible credentials leaking reported by Alex Birsan."
    },
    {
        "func": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tfree(name);\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-88",
            "CWE-522"
        ],
        "project": "git",
        "commit_id": "a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46",
        "hash": 294909521817059328068170986041031088321,
        "size": 21,
        "message": "fsck: detect submodule urls starting with dash\n\nUrls with leading dashes can cause mischief on older\nversions of Git. We should detect them so that they can be\nrejected by receive.fsckObjects, preventing modern versions\nof git from being a vector by which attacks can spread.\n\nSigned-off-by: Jeff King <peff@peff.net>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"
    },
    {
        "func": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}",
        "target": 1,
        "cwe": [
            "CWE-522",
            "CWE-22"
        ],
        "project": "Sigil",
        "commit_id": "369eebe936e4a8c83cc54662a3412ce8bef189e4",
        "hash": 42427277626024576449429756639304152816,
        "size": 112,
        "message": "do not allow zip files to have upward relative path sections"
    },
    {
        "func": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_istr_startswith(adata->buf, \"* OK\"))\n  {\n    if (!mutt_istr_startswith(adata->buf, \"* OK [CAPABILITY\") && check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && (adata->conn->ssf == 0))\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_istr_startswith(adata->buf, \"* PREAUTH\"))\n  {\n#ifdef USE_SSL\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response may be a\n     * MITM attack.  The only way to stop \"STARTTLS\" MITM attacks is via\n     * $ssl_force_tls: an attacker can easily spoof \"* OK\" and strip the\n     * STARTTLS capability.  So consult $ssl_force_tls, not $ssl_starttls, to\n     * decide whether to abort. Note that if using $tunnel and\n     * $tunnel_is_secure, adata->conn->ssf will be set to 1. */\n    if ((adata->conn->ssf == 0) && C_SslForceTls)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}",
        "target": 1,
        "cwe": [
            "CWE-522",
            "CWE-287",
            "CWE-755"
        ],
        "project": "neomutt",
        "commit_id": "9c36717a3e2af1f2c1b7242035455ec8112b4b06",
        "hash": 116037772614219807053318355003276943446,
        "size": 101,
        "message": "imap: close connection on all failures\n\nThanks to Gabriel Salles-Loustau for spotting the problem.\n\nCo-authored-by: Kevin McCarthy <kevin@8t8.us>"
    },
    {
        "func": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-522"
        ],
        "project": "git",
        "commit_id": "c44088ecc4b0722636e0a305f9608d3047197282",
        "hash": 295188544435867269840836965008721456240,
        "size": 28,
        "message": "credential: treat URL without scheme as invalid\n\nlibcurl permits making requests without a URL scheme specified.  In\nthis case, it guesses the URL from the hostname, so I can run\n\n\tgit ls-remote http::ftp.example.com/path/to/repo\n\nand it would make an FTP request.\n\nAny user intentionally using such a URL is likely to have made a typo.\nUnfortunately, credential_from_url is not able to determine the host and\nprotocol in order to determine appropriate credentials to send, and\nuntil \"credential: refuse to operate when missing host or protocol\",\nthis resulted in another host's credentials being leaked to the named\nhost.\n\nTeach credential_from_url_gently to consider such a URL to be invalid\nso that fsck can detect and block gitmodules files with such URLs,\nallowing server operators to avoid serving them to downstream users\nrunning older versions of Git.\n\nThis also means that when such URLs are passed on the command line, Git\nwill print a clearer error so affected users can switch to the simpler\nURL that explicitly specifies the host and protocol they intend.\n\nOne subtlety: .gitmodules files can contain relative URLs, representing\na URL relative to the URL they were cloned from.  The relative URL\nresolver used for .gitmodules can follow \"..\" components out of the path\npart and past the host part of a URL, meaning that such a relative URL\ncan be used to traverse from a https://foo.example.com/innocent\nsuperproject to a https::attacker.example.com/exploit submodule.\nFortunately a leading ':' in the first path component after a series of\nleading './' and '../' components is unlikely to show up in other\ncontexts, so we can catch this by detecting that pattern.\n\nReported-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>\nReviewed-by: Jeff King <peff@peff.net>"
    },
    {
        "func": "int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-522"
        ],
        "project": "git",
        "commit_id": "c44088ecc4b0722636e0a305f9608d3047197282",
        "hash": 160035322481530354086125203441102417749,
        "size": 59,
        "message": "credential: treat URL without scheme as invalid\n\nlibcurl permits making requests without a URL scheme specified.  In\nthis case, it guesses the URL from the hostname, so I can run\n\n\tgit ls-remote http::ftp.example.com/path/to/repo\n\nand it would make an FTP request.\n\nAny user intentionally using such a URL is likely to have made a typo.\nUnfortunately, credential_from_url is not able to determine the host and\nprotocol in order to determine appropriate credentials to send, and\nuntil \"credential: refuse to operate when missing host or protocol\",\nthis resulted in another host's credentials being leaked to the named\nhost.\n\nTeach credential_from_url_gently to consider such a URL to be invalid\nso that fsck can detect and block gitmodules files with such URLs,\nallowing server operators to avoid serving them to downstream users\nrunning older versions of Git.\n\nThis also means that when such URLs are passed on the command line, Git\nwill print a clearer error so affected users can switch to the simpler\nURL that explicitly specifies the host and protocol they intend.\n\nOne subtlety: .gitmodules files can contain relative URLs, representing\na URL relative to the URL they were cloned from.  The relative URL\nresolver used for .gitmodules can follow \"..\" components out of the path\npart and past the host part of a URL, meaning that such a relative URL\ncan be used to traverse from a https://foo.example.com/innocent\nsuperproject to a https::attacker.example.com/exploit submodule.\nFortunately a leading ':' in the first path component after a series of\nleading './' and '../' components is unlikely to show up in other\ncontexts, so we can catch this by detecting that pattern.\n\nReported-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>\nReviewed-by: Jeff King <peff@peff.net>"
    },
    {
        "func": "void CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}",
        "target": 1,
        "cwe": [
            "CWE-400",
            "CWE-522",
            "CWE-674"
        ],
        "project": "mcrouter",
        "commit_id": "97e033b3bb0cb16b61bf49f0dc7f311a3e0edd1b",
        "hash": 34233826201150323851035799720620384534,
        "size": 61,
        "message": "Attempt to make CarbonProtocolReader::skip tail recursive\n\nReviewed By: edenzik\n\nDifferential Revision: D17967570\n\nfbshipit-source-id: fdc32e190a521349c7c8f4d6081902fa18eb0284"
    },
    {
        "func": "  void readStructEnd() {\n    lastFieldId_ = nestedStructFieldIds_.back();\n    nestedStructFieldIds_.pop_back();\n  }",
        "target": 1,
        "cwe": [
            "CWE-400",
            "CWE-522",
            "CWE-674"
        ],
        "project": "mcrouter",
        "commit_id": "97e033b3bb0cb16b61bf49f0dc7f311a3e0edd1b",
        "hash": 186766242267293620797839128970005322524,
        "size": 4,
        "message": "Attempt to make CarbonProtocolReader::skip tail recursive\n\nReviewed By: edenzik\n\nDifferential Revision: D17967570\n\nfbshipit-source-id: fdc32e190a521349c7c8f4d6081902fa18eb0284"
    },
    {
        "func": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}",
        "target": 1,
        "cwe": [
            "CWE-522",
            "CWE-61"
        ],
        "project": "git",
        "commit_id": "9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b",
        "hash": 199261788759877127757600797243017384081,
        "size": 6,
        "message": "credential: avoid writing values with newlines\n\nThe credential protocol that we use to speak to helpers can't represent\nvalues with newlines in them. This was an intentional design choice to\nkeep the protocol simple, since none of the values we pass should\ngenerally have newlines.\n\nHowever, if we _do_ encounter a newline in a value, we blindly transmit\nit in credential_write(). Such values may break the protocol syntax, or\nworse, inject new valid lines into the protocol stream.\n\nThe most likely way for a newline to end up in a credential struct is by\ndecoding a URL with a percent-encoded newline. However, since the bug\noccurs at the moment we write the value to the protocol, we'll catch it\nthere. That should leave no possibility of accidentally missing a code\npath that can trigger the problem.\n\nAt this level of the code we have little choice but to die(). However,\nsince we'd not ever expect to see this case outside of a malicious URL,\nthat's an acceptable outcome.\n\nReported-by: Felix Wilhelm <fwilhelm@google.com>"
    },
    {
        "func": "static int unix_detach(void *instance)\n{\n#define inst ((struct unix_instance *)instance)\n\n\tpaircompare_unregister(PW_GROUP, groupcmp);\n#ifdef PW_GROUP_NAME\n\tpaircompare_unregister(PW_GROUP_NAME, groupcmp);\n#endif\n#undef inst\n\tfree(instance);\n\treturn 0;\n}",
        "target": 0,
        "cwe": [
            "CWE-522",
            "CWE-255"
        ],
        "project": "freeradius-server",
        "commit_id": "1b1ec5ce75e224bd1755650c18ccdaa6dc53e605",
        "hash": 295519399613912735416882679149803247346,
        "size": 12,
        "message": "heck for account and password expiration"
    },
    {
        "func": "static char *uue(void *in)\n{\n\tint i;\n\tstatic unsigned char res[7];\n\tunsigned char *data = (unsigned char *)in;\n\n\tres[0] = ENC( data[0] >> 2 );\n\tres[1] = ENC( ((data[0] << 4) & 060) + ((data[1] >> 4) & 017) );\n\tres[2] = ENC( ((data[1] << 2) & 074) + ((data[2] >> 6) & 03) );\n\tres[3] = ENC( data[2] & 077 );\n\n\tres[4] = ENC( data[3] >> 2 );\n\tres[5] = ENC( (data[3] << 4) & 060 );\n\tres[6] = 0;\n\n\tfor(i = 0; i < 6; i++) {\n\t\tif (res[i] == ' ') res[i] = '`';\n\t\tif (res[i] < 32 || res[i] > 127)\n\t\t\tprintf(\"uue: protocol error ?!\\n\");\n\t}\n\treturn (char *)res;\n}",
        "target": 0,
        "cwe": [
            "CWE-522",
            "CWE-255"
        ],
        "project": "freeradius-server",
        "commit_id": "1b1ec5ce75e224bd1755650c18ccdaa6dc53e605",
        "hash": 336886806285031792895757333741020628652,
        "size": 22,
        "message": "heck for account and password expiration"
    },
    {
        "func": "SYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename, mode_t, mode)\n{\n\tstruct path path;\n\tstruct inode *inode;\n\tint error;\n\tstruct iattr newattrs;\n\n\terror = user_path_at(dfd, filename, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\tgoto out;\n\tinode = path.dentry->d_inode;\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto dput_and_out;\n\tmutex_lock(&inode->i_mutex);\n\terror = security_path_chmod(path.dentry, path.mnt, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tif (mode == (mode_t) -1)\n\t\tmode = inode->i_mode;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path.dentry, &newattrs);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write(path.mnt);\ndput_and_out:\n\tpath_put(&path);\nout:\n\treturn error;\n}",
        "target": 1,
        "cwe": [
            "CWE-732"
        ],
        "project": "linux-stable",
        "commit_id": "e57712ebebbb9db7d8dcef216437b3171ddcf115",
        "hash": 134281698522381521388548795404109797991,
        "size": 32,
        "message": "merge fchmod() and fchmodat() guts, kill ancient broken kludge\n\nThe kludge in question is undocumented and doesn't work for 32bit\nbinaries on amd64, sparc64 and s390.  Passing (mode_t)-1 as\nmode had (since 0.99.14v and contrary to behaviour of any\nother Unix, prescriptions of POSIX, SuS and our own manpages)\nwas kinda-sorta no-op.  Note that any software relying on\nthat (and looking for examples shows none) would be visibly\nbroken on sparc64, where practically all userland is built\n32bit.  No such complaints noticed...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>"
    },
    {
        "func": "SYSCALL_DEFINE2(fchmod, unsigned int, fd, mode_t, mode)\n{\n\tstruct inode * inode;\n\tstruct dentry * dentry;\n\tstruct file * file;\n\tint err = -EBADF;\n\tstruct iattr newattrs;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\tgoto out;\n\n\tdentry = file->f_path.dentry;\n\tinode = dentry->d_inode;\n\n\taudit_inode(NULL, dentry);\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out_putf;\n\tmutex_lock(&inode->i_mutex);\n\terr = security_path_chmod(dentry, file->f_vfsmnt, mode);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (mode == (mode_t) -1)\n\t\tmode = inode->i_mode;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terr = notify_change(dentry, &newattrs);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write(file->f_path.mnt);\nout_putf:\n\tfput(file);\nout:\n\treturn err;\n}",
        "target": 1,
        "cwe": [
            "CWE-732"
        ],
        "project": "linux-stable",
        "commit_id": "e57712ebebbb9db7d8dcef216437b3171ddcf115",
        "hash": 250404441371169092736875190291644950133,
        "size": 37,
        "message": "merge fchmod() and fchmodat() guts, kill ancient broken kludge\n\nThe kludge in question is undocumented and doesn't work for 32bit\nbinaries on amd64, sparc64 and s390.  Passing (mode_t)-1 as\nmode had (since 0.99.14v and contrary to behaviour of any\nother Unix, prescriptions of POSIX, SuS and our own manpages)\nwas kinda-sorta no-op.  Note that any software relying on\nthat (and looking for examples shows none) would be visibly\nbroken on sparc64, where practically all userland is built\n32bit.  No such complaints noticed...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>"
    },
    {
        "func": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    if (dir_path) {\n        v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n        v9fs_path_sprintf(target, \"%s\", name);\n    }\n    return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-732"
        ],
        "project": "qemu",
        "commit_id": "9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "hash": 133029921061643691755895753369530096198,
        "size": 10,
        "message": "9pfs: local: set the path of the export root to \".\"\n\nThe local backend was recently converted to using \"at*()\" syscalls in order\nto ensure all accesses happen below the shared directory. This requires that\nwe only pass relative paths, otherwise the dirfd argument to the \"at*()\"\nsyscalls is ignored and the path is treated as an absolute path in the host.\nThis is actually the case for paths in all fids, with the notable exception\nof the root fid, whose path is \"/\". This causes the following backend ops to\nact on the \"/\" directory of the host instead of the virtfs shared directory\nwhen the export root is involved:\n- lstat\n- chmod\n- chown\n- utimensat\n\nie, chmod /9p_mount_point in the guest will be converted to chmod / in the\nhost for example. This could cause security issues with a privileged QEMU.\n\nAll \"*at()\" syscalls are being passed an open file descriptor. In the case\nof the export root, this file descriptor points to the path in the host that\nwas passed to -fsdev.\n\nThe fix is thus as simple as changing the path of the export root fid to be\n\".\" instead of \"/\".\n\nThis is CVE-2017-7471.\n\nCc: qemu-stable@nongnu.org\nReported-by: L\u00e9o Gaspard <leo@gaspard.io>\nSigned-off-by: Greg Kurz <groug@kaod.org>\nReviewed-by: Eric Blake <eblake@redhat.com>\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>"
    },
    {
        "func": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-732"
        ],
        "project": "linux",
        "commit_id": "a4866aa812518ed1a37d8ea0c881dc946409de94",
        "hash": 122999416535253334502366598961722061169,
        "size": 10,
        "message": "mm: Tighten x86 /dev/mem with zeroing reads\n\nUnder CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is\ndisallowed. However, on x86, the first 1MB was always allowed for BIOS\nand similar things, regardless of it actually being System RAM. It was\npossible for heap to end up getting allocated in low 1MB RAM, and then\nread by things like x86info or dd, which would trip hardened usercopy:\n\nusercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)\n\nThis changes the x86 exception for the low 1MB by reading back zeros for\nSystem RAM areas instead of blindly allowing them. More work is needed to\nextend this to mmap, but currently mmap doesn't go through usercopy, so\nhardened usercopy won't Oops the kernel.\n\nReported-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nTested-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>"
    },
    {
        "func": "static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\n\twritten = 0;\n\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\t/* Hmm. Do something? */\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tsz = size_inside_page(p, count);\n\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n\t\t * it must also be accessed uncached by the kernel or data\n\t\t * corruption may occur.\n\t\t */\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (copied) {\n\t\t\twritten += sz - copied;\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\n\t*ppos += written;\n\treturn written;\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-732"
        ],
        "project": "linux",
        "commit_id": "a4866aa812518ed1a37d8ea0c881dc946409de94",
        "hash": 207811956488557989654594292544228342652,
        "size": 64,
        "message": "mm: Tighten x86 /dev/mem with zeroing reads\n\nUnder CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is\ndisallowed. However, on x86, the first 1MB was always allowed for BIOS\nand similar things, regardless of it actually being System RAM. It was\npossible for heap to end up getting allocated in low 1MB RAM, and then\nread by things like x86info or dd, which would trip hardened usercopy:\n\nusercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)\n\nThis changes the x86 exception for the low 1MB by reading back zeros for\nSystem RAM areas instead of blindly allowing them. More work is needed to\nextend this to mmap, but currently mmap doesn't go through usercopy, so\nhardened usercopy won't Oops the kernel.\n\nReported-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nTested-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>"
    },
    {
        "func": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn 0;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n\t\t * it must also be accessed uncached by the kernel or data\n\t\t * corruption may occur.\n\t\t */\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\n\t*ppos += read;\n\treturn read;\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-732"
        ],
        "project": "linux",
        "commit_id": "a4866aa812518ed1a37d8ea0c881dc946409de94",
        "hash": 166122449003007923344717508455987518563,
        "size": 59,
        "message": "mm: Tighten x86 /dev/mem with zeroing reads\n\nUnder CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is\ndisallowed. However, on x86, the first 1MB was always allowed for BIOS\nand similar things, regardless of it actually being System RAM. It was\npossible for heap to end up getting allocated in low 1MB RAM, and then\nread by things like x86info or dd, which would trip hardened usercopy:\n\nusercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)\n\nThis changes the x86 exception for the low 1MB by reading back zeros for\nSystem RAM areas instead of blindly allowing them. More work is needed to\nextend this to mmap, but currently mmap doesn't go through usercopy, so\nhardened usercopy won't Oops the kernel.\n\nReported-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nTested-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>"
    },
    {
        "func": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}",
        "target": 1,
        "cwe": [
            "CWE-732",
            "CWE-703",
            "CWE-269"
        ],
        "project": "src",
        "commit_id": "a6981567e8e215acc1ef690c8dbb30f2d9b00a19",
        "hash": 230380318694161070482946787836068977359,
        "size": 40,
        "message": "disallow creation (of empty files) in read-only mode; reported by\nMichal Zalewski, feedback & ok deraadt@"
    },
    {
        "func": "switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}",
        "target": 1,
        "cwe": [
            "CWE-284",
            "CWE-732"
        ],
        "project": "passenger",
        "commit_id": "4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8",
        "hash": 27177970069787986365761982058014953974,
        "size": 50,
        "message": "ExecHelperMain: fix privilege lowering code"
    },
    {
        "func": "sg_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tint req_pack_id = -1;\n\tsg_io_hdr_t *hp;\n\tstruct sg_header *old_hdr = NULL;\n\tint retval = 0;\n\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_read: count=%d\\n\", (int) count));\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\tif (sfp->force_packid && (count >= SZ_SG_HEADER)) {\n\t\told_hdr = kmalloc(SZ_SG_HEADER, GFP_KERNEL);\n\t\tif (!old_hdr)\n\t\t\treturn -ENOMEM;\n\t\tif (__copy_from_user(old_hdr, buf, SZ_SG_HEADER)) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tif (old_hdr->reply_len < 0) {\n\t\t\tif (count >= SZ_SG_IO_HDR) {\n\t\t\t\tsg_io_hdr_t *new_hdr;\n\t\t\t\tnew_hdr = kmalloc(SZ_SG_IO_HDR, GFP_KERNEL);\n\t\t\t\tif (!new_hdr) {\n\t\t\t\t\tretval = -ENOMEM;\n\t\t\t\t\tgoto free_old_hdr;\n\t\t\t\t}\n\t\t\t\tretval =__copy_from_user\n\t\t\t\t    (new_hdr, buf, SZ_SG_IO_HDR);\n\t\t\t\treq_pack_id = new_hdr->pack_id;\n\t\t\t\tkfree(new_hdr);\n\t\t\t\tif (retval) {\n\t\t\t\t\tretval = -EFAULT;\n\t\t\t\t\tgoto free_old_hdr;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\treq_pack_id = old_hdr->pack_id;\n\t}\n\tsrp = sg_get_rq_mark(sfp, req_pack_id);\n\tif (!srp) {\t\t/* now wait on packet to arrive */\n\t\tif (atomic_read(&sdp->detaching)) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tretval = wait_event_interruptible(sfp->read_wait,\n\t\t\t(atomic_read(&sdp->detaching) ||\n\t\t\t(srp = sg_get_rq_mark(sfp, req_pack_id))));\n\t\tif (atomic_read(&sdp->detaching)) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tif (retval) {\n\t\t\t/* -ERESTARTSYS as signal hit process */\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t}\n\tif (srp->header.interface_id != '\\0') {\n\t\tretval = sg_new_read(sfp, buf, count, srp);\n\t\tgoto free_old_hdr;\n\t}\n\n\thp = &srp->header;\n\tif (old_hdr == NULL) {\n\t\told_hdr = kmalloc(SZ_SG_HEADER, GFP_KERNEL);\n\t\tif (! old_hdr) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t}\n\tmemset(old_hdr, 0, SZ_SG_HEADER);\n\told_hdr->reply_len = (int) hp->timeout;\n\told_hdr->pack_len = old_hdr->reply_len; /* old, strange behaviour */\n\told_hdr->pack_id = hp->pack_id;\n\told_hdr->twelve_byte =\n\t    ((srp->data.cmd_opcode >= 0xc0) && (12 == hp->cmd_len)) ? 1 : 0;\n\told_hdr->target_status = hp->masked_status;\n\told_hdr->host_status = hp->host_status;\n\told_hdr->driver_status = hp->driver_status;\n\tif ((CHECK_CONDITION & hp->masked_status) ||\n\t    (DRIVER_SENSE & hp->driver_status))\n\t\tmemcpy(old_hdr->sense_buffer, srp->sense_b,\n\t\t       sizeof (old_hdr->sense_buffer));\n\tswitch (hp->host_status) {\n\t/* This setup of 'result' is for backward compatibility and is best\n\t   ignored by the user who should use target, host + driver status */\n\tcase DID_OK:\n\tcase DID_PASSTHROUGH:\n\tcase DID_SOFT_ERROR:\n\t\told_hdr->result = 0;\n\t\tbreak;\n\tcase DID_NO_CONNECT:\n\tcase DID_BUS_BUSY:\n\tcase DID_TIME_OUT:\n\t\told_hdr->result = EBUSY;\n\t\tbreak;\n\tcase DID_BAD_TARGET:\n\tcase DID_ABORT:\n\tcase DID_PARITY:\n\tcase DID_RESET:\n\tcase DID_BAD_INTR:\n\t\told_hdr->result = EIO;\n\t\tbreak;\n\tcase DID_ERROR:\n\t\told_hdr->result = (srp->sense_b[0] == 0 &&\n\t\t\t\t  hp->masked_status == GOOD) ? 0 : EIO;\n\t\tbreak;\n\tdefault:\n\t\told_hdr->result = EIO;\n\t\tbreak;\n\t}\n\n\t/* Now copy the result back to the user buffer.  */\n\tif (count >= SZ_SG_HEADER) {\n\t\tif (__copy_to_user(buf, old_hdr, SZ_SG_HEADER)) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tbuf += SZ_SG_HEADER;\n\t\tif (count > old_hdr->reply_len)\n\t\t\tcount = old_hdr->reply_len;\n\t\tif (count > SZ_SG_HEADER) {\n\t\t\tif (sg_read_oxfer(srp, buf, count - SZ_SG_HEADER)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto free_old_hdr;\n\t\t\t}\n\t\t}\n\t} else\n\t\tcount = (old_hdr->result == 0) ? 0 : -EIO;\n\tsg_finish_rem_req(srp);\n\tretval = count;\nfree_old_hdr:\n\tkfree(old_hdr);\n\treturn retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-732"
        ],
        "project": "android_kernel_xiaomi_msm8996",
        "commit_id": "4e624aeb719ba0a13390f70b18f2388372614b94",
        "hash": 260457130391440737354971870207868562458,
        "size": 145,
        "message": "ANDROID: scsi: Add segment checking in sg_read\n\nBug: 65023233\nSigned-off-by: Roberto Pereira <rpere@google.com>\nChange-Id: I91b6b5dbcea7c39643beffdc12a23ee3d8f8775d"
    },
    {
        "func": "sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n{\n\tint mxsize, cmd_size, k;\n\tint input_size, blocking;\n\tunsigned char opcode;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tstruct sg_header old_hdr;\n\tsg_io_hdr_t *hp;\n\tunsigned char cmnd[SG_MAX_CDB_SIZE];\n\n\tif (unlikely(uaccess_kernel()))\n\t\treturn -EINVAL;\n\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_write: count=%d\\n\", (int) count));\n\tif (atomic_read(&sdp->detaching))\n\t\treturn -ENODEV;\n\tif (!((filp->f_flags & O_NONBLOCK) ||\n\t      scsi_block_when_processing_errors(sdp->device)))\n\t\treturn -ENXIO;\n\n\tif (!access_ok(VERIFY_READ, buf, count))\n\t\treturn -EFAULT;\t/* protects following copy_from_user()s + get_user()s */\n\tif (count < SZ_SG_HEADER)\n\t\treturn -EIO;\n\tif (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))\n\t\treturn -EFAULT;\n\tblocking = !(filp->f_flags & O_NONBLOCK);\n\tif (old_hdr.reply_len < 0)\n\t\treturn sg_new_write(sfp, filp, buf, count,\n\t\t\t\t    blocking, 0, 0, NULL);\n\tif (count < (SZ_SG_HEADER + 6))\n\t\treturn -EIO;\t/* The minimum scsi command length is 6 bytes. */\n\n\tif (!(srp = sg_add_request(sfp))) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,\n\t\t\t\t\t      \"sg_write: queue full\\n\"));\n\t\treturn -EDOM;\n\t}\n\tbuf += SZ_SG_HEADER;\n\t__get_user(opcode, buf);\n\tmutex_lock(&sfp->f_mutex);\n\tif (sfp->next_cmd_len > 0) {\n\t\tcmd_size = sfp->next_cmd_len;\n\t\tsfp->next_cmd_len = 0;\t/* reset so only this write() effected */\n\t} else {\n\t\tcmd_size = COMMAND_SIZE(opcode);\t/* based on SCSI command group */\n\t\tif ((opcode >= 0xc0) && old_hdr.twelve_byte)\n\t\t\tcmd_size = 12;\n\t}\n\tmutex_unlock(&sfp->f_mutex);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,\n\t\t\"sg_write:   scsi opcode=0x%02x, cmd_size=%d\\n\", (int) opcode, cmd_size));\n/* Determine buffer size.  */\n\tinput_size = count - cmd_size;\n\tmxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;\n\tmxsize -= SZ_SG_HEADER;\n\tinput_size -= SZ_SG_HEADER;\n\tif (input_size < 0) {\n\t\tsg_remove_request(sfp, srp);\n\t\treturn -EIO;\t/* User did not pass enough bytes for this command. */\n\t}\n\thp = &srp->header;\n\thp->interface_id = '\\0';\t/* indicator of old interface tunnelled */\n\thp->cmd_len = (unsigned char) cmd_size;\n\thp->iovec_count = 0;\n\thp->mx_sb_len = 0;\n\tif (input_size > 0)\n\t\thp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?\n\t\t    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;\n\telse\n\t\thp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;\n\thp->dxfer_len = mxsize;\n\tif ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||\n\t    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))\n\t\thp->dxferp = (char __user *)buf + cmd_size;\n\telse\n\t\thp->dxferp = NULL;\n\thp->sbp = NULL;\n\thp->timeout = old_hdr.reply_len;\t/* structure abuse ... */\n\thp->flags = input_size;\t/* structure abuse ... */\n\thp->pack_id = old_hdr.pack_id;\n\thp->usr_ptr = NULL;\n\tif (__copy_from_user(cmnd, buf, cmd_size))\n\t\treturn -EFAULT;\n\t/*\n\t * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,\n\t * but is is possible that the app intended SG_DXFER_TO_DEV, because there\n\t * is a non-zero input_size, so emit a warning.\n\t */\n\tif (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"sg_write: data in/out %d/%d bytes \"\n\t\t\t\t   \"for SCSI command 0x%x-- guessing \"\n\t\t\t\t   \"data in;\\n   program %s not setting \"\n\t\t\t\t   \"count and/or reply_len properly\\n\",\n\t\t\t\t   old_hdr.reply_len - (int)SZ_SG_HEADER,\n\t\t\t\t   input_size, (unsigned int) cmnd[0],\n\t\t\t\t   current->comm);\n\t}\n\tk = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);\n\treturn (k < 0) ? k : count;\n}",
        "target": 1,
        "cwe": [
            "CWE-732"
        ],
        "project": "linux",
        "commit_id": "26b5b874aff5659a7e26e5b1997e3df2c41fa7fd",
        "hash": 188624726538839413902525145698829058359,
        "size": 107,
        "message": "scsi: sg: mitigate read/write abuse\n\nAs Al Viro noted in commit 128394eff343 (\"sg_write()/bsg_write() is not fit\nto be called under KERNEL_DS\"), sg improperly accesses userspace memory\noutside the provided buffer, permitting kernel memory corruption via\nsplice().  But it doesn't just do it on ->write(), also on ->read().\n\nAs a band-aid, make sure that the ->read() and ->write() handlers can not\nbe called in weird contexts (kernel context or credentials different from\nfile opener), like for ib_safe_file_access().\n\nIf someone needs to use these interfaces from different security contexts,\na new interface should be written that goes through the ->ioctl() handler.\n\nI've mostly copypasted ib_safe_file_access() over as sg_safe_file_access()\nbecause I couldn't find a good common header - please tell me if you know a\nbetter way.\n\n[mkp: s/_safe_/_check_/]\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nCc: <stable@vger.kernel.org>\nSigned-off-by: Jann Horn <jannh@google.com>\nAcked-by: Douglas Gilbert <dgilbert@interlog.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>"
    },
    {
        "func": "sg_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tint req_pack_id = -1;\n\tsg_io_hdr_t *hp;\n\tstruct sg_header *old_hdr = NULL;\n\tint retval = 0;\n\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_read: count=%d\\n\", (int) count));\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\tif (sfp->force_packid && (count >= SZ_SG_HEADER)) {\n\t\told_hdr = kmalloc(SZ_SG_HEADER, GFP_KERNEL);\n\t\tif (!old_hdr)\n\t\t\treturn -ENOMEM;\n\t\tif (__copy_from_user(old_hdr, buf, SZ_SG_HEADER)) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tif (old_hdr->reply_len < 0) {\n\t\t\tif (count >= SZ_SG_IO_HDR) {\n\t\t\t\tsg_io_hdr_t *new_hdr;\n\t\t\t\tnew_hdr = kmalloc(SZ_SG_IO_HDR, GFP_KERNEL);\n\t\t\t\tif (!new_hdr) {\n\t\t\t\t\tretval = -ENOMEM;\n\t\t\t\t\tgoto free_old_hdr;\n\t\t\t\t}\n\t\t\t\tretval =__copy_from_user\n\t\t\t\t    (new_hdr, buf, SZ_SG_IO_HDR);\n\t\t\t\treq_pack_id = new_hdr->pack_id;\n\t\t\t\tkfree(new_hdr);\n\t\t\t\tif (retval) {\n\t\t\t\t\tretval = -EFAULT;\n\t\t\t\t\tgoto free_old_hdr;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\treq_pack_id = old_hdr->pack_id;\n\t}\n\tsrp = sg_get_rq_mark(sfp, req_pack_id);\n\tif (!srp) {\t\t/* now wait on packet to arrive */\n\t\tif (atomic_read(&sdp->detaching)) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tretval = wait_event_interruptible(sfp->read_wait,\n\t\t\t(atomic_read(&sdp->detaching) ||\n\t\t\t(srp = sg_get_rq_mark(sfp, req_pack_id))));\n\t\tif (atomic_read(&sdp->detaching)) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tif (retval) {\n\t\t\t/* -ERESTARTSYS as signal hit process */\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t}\n\tif (srp->header.interface_id != '\\0') {\n\t\tretval = sg_new_read(sfp, buf, count, srp);\n\t\tgoto free_old_hdr;\n\t}\n\n\thp = &srp->header;\n\tif (old_hdr == NULL) {\n\t\told_hdr = kmalloc(SZ_SG_HEADER, GFP_KERNEL);\n\t\tif (! old_hdr) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t}\n\tmemset(old_hdr, 0, SZ_SG_HEADER);\n\told_hdr->reply_len = (int) hp->timeout;\n\told_hdr->pack_len = old_hdr->reply_len; /* old, strange behaviour */\n\told_hdr->pack_id = hp->pack_id;\n\told_hdr->twelve_byte =\n\t    ((srp->data.cmd_opcode >= 0xc0) && (12 == hp->cmd_len)) ? 1 : 0;\n\told_hdr->target_status = hp->masked_status;\n\told_hdr->host_status = hp->host_status;\n\told_hdr->driver_status = hp->driver_status;\n\tif ((CHECK_CONDITION & hp->masked_status) ||\n\t    (DRIVER_SENSE & hp->driver_status))\n\t\tmemcpy(old_hdr->sense_buffer, srp->sense_b,\n\t\t       sizeof (old_hdr->sense_buffer));\n\tswitch (hp->host_status) {\n\t/* This setup of 'result' is for backward compatibility and is best\n\t   ignored by the user who should use target, host + driver status */\n\tcase DID_OK:\n\tcase DID_PASSTHROUGH:\n\tcase DID_SOFT_ERROR:\n\t\told_hdr->result = 0;\n\t\tbreak;\n\tcase DID_NO_CONNECT:\n\tcase DID_BUS_BUSY:\n\tcase DID_TIME_OUT:\n\t\told_hdr->result = EBUSY;\n\t\tbreak;\n\tcase DID_BAD_TARGET:\n\tcase DID_ABORT:\n\tcase DID_PARITY:\n\tcase DID_RESET:\n\tcase DID_BAD_INTR:\n\t\told_hdr->result = EIO;\n\t\tbreak;\n\tcase DID_ERROR:\n\t\told_hdr->result = (srp->sense_b[0] == 0 && \n\t\t\t\t  hp->masked_status == GOOD) ? 0 : EIO;\n\t\tbreak;\n\tdefault:\n\t\told_hdr->result = EIO;\n\t\tbreak;\n\t}\n\n\t/* Now copy the result back to the user buffer.  */\n\tif (count >= SZ_SG_HEADER) {\n\t\tif (__copy_to_user(buf, old_hdr, SZ_SG_HEADER)) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto free_old_hdr;\n\t\t}\n\t\tbuf += SZ_SG_HEADER;\n\t\tif (count > old_hdr->reply_len)\n\t\t\tcount = old_hdr->reply_len;\n\t\tif (count > SZ_SG_HEADER) {\n\t\t\tif (sg_read_oxfer(srp, buf, count - SZ_SG_HEADER)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto free_old_hdr;\n\t\t\t}\n\t\t}\n\t} else\n\t\tcount = (old_hdr->result == 0) ? 0 : -EIO;\n\tsg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\tretval = count;\nfree_old_hdr:\n\tkfree(old_hdr);\n\treturn retval;\n}",
        "target": 1,
        "cwe": [
            "CWE-732"
        ],
        "project": "linux",
        "commit_id": "26b5b874aff5659a7e26e5b1997e3df2c41fa7fd",
        "hash": 243121034827309384702404275983186696843,
        "size": 146,
        "message": "scsi: sg: mitigate read/write abuse\n\nAs Al Viro noted in commit 128394eff343 (\"sg_write()/bsg_write() is not fit\nto be called under KERNEL_DS\"), sg improperly accesses userspace memory\noutside the provided buffer, permitting kernel memory corruption via\nsplice().  But it doesn't just do it on ->write(), also on ->read().\n\nAs a band-aid, make sure that the ->read() and ->write() handlers can not\nbe called in weird contexts (kernel context or credentials different from\nfile opener), like for ib_safe_file_access().\n\nIf someone needs to use these interfaces from different security contexts,\na new interface should be written that goes through the ->ioctl() handler.\n\nI've mostly copypasted ib_safe_file_access() over as sg_safe_file_access()\nbecause I couldn't find a good common header - please tell me if you know a\nbetter way.\n\n[mkp: s/_safe_/_check_/]\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nCc: <stable@vger.kernel.org>\nSigned-off-by: Jann Horn <jannh@google.com>\nAcked-by: Douglas Gilbert <dgilbert@interlog.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>"
    },
    {
        "func": "int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb->config_file = argv[i+1];\n\n\t\t\t\tif(config__read(db, config, false)){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open configuration file.\");\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>65535){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = port_tmp;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb->verbose = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\tif(config->listener_count == 0\n#ifdef WITH_TLS\n\t\t\t|| config->default_listener.cafile\n\t\t\t|| config->default_listener.capath\n\t\t\t|| config->default_listener.certfile\n\t\t\t|| config->default_listener.keyfile\n\t\t\t|| config->default_listener.ciphers\n\t\t\t|| config->default_listener.psk_hint\n\t\t\t|| config->default_listener.require_certificate\n\t\t\t|| config->default_listener.crlfile\n\t\t\t|| config->default_listener.use_identity_as_username\n\t\t\t|| config->default_listener.use_subject_as_username\n#endif\n\t\t\t|| config->default_listener.use_username_as_clientid\n\t\t\t|| config->default_listener.host\n\t\t\t|| config->default_listener.port\n\t\t\t|| config->default_listener.max_connections != -1\n\t\t\t|| config->default_listener.mount_point\n\t\t\t|| config->default_listener.protocol != mp_mqtt\n\t\t\t|| config->default_listener.socket_domain\n\t\t\t|| config->default_listener.security_options.password_file\n\t\t\t|| config->default_listener.security_options.psk_file\n\t\t\t|| config->default_listener.security_options.auth_plugin_config_count\n\t\t\t|| config->default_listener.security_options.allow_anonymous != -1\n\t\t\t){\n\n\t\tconfig->listener_count++;\n\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\tif(!config->listeners){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmemset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));\n\t\tif(config->default_listener.port){\n\t\t\tconfig->listeners[config->listener_count-1].port = config->default_listener.port;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].port = 1883;\n\t\t}\n\t\tif(config->default_listener.host){\n\t\t\tconfig->listeners[config->listener_count-1].host = config->default_listener.host;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].host = NULL;\n\t\t}\n\t\tif(config->default_listener.mount_point){\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = NULL;\n\t\t}\n\t\tconfig->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;\n\t\tconfig->listeners[config->listener_count-1].protocol = config->default_listener.protocol;\n\t\tconfig->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].socks = NULL;\n\t\tconfig->listeners[config->listener_count-1].sock_count = 0;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;\n#ifdef WITH_TLS\n\t\tconfig->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;\n\t\tconfig->listeners[config->listener_count-1].cafile = config->default_listener.cafile;\n\t\tconfig->listeners[config->listener_count-1].capath = config->default_listener.capath;\n\t\tconfig->listeners[config->listener_count-1].certfile = config->default_listener.certfile;\n\t\tconfig->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;\n\t\tconfig->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;\n\t\tconfig->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;\n\t\tconfig->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;\n\t\tconfig->listeners[config->listener_count-1].ssl_ctx = NULL;\n\t\tconfig->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;\n\t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n\t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n#endif\n\t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;\n\t\tconfig->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}\n\treturn config__check(config);\n}",
        "target": 1,
        "cwe": [
            "CWE-200",
            "CWE-732",
            "CWE-254"
        ],
        "project": "mosquitto",
        "commit_id": "9097577b49b7fdcf45d30975976dd93808ccc0c4",
        "hash": 13621695757493051368899806356088234213,
        "size": 136,
        "message": "Fix acl_file being ignore for default listener if with per_listener_settings\n\nClose #1073. Thanks to Jef Driesen.\n\nBug: https://github.com/eclipse/mosquitto/issues/1073"
    },
    {
        "func": "ns_xfr_start(ns_client_t *client, dns_rdatatype_t reqtype) {\n\tisc_result_t result;\n\tdns_name_t *question_name;\n\tdns_rdataset_t *question_rdataset;\n\tdns_zone_t *zone = NULL, *raw = NULL, *mayberaw;\n\tdns_db_t *db = NULL;\n\tdns_dbversion_t *ver = NULL;\n\tdns_rdataclass_t question_class;\n\trrstream_t *soa_stream = NULL;\n\trrstream_t *data_stream = NULL;\n\trrstream_t *stream = NULL;\n\tdns_difftuple_t *current_soa_tuple = NULL;\n\tdns_name_t *soa_name;\n\tdns_rdataset_t *soa_rdataset;\n\tdns_rdata_t soa_rdata = DNS_RDATA_INIT;\n\tbool have_soa = false;\n\tconst char *mnemonic = NULL;\n\tisc_mem_t *mctx = client->mctx;\n\tdns_message_t *request = client->message;\n\txfrout_ctx_t *xfr = NULL;\n\tisc_quota_t *quota = NULL;\n\tdns_transfer_format_t format = client->view->transfer_format;\n\tisc_netaddr_t na;\n\tdns_peer_t *peer = NULL;\n\tisc_buffer_t *tsigbuf = NULL;\n\tchar *journalfile;\n\tchar msg[NS_CLIENT_ACLMSGSIZE(\"zone transfer\")];\n\tchar keyname[DNS_NAME_FORMATSIZE];\n\tbool is_poll = false;\n\tbool is_dlz = false;\n\tbool is_ixfr = false;\n\tuint32_t begin_serial = 0, current_serial;\n\n\tswitch (reqtype) {\n\tcase dns_rdatatype_axfr:\n\t\tmnemonic = \"AXFR\";\n\t\tbreak;\n\tcase dns_rdatatype_ixfr:\n\t\tmnemonic = \"IXFR\";\n\t\tbreak;\n\tdefault:\n\t\tINSIST(0);\n\t\tISC_UNREACHABLE();\n\t}\n\n\tns_client_log(client,\n\t\t      DNS_LOGCATEGORY_XFER_OUT, NS_LOGMODULE_XFER_OUT,\n\t\t      ISC_LOG_DEBUG(6), \"%s request\", mnemonic);\n\t/*\n\t * Apply quota.\n\t */\n\tresult = isc_quota_attach(&ns_g_server->xfroutquota, &quota);\n\tif (result != ISC_R_SUCCESS) {\n\t\tisc_log_write(XFROUT_COMMON_LOGARGS, ISC_LOG_WARNING,\n\t\t\t      \"%s request denied: %s\", mnemonic,\n\t\t\t      isc_result_totext(result));\n\t\tgoto failure;\n\t}\n\n\t/*\n\t * Interpret the question section.\n\t */\n\tresult = dns_message_firstname(request, DNS_SECTION_QUESTION);\n\tINSIST(result == ISC_R_SUCCESS);\n\n\t/*\n\t * The question section must contain exactly one question, and\n\t * it must be for AXFR/IXFR as appropriate.\n\t */\n\tquestion_name = NULL;\n\tdns_message_currentname(request, DNS_SECTION_QUESTION, &question_name);\n\tquestion_rdataset = ISC_LIST_HEAD(question_name->list);\n\tquestion_class = question_rdataset->rdclass;\n\tINSIST(question_rdataset->type == reqtype);\n\tif (ISC_LIST_NEXT(question_rdataset, link) != NULL)\n\t\tFAILC(DNS_R_FORMERR, \"multiple questions\");\n\tresult = dns_message_nextname(request, DNS_SECTION_QUESTION);\n\tif (result != ISC_R_NOMORE)\n\t\tFAILC(DNS_R_FORMERR, \"multiple questions\");\n\n\tresult = dns_zt_find(client->view->zonetable, question_name, 0, NULL,\n\t\t\t     &zone);\n\n\tif (result != ISC_R_SUCCESS) {\n\t\t/*\n\t\t * Normal zone table does not have a match.\n\t\t * Try the DLZ database\n\t\t */\n\t\t// Temporary: only searching the first DLZ database\n\t\tif (! ISC_LIST_EMPTY(client->view->dlz_searched)) {\n\t\t\tresult = dns_dlzallowzonexfr(client->view,\n\t\t\t\t\t\t     question_name,\n\t\t\t\t\t\t     &client->peeraddr,\n\t\t\t\t\t\t     &db);\n\n\t\t\tif (result == ISC_R_NOPERM) {\n\t\t\t\tchar _buf1[DNS_NAME_FORMATSIZE];\n\t\t\t\tchar _buf2[DNS_RDATACLASS_FORMATSIZE];\n\n\t\t\t\tresult = DNS_R_REFUSED;\n\t\t\t\tdns_name_format(question_name, _buf1,\n\t\t\t\t\t\tsizeof(_buf1));\n\t\t\t\tdns_rdataclass_format(question_class,\n\t\t\t\t\t\t      _buf2, sizeof(_buf2));\n\t\t\t\tns_client_log(client, DNS_LOGCATEGORY_SECURITY,\n\t\t\t\t\t      NS_LOGMODULE_XFER_OUT,\n\t\t\t\t\t      ISC_LOG_ERROR,\n\t\t\t\t\t      \"zone transfer '%s/%s' denied\",\n\t\t\t\t\t      _buf1, _buf2);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (result != ISC_R_SUCCESS)\n\t\t\t\tFAILQ(DNS_R_NOTAUTH, \"non-authoritative zone\",\n\t\t\t\t      question_name, question_class);\n\t\t\tis_dlz = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * not DLZ and not in normal zone table, we are\n\t\t\t * not authoritative\n\t\t\t */\n\t\t\tFAILQ(DNS_R_NOTAUTH, \"non-authoritative zone\",\n\t\t\t      question_name, question_class);\n\t\t}\n\t} else {\n\t\t/* zone table has a match */\n\t\tswitch(dns_zone_gettype(zone)) {\n\t\t\t/* Master and slave zones are OK for transfer. */\n\t\t\tcase dns_zone_master:\n\t\t\tcase dns_zone_slave:\n\t\t\tcase dns_zone_dlz:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tFAILQ(DNS_R_NOTAUTH, \"non-authoritative zone\",\n\t\t\t\t      question_name, question_class);\n\t\t\t}\n\t\tCHECK(dns_zone_getdb(zone, &db));\n\t\tdns_db_currentversion(db, &ver);\n\t}\n\n\txfrout_log1(client, question_name, question_class, ISC_LOG_DEBUG(6),\n\t\t    \"%s question section OK\", mnemonic);\n\n\t/*\n\t * Check the authority section.  Look for a SOA record with\n\t * the same name and class as the question.\n\t */\n\tfor (result = dns_message_firstname(request, DNS_SECTION_AUTHORITY);\n\t     result == ISC_R_SUCCESS;\n\t     result = dns_message_nextname(request, DNS_SECTION_AUTHORITY))\n\t{\n\t\tsoa_name = NULL;\n\t\tdns_message_currentname(request, DNS_SECTION_AUTHORITY,\n\t\t\t\t\t&soa_name);\n\n\t\t/*\n\t\t * Ignore data whose owner name is not the zone apex.\n\t\t */\n\t\tif (! dns_name_equal(soa_name, question_name))\n\t\t\tcontinue;\n\n\t\tfor (soa_rdataset = ISC_LIST_HEAD(soa_name->list);\n\t\t     soa_rdataset != NULL;\n\t\t     soa_rdataset = ISC_LIST_NEXT(soa_rdataset, link))\n\t\t{\n\t\t\t/*\n\t\t\t * Ignore non-SOA data.\n\t\t\t */\n\t\t\tif (soa_rdataset->type != dns_rdatatype_soa)\n\t\t\t\tcontinue;\n\t\t\tif (soa_rdataset->rdclass != question_class)\n\t\t\t\tcontinue;\n\n\t\t\tCHECK(dns_rdataset_first(soa_rdataset));\n\t\t\tdns_rdataset_current(soa_rdataset, &soa_rdata);\n\t\t\tresult = dns_rdataset_next(soa_rdataset);\n\t\t\tif (result == ISC_R_SUCCESS)\n\t\t\t\tFAILC(DNS_R_FORMERR,\n\t\t\t\t      \"IXFR authority section \"\n\t\t\t\t      \"has multiple SOAs\");\n\t\t\thave_soa = true;\n\t\t\tgoto got_soa;\n\t\t}\n\t}\n got_soa:\n\tif (result != ISC_R_NOMORE)\n\t\tCHECK(result);\n\n\txfrout_log1(client, question_name, question_class, ISC_LOG_DEBUG(6),\n\t\t    \"%s authority section OK\", mnemonic);\n\n\t/*\n\t * If not a DLZ zone, decide whether to allow this transfer.\n\t */\n\tif (!is_dlz) {\n\t\tns_client_aclmsg(\"zone transfer\", question_name, reqtype,\n\t\t\t\t client->view->rdclass, msg, sizeof(msg));\n\t\tCHECK(ns_client_checkacl(client, NULL, msg,\n\t\t\t\t\t dns_zone_getxfracl(zone),\n\t\t\t\t\t true, ISC_LOG_ERROR));\n\t}\n\n\t/*\n\t * AXFR over UDP is not possible.\n\t */\n\tif (reqtype == dns_rdatatype_axfr &&\n\t    (client->attributes & NS_CLIENTATTR_TCP) == 0)\n\t\tFAILC(DNS_R_FORMERR, \"attempted AXFR over UDP\");\n\n\t/*\n\t * Look up the requesting server in the peer table.\n\t */\n\tisc_netaddr_fromsockaddr(&na, &client->peeraddr);\n\t(void)dns_peerlist_peerbyaddr(client->view->peers, &na, &peer);\n\n\t/*\n\t * Decide on the transfer format (one-answer or many-answers).\n\t */\n\tif (peer != NULL)\n\t\t(void)dns_peer_gettransferformat(peer, &format);\n\n\t/*\n\t * Get a dynamically allocated copy of the current SOA.\n\t */\n\tif (is_dlz)\n\t\tdns_db_currentversion(db, &ver);\n\n\tCHECK(dns_db_createsoatuple(db, ver, mctx, DNS_DIFFOP_EXISTS,\n\t\t\t\t    &current_soa_tuple));\n\n\tcurrent_serial = dns_soa_getserial(&current_soa_tuple->rdata);\n\tif (reqtype == dns_rdatatype_ixfr) {\n\t\tbool provide_ixfr;\n\n\t\t/*\n\t\t * Outgoing IXFR may have been disabled for this peer\n\t\t * or globally.\n\t\t */\n\t\tprovide_ixfr = client->view->provideixfr;\n\t\tif (peer != NULL)\n\t\t\t(void) dns_peer_getprovideixfr(peer, &provide_ixfr);\n\t\tif (provide_ixfr == false)\n\t\t\tgoto axfr_fallback;\n\n\t\tif (! have_soa)\n\t\t\tFAILC(DNS_R_FORMERR,\n\t\t\t      \"IXFR request missing SOA\");\n\n\t\tbegin_serial = dns_soa_getserial(&soa_rdata);\n\n\t\t/*\n\t\t * RFC1995 says \"If an IXFR query with the same or\n\t\t * newer version number than that of the server\n\t\t * is received, it is replied to with a single SOA\n\t\t * record of the server's current version, just as\n\t\t * in AXFR\".  The claim about AXFR is incorrect,\n\t\t * but other than that, we do as the RFC says.\n\t\t *\n\t\t * Sending a single SOA record is also how we refuse\n\t\t * IXFR over UDP (currently, we always do).\n\t\t */\n\t\tif (DNS_SERIAL_GE(begin_serial, current_serial) ||\n\t\t    (client->attributes & NS_CLIENTATTR_TCP) == 0)\n\t\t{\n\t\t\tCHECK(soa_rrstream_create(mctx, db, ver, &stream));\n\t\t\tis_poll = true;\n\t\t\tgoto have_stream;\n\t\t}\n\t\tjournalfile = is_dlz ? NULL : dns_zone_getjournal(zone);\n\t\tif (journalfile != NULL)\n\t\t\tresult = ixfr_rrstream_create(mctx,\n\t\t\t\t\t\t      journalfile,\n\t\t\t\t\t\t      begin_serial,\n\t\t\t\t\t\t      current_serial,\n\t\t\t\t\t\t      &data_stream);\n\t\telse\n\t\t\tresult = ISC_R_NOTFOUND;\n\t\tif (result == ISC_R_NOTFOUND ||\n\t\t    result == ISC_R_RANGE) {\n\t\t\txfrout_log1(client, question_name, question_class,\n\t\t\t\t    ISC_LOG_DEBUG(4),\n\t\t\t\t    \"IXFR version not in journal, \"\n\t\t\t\t    \"falling back to AXFR\");\n\t\t\tmnemonic = \"AXFR-style IXFR\";\n\t\t\tgoto axfr_fallback;\n\t\t}\n\t\tCHECK(result);\n\t\tis_ixfr = true;\n\t} else {\n\taxfr_fallback:\n\t\tCHECK(axfr_rrstream_create(mctx, db, ver, &data_stream));\n\t}\n\n\t/*\n\t * Bracket the data stream with SOAs.\n\t */\n\tCHECK(soa_rrstream_create(mctx, db, ver, &soa_stream));\n\tCHECK(compound_rrstream_create(mctx, &soa_stream, &data_stream,\n\t\t\t\t       &stream));\n\tsoa_stream = NULL;\n\tdata_stream = NULL;\n\n have_stream:\n\tCHECK(dns_message_getquerytsig(request, mctx, &tsigbuf));\n\t/*\n\t * Create the xfrout context object.  This transfers the ownership\n\t * of \"stream\", \"db\", \"ver\", and \"quota\" to the xfrout context object.\n\t */\n\n\n\n\tif (is_dlz)\n\t\tCHECK(xfrout_ctx_create(mctx, client, request->id,\n\t\t\t\t\tquestion_name, reqtype, question_class,\n\t\t\t\t\tzone, db, ver, quota, stream,\n\t\t\t\t\tdns_message_gettsigkey(request),\n\t\t\t\t\ttsigbuf,\n\t\t\t\t\trequest->verified_sig,\n\t\t\t\t\t3600,\n\t\t\t\t\t3600,\n\t\t\t\t\t(format == dns_many_answers) ?\n\t\t\t\t\ttrue : false,\n\t\t\t\t\t&xfr));\n\telse\n\t\tCHECK(xfrout_ctx_create(mctx, client, request->id,\n\t\t\t\t\tquestion_name, reqtype, question_class,\n\t\t\t\t\tzone, db, ver, quota, stream,\n\t\t\t\t\tdns_message_gettsigkey(request),\n\t\t\t\t\ttsigbuf,\n\t\t\t\t\trequest->verified_sig,\n\t\t\t\t\tdns_zone_getmaxxfrout(zone),\n\t\t\t\t\tdns_zone_getidleout(zone),\n\t\t\t\t\t(format == dns_many_answers) ?\n\t\t\t\t\ttrue : false,\n\t\t\t\t\t&xfr));\n\n\txfr->mnemonic = mnemonic;\n\tstream = NULL;\n\tquota = NULL;\n\n\tCHECK(xfr->stream->methods->first(xfr->stream));\n\n\tif (xfr->tsigkey != NULL)\n\t\tdns_name_format(&xfr->tsigkey->name, keyname, sizeof(keyname));\n\telse\n\t\tkeyname[0] = '\\0';\n\tif (is_poll)\n\t\txfrout_log1(client, question_name, question_class,\n\t\t\t    ISC_LOG_DEBUG(1), \"IXFR poll up to date%s%s\",\n\t\t\t    (xfr->tsigkey != NULL) ? \": TSIG \" : \"\", keyname);\n\telse if (is_ixfr)\n\t\txfrout_log1(client, question_name, question_class,\n\t\t\t    ISC_LOG_INFO, \"%s started%s%s (serial %u -> %u)\",\n\t\t\t    mnemonic, (xfr->tsigkey != NULL) ? \": TSIG \" : \"\",\n\t\t\t    keyname, begin_serial, current_serial);\n\telse\n\t\txfrout_log1(client, question_name, question_class,\n\t\t\t    ISC_LOG_INFO, \"%s started%s%s (serial %u)\",\n\t\t\t    mnemonic, (xfr->tsigkey != NULL) ? \": TSIG \" : \"\",\n\t\t\t    keyname, current_serial);\n\n\n\tif (zone != NULL) {\n\t\tdns_zone_getraw(zone, &raw);\n\t\tmayberaw = (raw != NULL) ? raw : zone;\n\t\tif ((client->attributes & NS_CLIENTATTR_WANTEXPIRE) != 0 &&\n\t\t    dns_zone_gettype(mayberaw) == dns_zone_slave) {\n\t\t\tisc_time_t expiretime;\n\t\t\tuint32_t secs;\n\t\t\tdns_zone_getexpiretime(zone, &expiretime);\n\t\t\tsecs = isc_time_seconds(&expiretime);\n\t\t\tif (secs >= client->now && result == ISC_R_SUCCESS) {\n\t\t\t\tclient->attributes |= NS_CLIENTATTR_HAVEEXPIRE;\n\t\t\t\tclient->expire = secs - client->now;\n\t\t\t}\n\t\t}\n\t\tif (raw != NULL)\n\t\t\tdns_zone_detach(&raw);\n\t}\n\n\t/*\n\t * Hand the context over to sendstream().  Set xfr to NULL;\n\t * sendstream() is responsible for either passing the\n\t * context on to a later event handler or destroying it.\n\t */\n\tsendstream(xfr);\n\txfr = NULL;\n\n\tresult = ISC_R_SUCCESS;\n\n failure:\n\tif (result == DNS_R_REFUSED)\n\t\tinc_stats(zone, dns_nsstatscounter_xfrrej);\n\tif (quota != NULL)\n\t\tisc_quota_detach(&quota);\n\tif (current_soa_tuple != NULL)\n\t\tdns_difftuple_free(&current_soa_tuple);\n\tif (stream != NULL)\n\t\tstream->methods->destroy(&stream);\n\tif (soa_stream != NULL)\n\t\tsoa_stream->methods->destroy(&soa_stream);\n\tif (data_stream != NULL)\n\t\tdata_stream->methods->destroy(&data_stream);\n\tif (ver != NULL)\n\t\tdns_db_closeversion(db, &ver, false);\n\tif (db != NULL)\n\t\tdns_db_detach(&db);\n\tif (zone != NULL)\n\t\tdns_zone_detach(&zone);\n\t/* XXX kludge */\n\tif (xfr != NULL) {\n\t\txfrout_fail(xfr, result, \"setting up zone transfer\");\n\t} else if (result != ISC_R_SUCCESS) {\n\t\tns_client_log(client, DNS_LOGCATEGORY_XFER_OUT,\n\t\t\t      NS_LOGMODULE_XFER_OUT,\n\t\t\t      ISC_LOG_DEBUG(3), \"zone transfer setup failed\");\n\t\tns_client_error(client, result);\n\t}\n}",
        "target": 1,
        "cwe": [
            "CWE-732"
        ],
        "project": "bind9",
        "commit_id": "34348d9ee4db15307c6c42db294419b4df569f76",
        "hash": 125804323100717168540864094147242390684,
        "size": 418,
        "message": "denied axfr requests were not effective for writable DLZ zones\n\n(cherry picked from commit d9077cd0038e59726e1956de18b4b7872038a283)"
    },
    {
        "func": "dlz_allowzonexfr(void *dbdata, const char *name, const char *client) {\n\tUNUSED(client);\n\n\t/* Just say yes for all our zones */\n\treturn (dlz_findzonedb(dbdata, name, NULL, NULL));\n}",
        "target": 1,
        "cwe": [
            "CWE-732"
        ],
        "project": "bind9",
        "commit_id": "34348d9ee4db15307c6c42db294419b4df569f76",
        "hash": 161199142935997827977917088147755992542,
        "size": 6,
        "message": "denied axfr requests were not effective for writable DLZ zones\n\n(cherry picked from commit d9077cd0038e59726e1956de18b4b7872038a283)"
    },
    {
        "func": "void preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}",
        "target": 1,
        "cwe": [
            "CWE-284",
            "CWE-732"
        ],
        "project": "firejail",
        "commit_id": "eecf35c2f8249489a1d3e512bb07f0d427183134",
        "hash": 169345403866433646450040406705309300195,
        "size": 34,
        "message": "mount runtime seccomp files read-only (#2602)\n\navoid creating locations in the file system that are both writable and\r\nexecutable (in this case for processes with euid of the user).\r\n\r\nfor the same reason also remove user owned libfiles\r\nwhen it is not needed any more"
    },
    {
        "func": "int sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \"/firejail\", RUN_FIREJAIL_LIB_DIR, \"none\", MS_BIND, NULL) < 0)\n\t\terrExit(\"mounting \" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace '%s' activated\\n\", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\"cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \"printif\", \"scan\");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \"printif\");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns4);\n\t\t\tfmessage(\"\\n\");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build protocol filter: %s\\n\", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \"protocol\", \"build\", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/etc\", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-opt feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-opt feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/opt\", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-srv feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-srv feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/srv\", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-lib feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-lib feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-cache feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-cache feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\"Current directory: %s\\n\", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// set capabilities\n\tset_caps();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install protocol filter: %s\\n\", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install memory write&execute filter\\n\");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n#endif\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\"cannot create a new user namespace, going forward without it...\\n\");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\"cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfwarning(\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}",
        "target": 1,
        "cwe": [
            "CWE-284",
            "CWE-732"
        ],
        "project": "firejail",
        "commit_id": "eecf35c2f8249489a1d3e512bb07f0d427183134",
        "hash": 111332967924299128509420306711130810900,
        "size": 634,
        "message": "mount runtime seccomp files read-only (#2602)\n\navoid creating locations in the file system that are both writable and\r\nexecutable (in this case for processes with euid of the user).\r\n\r\nfor the same reason also remove user owned libfiles\r\nwhen it is not needed any more"
    },
    {
        "func": "void *create_directory_config(apr_pool_t *mp, char *path)\n{\n    directory_config *dcfg = (directory_config *)apr_pcalloc(mp, sizeof(directory_config));\n    if (dcfg == NULL) return NULL;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Created directory config %pp path %s\", dcfg, path);\n    #endif\n\n    dcfg->mp = mp;\n    dcfg->is_enabled = NOT_SET;\n\n    dcfg->reqbody_access = NOT_SET;\n    dcfg->reqintercept_oe = NOT_SET;\n    dcfg->reqbody_buffering = NOT_SET;\n    dcfg->reqbody_inmemory_limit = NOT_SET;\n    dcfg->reqbody_limit = NOT_SET;\n    dcfg->reqbody_no_files_limit = NOT_SET;\n    dcfg->resbody_access = NOT_SET;\n\n    dcfg->debuglog_name = NOT_SET_P;\n    dcfg->debuglog_level = NOT_SET;\n    dcfg->debuglog_fd = NOT_SET_P;\n\n    dcfg->of_limit = NOT_SET;\n    dcfg->if_limit_action = NOT_SET;\n    dcfg->of_limit_action = NOT_SET;\n    dcfg->of_mime_types = NOT_SET_P;\n    dcfg->of_mime_types_cleared = NOT_SET;\n\n    dcfg->cookie_format = NOT_SET;\n    dcfg->argument_separator = NOT_SET;\n    dcfg->cookiev0_separator = NOT_SET_P;\n\n    dcfg->rule_inheritance = NOT_SET;\n    dcfg->rule_exceptions = apr_array_make(mp, 16, sizeof(rule_exception *));\n    dcfg->hash_method = apr_array_make(mp, 16, sizeof(hash_method *));\n\n    /* audit log variables */\n    dcfg->auditlog_flag = NOT_SET;\n    dcfg->auditlog_type = NOT_SET;\n    dcfg->max_rule_time = NOT_SET;\n    dcfg->auditlog_dirperms = NOT_SET;\n    dcfg->auditlog_fileperms = NOT_SET;\n    dcfg->auditlog_name = NOT_SET_P;\n    dcfg->auditlog2_name = NOT_SET_P;\n    dcfg->auditlog_fd = NOT_SET_P;\n    dcfg->auditlog2_fd = NOT_SET_P;\n    dcfg->auditlog_storage_dir = NOT_SET_P;\n    dcfg->auditlog_parts = NOT_SET_P;\n    dcfg->auditlog_relevant_regex = NOT_SET_P;\n\n    dcfg->ruleset = NULL;\n\n    /* Upload */\n    dcfg->tmp_dir = NOT_SET_P;\n    dcfg->upload_dir = NOT_SET_P;\n    dcfg->upload_keep_files = NOT_SET;\n    dcfg->upload_validates_files = NOT_SET;\n    dcfg->upload_filemode = NOT_SET;\n    dcfg->upload_file_limit = NOT_SET;\n\n    /* These are only used during the configuration process. */\n    dcfg->tmp_chain_starter = NULL;\n    dcfg->tmp_default_actionset = NULL;\n    dcfg->tmp_rule_placeholders = NULL;\n\n    /* Misc */\n    dcfg->data_dir = NOT_SET_P;\n    dcfg->webappid = NOT_SET_P;\n    dcfg->sensor_id = NOT_SET_P;\n    dcfg->httpBlkey = NOT_SET_P;\n\n    /* Content injection. */\n    dcfg->content_injection_enabled = NOT_SET;\n\n    /* Stream inspection */\n    dcfg->stream_inbody_inspection = NOT_SET;\n    dcfg->stream_outbody_inspection = NOT_SET;\n\n    /* Geo Lookups */\n    dcfg->geo = NOT_SET_P;\n\n    /* Gsb Lookups */\n    dcfg->gsb = NOT_SET_P;\n\n    /* Unicode Map */\n    dcfg->u_map = NOT_SET_P;\n\n    /* Cache */\n    dcfg->cache_trans = NOT_SET;\n    dcfg->cache_trans_incremental = NOT_SET;\n    dcfg->cache_trans_min = NOT_SET;\n    dcfg->cache_trans_max = NOT_SET;\n    dcfg->cache_trans_maxitems = NOT_SET;\n\n    /* Rule ids */\n    dcfg->rule_id_htab = apr_hash_make(mp);\n    dcfg->component_signatures = apr_array_make(mp, 16, sizeof(char *));\n\n    dcfg->request_encoding = NOT_SET_P;\n    dcfg->disable_backend_compression = NOT_SET;\n\n    /* Collection timeout */\n    dcfg->col_timeout = NOT_SET;\n\n    dcfg->crypto_key = NOT_SET_P;\n    dcfg->crypto_key_len = NOT_SET;\n    dcfg->crypto_key_add = NOT_SET;\n    dcfg->crypto_param_name = NOT_SET_P;\n    dcfg->hash_is_enabled = NOT_SET;\n    dcfg->hash_enforcement = NOT_SET;\n    dcfg->crypto_hash_href_rx = NOT_SET;\n    dcfg->crypto_hash_faction_rx = NOT_SET;\n    dcfg->crypto_hash_location_rx = NOT_SET;\n    dcfg->crypto_hash_iframesrc_rx = NOT_SET;\n    dcfg->crypto_hash_framesrc_rx = NOT_SET;\n    dcfg->crypto_hash_href_pm = NOT_SET;\n    dcfg->crypto_hash_faction_pm = NOT_SET;\n    dcfg->crypto_hash_location_pm = NOT_SET;\n    dcfg->crypto_hash_iframesrc_pm = NOT_SET;\n    dcfg->crypto_hash_framesrc_pm = NOT_SET;\n\n\n    return dcfg;\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-611"
        ],
        "project": "ModSecurity",
        "commit_id": "d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "hash": 88502794977987007652787973353414007835,
        "size": 126,
        "message": "Added SecXmlExternalEntity"
    },
    {
        "func": "int xml_init(modsec_rec *msr, char **error_msg) {\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n\n    return 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-611"
        ],
        "project": "ModSecurity",
        "commit_id": "d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "hash": 276066474089244810660069051950316213617,
        "size": 9,
        "message": "Added SecXmlExternalEntity"
    },
    {
        "func": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n\n    return NULL;\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-611"
        ],
        "project": "ModSecurity",
        "commit_id": "d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "hash": 210014868356171618758476584077332465545,
        "size": 17,
        "message": "Added SecXmlExternalEntity"
    },
    {
        "func": "void *merge_directory_configs(apr_pool_t *mp, void *_parent, void *_child)\n{\n    directory_config *parent = (directory_config *)_parent;\n    directory_config *child = (directory_config *)_child;\n    directory_config *merged = create_directory_config(mp, NULL);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Merge parent %pp child %pp RESULT %pp\", _parent, _child, merged);\n    #endif\n\n    if (merged == NULL) return NULL;\n\n    /* Use values from the child configuration where possible,\n     * otherwise use the parent's.\n     */\n\n    merged->is_enabled = (child->is_enabled == NOT_SET\n        ? parent->is_enabled : child->is_enabled);\n\n    /* IO parameters */\n    merged->reqbody_access = (child->reqbody_access == NOT_SET\n        ? parent->reqbody_access : child->reqbody_access);\n    merged->reqbody_buffering = (child->reqbody_buffering == NOT_SET\n        ? parent->reqbody_buffering : child->reqbody_buffering);\n    merged->reqbody_inmemory_limit = (child->reqbody_inmemory_limit == NOT_SET\n        ? parent->reqbody_inmemory_limit : child->reqbody_inmemory_limit);\n    merged->reqbody_limit = (child->reqbody_limit == NOT_SET\n        ? parent->reqbody_limit : child->reqbody_limit);\n    merged->reqbody_no_files_limit = (child->reqbody_no_files_limit == NOT_SET\n        ? parent->reqbody_no_files_limit : child->reqbody_no_files_limit);\n    merged->resbody_access = (child->resbody_access == NOT_SET\n        ? parent->resbody_access : child->resbody_access);\n\n    merged->of_limit = (child->of_limit == NOT_SET\n        ? parent->of_limit : child->of_limit);\n    merged->if_limit_action = (child->if_limit_action == NOT_SET\n        ? parent->if_limit_action : child->if_limit_action);\n    merged->of_limit_action = (child->of_limit_action == NOT_SET\n        ? parent->of_limit_action : child->of_limit_action);\n    merged->reqintercept_oe = (child->reqintercept_oe == NOT_SET\n        ? parent->reqintercept_oe : child->reqintercept_oe);\n\n    if (child->of_mime_types != NOT_SET_P) {\n        /* Child added to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            /* The list of MIME types was cleared in the child,\n             * which means the parent's MIME types went away and\n             * we should not take them into consideration here.\n             */\n            merged->of_mime_types = child->of_mime_types;\n            merged->of_mime_types_cleared = 1;\n        } else {\n            /* Add MIME types defined in the child to those\n             * defined in the parent context.\n             */\n            if (parent->of_mime_types == NOT_SET_P) {\n                merged->of_mime_types = child->of_mime_types;\n                merged->of_mime_types_cleared = NOT_SET;\n            } else {\n                merged->of_mime_types = apr_table_overlay(mp, parent->of_mime_types,\n                    child->of_mime_types);\n                if (merged->of_mime_types == NULL) return NULL;\n            }\n        }\n    } else {\n        /* Child did not add to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            merged->of_mime_types_cleared = 1;\n        } else {\n            merged->of_mime_types = parent->of_mime_types;\n            merged->of_mime_types_cleared = parent->of_mime_types_cleared;\n        }\n    }\n\n    /* debug log */\n    if (child->debuglog_fd == NOT_SET_P) {\n        merged->debuglog_name = parent->debuglog_name;\n        merged->debuglog_fd = parent->debuglog_fd;\n    } else {\n        merged->debuglog_name = child->debuglog_name;\n        merged->debuglog_fd = child->debuglog_fd;\n    }\n\n    merged->debuglog_level = (child->debuglog_level == NOT_SET\n        ? parent->debuglog_level : child->debuglog_level);\n\n    merged->cookie_format = (child->cookie_format == NOT_SET\n        ? parent->cookie_format : child->cookie_format);\n    merged->argument_separator = (child->argument_separator == NOT_SET\n        ? parent->argument_separator : child->argument_separator);\n    merged->cookiev0_separator = (child->cookiev0_separator == NOT_SET_P\n        ? parent->cookiev0_separator : child->cookiev0_separator);\n\n\n    /* rule inheritance */\n    if ((child->rule_inheritance == NOT_SET)||(child->rule_inheritance == 1)) {\n        merged->rule_inheritance = parent->rule_inheritance;\n        if ((child->ruleset == NULL)&&(parent->ruleset == NULL)) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"No rules in this context.\");\n            #endif\n\n            /* Do nothing, there are no rules in either context. */\n        } else\n        if (child->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent rules in this context.\");\n            #endif\n\n            /* Copy the rules from the parent context. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n        } else\n        if (parent->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using child rules in this context.\");\n            #endif\n\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        } else {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent then child rules in this context.\");\n            #endif\n\n            /* Copy parent rules, then add child rules to it. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n\n            apr_array_cat(merged->ruleset->phase_request_headers,\n                child->ruleset->phase_request_headers);\n            apr_array_cat(merged->ruleset->phase_request_body,\n                child->ruleset->phase_request_body);\n            apr_array_cat(merged->ruleset->phase_response_headers,\n                child->ruleset->phase_response_headers);\n            apr_array_cat(merged->ruleset->phase_response_body,\n                child->ruleset->phase_response_body);\n            apr_array_cat(merged->ruleset->phase_logging,\n                child->ruleset->phase_logging);\n        }\n    } else {\n        merged->rule_inheritance = 0;\n        if (child->ruleset != NULL) {\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        }\n    }\n\n    /* Merge rule exceptions. */\n    merged->rule_exceptions = apr_array_append(mp, parent->rule_exceptions,\n        child->rule_exceptions);\n\n    merged->hash_method = apr_array_append(mp, parent->hash_method,\n        child->hash_method);\n\n    /* audit log variables */\n    merged->auditlog_flag = (child->auditlog_flag == NOT_SET\n        ? parent->auditlog_flag : child->auditlog_flag);\n    merged->auditlog_type = (child->auditlog_type == NOT_SET\n        ? parent->auditlog_type : child->auditlog_type);\n    merged->max_rule_time = (child->max_rule_time == NOT_SET\n        ? parent->max_rule_time : child->max_rule_time);\n    merged->auditlog_dirperms = (child->auditlog_dirperms == NOT_SET\n        ? parent->auditlog_dirperms : child->auditlog_dirperms);\n    merged->auditlog_fileperms = (child->auditlog_fileperms == NOT_SET\n        ? parent->auditlog_fileperms : child->auditlog_fileperms);\n    if (child->auditlog_fd != NOT_SET_P) {\n        merged->auditlog_fd = child->auditlog_fd;\n        merged->auditlog_name = child->auditlog_name;\n    } else {\n        merged->auditlog_fd = parent->auditlog_fd;\n        merged->auditlog_name = parent->auditlog_name;\n    }\n    if (child->auditlog2_fd != NOT_SET_P) {\n        merged->auditlog2_fd = child->auditlog2_fd;\n        merged->auditlog2_name = child->auditlog2_name;\n    } else {\n        merged->auditlog2_fd = parent->auditlog2_fd;\n        merged->auditlog2_name = parent->auditlog2_name;\n    }\n    merged->auditlog_storage_dir = (child->auditlog_storage_dir == NOT_SET_P\n        ? parent->auditlog_storage_dir : child->auditlog_storage_dir);\n    merged->auditlog_parts = (child->auditlog_parts == NOT_SET_P\n        ? parent->auditlog_parts : child->auditlog_parts);\n    merged->auditlog_relevant_regex = (child->auditlog_relevant_regex == NOT_SET_P\n        ? parent->auditlog_relevant_regex : child->auditlog_relevant_regex);\n\n    /* Upload */\n    merged->tmp_dir = (child->tmp_dir == NOT_SET_P\n        ? parent->tmp_dir : child->tmp_dir);\n    merged->upload_dir = (child->upload_dir == NOT_SET_P\n        ? parent->upload_dir : child->upload_dir);\n    merged->upload_keep_files = (child->upload_keep_files == NOT_SET\n        ? parent->upload_keep_files : child->upload_keep_files);\n    merged->upload_validates_files = (child->upload_validates_files == NOT_SET\n        ? parent->upload_validates_files : child->upload_validates_files);\n    merged->upload_filemode = (child->upload_filemode == NOT_SET\n        ? parent->upload_filemode : child->upload_filemode);\n    merged->upload_file_limit = (child->upload_file_limit == NOT_SET\n        ? parent->upload_file_limit : child->upload_file_limit);\n\n    /* Misc */\n    merged->data_dir = (child->data_dir == NOT_SET_P\n        ? parent->data_dir : child->data_dir);\n    merged->webappid = (child->webappid == NOT_SET_P\n        ? parent->webappid : child->webappid);\n    merged->sensor_id = (child->sensor_id == NOT_SET_P\n        ? parent->sensor_id : child->sensor_id);\n    merged->httpBlkey = (child->httpBlkey == NOT_SET_P\n        ? parent->httpBlkey : child->httpBlkey);\n\n    /* Content injection. */\n    merged->content_injection_enabled = (child->content_injection_enabled == NOT_SET\n        ? parent->content_injection_enabled : child->content_injection_enabled);\n\n    /* Stream inspection */\n    merged->stream_inbody_inspection = (child->stream_inbody_inspection == NOT_SET\n        ? parent->stream_inbody_inspection : child->stream_inbody_inspection);\n    merged->stream_outbody_inspection = (child->stream_outbody_inspection == NOT_SET\n        ? parent->stream_outbody_inspection : child->stream_outbody_inspection);\n\n    /* Geo Lookup */\n    merged->geo = (child->geo == NOT_SET_P\n        ? parent->geo : child->geo);\n\n    /* Gsb Lookup */\n    merged->gsb = (child->gsb == NOT_SET_P\n        ? parent->gsb : child->gsb);\n\n    /* Unicode Map */\n    merged->u_map = (child->u_map == NOT_SET_P\n        ? parent->u_map : child->u_map);\n\n    /* Cache */\n    merged->cache_trans = (child->cache_trans == NOT_SET\n        ? parent->cache_trans : child->cache_trans);\n    merged->cache_trans_incremental = (child->cache_trans_incremental == NOT_SET\n        ? parent->cache_trans_incremental : child->cache_trans_incremental);\n    merged->cache_trans_min = (child->cache_trans_min == (apr_size_t)NOT_SET\n        ? parent->cache_trans_min : child->cache_trans_min);\n    merged->cache_trans_max = (child->cache_trans_max == (apr_size_t)NOT_SET\n        ? parent->cache_trans_max : child->cache_trans_max);\n    merged->cache_trans_maxitems = (child->cache_trans_maxitems == (apr_size_t)NOT_SET\n        ? parent->cache_trans_maxitems : child->cache_trans_maxitems);\n\n    /* Merge component signatures. */\n    merged->component_signatures = apr_array_append(mp, parent->component_signatures,\n        child->component_signatures);\n\n    merged->request_encoding = (child->request_encoding == NOT_SET_P\n        ? parent->request_encoding : child->request_encoding);\n\n    merged->disable_backend_compression = (child->disable_backend_compression == NOT_SET\n        ? parent->disable_backend_compression : child->disable_backend_compression);\n\n    merged->col_timeout = (child->col_timeout == NOT_SET\n        ? parent->col_timeout : child->col_timeout);\n\n    /* Hash */\n    merged->crypto_key = (child->crypto_key == NOT_SET_P\n        ? parent->crypto_key : child->crypto_key);\n    merged->crypto_key_len = (child->crypto_key_len == NOT_SET\n        ? parent->crypto_key_len : child->crypto_key_len);\n    merged->crypto_key_add = (child->crypto_key_add == NOT_SET\n        ? parent->crypto_key_add : child->crypto_key_add);\n    merged->crypto_param_name = (child->crypto_param_name == NOT_SET_P\n        ? parent->crypto_param_name : child->crypto_param_name);\n    merged->hash_is_enabled = (child->hash_is_enabled == NOT_SET\n        ? parent->hash_is_enabled : child->hash_is_enabled);\n    merged->hash_enforcement = (child->hash_enforcement == NOT_SET\n        ? parent->hash_enforcement : child->hash_enforcement);\n    merged->crypto_hash_href_rx = (child->crypto_hash_href_rx == NOT_SET\n        ? parent->crypto_hash_href_rx : child->crypto_hash_href_rx);\n    merged->crypto_hash_faction_rx = (child->crypto_hash_faction_rx == NOT_SET\n        ? parent->crypto_hash_faction_rx : child->crypto_hash_faction_rx);\n    merged->crypto_hash_location_rx = (child->crypto_hash_location_rx == NOT_SET\n        ? parent->crypto_hash_location_rx : child->crypto_hash_location_rx);\n    merged->crypto_hash_iframesrc_rx = (child->crypto_hash_iframesrc_rx == NOT_SET\n        ? parent->crypto_hash_iframesrc_rx : child->crypto_hash_iframesrc_rx);\n    merged->crypto_hash_framesrc_rx = (child->crypto_hash_framesrc_rx == NOT_SET\n        ? parent->crypto_hash_framesrc_rx : child->crypto_hash_framesrc_rx);\n    merged->crypto_hash_href_pm = (child->crypto_hash_href_pm == NOT_SET\n        ? parent->crypto_hash_href_pm : child->crypto_hash_href_pm);\n    merged->crypto_hash_faction_pm = (child->crypto_hash_faction_pm == NOT_SET\n        ? parent->crypto_hash_faction_pm : child->crypto_hash_faction_pm);\n    merged->crypto_hash_location_pm = (child->crypto_hash_location_pm == NOT_SET\n        ? parent->crypto_hash_location_pm : child->crypto_hash_location_pm);\n    merged->crypto_hash_iframesrc_pm = (child->crypto_hash_iframesrc_pm == NOT_SET\n        ? parent->crypto_hash_iframesrc_pm : child->crypto_hash_iframesrc_pm);\n    merged->crypto_hash_framesrc_pm = (child->crypto_hash_framesrc_pm == NOT_SET\n        ? parent->crypto_hash_framesrc_pm : child->crypto_hash_framesrc_pm);\n\n    return merged;\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-611"
        ],
        "project": "ModSecurity",
        "commit_id": "d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "hash": 70068643626020604153748098262130824771,
        "size": 316,
        "message": "Added SecXmlExternalEntity"
    },
    {
        "func": "void init_directory_config(directory_config *dcfg)\n{\n    if (dcfg == NULL) return;\n\n    if (dcfg->is_enabled == NOT_SET) dcfg->is_enabled = 0;\n\n    if (dcfg->reqbody_access == NOT_SET) dcfg->reqbody_access = 0;\n    if (dcfg->reqintercept_oe == NOT_SET) dcfg->reqintercept_oe = 0;\n    if (dcfg->reqbody_buffering == NOT_SET) dcfg->reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF;\n    if (dcfg->reqbody_inmemory_limit == NOT_SET)\n        dcfg->reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT;\n    if (dcfg->reqbody_limit == NOT_SET) dcfg->reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT;\n    if (dcfg->reqbody_no_files_limit == NOT_SET) dcfg->reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT;\n    if (dcfg->resbody_access == NOT_SET) dcfg->resbody_access = 0;\n    if (dcfg->of_limit == NOT_SET) dcfg->of_limit = RESPONSE_BODY_DEFAULT_LIMIT;\n    if (dcfg->if_limit_action == NOT_SET) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT;\n    if (dcfg->of_limit_action == NOT_SET) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT;\n\n    if (dcfg->of_mime_types == NOT_SET_P) {\n        dcfg->of_mime_types = apr_table_make(dcfg->mp, 3);\n        if (dcfg->of_mime_types_cleared != 1) {\n            apr_table_setn(dcfg->of_mime_types, \"text/plain\", \"1\");\n            apr_table_setn(dcfg->of_mime_types, \"text/html\", \"1\");\n        }\n    }\n\n    if (dcfg->debuglog_fd == NOT_SET_P) dcfg->debuglog_fd = NULL;\n    if (dcfg->debuglog_name == NOT_SET_P) dcfg->debuglog_name = NULL;\n    if (dcfg->debuglog_level == NOT_SET) dcfg->debuglog_level = 0;\n\n    if (dcfg->cookie_format == NOT_SET) dcfg->cookie_format = 0;\n    if (dcfg->argument_separator == NOT_SET) dcfg->argument_separator = '&';\n    if (dcfg->cookiev0_separator == NOT_SET_P) dcfg->cookiev0_separator = NULL;\n\n    if (dcfg->rule_inheritance == NOT_SET) dcfg->rule_inheritance = 1;\n\n    /* audit log variables */\n    if (dcfg->auditlog_flag == NOT_SET) dcfg->auditlog_flag = 0;\n    if (dcfg->auditlog_type == NOT_SET) dcfg->auditlog_type = AUDITLOG_SERIAL;\n    if (dcfg->max_rule_time == NOT_SET) dcfg->max_rule_time = 0;\n    if (dcfg->auditlog_dirperms == NOT_SET) dcfg->auditlog_dirperms = CREATEMODE_DIR;\n    if (dcfg->auditlog_fileperms == NOT_SET) dcfg->auditlog_fileperms = CREATEMODE;\n    if (dcfg->auditlog_fd == NOT_SET_P) dcfg->auditlog_fd = NULL;\n    if (dcfg->auditlog2_fd == NOT_SET_P) dcfg->auditlog2_fd = NULL;\n    if (dcfg->auditlog_name == NOT_SET_P) dcfg->auditlog_name = NULL;\n    if (dcfg->auditlog2_name == NOT_SET_P) dcfg->auditlog2_name = NULL;\n    if (dcfg->auditlog_storage_dir == NOT_SET_P) dcfg->auditlog_storage_dir = NULL;\n    if (dcfg->auditlog_parts == NOT_SET_P) dcfg->auditlog_parts = \"ABCFHZ\";\n    if (dcfg->auditlog_relevant_regex == NOT_SET_P) dcfg->auditlog_relevant_regex = NULL;\n\n    /* Upload */\n    if (dcfg->tmp_dir == NOT_SET_P) dcfg->tmp_dir = guess_tmp_dir(dcfg->mp);\n    if (dcfg->upload_dir == NOT_SET_P) dcfg->upload_dir = NULL;\n    if (dcfg->upload_keep_files == NOT_SET) dcfg->upload_keep_files = KEEP_FILES_OFF;\n    if (dcfg->upload_validates_files == NOT_SET) dcfg->upload_validates_files = 0;\n    if (dcfg->upload_filemode == NOT_SET) dcfg->upload_filemode = 0600;\n    if (dcfg->upload_file_limit == NOT_SET) dcfg->upload_file_limit = 100;\n\n    /* Misc */\n    if (dcfg->data_dir == NOT_SET_P) dcfg->data_dir = NULL;\n    if (dcfg->webappid == NOT_SET_P) dcfg->webappid = \"default\";\n    if (dcfg->sensor_id == NOT_SET_P) dcfg->sensor_id = \"default\";\n    if (dcfg->httpBlkey == NOT_SET_P) dcfg->httpBlkey = NULL;\n\n    /* Content injection. */\n    if (dcfg->content_injection_enabled == NOT_SET) dcfg->content_injection_enabled = 0;\n\n    /* Stream inspection */\n    if (dcfg->stream_inbody_inspection == NOT_SET) dcfg->stream_inbody_inspection = 0;\n    if (dcfg->stream_outbody_inspection == NOT_SET) dcfg->stream_outbody_inspection = 0;\n\n    /* Geo Lookup */\n    if (dcfg->geo == NOT_SET_P) dcfg->geo = NULL;\n\n    /* Gsb Lookup */\n    if (dcfg->gsb == NOT_SET_P) dcfg->gsb = NULL;\n\n    /* Unicode Map */\n    if (dcfg->u_map == NOT_SET_P) dcfg->u_map = NULL;\n\n    /* Cache */\n    if (dcfg->cache_trans == NOT_SET) dcfg->cache_trans = MODSEC_CACHE_DISABLED;\n    if (dcfg->cache_trans_incremental == NOT_SET) dcfg->cache_trans_incremental = 0;\n    if (dcfg->cache_trans_min == (apr_size_t)NOT_SET) dcfg->cache_trans_min = 32;\n    if (dcfg->cache_trans_max == (apr_size_t)NOT_SET) dcfg->cache_trans_max = 1024;\n    if (dcfg->cache_trans_maxitems == (apr_size_t)NOT_SET) dcfg->cache_trans_maxitems = 512;\n\n    if (dcfg->request_encoding == NOT_SET_P) dcfg->request_encoding = NULL;\n\n    if (dcfg->disable_backend_compression == NOT_SET) dcfg->disable_backend_compression = 0;\n\n    if (dcfg->col_timeout == NOT_SET) dcfg->col_timeout = 3600;\n\n    /* Hash */\n    if (dcfg->crypto_key == NOT_SET_P) dcfg->crypto_key = getkey(dcfg->mp);\n    if (dcfg->crypto_key_len == NOT_SET) dcfg->crypto_key_len = strlen(dcfg->crypto_key);\n    if (dcfg->crypto_key_add == NOT_SET) dcfg->crypto_key_add = HASH_KEYONLY;\n    if (dcfg->crypto_param_name == NOT_SET_P) dcfg->crypto_param_name = \"crypt\";\n    if (dcfg->hash_is_enabled == NOT_SET) dcfg->hash_is_enabled = HASH_DISABLED;\n    if (dcfg->hash_enforcement == NOT_SET) dcfg->hash_enforcement = HASH_DISABLED;\n    if (dcfg->crypto_hash_href_rx == NOT_SET) dcfg->crypto_hash_href_rx = 0;\n    if (dcfg->crypto_hash_faction_rx == NOT_SET) dcfg->crypto_hash_faction_rx = 0;\n    if (dcfg->crypto_hash_location_rx == NOT_SET) dcfg->crypto_hash_location_rx = 0;\n    if (dcfg->crypto_hash_iframesrc_rx == NOT_SET) dcfg->crypto_hash_iframesrc_rx = 0;\n    if (dcfg->crypto_hash_framesrc_rx == NOT_SET) dcfg->crypto_hash_framesrc_rx = 0;\n    if (dcfg->crypto_hash_href_pm == NOT_SET) dcfg->crypto_hash_href_pm = 0;\n    if (dcfg->crypto_hash_faction_pm == NOT_SET) dcfg->crypto_hash_faction_pm = 0;\n    if (dcfg->crypto_hash_location_pm == NOT_SET) dcfg->crypto_hash_location_pm = 0;\n    if (dcfg->crypto_hash_iframesrc_pm == NOT_SET) dcfg->crypto_hash_iframesrc_pm = 0;\n    if (dcfg->crypto_hash_framesrc_pm == NOT_SET) dcfg->crypto_hash_framesrc_pm = 0;\n\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-611"
        ],
        "project": "ModSecurity",
        "commit_id": "d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "hash": 333787517006929461378650286001236668671,
        "size": 112,
        "message": "Added SecXmlExternalEntity"
    },
    {
        "func": "static PHP_RINIT_FUNCTION(libxml)\n{\n\tif (_php_libxml_per_request_initialization) {\n\t\t/* report errors via handler rather than stderr */\n\t\txmlSetGenericErrorFunc(NULL, php_libxml_error_handler);\n\t\txmlParserInputBufferCreateFilenameDefault(php_libxml_input_buffer_create_filename);\n\t\txmlOutputBufferCreateFilenameDefault(php_libxml_output_buffer_create_filename);\n\t}\n\treturn SUCCESS;\n}",
        "target": 1,
        "cwe": [
            "CWE-611"
        ],
        "project": "php-src",
        "commit_id": "de31324c221c1791b26350ba106cc26bad23ace9",
        "hash": 90670280804679933896311223232339813860,
        "size": 10,
        "message": "Fix bug #64938: libxml_disable_entity_loader setting is shared between threads\n\nThe availability of entity loading is stored in a module global which\npreviously was only initialized in the GINIT constructor. This had the\neffect that disabling the entity loader in one request caused\nsubsequent requests hitting the same Apache child process to  also have\nthe loader disabled.\n\nWith this change the loader is explicitely enabled in the request init\nphase."
    },
    {
        "func": "entityValueInitProcessor(XML_Parser parser,\n                         const char *s,\n                         const char *end,\n                         const char **nextPtr)\n{\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  eventPtr = start;\n\n  for (;;) {\n    tok = XmlPrologTok(encoding, start, end, &next);\n    eventEndPtr = next;\n    if (tok <= 0) {\n      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE:   /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, encoding, s, end);\n    }\n    else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        *nextPtr = next;\n        return XML_ERROR_NONE;\n      case XML_FINISHED:\n        return XML_ERROR_ABORTED;\n      default:\n        *nextPtr = next;\n      }\n      /* stop scanning for text declaration - we found one */\n      processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    /* If we are at the end of the buffer, this would cause XmlPrologTok to\n       return XML_TOK_NONE on the next call, which would then cause the\n       function to exit with *nextPtr set to s - that is what we want for other\n       tokens, but not for the BOM - we would rather like to skip it;\n       then, when this routine is entered the next time, XmlPrologTok will\n       return XML_TOK_INVALID, since the BOM is still in the buffer\n    */\n    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    eventPtr = start;\n  }\n}",
        "target": 1,
        "cwe": [
            "CWE-611"
        ],
        "project": "libexpat",
        "commit_id": "c4bf96bb51dd2a1b0e185374362ee136fe2c9d7f",
        "hash": 337998318068132835707143746781218093260,
        "size": 65,
        "message": "xmlparse.c: Fix external entity infinite loop bug (CVE-2017-9233)"
    },
    {
        "func": "setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n\n    }\n  }\n  return 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-611"
        ],
        "project": "libexpat",
        "commit_id": "11f8838bf99ea0a6f0b76f9760c43704d00c4ff6",
        "hash": 251842892383111659921860764452967239533,
        "size": 28,
        "message": "xmlparse.c: Fix extraction of namespace prefix from XML name (#186)"
    },
    {
        "func": "internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    /* put openEntity back in list of free instances */\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}",
        "target": 1,
        "cwe": [
            "CWE-611",
            "CWE-776",
            "CWE-415",
            "CWE-125"
        ],
        "project": "libexpat",
        "commit_id": "c20b758c332d9a13afbbb276d30db1d183a85d43",
        "hash": 243891075354895341809456533037163648861,
        "size": 59,
        "message": "xmlparse.c: Deny internal entities closing the doctype"
    },
    {
        "func": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "target": 1,
        "cwe": [
            "CWE-611",
            "CWE-776",
            "CWE-415",
            "CWE-125"
        ],
        "project": "libexpat",
        "commit_id": "c20b758c332d9a13afbbb276d30db1d183a85d43",
        "hash": 249682305267164788442820457735201551788,
        "size": 7,
        "message": "xmlparse.c: Deny internal entities closing the doctype"
    },
    {
        "func": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}",
        "target": 1,
        "cwe": [
            "CWE-611",
            "CWE-776",
            "CWE-415",
            "CWE-125"
        ],
        "project": "libexpat",
        "commit_id": "c20b758c332d9a13afbbb276d30db1d183a85d43",
        "hash": 235938583783437426817682593052372739359,
        "size": 54,
        "message": "xmlparse.c: Deny internal entities closing the doctype"
    },
    {
        "func": "externalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "target": 1,
        "cwe": [
            "CWE-611",
            "CWE-776",
            "CWE-415",
            "CWE-125"
        ],
        "project": "libexpat",
        "commit_id": "c20b758c332d9a13afbbb276d30db1d183a85d43",
        "hash": 43859884671313046444641427743463565778,
        "size": 36,
        "message": "xmlparse.c: Deny internal entities closing the doctype"
    },
    {
        "func": "doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,\n         int tok, const char *next, const char **nextPtr, XML_Bool haveMore) {\n#ifdef XML_DTD\n  static const XML_Char externalSubsetName[] = {ASCII_HASH, '\\0'};\n#endif /* XML_DTD */\n  static const XML_Char atypeCDATA[]\n      = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\\0'};\n  static const XML_Char atypeID[] = {ASCII_I, ASCII_D, '\\0'};\n  static const XML_Char atypeIDREF[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\\0'};\n  static const XML_Char atypeIDREFS[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\\0'};\n  static const XML_Char atypeENTITY[]\n      = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\\0'};\n  static const XML_Char atypeENTITIES[]\n      = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T,\n         ASCII_I, ASCII_E, ASCII_S, '\\0'};\n  static const XML_Char atypeNMTOKEN[]\n      = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\\0'};\n  static const XML_Char atypeNMTOKENS[]\n      = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K,\n         ASCII_E, ASCII_N, ASCII_S, '\\0'};\n  static const XML_Char notationPrefix[]\n      = {ASCII_N, ASCII_O, ASCII_T, ASCII_A,      ASCII_T,\n         ASCII_I, ASCII_O, ASCII_N, ASCII_LPAREN, '\\0'};\n  static const XML_Char enumValueSep[] = {ASCII_PIPE, '\\0'};\n  static const XML_Char enumValueStart[] = {ASCII_LPAREN, '\\0'};\n\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  enum XML_Content_Quant quant;\n\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n\n  for (;;) {\n    int role;\n    XML_Bool handleDefault = XML_TRUE;\n    *eventPP = s;\n    *eventEndPP = next;\n    if (tok <= 0) {\n      if (haveMore && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        *eventPP = next;\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case -XML_TOK_PROLOG_S:\n        tok = -tok;\n        break;\n      case XML_TOK_NONE:\n#ifdef XML_DTD\n        /* for internal PE NOT referenced between declarations */\n        if (enc != parser->m_encoding\n            && ! parser->m_openInternalEntities->betweenDecl) {\n          *nextPtr = s;\n          return XML_ERROR_NONE;\n        }\n        /* WFC: PE Between Declarations - must check that PE contains\n           complete markup, not only for external PEs, but also for\n           internal PEs if the reference occurs between declarations.\n        */\n        if (parser->m_isParamEntity || enc != parser->m_encoding) {\n          if (XmlTokenRole(&parser->m_prologState, XML_TOK_NONE, end, end, enc)\n              == XML_ROLE_ERROR)\n            return XML_ERROR_INCOMPLETE_PE;\n          *nextPtr = s;\n          return XML_ERROR_NONE;\n        }\n#endif /* XML_DTD */\n        return XML_ERROR_NO_ELEMENTS;\n      default:\n        tok = -tok;\n        next = end;\n        break;\n      }\n    }\n    role = XmlTokenRole(&parser->m_prologState, tok, s, next, enc);\n    switch (role) {\n    case XML_ROLE_XML_DECL: {\n      enum XML_Error result = processXmlDecl(parser, 0, s, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      enc = parser->m_encoding;\n      handleDefault = XML_FALSE;\n    } break;\n    case XML_ROLE_DOCTYPE_NAME:\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_doctypeName\n            = poolStoreString(&parser->m_tempPool, enc, s, next);\n        if (! parser->m_doctypeName)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        parser->m_doctypePubid = NULL;\n        handleDefault = XML_FALSE;\n      }\n      parser->m_doctypeSysid = NULL; /* always initialize to NULL */\n      break;\n    case XML_ROLE_DOCTYPE_INTERNAL_SUBSET:\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 1);\n        parser->m_doctypeName = NULL;\n        poolClear(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n#ifdef XML_DTD\n    case XML_ROLE_TEXT_DECL: {\n      enum XML_Error result = processXmlDecl(parser, 1, s, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      enc = parser->m_encoding;\n      handleDefault = XML_FALSE;\n    } break;\n#endif /* XML_DTD */\n    case XML_ROLE_DOCTYPE_PUBLIC_ID:\n#ifdef XML_DTD\n      parser->m_useForeignDTD = XML_FALSE;\n      parser->m_declEntity = (ENTITY *)lookup(\n          parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));\n      if (! parser->m_declEntity)\n        return XML_ERROR_NO_MEMORY;\n#endif /* XML_DTD */\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (parser->m_startDoctypeDeclHandler) {\n        XML_Char *pubId;\n        if (! XmlIsPublicId(enc, s, next, eventPP))\n          return XML_ERROR_PUBLICID;\n        pubId = poolStoreString(&parser->m_tempPool, enc,\n                                s + enc->minBytesPerChar,\n                                next - enc->minBytesPerChar);\n        if (! pubId)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(pubId);\n        poolFinish(&parser->m_tempPool);\n        parser->m_doctypePubid = pubId;\n        handleDefault = XML_FALSE;\n        goto alreadyChecked;\n      }\n      /* fall through */\n    case XML_ROLE_ENTITY_PUBLIC_ID:\n      if (! XmlIsPublicId(enc, s, next, eventPP))\n        return XML_ERROR_PUBLICID;\n    alreadyChecked:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        XML_Char *tem\n            = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                              next - enc->minBytesPerChar);\n        if (! tem)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(tem);\n        parser->m_declEntity->publicId = tem;\n        poolFinish(&dtd->pool);\n        /* Don't suppress the default handler if we fell through from\n         * the XML_ROLE_DOCTYPE_PUBLIC_ID case.\n         */\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_CLOSE:\n      if (parser->m_doctypeName) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 0);\n        poolClear(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      /* parser->m_doctypeSysid will be non-NULL in the case of a previous\n         XML_ROLE_DOCTYPE_SYSTEM_ID, even if parser->m_startDoctypeDeclHandler\n         was not set, indicating an external subset\n      */\n#ifdef XML_DTD\n      if (parser->m_doctypeSysid || parser->m_useForeignDTD) {\n        XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;\n        dtd->hasParamEntityRefs = XML_TRUE;\n        if (parser->m_paramEntityParsing\n            && parser->m_externalEntityRefHandler) {\n          ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                            externalSubsetName, sizeof(ENTITY));\n          if (! entity) {\n            /* The external subset name \"#\" will have already been\n             * inserted into the hash table at the start of the\n             * external entity parsing, so no allocation will happen\n             * and lookup() cannot fail.\n             */\n            return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n          }\n          if (parser->m_useForeignDTD)\n            entity->base = parser->m_curBase;\n          dtd->paramEntityRead = XML_FALSE;\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId))\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          if (dtd->paramEntityRead) {\n            if (! dtd->standalone && parser->m_notStandaloneHandler\n                && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n              return XML_ERROR_NOT_STANDALONE;\n          }\n          /* if we didn't read the foreign DTD then this means that there\n             is no external subset and we must reset dtd->hasParamEntityRefs\n          */\n          else if (! parser->m_doctypeSysid)\n            dtd->hasParamEntityRefs = hadParamEntityRefs;\n          /* end of DTD - no need to update dtd->keepProcessing */\n        }\n        parser->m_useForeignDTD = XML_FALSE;\n      }\n#endif /* XML_DTD */\n      if (parser->m_endDoctypeDeclHandler) {\n        parser->m_endDoctypeDeclHandler(parser->m_handlerArg);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_INSTANCE_START:\n#ifdef XML_DTD\n      /* if there is no DOCTYPE declaration then now is the\n         last chance to read the foreign DTD\n      */\n      if (parser->m_useForeignDTD) {\n        XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;\n        dtd->hasParamEntityRefs = XML_TRUE;\n        if (parser->m_paramEntityParsing\n            && parser->m_externalEntityRefHandler) {\n          ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                            externalSubsetName, sizeof(ENTITY));\n          if (! entity)\n            return XML_ERROR_NO_MEMORY;\n          entity->base = parser->m_curBase;\n          dtd->paramEntityRead = XML_FALSE;\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId))\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          if (dtd->paramEntityRead) {\n            if (! dtd->standalone && parser->m_notStandaloneHandler\n                && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n              return XML_ERROR_NOT_STANDALONE;\n          }\n          /* if we didn't read the foreign DTD then this means that there\n             is no external subset and we must reset dtd->hasParamEntityRefs\n          */\n          else\n            dtd->hasParamEntityRefs = hadParamEntityRefs;\n          /* end of DTD - no need to update dtd->keepProcessing */\n        }\n      }\n#endif /* XML_DTD */\n      parser->m_processor = contentProcessor;\n      return contentProcessor(parser, s, end, nextPtr);\n    case XML_ROLE_ATTLIST_ELEMENT_NAME:\n      parser->m_declElementType = getElementType(parser, enc, s, next);\n      if (! parser->m_declElementType)\n        return XML_ERROR_NO_MEMORY;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_NAME:\n      parser->m_declAttributeId = getAttributeId(parser, enc, s, next);\n      if (! parser->m_declAttributeId)\n        return XML_ERROR_NO_MEMORY;\n      parser->m_declAttributeIsCdata = XML_FALSE;\n      parser->m_declAttributeType = NULL;\n      parser->m_declAttributeIsId = XML_FALSE;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_CDATA:\n      parser->m_declAttributeIsCdata = XML_TRUE;\n      parser->m_declAttributeType = atypeCDATA;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ID:\n      parser->m_declAttributeIsId = XML_TRUE;\n      parser->m_declAttributeType = atypeID;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_IDREF:\n      parser->m_declAttributeType = atypeIDREF;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_IDREFS:\n      parser->m_declAttributeType = atypeIDREFS;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ENTITY:\n      parser->m_declAttributeType = atypeENTITY;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ENTITIES:\n      parser->m_declAttributeType = atypeENTITIES;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN:\n      parser->m_declAttributeType = atypeNMTOKEN;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS:\n      parser->m_declAttributeType = atypeNMTOKENS;\n    checkAttListDeclHandler:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ATTRIBUTE_ENUM_VALUE:\n    case XML_ROLE_ATTRIBUTE_NOTATION_VALUE:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler) {\n        const XML_Char *prefix;\n        if (parser->m_declAttributeType) {\n          prefix = enumValueSep;\n        } else {\n          prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE ? notationPrefix\n                                                              : enumValueStart);\n        }\n        if (! poolAppendString(&parser->m_tempPool, prefix))\n          return XML_ERROR_NO_MEMORY;\n        if (! poolAppend(&parser->m_tempPool, enc, s, next))\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declAttributeType = parser->m_tempPool.start;\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:\n    case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:\n      if (dtd->keepProcessing) {\n        if (! defineAttribute(parser->m_declElementType,\n                              parser->m_declAttributeId,\n                              parser->m_declAttributeIsCdata,\n                              parser->m_declAttributeIsId, 0, parser))\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {\n          if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)\n              || (*parser->m_declAttributeType == XML_T(ASCII_N)\n                  && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {\n            /* Enumerated or Notation type */\n            if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))\n                || ! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n              return XML_ERROR_NO_MEMORY;\n            parser->m_declAttributeType = parser->m_tempPool.start;\n            poolFinish(&parser->m_tempPool);\n          }\n          *eventEndPP = s;\n          parser->m_attlistDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name,\n              parser->m_declAttributeId->name, parser->m_declAttributeType, 0,\n              role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);\n          poolClear(&parser->m_tempPool);\n          handleDefault = XML_FALSE;\n        }\n      }\n      break;\n    case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:\n    case XML_ROLE_FIXED_ATTRIBUTE_VALUE:\n      if (dtd->keepProcessing) {\n        const XML_Char *attVal;\n        enum XML_Error result = storeAttributeValue(\n            parser, enc, parser->m_declAttributeIsCdata,\n            s + enc->minBytesPerChar, next - enc->minBytesPerChar, &dtd->pool);\n        if (result)\n          return result;\n        attVal = poolStart(&dtd->pool);\n        poolFinish(&dtd->pool);\n        /* ID attributes aren't allowed to have a default */\n        if (! defineAttribute(\n                parser->m_declElementType, parser->m_declAttributeId,\n                parser->m_declAttributeIsCdata, XML_FALSE, attVal, parser))\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {\n          if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)\n              || (*parser->m_declAttributeType == XML_T(ASCII_N)\n                  && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {\n            /* Enumerated or Notation type */\n            if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))\n                || ! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n              return XML_ERROR_NO_MEMORY;\n            parser->m_declAttributeType = parser->m_tempPool.start;\n            poolFinish(&parser->m_tempPool);\n          }\n          *eventEndPP = s;\n          parser->m_attlistDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name,\n              parser->m_declAttributeId->name, parser->m_declAttributeType,\n              attVal, role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);\n          poolClear(&parser->m_tempPool);\n          handleDefault = XML_FALSE;\n        }\n      }\n      break;\n    case XML_ROLE_ENTITY_VALUE:\n      if (dtd->keepProcessing) {\n        enum XML_Error result = storeEntityValue(\n            parser, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n        if (parser->m_declEntity) {\n          parser->m_declEntity->textPtr = poolStart(&dtd->entityValuePool);\n          parser->m_declEntity->textLen\n              = (int)(poolLength(&dtd->entityValuePool));\n          poolFinish(&dtd->entityValuePool);\n          if (parser->m_entityDeclHandler) {\n            *eventEndPP = s;\n            parser->m_entityDeclHandler(\n                parser->m_handlerArg, parser->m_declEntity->name,\n                parser->m_declEntity->is_param, parser->m_declEntity->textPtr,\n                parser->m_declEntity->textLen, parser->m_curBase, 0, 0, 0);\n            handleDefault = XML_FALSE;\n          }\n        } else\n          poolDiscard(&dtd->entityValuePool);\n        if (result != XML_ERROR_NONE)\n          return result;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_SYSTEM_ID:\n#ifdef XML_DTD\n      parser->m_useForeignDTD = XML_FALSE;\n#endif /* XML_DTD */\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_doctypeSysid = poolStoreString(&parser->m_tempPool, enc,\n                                                 s + enc->minBytesPerChar,\n                                                 next - enc->minBytesPerChar);\n        if (parser->m_doctypeSysid == NULL)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n#ifdef XML_DTD\n      else\n        /* use externalSubsetName to make parser->m_doctypeSysid non-NULL\n           for the case where no parser->m_startDoctypeDeclHandler is set */\n        parser->m_doctypeSysid = externalSubsetName;\n#endif /* XML_DTD */\n      if (! dtd->standalone\n#ifdef XML_DTD\n          && ! parser->m_paramEntityParsing\n#endif /* XML_DTD */\n          && parser->m_notStandaloneHandler\n          && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n        return XML_ERROR_NOT_STANDALONE;\n#ifndef XML_DTD\n      break;\n#else  /* XML_DTD */\n      if (! parser->m_declEntity) {\n        parser->m_declEntity = (ENTITY *)lookup(\n            parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity->publicId = NULL;\n      }\n#endif /* XML_DTD */\n      /* fall through */\n    case XML_ROLE_ENTITY_SYSTEM_ID:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        parser->m_declEntity->systemId\n            = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                              next - enc->minBytesPerChar);\n        if (! parser->m_declEntity->systemId)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity->base = parser->m_curBase;\n        poolFinish(&dtd->pool);\n        /* Don't suppress the default handler if we fell through from\n         * the XML_ROLE_DOCTYPE_SYSTEM_ID case.\n         */\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_SYSTEM_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_ENTITY_COMPLETE:\n      if (dtd->keepProcessing && parser->m_declEntity\n          && parser->m_entityDeclHandler) {\n        *eventEndPP = s;\n        parser->m_entityDeclHandler(\n            parser->m_handlerArg, parser->m_declEntity->name,\n            parser->m_declEntity->is_param, 0, 0, parser->m_declEntity->base,\n            parser->m_declEntity->systemId, parser->m_declEntity->publicId, 0);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_ENTITY_NOTATION_NAME:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        parser->m_declEntity->notation\n            = poolStoreString(&dtd->pool, enc, s, next);\n        if (! parser->m_declEntity->notation)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&dtd->pool);\n        if (parser->m_unparsedEntityDeclHandler) {\n          *eventEndPP = s;\n          parser->m_unparsedEntityDeclHandler(\n              parser->m_handlerArg, parser->m_declEntity->name,\n              parser->m_declEntity->base, parser->m_declEntity->systemId,\n              parser->m_declEntity->publicId, parser->m_declEntity->notation);\n          handleDefault = XML_FALSE;\n        } else if (parser->m_entityDeclHandler) {\n          *eventEndPP = s;\n          parser->m_entityDeclHandler(\n              parser->m_handlerArg, parser->m_declEntity->name, 0, 0, 0,\n              parser->m_declEntity->base, parser->m_declEntity->systemId,\n              parser->m_declEntity->publicId, parser->m_declEntity->notation);\n          handleDefault = XML_FALSE;\n        }\n      }\n      break;\n    case XML_ROLE_GENERAL_ENTITY_NAME: {\n      if (XmlPredefinedEntityName(enc, s, next)) {\n        parser->m_declEntity = NULL;\n        break;\n      }\n      if (dtd->keepProcessing) {\n        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                                                name, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_declEntity->name != name) {\n          poolDiscard(&dtd->pool);\n          parser->m_declEntity = NULL;\n        } else {\n          poolFinish(&dtd->pool);\n          parser->m_declEntity->publicId = NULL;\n          parser->m_declEntity->is_param = XML_FALSE;\n          /* if we have a parent parser or are reading an internal parameter\n             entity, then the entity declaration is not considered \"internal\"\n          */\n          parser->m_declEntity->is_internal\n              = ! (parser->m_parentParser || parser->m_openInternalEntities);\n          if (parser->m_entityDeclHandler)\n            handleDefault = XML_FALSE;\n        }\n      } else {\n        poolDiscard(&dtd->pool);\n        parser->m_declEntity = NULL;\n      }\n    } break;\n    case XML_ROLE_PARAM_ENTITY_NAME:\n#ifdef XML_DTD\n      if (dtd->keepProcessing) {\n        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                                name, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_declEntity->name != name) {\n          poolDiscard(&dtd->pool);\n          parser->m_declEntity = NULL;\n        } else {\n          poolFinish(&dtd->pool);\n          parser->m_declEntity->publicId = NULL;\n          parser->m_declEntity->is_param = XML_TRUE;\n          /* if we have a parent parser or are reading an internal parameter\n             entity, then the entity declaration is not considered \"internal\"\n          */\n          parser->m_declEntity->is_internal\n              = ! (parser->m_parentParser || parser->m_openInternalEntities);\n          if (parser->m_entityDeclHandler)\n            handleDefault = XML_FALSE;\n        }\n      } else {\n        poolDiscard(&dtd->pool);\n        parser->m_declEntity = NULL;\n      }\n#else  /* not XML_DTD */\n      parser->m_declEntity = NULL;\n#endif /* XML_DTD */\n      break;\n    case XML_ROLE_NOTATION_NAME:\n      parser->m_declNotationPublicId = NULL;\n      parser->m_declNotationName = NULL;\n      if (parser->m_notationDeclHandler) {\n        parser->m_declNotationName\n            = poolStoreString(&parser->m_tempPool, enc, s, next);\n        if (! parser->m_declNotationName)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_NOTATION_PUBLIC_ID:\n      if (! XmlIsPublicId(enc, s, next, eventPP))\n        return XML_ERROR_PUBLICID;\n      if (parser\n              ->m_declNotationName) { /* means m_notationDeclHandler != NULL */\n        XML_Char *tem = poolStoreString(&parser->m_tempPool, enc,\n                                        s + enc->minBytesPerChar,\n                                        next - enc->minBytesPerChar);\n        if (! tem)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(tem);\n        parser->m_declNotationPublicId = tem;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_NOTATION_SYSTEM_ID:\n      if (parser->m_declNotationName && parser->m_notationDeclHandler) {\n        const XML_Char *systemId = poolStoreString(&parser->m_tempPool, enc,\n                                                   s + enc->minBytesPerChar,\n                                                   next - enc->minBytesPerChar);\n        if (! systemId)\n          return XML_ERROR_NO_MEMORY;\n        *eventEndPP = s;\n        parser->m_notationDeclHandler(\n            parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,\n            systemId, parser->m_declNotationPublicId);\n        handleDefault = XML_FALSE;\n      }\n      poolClear(&parser->m_tempPool);\n      break;\n    case XML_ROLE_NOTATION_NO_SYSTEM_ID:\n      if (parser->m_declNotationPublicId && parser->m_notationDeclHandler) {\n        *eventEndPP = s;\n        parser->m_notationDeclHandler(\n            parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,\n            0, parser->m_declNotationPublicId);\n        handleDefault = XML_FALSE;\n      }\n      poolClear(&parser->m_tempPool);\n      break;\n    case XML_ROLE_ERROR:\n      switch (tok) {\n      case XML_TOK_PARAM_ENTITY_REF:\n        /* PE references in internal subset are\n           not allowed within declarations. */\n        return XML_ERROR_PARAM_ENTITY_REF;\n      case XML_TOK_XML_DECL:\n        return XML_ERROR_MISPLACED_XML_PI;\n      default:\n        return XML_ERROR_SYNTAX;\n      }\n#ifdef XML_DTD\n    case XML_ROLE_IGNORE_SECT: {\n      enum XML_Error result;\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      handleDefault = XML_FALSE;\n      result = doIgnoreSection(parser, enc, &next, end, nextPtr, haveMore);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = ignoreSectionProcessor;\n        return result;\n      }\n    } break;\n#endif /* XML_DTD */\n    case XML_ROLE_GROUP_OPEN:\n      if (parser->m_prologState.level >= parser->m_groupSize) {\n        if (parser->m_groupSize) {\n          {\n            char *const new_connector = (char *)REALLOC(\n                parser, parser->m_groupConnector, parser->m_groupSize *= 2);\n            if (new_connector == NULL) {\n              parser->m_groupSize /= 2;\n              return XML_ERROR_NO_MEMORY;\n            }\n            parser->m_groupConnector = new_connector;\n          }\n\n          if (dtd->scaffIndex) {\n            int *const new_scaff_index = (int *)REALLOC(\n                parser, dtd->scaffIndex, parser->m_groupSize * sizeof(int));\n            if (new_scaff_index == NULL)\n              return XML_ERROR_NO_MEMORY;\n            dtd->scaffIndex = new_scaff_index;\n          }\n        } else {\n          parser->m_groupConnector\n              = (char *)MALLOC(parser, parser->m_groupSize = 32);\n          if (! parser->m_groupConnector) {\n            parser->m_groupSize = 0;\n            return XML_ERROR_NO_MEMORY;\n          }\n        }\n      }\n      parser->m_groupConnector[parser->m_prologState.level] = 0;\n      if (dtd->in_eldecl) {\n        int myindex = nextScaffoldPart(parser);\n        if (myindex < 0)\n          return XML_ERROR_NO_MEMORY;\n        assert(dtd->scaffIndex != NULL);\n        dtd->scaffIndex[dtd->scaffLevel] = myindex;\n        dtd->scaffLevel++;\n        dtd->scaffold[myindex].type = XML_CTYPE_SEQ;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_GROUP_SEQUENCE:\n      if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_PIPE)\n        return XML_ERROR_SYNTAX;\n      parser->m_groupConnector[parser->m_prologState.level] = ASCII_COMMA;\n      if (dtd->in_eldecl && parser->m_elementDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_GROUP_CHOICE:\n      if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_COMMA)\n        return XML_ERROR_SYNTAX;\n      if (dtd->in_eldecl\n          && ! parser->m_groupConnector[parser->m_prologState.level]\n          && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n              != XML_CTYPE_MIXED)) {\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n            = XML_CTYPE_CHOICE;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      parser->m_groupConnector[parser->m_prologState.level] = ASCII_PIPE;\n      break;\n    case XML_ROLE_PARAM_ENTITY_REF:\n#ifdef XML_DTD\n    case XML_ROLE_INNER_PARAM_ENTITY_REF:\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (! parser->m_paramEntityParsing)\n        dtd->keepProcessing = dtd->standalone;\n      else {\n        const XML_Char *name;\n        ENTITY *entity;\n        name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);\n        poolDiscard(&dtd->pool);\n        /* first, determine if a check for an existing declaration is needed;\n           if yes, check that the entity exists, and that it is internal,\n           otherwise call the skipped entity handler\n        */\n        if (parser->m_prologState.documentEntity\n            && (dtd->standalone ? ! parser->m_openInternalEntities\n                                : ! dtd->hasParamEntityRefs)) {\n          if (! entity)\n            return XML_ERROR_UNDEFINED_ENTITY;\n          else if (! entity->is_internal) {\n            /* It's hard to exhaustively search the code to be sure,\n             * but there doesn't seem to be a way of executing the\n             * following line.  There are two cases:\n             *\n             * If 'standalone' is false, the DTD must have no\n             * parameter entities or we wouldn't have passed the outer\n             * 'if' statement.  That measn the only entity in the hash\n             * table is the external subset name \"#\" which cannot be\n             * given as a parameter entity name in XML syntax, so the\n             * lookup must have returned NULL and we don't even reach\n             * the test for an internal entity.\n             *\n             * If 'standalone' is true, it does not seem to be\n             * possible to create entities taking this code path that\n             * are not internal entities, so fail the test above.\n             *\n             * Because this analysis is very uncertain, the code is\n             * being left in place and merely removed from the\n             * coverage test statistics.\n             */\n            return XML_ERROR_ENTITY_DECLARED_IN_PE; /* LCOV_EXCL_LINE */\n          }\n        } else if (! entity) {\n          dtd->keepProcessing = dtd->standalone;\n          /* cannot report skipped entities in declarations */\n          if ((role == XML_ROLE_PARAM_ENTITY_REF)\n              && parser->m_skippedEntityHandler) {\n            parser->m_skippedEntityHandler(parser->m_handlerArg, name, 1);\n            handleDefault = XML_FALSE;\n          }\n          break;\n        }\n        if (entity->open)\n          return XML_ERROR_RECURSIVE_ENTITY_REF;\n        if (entity->textPtr) {\n          enum XML_Error result;\n          XML_Bool betweenDecl\n              = (role == XML_ROLE_PARAM_ENTITY_REF ? XML_TRUE : XML_FALSE);\n          result = processInternalEntity(parser, entity, betweenDecl);\n          if (result != XML_ERROR_NONE)\n            return result;\n          handleDefault = XML_FALSE;\n          break;\n        }\n        if (parser->m_externalEntityRefHandler) {\n          dtd->paramEntityRead = XML_FALSE;\n          entity->open = XML_TRUE;\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId)) {\n            entity->open = XML_FALSE;\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          }\n          entity->open = XML_FALSE;\n          handleDefault = XML_FALSE;\n          if (! dtd->paramEntityRead) {\n            dtd->keepProcessing = dtd->standalone;\n            break;\n          }\n        } else {\n          dtd->keepProcessing = dtd->standalone;\n          break;\n        }\n      }\n#endif /* XML_DTD */\n      if (! dtd->standalone && parser->m_notStandaloneHandler\n          && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n        return XML_ERROR_NOT_STANDALONE;\n      break;\n\n      /* Element declaration stuff */\n\n    case XML_ROLE_ELEMENT_NAME:\n      if (parser->m_elementDeclHandler) {\n        parser->m_declElementType = getElementType(parser, enc, s, next);\n        if (! parser->m_declElementType)\n          return XML_ERROR_NO_MEMORY;\n        dtd->scaffLevel = 0;\n        dtd->scaffCount = 0;\n        dtd->in_eldecl = XML_TRUE;\n        handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_ANY:\n    case XML_ROLE_CONTENT_EMPTY:\n      if (dtd->in_eldecl) {\n        if (parser->m_elementDeclHandler) {\n          XML_Content *content\n              = (XML_Content *)MALLOC(parser, sizeof(XML_Content));\n          if (! content)\n            return XML_ERROR_NO_MEMORY;\n          content->quant = XML_CQUANT_NONE;\n          content->name = NULL;\n          content->numchildren = 0;\n          content->children = NULL;\n          content->type = ((role == XML_ROLE_CONTENT_ANY) ? XML_CTYPE_ANY\n                                                          : XML_CTYPE_EMPTY);\n          *eventEndPP = s;\n          parser->m_elementDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name, content);\n          handleDefault = XML_FALSE;\n        }\n        dtd->in_eldecl = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_PCDATA:\n      if (dtd->in_eldecl) {\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n            = XML_CTYPE_MIXED;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_ELEMENT:\n      quant = XML_CQUANT_NONE;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_OPT:\n      quant = XML_CQUANT_OPT;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_REP:\n      quant = XML_CQUANT_REP;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_PLUS:\n      quant = XML_CQUANT_PLUS;\n    elementContent:\n      if (dtd->in_eldecl) {\n        ELEMENT_TYPE *el;\n        const XML_Char *name;\n        int nameLen;\n        const char *nxt\n            = (quant == XML_CQUANT_NONE ? next : next - enc->minBytesPerChar);\n        int myindex = nextScaffoldPart(parser);\n        if (myindex < 0)\n          return XML_ERROR_NO_MEMORY;\n        dtd->scaffold[myindex].type = XML_CTYPE_NAME;\n        dtd->scaffold[myindex].quant = quant;\n        el = getElementType(parser, enc, s, nxt);\n        if (! el)\n          return XML_ERROR_NO_MEMORY;\n        name = el->name;\n        dtd->scaffold[myindex].name = name;\n        nameLen = 0;\n        for (; name[nameLen++];)\n          ;\n        dtd->contentStringLen += nameLen;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_GROUP_CLOSE:\n      quant = XML_CQUANT_NONE;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_OPT:\n      quant = XML_CQUANT_OPT;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_REP:\n      quant = XML_CQUANT_REP;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_PLUS:\n      quant = XML_CQUANT_PLUS;\n    closeGroup:\n      if (dtd->in_eldecl) {\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n        dtd->scaffLevel--;\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;\n        if (dtd->scaffLevel == 0) {\n          if (! handleDefault) {\n            XML_Content *model = build_model(parser);\n            if (! model)\n              return XML_ERROR_NO_MEMORY;\n            *eventEndPP = s;\n            parser->m_elementDeclHandler(\n                parser->m_handlerArg, parser->m_declElementType->name, model);\n          }\n          dtd->in_eldecl = XML_FALSE;\n          dtd->contentStringLen = 0;\n        }\n      }\n      break;\n      /* End element declaration stuff */\n\n    case XML_ROLE_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_NONE:\n      switch (tok) {\n      case XML_TOK_BOM:\n        handleDefault = XML_FALSE;\n        break;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_NONE:\n      if (parser->m_startDoctypeDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ENTITY_NONE:\n      if (dtd->keepProcessing && parser->m_entityDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_NOTATION_NONE:\n      if (parser->m_notationDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ATTLIST_NONE:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ELEMENT_NONE:\n      if (parser->m_elementDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    } /* end of big switch */\n\n    if (handleDefault && parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:\n      s = next;\n      tok = XmlPrologTok(enc, s, end, &next);\n    }\n  }\n  /* not reached */\n}",
        "target": 1,
        "cwe": [
            "CWE-611",
            "CWE-776",
            "CWE-415",
            "CWE-125"
        ],
        "project": "libexpat",
        "commit_id": "c20b758c332d9a13afbbb276d30db1d183a85d43",
        "hash": 90613386023716257748373709475391861635,
        "size": 980,
        "message": "xmlparse.c: Deny internal entities closing the doctype"
    },
    {
        "func": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  /* In case someone passes us a node. ugh. */\n  doc = doc->doc;\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
        "target": 1,
        "cwe": [
            "CWE-611",
            "CWE-703"
        ],
        "project": "nokogiri",
        "commit_id": "9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "hash": 278629349903674139946898343273219451698,
        "size": 46,
        "message": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions\n\nI'm trying out a new pattern, which is that the parsed object carries\naround the ParseOptions it was created with, which should make some\ntesting a bit easier.\n\nI'm also not implementing the \"config block\" pattern in use for\nDocuments, because I think the UX is weird and I'm hoping to change\neverything to use kwargs in a 2.0 release, anyway."
    },
    {
        "func": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  /* In case someone passes us a node. ugh. */\n  doc = doc->doc;\n\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n\n  return Qnil;\n}",
        "target": 1,
        "cwe": [
            "CWE-611",
            "CWE-703"
        ],
        "project": "nokogiri",
        "commit_id": "9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "hash": 159700613265904492293723562994331217531,
        "size": 52,
        "message": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions\n\nI'm trying out a new pattern, which is that the parsed object carries\naround the ParseOptions it was created with, which should make some\ntesting a bit easier.\n\nI'm also not implementing the \"config block\" pattern in use for\nDocuments, because I think the UX is weird and I'm hoping to change\neverything to use kwargs in a 2.0 release, anyway."
    },
    {
        "func": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n   schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
        "target": 1,
        "cwe": [
            "CWE-611",
            "CWE-703"
        ],
        "project": "nokogiri",
        "commit_id": "9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "hash": 154902691343962345218199879200925178307,
        "size": 39,
        "message": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions\n\nI'm trying out a new pattern, which is that the parsed object carries\naround the ParseOptions it was created with, which should make some\ntesting a bit easier.\n\nI'm also not implementing the \"config block\" pattern in use for\nDocuments, because I think the UX is weird and I'm hoping to change\neverything to use kwargs in a 2.0 release, anyway."
    },
    {
        "func": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tchar *p;\n\n\tif (*(str) == '[' && str_len > 1) {\n\t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tp = memchr(str + 1, ']', str_len - 2);\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = atoi(p + 2);\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn host;\n}",
        "target": 1,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 237431913884466961963058935059398783855,
        "size": 38,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "daemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tsource[nread] = '\\0';\n\tplen -= nread;\n\n\t// XXX - make sure it's *not* a URL; we don't support opening\n\t// remote devices here.\n\n\t// Open the selected device\n\t// This is a fake open, since we do that only to get the needed parameters, then we close the device again\n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\t// Now, I can send a RPCAP open reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\t// We're done with the pcap_t.\n\tpcap_close(fp);\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-703",
            "CWE-918"
        ],
        "project": "libpcap",
        "commit_id": "33834cb2a4d035b52aa2a26742f832a112e90a0a",
        "hash": 236360285436192236902643224694774840536,
        "size": 84,
        "message": "In the open request, reject capture sources that are URLs.\n\nYou shouldn't be able to ask a server to open a remote device on some\n*other* server; just open it yourself.\n\nThis addresses Include Security issue F13: [libpcap] Remote Packet\nCapture Daemon Allows Opening Capture URLs."
    },
    {
        "func": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n\n}",
        "target": 1,
        "cwe": [
            "CWE-918"
        ],
        "project": "arangodb",
        "commit_id": "d9b7f019d2435f107b19a59190bf9cc27d5f34dd",
        "hash": 35156937576729943531477075055023183623,
        "size": 23,
        "message": "[APM-78] Disable installation from remote URL (#15292)"
    },
    {
        "func": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}",
        "target": 1,
        "cwe": [
            "CWE-918"
        ],
        "project": "arangodb",
        "commit_id": "d9b7f019d2435f107b19a59190bf9cc27d5f34dd",
        "hash": 88922380629990301386767515839292150134,
        "size": 8,
        "message": "[APM-78] Disable installation from remote URL (#15292)"
    },
    {
        "func": "void TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_CLUSTER_API_JWT_POLICY\"), JS_ClusterApiJwtPolicy, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"), JS_IsFoxxApiDisabled, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"), JS_IsFoxxStoreDisabled, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"), JS_RunInRestrictedContext, true);\n  \n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_CREATE_HOTBACKUP\"),\n                               JS_CreateHotbackup);\n\n  // debugging functions\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_CLEAR_FAILAT\"),\n                               JS_DebugClearFailAt);\n\n#ifdef ARANGODB_ENABLE_FAILURE_TESTS\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_TERMINATE\"), JS_DebugTerminate);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_SET_FAILAT\"),\n                               JS_DebugSetFailAt);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_REMOVE_FAILAT\"),\n                               JS_DebugRemoveFailAt);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_SHOULD_FAILAT\"),\n                               JS_DebugShouldFailAt);\n#endif\n\n  // poll interval for Foxx queues\n  TRI_GET_GLOBALS();\n  FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, \"FOXX_QUEUES_POLL_INTERVAL\"),\n          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC,\n          TRI_V8_ASCII_STRING(isolate, \"FOXX_STARTUP_WAIT_FOR_SELF_HEAL\"),\n          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n}",
        "target": 1,
        "cwe": [
            "CWE-918"
        ],
        "project": "arangodb",
        "commit_id": "d9b7f019d2435f107b19a59190bf9cc27d5f34dd",
        "hash": 322582954351856527055573097947734321767,
        "size": 57,
        "message": "[APM-78] Disable installation from remote URL (#15292)"
    },
    {
        "func": "void TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_CLUSTER_API_JWT_POLICY\"),\n      JS_ClusterApiJwtPolicy, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"),\n      JS_IsFoxxApiDisabled, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"),\n      JS_IsFoxxStoreDisabled, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"),\n      JS_RunInRestrictedContext, true);\n\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_CREATE_HOTBACKUP\"),\n      JS_CreateHotbackup);\n\n  // debugging functions\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_CLEAR_FAILAT\"),\n      JS_DebugClearFailAt);\n\n#ifdef ARANGODB_ENABLE_FAILURE_TESTS\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_TERMINATE\"),\n      JS_DebugTerminate);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_SET_FAILAT\"),\n      JS_DebugSetFailAt);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_REMOVE_FAILAT\"),\n      JS_DebugRemoveFailAt);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_SHOULD_FAILAT\"),\n      JS_DebugShouldFailAt);\n#endif\n\n  // poll interval for Foxx queues\n  TRI_GET_GLOBALS();\n  FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, \"FOXX_QUEUES_POLL_INTERVAL\"),\n          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC,\n          TRI_V8_ASCII_STRING(isolate, \"FOXX_STARTUP_WAIT_FOR_SELF_HEAL\"),\n          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()),\n          v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n}",
        "target": 1,
        "cwe": [
            "CWE-918"
        ],
        "project": "arangodb",
        "commit_id": "d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175",
        "hash": 72503858120705615389733716870391842460,
        "size": 58,
        "message": "[APM-78] Disable installation from remote URL (#15292) (#15343)\n\n* [APM-78] Disable installation from remote URL (#15292)\r\n\r\n* Update CHANGELOG\r\n\r\n* Fix clang-format\r\n\r\nCo-authored-by: Vadim <vadim@arangodb.com>"
    },
    {
        "func": "ServerSecurityFeature::ServerSecurityFeature(\n    application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}",
        "target": 1,
        "cwe": [
            "CWE-918"
        ],
        "project": "arangodb",
        "commit_id": "d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175",
        "hash": 177334571634870591275872108249829792660,
        "size": 9,
        "message": "[APM-78] Disable installation from remote URL (#15292) (#15343)\n\n* [APM-78] Disable installation from remote URL (#15292)\r\n\r\n* Update CHANGELOG\r\n\r\n* Fix clang-format\r\n\r\nCo-authored-by: Vadim <vadim@arangodb.com>"
    },
    {
        "func": "void ServerSecurityFeature::collectOptions(\n    std::shared_ptr<ProgramOptions> options) {\n  options\n      ->addOption(\n          \"--server.harden\",\n          \"lock down REST APIs that reveal version information or server \"\n          \"internals for non-admin users\",\n          new BooleanParameter(&_hardenedRestApi))\n      .setIntroducedIn(30500);\n\n  options\n      ->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                  new BooleanParameter(&_enableFoxxApi),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                  new BooleanParameter(&_enableFoxxStore),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n}",
        "target": 1,
        "cwe": [
            "CWE-918"
        ],
        "project": "arangodb",
        "commit_id": "d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175",
        "hash": 16406600449927655472414841452114221955,
        "size": 27,
        "message": "[APM-78] Disable installation from remote URL (#15292) (#15343)\n\n* [APM-78] Disable installation from remote URL (#15292)\r\n\r\n* Update CHANGELOG\r\n\r\n* Fix clang-format\r\n\r\nCo-authored-by: Vadim <vadim@arangodb.com>"
    },
    {
        "func": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tif (*(str) == '[' && str_len > 1) {\n\t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = strtol(p + 2, &e, 10);\n\t\tif (e && *e) {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\n\tif (colon) {\n\t\tchar *e = NULL;\n\t\t*portno = strtol(colon + 1, &e, 10);\n\t\tif (!e || !*e) {\n\t\t\treturn estrndup(str, colon - str);\n\t\t}\n\t}\n\n\tif (get_err) {\n\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t}\n\treturn NULL;\n}",
        "target": 0,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 285829628454012662583446240465180513178,
        "size": 45,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "static int php_sockop_cast(php_stream *stream, int castas, void **ret)\n{\n\tphp_netstream_data_t *sock = (php_netstream_data_t*)stream->abstract;\n\n\tif (!sock) {\n\t\treturn FAILURE;\n\t}\n\n\tswitch(castas)\t{\n\t\tcase PHP_STREAM_AS_STDIO:\n\t\t\tif (ret)\t{\n\t\t\t\t*(FILE**)ret = fdopen(sock->socket, stream->mode);\n\t\t\t\tif (*ret)\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\tcase PHP_STREAM_AS_FD_FOR_SELECT:\n\t\tcase PHP_STREAM_AS_FD:\n\t\tcase PHP_STREAM_AS_SOCKETD:\n\t\t\tif (ret)\n\t\t\t\t*(php_socket_t *)ret = sock->socket;\n\t\t\treturn SUCCESS;\n\t\tdefault:\n\t\t\treturn FAILURE;\n\t}\n}",
        "target": 0,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 322273073805044099210490408410683477525,
        "size": 27,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "static int php_sockop_close(php_stream *stream, int close_handle)\n{\n\tphp_netstream_data_t *sock = (php_netstream_data_t*)stream->abstract;\n#ifdef PHP_WIN32\n\tint n;\n#endif\n\n\tif (!sock) {\n\t\treturn 0;\n\t}\n\n\tif (close_handle) {\n\n#ifdef PHP_WIN32\n\t\tif (sock->socket == -1)\n\t\t\tsock->socket = SOCK_ERR;\n#endif\n\t\tif (sock->socket != SOCK_ERR) {\n#ifdef PHP_WIN32\n\t\t\t/* prevent more data from coming in */\n\t\t\tshutdown(sock->socket, SHUT_RD);\n\n\t\t\t/* try to make sure that the OS sends all data before we close the connection.\n\t\t\t * Essentially, we are waiting for the socket to become writeable, which means\n\t\t\t * that all pending data has been sent.\n\t\t\t * We use a small timeout which should encourage the OS to send the data,\n\t\t\t * but at the same time avoid hanging indefinitely.\n\t\t\t * */\n\t\t\tdo {\n\t\t\t\tn = php_pollfd_for_ms(sock->socket, POLLOUT, 500);\n\t\t\t} while (n == -1 && php_socket_errno() == EINTR);\n#endif\n\t\t\tclosesocket(sock->socket);\n\t\t\tsock->socket = SOCK_ERR;\n\t\t}\n\n\t}\n\n\tpefree(sock, php_stream_is_persistent(stream));\n\n\treturn 0;\n}",
        "target": 0,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 103081769905423632314150806706153117787,
        "size": 42,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "static int php_sockop_flush(php_stream *stream)\n{\n#if 0\n\tphp_netstream_data_t *sock = (php_netstream_data_t*)stream->abstract;\n\treturn fsync(sock->socket);\n#endif\n\treturn 0;\n}",
        "target": 0,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 223397209832140216623668597333965748571,
        "size": 8,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "static size_t php_sockop_read(php_stream *stream, char *buf, size_t count)\n{\n\tphp_netstream_data_t *sock = (php_netstream_data_t*)stream->abstract;\n\tssize_t nr_bytes = 0;\n\tint err;\n\n\tif (!sock || sock->socket == -1) {\n\t\treturn 0;\n\t}\n\n\tif (sock->is_blocked) {\n\t\tphp_sock_stream_wait_for_data(stream, sock);\n\t\tif (sock->timeout_event)\n\t\t\treturn 0;\n\t}\n\n\tnr_bytes = recv(sock->socket, buf, XP_SOCK_BUF_SIZE(count), (sock->is_blocked && sock->timeout.tv_sec != -1) ? MSG_DONTWAIT : 0);\n\terr = php_socket_errno();\n\n\tstream->eof = (nr_bytes == 0 || (nr_bytes == -1 && err != EWOULDBLOCK && err != EAGAIN));\n\n\tif (nr_bytes > 0) {\n\t\tphp_stream_notify_progress_increment(PHP_STREAM_CONTEXT(stream), nr_bytes, 0);\n\t}\n\n\tif (nr_bytes < 0) {\n\t\tnr_bytes = 0;\n\t}\n\n\treturn nr_bytes;\n}",
        "target": 0,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 115834753823559311743125329819595984692,
        "size": 31,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "static inline int sock_sendto(php_netstream_data_t *sock, const char *buf, size_t buflen, int flags,\n\t\tstruct sockaddr *addr, socklen_t addrlen\n\t\t)\n{\n\tint ret;\n\tif (addr) {\n\t\tret = sendto(sock->socket, buf, XP_SOCK_BUF_SIZE(buflen), flags, addr, XP_SOCK_BUF_SIZE(addrlen));\n\n\t\treturn (ret == SOCK_CONN_ERR) ? -1 : ret;\n\t}\n#ifdef PHP_WIN32\n\treturn ((ret = send(sock->socket, buf, buflen > INT_MAX ? INT_MAX : (int)buflen, flags)) == SOCK_CONN_ERR) ? -1 : ret;\n#else\n\treturn ((ret = send(sock->socket, buf, buflen, flags)) == SOCK_CONN_ERR) ? -1 : ret;\n#endif\n}",
        "target": 0,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 170161044623641492686882272457773135306,
        "size": 16,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "static inline int sock_recvfrom(php_netstream_data_t *sock, char *buf, size_t buflen, int flags,\n\t\tzend_string **textaddr,\n\t\tstruct sockaddr **addr, socklen_t *addrlen\n\t\t)\n{\n\tint ret;\n\tint want_addr = textaddr || addr;\n\n\tif (want_addr) {\n\t\tphp_sockaddr_storage sa;\n\t\tsocklen_t sl = sizeof(sa);\n\t\tret = recvfrom(sock->socket, buf, XP_SOCK_BUF_SIZE(buflen), flags, (struct sockaddr*)&sa, &sl);\n\t\tret = (ret == SOCK_CONN_ERR) ? -1 : ret;\n\t\tif (sl) {\n\t\t\tphp_network_populate_name_from_sockaddr((struct sockaddr*)&sa, sl,\n\t\t\t\t\ttextaddr, addr, addrlen);\n\t\t} else {\n\t\t\tif (textaddr) {\n\t\t\t\t*textaddr = ZSTR_EMPTY_ALLOC();\n\t\t\t}\n\t\t\tif (addr) {\n\t\t\t\t*addr = NULL;\n\t\t\t\t*addrlen = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = recv(sock->socket, buf, XP_SOCK_BUF_SIZE(buflen), flags);\n\t\tret = (ret == SOCK_CONN_ERR) ? -1 : ret;\n\t}\n\n\treturn ret;\n}",
        "target": 0,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 25903311340178002162423868300792651654,
        "size": 32,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "static inline int parse_unix_address(php_stream_xport_param *xparam, struct sockaddr_un *unix_addr)\n{\n\tmemset(unix_addr, 0, sizeof(*unix_addr));\n\tunix_addr->sun_family = AF_UNIX;\n\n\t/* we need to be binary safe on systems that support an abstract\n\t * namespace */\n\tif (xparam->inputs.namelen >= sizeof(unix_addr->sun_path)) {\n\t\t/* On linux, when the path begins with a NUL byte we are\n\t\t * referring to an abstract namespace.  In theory we should\n\t\t * allow an extra byte below, since we don't need the NULL.\n\t\t * BUT, to get into this branch of code, the name is too long,\n\t\t * so we don't care. */\n\t\txparam->inputs.namelen = sizeof(unix_addr->sun_path) - 1;\n\t\tphp_error_docref(NULL, E_NOTICE,\n\t\t\t\"socket path exceeded the maximum allowed length of %lu bytes \"\n\t\t\t\"and was truncated\", (unsigned long)sizeof(unix_addr->sun_path));\n\t}\n\n\tmemcpy(unix_addr->sun_path, xparam->inputs.name, xparam->inputs.namelen);\n\n\treturn 1;\n}",
        "target": 0,
        "cwe": [
            "CWE-20",
            "CWE-918"
        ],
        "project": "php-src",
        "commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a",
        "hash": 25136566035132985079411784108357968373,
        "size": 23,
        "message": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error."
    },
    {
        "func": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-77"
        ],
        "project": "util-linux",
        "commit_id": "89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc",
        "hash": 200464239611257305885148788657014124408,
        "size": 25,
        "message": "libblkid: care about unsafe chars in cache\n\nThe high-level libblkid API uses /run/blkid/blkid.tab cache to\nstore probing results. The cache format is\n\n   <device NAME=\"value\" ...>devname</device>\n\nand unfortunately the cache code does not escape quotation marks:\n\n   # mkfs.ext4 -L 'AAA\"BBB'\n\n   # cat /run/blkid/blkid.tab\n   ...\n   <device ... LABEL=\"AAA\"BBB\" ...>/dev/sdb1</device>\n\nsuch string is later incorrectly parsed and blkid(8) returns\nnonsenses. And for use-cases like\n\n   # eval $(blkid -o export /dev/sdb1)\n\nit's also insecure.\n\nNote that mount, udevd and blkid -p are based on low-level libblkid\nAPI, it bypass the cache and directly read data from the devices.\n\nThe current udevd upstream does not depend on blkid(8) output at all,\nit's directly linked with the library and all unsafe chars are encoded by\n\\x<hex> notation.\n\n   # mkfs.ext4 -L 'X\"`/tmp/foo` \"' /dev/sdb1\n   # udevadm info --export-db | grep LABEL\n   ...\n   E: ID_FS_LABEL=X__/tmp/foo___\n   E: ID_FS_LABEL_ENC=X\\x22\\x60\\x2ftmp\\x2ffoo\\x60\\x20\\x22\n\nSigned-off-by: Karel Zak <kzak@redhat.com>"
    },
    {
        "func": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}",
        "target": 1,
        "cwe": [
            "CWE-77"
        ],
        "project": "util-linux",
        "commit_id": "89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc",
        "hash": 323259796987437908313101242253501992940,
        "size": 28,
        "message": "libblkid: care about unsafe chars in cache\n\nThe high-level libblkid API uses /run/blkid/blkid.tab cache to\nstore probing results. The cache format is\n\n   <device NAME=\"value\" ...>devname</device>\n\nand unfortunately the cache code does not escape quotation marks:\n\n   # mkfs.ext4 -L 'AAA\"BBB'\n\n   # cat /run/blkid/blkid.tab\n   ...\n   <device ... LABEL=\"AAA\"BBB\" ...>/dev/sdb1</device>\n\nsuch string is later incorrectly parsed and blkid(8) returns\nnonsenses. And for use-cases like\n\n   # eval $(blkid -o export /dev/sdb1)\n\nit's also insecure.\n\nNote that mount, udevd and blkid -p are based on low-level libblkid\nAPI, it bypass the cache and directly read data from the devices.\n\nThe current udevd upstream does not depend on blkid(8) output at all,\nit's directly linked with the library and all unsafe chars are encoded by\n\\x<hex> notation.\n\n   # mkfs.ext4 -L 'X\"`/tmp/foo` \"' /dev/sdb1\n   # udevadm info --export-db | grep LABEL\n   ...\n   E: ID_FS_LABEL=X__/tmp/foo___\n   E: ID_FS_LABEL_ENC=X\\x22\\x60\\x2ftmp\\x2ffoo\\x60\\x20\\x22\n\nSigned-off-by: Karel Zak <kzak@redhat.com>"
    },
    {
        "func": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\n\tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend++;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}",
        "target": 1,
        "cwe": [
            "CWE-77"
        ],
        "project": "util-linux",
        "commit_id": "89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc",
        "hash": 269977846131554548491550978717218645624,
        "size": 35,
        "message": "libblkid: care about unsafe chars in cache\n\nThe high-level libblkid API uses /run/blkid/blkid.tab cache to\nstore probing results. The cache format is\n\n   <device NAME=\"value\" ...>devname</device>\n\nand unfortunately the cache code does not escape quotation marks:\n\n   # mkfs.ext4 -L 'AAA\"BBB'\n\n   # cat /run/blkid/blkid.tab\n   ...\n   <device ... LABEL=\"AAA\"BBB\" ...>/dev/sdb1</device>\n\nsuch string is later incorrectly parsed and blkid(8) returns\nnonsenses. And for use-cases like\n\n   # eval $(blkid -o export /dev/sdb1)\n\nit's also insecure.\n\nNote that mount, udevd and blkid -p are based on low-level libblkid\nAPI, it bypass the cache and directly read data from the devices.\n\nThe current udevd upstream does not depend on blkid(8) output at all,\nit's directly linked with the library and all unsafe chars are encoded by\n\\x<hex> notation.\n\n   # mkfs.ext4 -L 'X\"`/tmp/foo` \"' /dev/sdb1\n   # udevadm info --export-db | grep LABEL\n   ...\n   E: ID_FS_LABEL=X__/tmp/foo___\n   E: ID_FS_LABEL_ENC=X\\x22\\x60\\x2ftmp\\x2ffoo\\x60\\x20\\x22\n\nSigned-off-by: Karel Zak <kzak@redhat.com>"
    },
    {
        "func": "do_command (unsigned char c)\n{\n\tstatic int dtr_up = 0;\n\tint newbaud, newflow, newparity, newbits;\n\tconst char *xfr_cmd;\n\tchar *fname;\n\tint r;\n\n\tswitch (c) {\n\tcase KEY_EXIT:\n\t\treturn 1;\n\tcase KEY_QUIT:\n\t\tterm_set_hupcl(tty_fd, 0);\n\t\tterm_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tterm_erase(tty_fd);\n\t\treturn 1;\n\tcase KEY_STATUS:\n\t\tshow_status(dtr_up);\n\t\tbreak;\n\tcase KEY_PULSE:\n\t\tfd_printf(STO, \"\\r\\n*** pulse DTR ***\\r\\n\");\n\t\tif ( term_pulse_dtr(tty_fd) < 0 )\n\t\t\tfd_printf(STO, \"*** FAILED\\r\\n\");\n\t\tbreak;\n\tcase KEY_TOGGLE:\n\t\tif ( dtr_up )\n\t\t\tr = term_lower_dtr(tty_fd);\n\t\telse\n\t\t\tr = term_raise_dtr(tty_fd);\n\t\tif ( r >= 0 ) dtr_up = ! dtr_up;\n\t\tfd_printf(STO, \"\\r\\n*** DTR: %s ***\\r\\n\", \n\t\t\t\t  dtr_up ? \"up\" : \"down\");\n\t\tbreak;\n\tcase KEY_BAUD_UP:\n\tcase KEY_BAUD_DN:\n\t\tif (c == KEY_BAUD_UP)\n\t\t\topts.baud = baud_up(opts.baud);\n\t\telse \n\t\t\topts.baud = baud_down(opts.baud);\n\t\tterm_set_baudrate(tty_fd, opts.baud);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbaud = term_get_baudrate(tty_fd, NULL);\n\t\tif ( opts.baud != newbaud ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d (%d) ***\\r\\n\", \n\t\t\t\t\t  opts.baud, newbaud);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d ***\\r\\n\", opts.baud);\n\t\t}\n\t\tset_tty_write_sz(newbaud);\n\t\tbreak;\n\tcase KEY_FLOW:\n\t\topts.flow = flow_next(opts.flow);\n\t\tterm_set_flowcntrl(tty_fd, opts.flow);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewflow = term_get_flowcntrl(tty_fd);\n\t\tif ( opts.flow != newflow ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s (%s) ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow]);\n\t\t}\n\t\tbreak;\n\tcase KEY_PARITY:\n\t\topts.parity = parity_next(opts.parity);\n\t\tterm_set_parity(tty_fd, opts.parity);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewparity = term_get_parity(tty_fd);\n\t\tif (opts.parity != newparity ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s (%s) ***\\r\\n\",\n\t\t\t\t\t  parity_str[opts.parity], \n\t\t\t\t\t  parity_str[newparity]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s ***\\r\\n\", \n\t\t\t\t\t  parity_str[opts.parity]);\n\t\t}\n\t\tbreak;\n\tcase KEY_BITS:\n\t\topts.databits = bits_next(opts.databits);\n\t\tterm_set_databits(tty_fd, opts.databits);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbits = term_get_databits(tty_fd);\n\t\tif (opts.databits != newbits ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d (%d) ***\\r\\n\",\n\t\t\t\t\t  opts.databits, newbits);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d ***\\r\\n\", \n\t\t\t\t\t  opts.databits);\n\t\t}\n\t\tbreak;\n\tcase KEY_LECHO:\n\t\topts.lecho = ! opts.lecho;\n\t\tfd_printf(STO, \"\\r\\n*** local echo: %s ***\\r\\n\", \n\t\t\t\t  opts.lecho ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase KEY_SEND:\n\tcase KEY_RECEIVE:\n\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-77",
            "CWE-125"
        ],
        "project": "picocom",
        "commit_id": "1ebc60b20fbe9a02436d5cbbf8951714e749ddb1",
        "hash": 330476393467195963013725159946352884213,
        "size": 125,
        "message": "Do not use \"/bin/sh\" to run external commands.\n\nPicocom no longer uses /bin/sh to run external commands for\nfile-transfer operations. Parsing the command line and spliting it into\narguments is now performed internally by picocom, using quoting rules\nvery similar to those of the Unix shell. Hopefully, this makes it\nimpossible to inject shell-commands when supplying filenames or\nextra arguments to the send- and receive-file commands."
    },
    {
        "func": "run_cmd(int fd, ...)\n{\n\tpid_t pid;\n\tsigset_t sigm, sigm_old;\n\n\t/* block signals, let child establish its own handlers */\n\tsigemptyset(&sigm);\n\tsigaddset(&sigm, SIGTERM);\n\tsigprocmask(SIG_BLOCK, &sigm, &sigm_old);\n\n\tpid = fork();\n\tif ( pid < 0 ) {\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\tfd_printf(STO, \"*** cannot fork: %s ***\\r\\n\", strerror(errno));\n\t\treturn -1;\n\t} else if ( pid ) {\n\t\t/* father: picocom */\n\t\tint status, r;\n\n\t\t/* reset the mask */\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\t/* wait for child to finish */\n\t\tdo {\n\t\t\tr = waitpid(pid, &status, 0);\n\t\t} while ( r < 0 && errno == EINTR );\n\t\t/* reset terminal (back to raw mode) */\n\t\tterm_apply(STI);\n\t\t/* check and report child return status */\n\t\tif ( WIFEXITED(status) ) { \n\t\t\tfd_printf(STO, \"\\r\\n*** exit status: %d ***\\r\\n\", \n\t\t\t\t\t  WEXITSTATUS(status));\n\t\t\treturn WEXITSTATUS(status);\n\t\t} else if ( WIFSIGNALED(status) ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** killed by signal: %d ***\\r\\n\", \n\t\t\t\t\t  WTERMSIG(status));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** abnormal termination: 0x%x ***\\r\\n\", r);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* child: external program */\n\t\tlong fl;\n\t\tchar cmd[512];\n\n\t\t/* unmanage terminal, and reset it to canonical mode */\n\t\tterm_remove(STI);\n\t\t/* unmanage serial port fd, without reset */\n\t\tterm_erase(fd);\n\t\t/* set serial port fd to blocking mode */\n\t\tfl = fcntl(fd, F_GETFL); \n\t\tfl &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, fl);\n\t\t/* connect stdin and stdout to serial port */\n\t\tclose(STI);\n\t\tclose(STO);\n\t\tdup2(fd, STI);\n\t\tdup2(fd, STO);\n\t\t{\n\t\t\t/* build command-line */\n\t\t\tchar *c, *ce;\n\t\t\tconst char *s;\n\t\t\tint n;\n\t\t\tva_list vls;\n\t\t\t\n\t\t\tstrcpy(cmd, EXEC);\n\t\t\tc = &cmd[sizeof(EXEC)- 1];\n\t\t\tce = cmd + sizeof(cmd) - 1;\n\t\t\tva_start(vls, fd);\n\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n\t\t\t\tn = strlen(s);\n\t\t\t\tif ( c + n + 1 >= ce ) break;\n\t\t\t\tmemcpy(c, s, n); c += n;\n\t\t\t\t*c++ = ' ';\n\t\t\t}\n\t\t\tva_end(vls);\n\t\t\t*c = '\\0';\n\t\t}\n\t\t/* run extenral command */\n\t\tfd_printf(STDERR_FILENO, \"%s\\n\", &cmd[sizeof(EXEC) - 1]);\n\t\testablish_child_signal_handlers();\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n\t\texit(42);\n\t}\n}",
        "target": 1,
        "cwe": [
            "CWE-77",
            "CWE-125"
        ],
        "project": "picocom",
        "commit_id": "1ebc60b20fbe9a02436d5cbbf8951714e749ddb1",
        "hash": 237609986934169136707874388362783419232,
        "size": 86,
        "message": "Do not use \"/bin/sh\" to run external commands.\n\nPicocom no longer uses /bin/sh to run external commands for\nfile-transfer operations. Parsing the command line and spliting it into\narguments is now performed internally by picocom, using quoting rules\nvery similar to those of the Unix shell. Hopefully, this makes it\nimpossible to inject shell-commands when supplying filenames or\nextra arguments to the send- and receive-file commands."
    },
    {
        "func": "bool format_go_output(const string& file_path) {\n  const string command = \"gofmt -w \" + file_path;\n\n  if (system(command.c_str()) == 0) {\n    return true;\n  }\n\n  fprintf(stderr, \"WARNING - Running '%s' failed.\\n\", command.c_str());\n  return false;\n}",
        "target": 1,
        "cwe": [
            "CWE-77"
        ],
        "project": "thrift",
        "commit_id": "2007783e874d524a46b818598a45078448ecc53e",
        "hash": 103115327118230832249319819756280220698,
        "size": 10,
        "message": "THRIFT-3893 Command injection in format_go_output\nClient: Go\nPatch: Jens Geyer"
    },
    {
        "func": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "95e80bf9ff10f68cb6443f760b85df4117cb15eb",
        "hash": 51192060095297482675395799069061875357,
        "size": 57,
        "message": "Quote path in imap_subscribe"
    },
    {
        "func": "static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \"OR \");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 222630270967631751654806842484768220801,
        "size": 96,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\"Logging in...\"));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \"Logging in...\".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 58712600715241729698763039907271558401,
        "size": 40,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf);\n\n  FREE(&buf);\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 280064003594277246918076946170594027106,
        "size": 9,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 237931988464177258235718341233506567636,
        "size": 46,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}",
        "target": 1,
        "cwe": [
            "CWE-78",
            "CWE-77"
        ],
        "project": "neomutt",
        "commit_id": "e52393740334443ae0206cab2d7caef381646725",
        "hash": 155394546650805050914751528184108702294,
        "size": 29,
        "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>"
    },
    {
        "func": "main(\n    int\t\targc,\n    char **\targv)\n{\n#ifdef GNUTAR\n    int i;\n    char *e;\n    char *dbf;\n    char *cmdline;\n    GPtrArray *array = g_ptr_array_new();\n    gchar **strings;\n    char **new_argv;\n    char **env;\n#endif\n\n    if (argc > 1 && argv[1] && g_str_equal(argv[1], \"--version\")) {\n\tprintf(\"runtar-%s\\n\", VERSION);\n\treturn (0);\n    }\n\n    /*\n     * Configure program for internationalization:\n     *   1) Only set the message locale for now.\n     *   2) Set textdomain for all amanda related programs to \"amanda\"\n     *      We don't want to be forced to support dozens of message catalogs.\n     */\n    setlocale(LC_MESSAGES, \"C\");\n    textdomain(\"amanda\"); \n\n    safe_fd(-1, 0);\n    safe_cd();\n\n    set_pname(\"runtar\");\n\n    /* Don't die when child closes pipe */\n    signal(SIGPIPE, SIG_IGN);\n\n    dbopen(DBG_SUBDIR_CLIENT);\n    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);\n\n    if (argc < 3) {\n\terror(_(\"Need at least 3 arguments\\n\"));\n\t/*NOTREACHED*/\n    }\n\n    dbprintf(_(\"version %s\\n\"), VERSION);\n\n    if (!g_str_equal(argv[3], \"--create\")) {\n\terror(_(\"Can only be used to create tar archives\\n\"));\n\t/*NOTREACHED*/\n    }\n\n#ifndef GNUTAR\n\n    g_fprintf(stderr,_(\"gnutar not available on this system.\\n\"));\n    dbprintf(_(\"%s: gnutar not available on this system.\\n\"), argv[0]);\n    dbclose();\n    return 1;\n\n#else\n\n    /*\n     * Print out version information for tar.\n     */\n    do {\n\tFILE *\tversion_file;\n\tchar\tversion_buf[80];\n\n\tif ((version_file = popen(GNUTAR \" --version 2>&1\", \"r\")) != NULL) {\n\t    if (fgets(version_buf, (int)sizeof(version_buf), version_file) != NULL) {\n\t\tdbprintf(_(GNUTAR \" version: %s\\n\"), version_buf);\n\t    } else {\n\t\tif (ferror(version_file)) {\n\t\t    dbprintf(_(GNUTAR \" version: Read failure: %s\\n\"), strerror(errno));\n\t\t} else {\n\t\t    dbprintf(_(GNUTAR \" version: Read failure; EOF\\n\"));\n\t\t}\n\t    }\n\t} else {\n\t    dbprintf(_(GNUTAR \" version: unavailable: %s\\n\"), strerror(errno));\n\t}\n    } while(0);\n\n#ifdef WANT_SETUID_CLIENT\n    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);\n    if (!become_root()) {\n\terror(_(\"error [%s could not become root (is the setuid bit set?)]\\n\"), get_pname());\n\t/*NOTREACHED*/\n    }\n#else\n    check_running_as(RUNNING_AS_CLIENT_LOGIN);\n#endif\n\n    /* skip argv[0] */\n    argc--;\n    argv++;\n\n    dbprintf(_(\"config: %s\\n\"), argv[0]);\n    if (!g_str_equal(argv[0], \"NOCONFIG\"))\n\tdbrename(argv[0], DBG_SUBDIR_CLIENT);\n    argc--;\n    argv++;\n\n    new_argv = g_new0(char *, argc+1);\n\n    new_argv[0] = g_strdup_printf(\"%s\", argv[0]);\n    g_ptr_array_add(array, g_strdup(GNUTAR));\n    for (i = 1; argv[i]; i++) {\n        g_ptr_array_add(array, quote_string(argv[i]));\n\tnew_argv[i] = g_strdup_printf(\"%s\", argv[i]);\n    }\n\n    g_ptr_array_add(array, NULL);\n    strings = (gchar **)g_ptr_array_free(array, FALSE);\n\n    cmdline = g_strjoinv(\" \", strings);\n    g_strfreev(strings);\n\n    dbprintf(_(\"running: %s\\n\"), cmdline);\n    amfree(cmdline);\n\n    dbf = dbfn();\n    if (dbf) {\n\tdbf = g_strdup(dbf);\n    }\n    dbclose();\n\n    env = safe_env();\n    execve(GNUTAR, new_argv, env);\n    free_env(env);\n\n    e = strerror(errno);\n    dbreopen(dbf, \"more\");\n    amfree(dbf);\n    dbprintf(_(\"execve of %s failed (%s)\\n\"), GNUTAR, e);\n    dbclose();\n\n    g_fprintf(stderr, _(\"runtar: could not exec %s: %s\\n\"), GNUTAR, e);\n    return 1;\n#endif\n}",
        "target": 1,
        "cwe": [
            "CWE-77"
        ],
        "project": "amanda",
        "commit_id": "2ba9a5fb84ba2faaeb95695a03bd7f26cbdfedb8",
        "hash": 144454950056071142681337133448362724544,
        "size": 141,
        "message": "* client-src/runtar.c: Filter tar arguments\n* installcheck/runtar.pl: Check runtar errorr\n* installcheck/Makefile.am: Add runtar.pl\n\n\ngit-svn-id: https://svn.code.sf.net/p/amanda/code/amanda/trunk@6479 a8d146d6-cc15-0410-8900-af154a0219e0"
    },
    {
        "func": "amgtar_backup(\n    application_argument_t *argument)\n{\n    int         dumpin;\n    char      *cmd = NULL;\n    char      *qdisk;\n    char      *incrname;\n    char       line[32768];\n    amregex_t *rp;\n    off_t      dump_size = -1;\n    char      *type;\n    char       startchr;\n    int        dataf = 1;\n    int        mesgf = 3;\n    int        indexf = 4;\n    int        outf;\n    FILE      *mesgstream;\n    FILE      *indexstream = NULL;\n    FILE      *outstream;\n    char      *errmsg = NULL;\n    amwait_t   wait_status;\n    GPtrArray *argv_ptr;\n    int        tarpid;\n    char      *file_exclude;\n    char      *file_include;\n\n    mesgstream = fdopen(mesgf, \"w\");\n    if (!mesgstream) {\n\terror(_(\"error mesgstream(%d): %s\\n\"), mesgf, strerror(errno));\n    }\n\n    if (!gnutar_path) {\n\terror(_(\"GNUTAR-PATH not defined\"));\n    }\n    if (!gnutar_listdir) {\n\terror(_(\"GNUTAR-LISTDIR not defined\"));\n    }\n\n    if (!argument->level) {\n        fprintf(mesgstream, \"? No level argument\\n\");\n        error(_(\"No level argument\"));\n    }\n    if (!argument->dle.disk) {\n        fprintf(mesgstream, \"? No disk argument\\n\");\n        error(_(\"No disk argument\"));\n    }\n    if (!argument->dle.device) {\n        fprintf(mesgstream, \"? No device argument\\n\");\n        error(_(\"No device argument\"));\n    }\n\n    if (!check_exec_for_suid(gnutar_path, FALSE)) {\n        fprintf(mesgstream, \"? '%s' binary is not secure\", gnutar_path);\n        error(\"'%s' binary is not secure\", gnutar_path);\n    }\n\n    qdisk = quote_string(argument->dle.disk);\n\n    incrname = amgtar_get_incrname(argument,\n\t\t\t\t   GPOINTER_TO_INT(argument->level->data),\n\t\t\t\t   mesgstream, CMD_BACKUP);\n    cmd = g_strdup(gnutar_path);\n    argv_ptr = amgtar_build_argv(argument, incrname, &file_exclude,\n\t\t\t\t &file_include, CMD_BACKUP);\n\n    tarpid = pipespawnv(cmd, STDIN_PIPE|STDERR_PIPE, 1,\n\t\t\t&dumpin, &dataf, &outf, (char **)argv_ptr->pdata);\n    /* close the write ends of the pipes */\n\n    aclose(dumpin);\n    aclose(dataf);\n    if (argument->dle.create_index) {\n\tindexstream = fdopen(indexf, \"w\");\n\tif (!indexstream) {\n\t    error(_(\"error indexstream(%d): %s\\n\"), indexf, strerror(errno));\n\t}\n    }\n    outstream = fdopen(outf, \"r\");\n    if (!outstream) {\n\terror(_(\"error outstream(%d): %s\\n\"), outf, strerror(errno));\n    }\n\n    while (fgets(line, sizeof(line), outstream) != NULL) {\n\tif (strlen(line) > 0 && line[strlen(line)-1] == '\\n') {\n\t    /* remove trailling \\n */\n\t    line[strlen(line)-1] = '\\0';\n\t}\n\tif (strncmp(line, \"block \", 6) == 0) { /* filename */\n\t    off_t block_no = g_ascii_strtoull(line+6, NULL, 0);\n\t    char *filename = strchr(line, ':');\n\t    if (filename) {\n\t\tfilename += 2;\n\t\tif (*filename == '.' && *(filename+1) == '/') {\n\t\t    if (argument->dle.create_index) {\n\t\t\tfprintf(indexstream, \"%s\\n\", &filename[1]); /* remove . */\n\t\t    }\n\t\t    if (argument->state_stream != -1) {\n\t\t\tchar *s = g_strdup_printf(\"%lld %s\\n\",\n\t\t\t\t\t (long long)block_no, &filename[1]);\n\t\t\tguint a = full_write(argument->state_stream, s, strlen(s));\n\t\t\tif (a < strlen(s)) {\n\t\t\t    g_debug(\"Failed to write to the state stream: %s\",\n\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t\tg_free(s);\n\t\t    } else if (argument->amfeatures &&\n\t\t\t       am_has_feature(argument->amfeatures,\n\t\t\t\t\t      fe_sendbackup_state)) {\n\t\t\tfprintf(mesgstream, \"sendbackup: state %lld %s\\n\",\n\t\t\t        (long long)block_no, &filename[1]);\n\t\t    }\n\t\t}\n\t    }\n\t} else { /* message */\n\t    for(rp = re_table; rp->regex != NULL; rp++) {\n\t\tif(match(rp->regex, line)) {\n\t\t    break;\n\t\t}\n\t    }\n\t    if(rp->typ == DMP_SIZE) {\n\t\tdump_size = (off_t)((the_num(line, rp->field)* rp->scale+1023.0)/1024.0);\n\t    }\n\t    switch(rp->typ) {\n\t    case DMP_NORMAL:\n\t\ttype = \"normal\";\n\t\tstartchr = '|';\n\t\tbreak;\n\t    case DMP_IGNORE:\n\t\tcontinue;\n\t    case DMP_STRANGE:\n\t\ttype = \"strange\";\n\t\tstartchr = '?';\n\t\tbreak;\n\t    case DMP_SIZE:\n\t\ttype = \"size\";\n\t\tstartchr = '|';\n\t\tbreak;\n\t    case DMP_ERROR:\n\t\ttype = \"error\";\n\t\tstartchr = '?';\n\t\tbreak;\n\t    default:\n\t\ttype = \"unknown\";\n\t\tstartchr = '!';\n\t\tbreak;\n\t    }\n\t    dbprintf(\"%3d: %7s(%c): %s\\n\", rp->srcline, type, startchr, line);\n\t    fprintf(mesgstream,\"%c %s\\n\", startchr, line);\n        }\n    }\n    fclose(outstream);\n\n    waitpid(tarpid, &wait_status, 0);\n    if (WIFSIGNALED(wait_status)) {\n\terrmsg = g_strdup_printf(_(\"%s terminated with signal %d: see %s\"),\n\t\t\t    cmd, WTERMSIG(wait_status), dbfn());\n    } else if (WIFEXITED(wait_status)) {\n\tif (exit_value[WEXITSTATUS(wait_status)] == 1) {\n\t    errmsg = g_strdup_printf(_(\"%s exited with status %d: see %s\"),\n\t\t\t\tcmd, WEXITSTATUS(wait_status), dbfn());\n\t} else {\n\t    /* Normal exit */\n\t}\n    } else {\n\terrmsg = g_strdup_printf(_(\"%s got bad exit: see %s\"),\n\t\t\t    cmd, dbfn());\n    }\n    dbprintf(_(\"after %s %s wait\\n\"), cmd, qdisk);\n    dbprintf(_(\"amgtar: %s: pid %ld\\n\"), cmd, (long)tarpid);\n    if (errmsg) {\n\tdbprintf(\"%s\", errmsg);\n\tg_fprintf(mesgstream, \"sendbackup: error [%s]\\n\", errmsg);\n    }\n\n    if (!errmsg && strlen(incrname) > 4) {\n\tif (argument->dle.record) {\n\t    char *nodotnew;\n\t    nodotnew = g_strdup(incrname);\n\t    nodotnew[strlen(nodotnew)-4] = '\\0';\n\t    if (rename(incrname, nodotnew)) {\n\t\tdbprintf(_(\"%s: warning [renaming %s to %s: %s]\\n\"),\n\t\t\t get_pname(), incrname, nodotnew, strerror(errno));\n\t\tg_fprintf(mesgstream, _(\"? warning [renaming %s to %s: %s]\\n\"),\n\t\t\t  incrname, nodotnew, strerror(errno));\n\t    }\n\t    amfree(nodotnew);\n\t} else {\n\t    if (unlink(incrname) == -1) {\n\t\tdbprintf(_(\"%s: warning [unlink %s: %s]\\n\"),\n\t\t\t get_pname(), incrname, strerror(errno));\n\t\tg_fprintf(mesgstream, _(\"? warning [unlink %s: %s]\\n\"),\n\t\t\t  incrname, strerror(errno));\n\t    }\n\t}\n    }\n\n    dbprintf(\"sendbackup: size %lld\\n\", (long long)dump_size);\n    fprintf(mesgstream, \"sendbackup: size %lld\\n\", (long long)dump_size);\n\n    if (argument->dle.create_index)\n\tfclose(indexstream);\n\n    fclose(mesgstream);\n\n    if (argument->verbose == 0) {\n\tif (file_exclude)\n\t    unlink(file_exclude);\n\tif (file_include)\n\t    unlink(file_include);\n    }\n\n    amfree(file_exclude);\n    amfree(file_include);\n    amfree(incrname);\n    amfree(qdisk);\n    amfree(cmd);\n    amfree(errmsg);\n    g_ptr_array_free_full(argv_ptr);\n}",
        "target": 1,
        "cwe": [
            "CWE-77"
        ],
        "project": "amanda",
        "commit_id": "29bae2e271093cd8d06ea98f73a474c685c5a314",
        "hash": 227397811014051201456148276981539628232,
        "size": 219,
        "message": "* application-src/ambsdtar.c, application-src/amgtar.c,\n  application-src/amstar.c: Filter option from COMMAND-OPTIONS\n* common-src/ammessage.c: Add message.\n\n\ngit-svn-id: https://svn.code.sf.net/p/amanda/code/amanda/trunk@6483 a8d146d6-cc15-0410-8900-af154a0219e0"
    },
    {
        "func": "amstar_backup(\n    application_argument_t *argument)\n{\n    int        dumpin;\n    char      *cmd = NULL;\n    char      *qdisk;\n    char       line[32768];\n    amregex_t *rp;\n    off_t      dump_size = -1;\n    char      *type;\n    char       startchr;\n    GPtrArray *argv_ptr;\n    int        starpid;\n    int        dataf = 1;\n    int        mesgf = 3;\n    int        indexf = 4;\n    int        outf;\n    FILE      *mesgstream;\n    FILE      *indexstream = NULL;\n    FILE      *outstream;\n    int        level;\n    regex_t    regex_root;\n    regex_t    regex_dir;\n    regex_t    regex_file;\n    regex_t    regex_special;\n    regex_t    regex_symbolic;\n    regex_t    regex_hard;\n\n    mesgstream = fdopen(mesgf, \"w\");\n    if (!mesgstream) {\n\terror(_(\"error mesgstream(%d): %s\\n\"), mesgf, strerror(errno));\n    }\n\n    if (!argument->level) {\n\tfprintf(mesgstream, \"? No level argument\\n\");\n\terror(_(\"No level argument\"));\n    }\n    if (!argument->dle.disk) {\n\tfprintf(mesgstream, \"? No disk argument\\n\");\n\terror(_(\"No disk argument\"));\n    }\n    if (!argument->dle.device) {\n\tfprintf(mesgstream, \"? No device argument\\n\");\n\terror(_(\"No device argument\"));\n    }\n\n    if (!check_exec_for_suid(star_path, FALSE)) {\n\tfprintf(mesgstream, \"? '%s' binary is not secure\", star_path);\n\terror(\"'%s' binary is not secure\", star_path);\n    }\n\n    if (argument->dle.include_list &&\n\targument->dle.include_list->nb_element >= 0) {\n\tfprintf(mesgstream, \"? include-list not supported for backup\\n\");\n    }\n\n    level = GPOINTER_TO_INT(argument->level->data);\n\n    qdisk = quote_string(argument->dle.disk);\n\n    argv_ptr = amstar_build_argv(argument, level, CMD_BACKUP, mesgstream);\n\n    cmd = g_strdup(star_path);\n\n    starpid = pipespawnv(cmd, STDIN_PIPE|STDERR_PIPE, 1,\n\t\t\t &dumpin, &dataf, &outf, (char **)argv_ptr->pdata);\n\n    g_ptr_array_free_full(argv_ptr);\n    /* close the write ends of the pipes */\n    aclose(dumpin);\n    aclose(dataf);\n    if (argument->dle.create_index) {\n\tindexstream = fdopen(indexf, \"w\");\n\tif (!indexstream) {\n\t    error(_(\"error indexstream(%d): %s\\n\"), indexf, strerror(errno));\n\t}\n    }\n    outstream = fdopen(outf, \"r\");\n    if (!outstream) {\n\terror(_(\"error outstream(%d): %s\\n\"), outf, strerror(errno));\n    }\n\n    regcomp(&regex_root, \"^a \\\\.\\\\/ directory$\", REG_EXTENDED|REG_NEWLINE);\n    regcomp(&regex_dir, \"^a (.*) directory$\", REG_EXTENDED|REG_NEWLINE);\n    regcomp(&regex_file, \"^a (.*) (.*) bytes\", REG_EXTENDED|REG_NEWLINE);\n    regcomp(&regex_special, \"^a (.*) special\", REG_EXTENDED|REG_NEWLINE);\n    regcomp(&regex_symbolic, \"^a (.*) symbolic\", REG_EXTENDED|REG_NEWLINE);\n    regcomp(&regex_hard, \"^a (.*) link to\", REG_EXTENDED|REG_NEWLINE);\n\n    while ((fgets(line, sizeof(line), outstream)) != NULL) {\n\tregmatch_t regmatch[3];\n\n\tif (strlen(line) > 0 && line[strlen(line)-1] == '\\n') {\n\t    /* remove trailling \\n */\n\t    line[strlen(line)-1] = '\\0';\n\t}\n\n\tif (regexec(&regex_root, line, 1, regmatch, 0) == 0) {\n\t    if (argument->dle.create_index)\n\t\tfprintf(indexstream, \"%s\\n\", \"/\");\n\t    continue;\n\t}\n\n\tif (regexec(&regex_dir, line, 3, regmatch, 0) == 0) {\n\t    if (argument->dle.create_index && regmatch[1].rm_so == 2) {\n\t\tline[regmatch[1].rm_eo]='\\0';\n\t\tfprintf(indexstream, \"/%s\\n\", &line[regmatch[1].rm_so]);\n\t    }\n\t    continue;\n\t}\n\n\tif (regexec(&regex_file, line, 3, regmatch, 0) == 0 ||\n\t    regexec(&regex_special, line, 3, regmatch, 0) == 0 ||\n\t    regexec(&regex_symbolic, line, 3, regmatch, 0) == 0 ||\n\t    regexec(&regex_hard, line, 3, regmatch, 0) == 0) {\n\t    if (argument->dle.create_index && regmatch[1].rm_so == 2) {\n\t\tline[regmatch[1].rm_eo]='\\0';\n\t\tfprintf(indexstream, \"/%s\\n\", &line[regmatch[1].rm_so]);\n\t    }\n\t    continue;\n\t}\n\n\tfor (rp = re_table; rp->regex != NULL; rp++) {\n\t    if (match(rp->regex, line)) {\n\t\tbreak;\n\t    }\n\t}\n\tif (rp->typ == DMP_SIZE) {\n\t    dump_size = (off_t)((the_num(line, rp->field)* rp->scale+1023.0)/1024.0);\n\t}\n\tswitch (rp->typ) {\n\t    case DMP_IGNORE:\n\t\tcontinue;\n\t    case DMP_NORMAL:\n\t\ttype = \"normal\";\n\t\tstartchr = '|';\n\t\tbreak;\n\t    case DMP_STRANGE:\n\t\ttype = \"strange\";\n\t\tstartchr = '?';\n\t\tbreak;\n\t    case DMP_SIZE:\n\t\ttype = \"size\";\n\t\tstartchr = '|';\n\t\tbreak;\n\t    case DMP_ERROR:\n\t\ttype = \"error\";\n\t\tstartchr = '?';\n\t\tbreak;\n\t    default:\n\t\ttype = \"unknown\";\n\t\tstartchr = '!';\n\t\tbreak;\n\t}\n\tdbprintf(\"%3d: %7s(%c): %s\\n\", rp->srcline, type, startchr, line);\n\tfprintf(mesgstream,\"%c %s\\n\", startchr, line);\n    }\n    fclose(outstream);\n\n    regfree(&regex_root);\n    regfree(&regex_dir);\n    regfree(&regex_file);\n    regfree(&regex_special);\n    regfree(&regex_symbolic);\n    regfree(&regex_hard);\n\n    dbprintf(_(\"gnutar: %s: pid %ld\\n\"), cmd, (long)starpid);\n\n    dbprintf(\"sendbackup: size %lld\\n\", (long long)dump_size);\n    fprintf(mesgstream, \"sendbackup: size %lld\\n\", (long long)dump_size);\n\n    fclose(mesgstream);\n    if (argument->dle.create_index)\n\tfclose(indexstream);\n\n    amfree(qdisk);\n    amfree(cmd);\n}",
        "target": 1,
        "cwe": [
            "CWE-77"
        ],
        "project": "amanda",
        "commit_id": "29bae2e271093cd8d06ea98f73a474c685c5a314",
        "hash": 257878683022206629709454340370792218741,
        "size": 178,
        "message": "* application-src/ambsdtar.c, application-src/amgtar.c,\n  application-src/amstar.c: Filter option from COMMAND-OPTIONS\n* common-src/ammessage.c: Add message.\n\n\ngit-svn-id: https://svn.code.sf.net/p/amanda/code/amanda/trunk@6483 a8d146d6-cc15-0410-8900-af154a0219e0"
    },
    {
        "func": "set_message(\n    message_t *message,\n    int        want_quoted)\n{\n    char *msg = NULL;\n    char *hint = NULL;\n    GString *result;\n\n    init_errcode();\n\n    if (message == NULL)\n\treturn;\n\n    if (message->code == 123) {\n\tmsg  = \"%{errstr}\";\n    } else if (message->code == 2800000) {\n\tmsg  = \"Usage: amcheck [--version] [-am] [-w] [-sclt] [-M <address>] [--client-verbose] [--exact_match] [-o configoption]* <conf> [host [disk]* ]*\";\n    } else if (message->code == 2800001) {\n\tmsg  = \"amcheck-%{version}\";\n    } else if (message->code == 2800002) {\n\tmsg  = \"Multiple -M options\";\n    } else if (message->code == 2800003) {\n\tmsg  = \"Invalid characters in mail address\";\n    } else if (message->code == 2800004) {\n\tmsg  = \"You can't use -a because a mailer is not defined\";\n    } else if (message->code == 2800005) {\n\tmsg  = \"You can't use -m because a mailer is not defined\";\n    } else if (message->code == 2800006) {\n\tmsg  = \"No mail address configured in amanda.conf\";\n\thint = \"To receive dump results by email configure the \"\n                 \"\\\"mailto\\\" parameter in amanda.conf\";\n    } else if (message->code == 2800007) {\n\tmsg  = \"To receive dump results by email configure the \"\n                 \"\\\"mailto\\\" parameter in amanda.conf\";\n    } else if (message->code == 2800008) {\n\tmsg  = \"When using -a option please specify -Maddress also\";\n    } else if (message->code == 2800009) {\n\tmsg  = \"Use -Maddress instead of -m\";\n    } else if (message->code == 2800010) {\n\tmsg  = \"Mail address '%{mailto}' in amanda.conf has invalid characters\";\n    } else if (message->code == 2800011) {\n\tmsg  = \"No email will be sent\";\n    } else if (message->code == 2800012) {\n\tmsg  = \"No mail address configured in amanda.conf\";\n    } else if (message->code == 2800013) {\n\tmsg  = \"When using -a option please specify -Maddress also\";\n    } else if (message->code == 2800014) {\n\tmsg  = \"Use -Maddress instead of -m\";\n    } else if (message->code == 2800015) {\n\tmsg  = \"%{errstr}\";\n    } else if (message->code == 2800016) {\n\tmsg  = \"(brought to you by Amanda %{version})\";\n    } else if (message->code == 2800017) {\n\tmsg  = \"Invalid mailto address '%{mailto}'\";\n    } else if (message->code == 2800018) {\n\tmsg  = \"tapelist '%{tapelist}': should be a regular file\";\n    } else if (message->code == 2800019) {\n\tmsg  = \"can't access tapelist '%{tapelist}': %{errnostr}\";\n    } else if (message->code == 2800020) {\n\tmsg  = \"tapelist '%{tapelist}': not writable: %{errnostr}\";\n    } else if (message->code == 2800021) {\n\tmsg  = \"parent: reaped bogus pid %{pid}\";\n    } else if (message->code == 2800022) {\n\tmsg  = \"program %{program}: does not exist\";\n    } else if (message->code == 2800023) {\n\tmsg  = \"program %{program}: not a file\";\n    } else if (message->code == 2800024) {\n\tmsg  = \"program %{program}: not executable\";\n    } else if (message->code == 2800025) {\n\tmsg  = \"program %{program}: not setuid-root\";\n    } else if (message->code == 2800026) {\n\tmsg  = \"amcheck-device terminated with signal %{signal}\";\n    } else if (message->code == 2800027) {\n\tmsg  = \"Amanda Tape Server Host Check\";\n    } else if (message->code == 2800028) {\n\tmsg  = \"-----------------------------\";\n    } else if (message->code == 2800029) {\n\tmsg  = \"storage '%{storage}': cannot read label template (lbl-templ) file %{filename}: %{errnostr}\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800030) {\n\tmsg  = \"storage '%{storage}': lbl-templ set but no LPR command defined\";\n\thint = \"you should reconfigure amanda and make sure it finds a lpr or lp command\";\n    } else if (message->code == 2800031) {\n\tmsg  = \"storage '%{storage}': flush-threshold-dumped (%{flush_threshold_dumped}) must be less than or equal to flush-threshold-scheduled (%{flush_threshold_scheduled})\";\n    } else if (message->code == 2800032) {\n\tmsg  = \"storage '%{storage}': taperflush (%{taperflush}) must be less than or equal to flush-threshold-scheduled (%{flush_threshold_scheduled})\";\n    } else if (message->code == 2800033) {\n\tmsg  = \"WARNING: storage '%{storage}': autoflush must be set to 'yes' or 'all' if taperflush (%{taperflush}) is greater that 0\";\n    } else if (message->code == 2800034) {\n\tmsg  = \"storage '%{storage}': no tapetype specified; you must give a value for the 'tapetype' parameter or the storage\";\n    } else if (message->code == 2800035) {\n\tmsg  = \"storage '%{storage}': runtapes is larger or equal to policy '%{policy}' retention-tapes\";\n    } else if (message->code == 2800036) {\n\tmsg  = \"system has %{size:kb_avail} memory, but device-output-buffer-size needs {size:kb_needed}\";\n    } else if (message->code == 2800037) {\n\tmsg  = \"Cannot resolve `localhost': %{gai_strerror}\";\n    } else if (message->code == 2800038) {\n\tmsg  = \"directory '%{dir}' containing Amanda tools is not accessible: %{errnostr}\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800039) {\n\tmsg = \"Check permissions\";\n    } else if (message->code == 2800040) {\n\tmsg  = \"directory '%{dir}' containing Amanda tools is not accessible: %{errnostr}\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800041) {\n\tmsg  = \"Check permissions\";\n    } else if (message->code == 2800042) {\n\tmsg  = \"WARNING: '%{program}' is not executable: %{errnostr}, server-compression and indexing will not work\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800043) {\n\tmsg  = \"Check permissions\";\n    } else if (message->code == 2800044) {\n\tmsg  = \"tapelist dir '%{tape_dir}': not writable: %{errnostr}\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800045) {\n\tmsg  = \"tapelist '%{tapefile}' (%{errnostr}), you must create an empty file\";\n    } else if (message->code == 2800046) {\n\tmsg  = \"tapelist file do not exists\";\n\thint = \"it will be created on the next run\";\n    } else if (message->code == 2800047) {\n\tmsg  = \"tapelist '%{tapefile}': parse error\";\n    } else if (message->code == 2800048) {\n\tmsg  = \"hold file '%{holdfile}' exists. Amdump will sleep as long as this file exists\";\n\thint = \"You might want to delete the existing hold file\";\n    } else if (message->code == 2800049) {\n\tmsg  = \"Amdump will sleep as long as this file exists\";\n    } else if (message->code == 2800050) {\n\tmsg  = \"You might want to delete the existing hold file\";\n    } else if (message->code == 2800051) {\n\tmsg  = \"WARNING:Parameter \\\"tapedev\\\", \\\"tpchanger\\\" or storage not specified in amanda.conf\";\n    } else if (message->code == 2800052) {\n\tmsg  = \"part-cache-type specified, but no part-size\";\n    } else if (message->code == 2800053) {\n\tmsg  = \"part-cache-dir specified, but no part-size\";\n    } else if (message->code == 2800054) {\n\tmsg  = \"part-cache-max-size specified, but no part-size\";\n    } else if (message->code == 2800055) {\n\tmsg  = \"part-cache-type is DISK, but no part-cache-dir specified\";\n    } else if (message->code == 2800056) {\n\tmsg  = \"part-cache-dir '%{part-cache-dir}': %{errnostr}\";\n    } else if (message->code == 2800057) {\n\tmsg  = \"part-cache-dir has %{size:kb_avail} available, but needs %{size:kb_needed}\";\n    } else if (message->code == 2800058) {\n\tmsg  = \"system has %{size:kb_avail} memory, but part cache needs %{size:kb_needed}\";\n    } else if (message->code == 2800059) {\n\tmsg  = \"part-cache-dir specified, but part-cache-type is not DISK\";\n    } else if (message->code == 2800060) {\n\tmsg  = \"part_size is zero, but part-cache-type is not 'none'\";\n    } else if (message->code == 2800061) {\n\tmsg  = \"part-cache-max-size is specified but no part cache is in use\";\n    } else if (message->code == 2800062) {\n\tmsg  = \"WARNING: part-cache-max-size is greater than part-size\";\n    } else if (message->code == 2800063) {\n\tmsg  = \"WARNING: part-size of %{size:part_size} < 0.1%% of tape length\";\n    } else if (message->code == 2800064) {\n\tmsg  = \"This may create > 1000 parts, severely degrading backup/restore performance.\"\n        \" See http://wiki.zmanda.com/index.php/Splitsize_too_small for more information.\";\n    } else if (message->code == 2800065) {\n\tmsg  = \"part-cache-max-size of %{size:part_size_max_size} < 0.1%% of tape length\";\n    } else if (message->code == 2800066) {\n\tmsg  = \"holding dir '%{holding_dir}' (%{errnostr})\";\n\thint = \"you must create a directory\";\n    } else if (message->code == 2800067) {\n\tmsg  = \"holding disk '%{holding_dir}': not writable: %{errnostr}\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800068) {\n\tmsg  = \"Check permissions\";\n    } else if (message->code == 2800069) {\n\tmsg  = \"holding disk '%{holding_dir}': not searcheable: %{errnostr}\";\n\thint = \"check permissions of ancestors\";\n    } else if (message->code == 2800070) {\n\tmsg  = \"Check permissions of ancestors of\";\n    } else if (message->code == 2800071) {\n\tmsg  = \"WARNING: holding disk '%{holding_dir}': no space available (%{size:size} requested)\";\n    } else if (message->code == 2800072) {\n\tmsg  = \"WARNING: holding disk '%{holding_dir}': only %{size:avail} available (%{size:requested} requested)\";\n    } else if (message->code == 2800073) {\n\tmsg = \"Holding disk '%{holding_dir}': %{size:avail} disk space available, using %{size:requested} as requested\";\n    } else if (message->code == 2800074) {\n\tmsg  = \"holding disk '%{holding_dir}': only %{size:avail} free, using nothing\";\n    } else if (message->code == 2800075) {\n\tmsg = \"Not enough free space specified in amanda.conf\";\n    } else if (message->code == 2800076) {\n\tmsg  = \"Holding disk '%{holding_dir}': %{size:avail} disk space available, using %{size:using}\";\n    } else if (message->code == 2800077) {\n\tmsg  = \"logdir '%{logdir}' (%{errnostr})\";\n\thint = \"you must create directory\";\n    } else if (message->code == 2800078) {\n\tmsg  = \"log dir '%{logdir}' (%{errnostr}): not writable\";\n    } else if (message->code == 2800079) {\n\tmsg  = \"oldlog directory '%{olddir}' is not a directory\";\n\thint = \"remove the entry and create a new directory\";\n    } else if (message->code == 2800080) {\n\tmsg  = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800081) {\n\tmsg  = \"oldlog dir '%{oldlogdir}' (%{errnostr}): not writable\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800082) {\n\tmsg  = \"Check permissions\";\n    } else if (message->code == 2800083) {\n\tmsg  = \"oldlog directory '%{oldlogdir}' (%{errnostr}) is not a directory\";\n\thint = \"remove the entry and create a new directory\";\n    } else if (message->code == 2800084) {\n\tmsg  = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800085) {\n\tmsg  = \"skipping tape test because amdump or amflush seem to be running\";\n\thint = \"if they are not, you must run amcleanup\";\n    } else if (message->code == 2800086) {\n\tmsg  = \"if they are not, you must run amcleanup\";\n    } else if (message->code == 2800087) {\n\tmsg  = \"amdump or amflush seem to be running\";\n\thint = \"if they are not, you must run amcleanup\";\n    } else if (message->code == 2800088) {\n\tmsg  = \"if they are not, you must run amcleanup\";\n    } else if (message->code == 2800089) {\n\tmsg  = \"skipping tape checks\";\n    } else if (message->code == 2800090) {\n\tmsg  = \"tapecycle (%{tapecycle}) <= runspercycle (%{runspercycle}\";\n    } else if (message->code == 2800091) {\n\tmsg  = \"tapecycle (%{tapecycle}) <= runtapes (%{runtapes})\";\n    } else if (message->code == 2800092) {\n\tmsg  = \"conf info dir '%{infodir}' does not exist\";\n\thint = \"it will be created on the next run\";\n    } else if (message->code == 2800093) {\n\tmsg  = \"it will be created on the next run.\";\n    } else if (message->code == 2800094) {\n\tmsg  = \"conf info dir '%{infodir}' (%{errnostr})\";\n    } else if (message->code == 2800095) {\n\tmsg  = \"info dir '%{infodir}': not a directory\";\n\thint = \"remove the entry and create a new directory\";\n    } else if (message->code == 2800096) {\n\tmsg  = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800097) {\n\tmsg  = \"info dir '{infodir}' (%{errnostr}): not writable\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800098) {\n\tmsg  = \"Check permissions\";\n    } else if (message->code == 2800099) {\n\tmsg  = \"Can't copy infofile: %{errmsg}\";\n    } else if (message->code == 2800100) {\n\tmsg  = \"host info dir '%{hostinfodir}' does not exist\";\n\thint = \"It will be created on the next run\";\n    } else if (message->code == 2800101) {\n\tmsg  = \"it will be created on the next run\";\n    } else if (message->code == 2800102) {\n\tmsg  = \"host info dir '%{hostinfodir}' (%{errnostr})\";\n    } else if (message->code == 2800103) {\n\tmsg  = \"info dir '%{hostinfodir}': not a directory\";\n\thint = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800104) {\n\tmsg  = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800105) {\n\tmsg  = \"info dir '%{hostinfodir}': not writable\";\n\thint = \"Check permissions\";\n    } else if (message->code == 2800106) {\n\tmsg  = \"Check permissions\";\n    } else if (message->code == 2800107) {\n\tmsg  = \"info dir '%{diskdir}' does not exist\";\n\thint = \"it will be created on the next run\";\n    } else if (message->code == 2800108) {\n\tmsg  = \"it will be created on the next run.\";\n    } else if (message->code == 2800109) {\n\tmsg  = \"info dir '%{diskdir}' (%{errnostr})\";\n    } else if (message->code == 2800110) {\n\tmsg  = \"info dir '%{diskdir}': not a directory\";\n\thint = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800111) {\n\tmsg  = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800112) {\n\tmsg  = \"info dir '%{diskdir}': not writable\";\n\thint = \"Check permissions\";\n    } else if (message->code == 2800113) {\n\tmsg  = \"Check permissions\";\n    } else if (message->code == 2800114) {\n\tmsg  = \"info file '%{infofile}' does not exist\";\n\thint = \"it will be created on the next run\";\n    } else if (message->code == 2800115) {\n\tmsg  = \"it will be created on the next run\";\n    } else if (message->code == 2800116) {\n\tmsg  = \"info dir '%{diskdir}' (%{errnostr})\";\n    } else if (message->code == 2800117) {\n\tmsg  = \"info file '%{infofile}': not a file\";\n\thint = \"remove the entry and create a new file\";\n    } else if (message->code == 2800118) {\n\tmsg  = \"Remove the entry and create a new file\";\n    } else if (message->code == 2800119) {\n\tmsg  = \"info file '%{infofile}': not readable\";\n\thint = \"Check permissions\";\n    } else if (message->code == 2800120) {\n\tmsg  = \"index dir '%{indexdir}' does not exist\";\n\thint = \"it will be created on the next run\";\n    } else if (message->code == 2800121) {\n\tmsg  = \"it will be created on the next run.\";\n    } else if (message->code == 2800122) {\n\tmsg  = \"index dir '%{indexdir}' (%{errnostr})\";\n    } else if (message->code == 2800123) {\n\tmsg  = \"index dir '%{indexdir}': not a directory\";\n\thint = \"remove the entry and create a new directory\";\n    } else if (message->code == 2800124) {\n\tmsg  = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800125) {\n\tmsg  = \"index dir '%{indexdir}': not writable\";\n    } else if (message->code == 2800126) {\n\tmsg  = \"index dir '%{hostindexdir}' does not exist\";\n\thint = \"it will be created on the next run\";\n    } else if (message->code == 2800127) {\n\tmsg  = \"it will be created on the next run.\";\n    } else if (message->code == 2800128) {\n\tmsg  = \"index dir '%{hostindexdir}' (%{errnostr})\";\n    } else if (message->code == 2800129) {\n\tmsg  = \"index dir '%{hostindexdir}': not a directory\";\n\thint = \"remove the entry and create a new directory\";\n    } else if (message->code == 2800130) {\n\tmsg  = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800131) {\n\tmsg  = \"index dir '%{hostindexdir}': not writable\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800132) {\n\tmsg  = \"index dir '%{diskindexdir}' does not exist\";\n\thint = \"it will be created on the next run\";\n    } else if (message->code == 2800133) {\n\tmsg  = \"it will be created on the next run.\";\n    } else if (message->code == 2800134) {\n\tmsg  = \"index dir '%{diskindexdir}' (%{errnostr})\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800135) {\n\tmsg  = \"index dir '%{diskindexdir}': not a directory\";\n\thint = \"remove the entry and create a new directory\";\n    } else if (message->code == 2800136) {\n\tmsg  = \"Remove the entry and create a new directory\";\n    } else if (message->code == 2800137) {\n\tmsg  = \"index dir '%{diskindexdir}': is not writable\";\n\thint = \"check permissions\";\n    } else if (message->code == 2800138) {\n\tmsg  = \"server encryption program not specified\";\n\thint = \"Specify \\\"server-custom-encrypt\\\" in the dumptype\";\n    } else if (message->code == 2800139) {\n\tmsg  = \"Specify \\\"server-custom-encrypt\\\" in the dumptype\";\n    } else if (message->code == 2800140) {\n\tmsg  = \"'%{program}' is not executable, server encryption will not work\";\n\thint = \"check file type\";\n    } else if (message->code == 2800141) {\n\tmsg  = \"Check file type\";\n    } else if (message->code == 2800142) {\n\tmsg  = \"server custom compression program not specified\";\n\thint = \"Specify \\\"server-custom-compress\\\" in the dumptype\";\n    } else if (message->code == 2800143) {\n\tmsg  = \"Specify \\\"server-custom-compress\\\" in the dumptype\";\n    } else if (message->code == 2800144) {\n\tmsg  = \"'%{program}' is not executable, server custom compression will not work\";\n\thint = \"check file type\";\n    } else if (message->code == 2800145) {\n\tmsg  = \"Check file type\";\n    } else if (message->code == 2800146) {\n\tmsg  = \"%{hostname} %{diskname}: tape-splitsize > tape size\";\n    } else if (message->code == 2800147) {\n\tmsg  = \"%{hostname} %{diskname}: fallback-splitsize > total available memory\";\n    } else if (message->code == 2800148) {\n\tmsg  = \"%{hostname} %{diskname}: fallback-splitsize > tape size\";\n    } else if (message->code == 2800149) {\n\tmsg  = \"%{hostname} %{diskname}: tape-splitsize of %{size:tape_splitsize} < 0.1%% of tape length\";\n    } else if (message->code == 2800151) {\n\tmsg  = \"%{hostname} %{diskname}: fallback-splitsize of %{size:fallback_splitsize} < 0.1%% of tape length\";\n    } else if (message->code == 2800153) {\n\tmsg  = \"%{hostname} %{diskname}: Can't compress directtcp data-path\";\n    } else if (message->code == 2800154) {\n\tmsg  = \"%{hostname} %{diskname}: Can't encrypt directtcp data-path\";\n    } else if (message->code == 2800155) {\n\tmsg  = \"%{hostname} %{diskname}: Holding disk can't be use for directtcp data-path\";\n    } else if (message->code == 2800156) {\n\tmsg  = \"%{hostname} %{diskname}: data-path is DIRECTTCP but device do not support it\";\n    } else if (message->code == 2800157) {\n\tmsg  = \"%{hostname} %{diskname}: data-path is AMANDA but device do not support it\";\n    } else if (message->code == 2800158) {\n\tmsg  = \"%{hostname} %{diskname}: Can't run pre-host-backup script on client\";\n    } else if (message->code == 2800159) {\n\tmsg  = \"%{hostname} %{diskname}: Can't run post-host-backup script on client\";\n    } else if (message->code == 2800160) {\n\tmsg  = \"Server check took %{seconds} seconds\";\n    } else if (message->code == 2800161) {\n\tmsg  = \"Client %{hostname} does not support selfcheck REQ packet\";\n\thint = \"Client might be of a very old version\";\n    } else if (message->code == 2800162) {\n\tmsg  = \"Client might be of a very old version\";\n    } else if (message->code == 2800163) {\n\tmsg  = \"Client %{hostname} does not support selfcheck REP packet\";\n\thint = \"Client might be of a very old version\";\n    } else if (message->code == 2800164) {\n\tmsg  = \"Client might be of a very old version\";\n    } else if (message->code == 2800165) {\n\tmsg  = \"Client %{hostname} does not support sendsize REQ packet\";\n\thint = \"Client might be of a very old version\";\n    } else if (message->code == 2800166) {\n\tmsg  = \"Client might be of a very old version\";\n    } else if (message->code == 2800167) {\n\tmsg  = \"Client %{hostname} does not support sendsize REP packet\";\n\thint = \"Client might be of a very old version\";\n    } else if (message->code == 2800168) {\n\tmsg  = \"Client might be of a very old version\";\n    } else if (message->code == 2800169) {\n\tmsg  = \"Client %{hostname} does not support sendbackup REQ packet\";\n\thint = \"Client might be of a very old version\";\n    } else if (message->code == 2800170) {\n\tmsg  = \"Client might be of a very old version\";\n    } else if (message->code == 2800171) {\n\tmsg  = \"Client %{hostname} does not support sendbackup REP packet\";\n\thint = \"Client might be of a very old version\";\n    } else if (message->code == 2800172) {\n\tmsg  = \"Client might be of a very old version\";\n    } else if (message->code == 2800173) {\n\tmsg  = \"%{hostname}:%{diskname} %{errstr}\";\n    } else if (message->code == 2800174) {\n\tmsg  = \"%{hostname}:%{diskname} (%{device}) host does not support quoted text\";\n\thint = \"You must upgrade amanda on the client to \"\n                                    \"specify a quoted text/device in the disklist, \"\n                                    \"or don't use quoted text for the device\";\n    } else if (message->code == 2800175) {\n\tmsg  = \"You must upgrade amanda on the client to \"\n                                    \"specify a quoted text/device in the disklist, \"\n                                    \"or don't use quoted text for the device\";\n    } else if (message->code == 2800176) {\n\tmsg  = \"%{hostname}:%{diskname} (%{device}): selfcheck does not support device\";\n\thint = \"You must upgrade amanda on the client to \"\n                                    \"specify a diskdevice in the disklist \"\n                                    \"or don't specify a diskdevice in the disklist\";\n    } else if (message->code == 2800177) {\n\tmsg  = \"You must upgrade amanda on the client to \"\n                                    \"specify a diskdevice in the disklist \"\n                                    \"or don't specify a diskdevice in the disklist\";\n    } else if (message->code == 2800178) {\n\tmsg  = \"%{hostname}:%{diskname} (%{device}): sendsize does not support device\";\n\thint = \"You must upgrade amanda on the client to \"\n                                    \"specify a diskdevice in the disklist\"\n                                    \"or don't specify a diskdevice in the disklist\";\n    } else if (message->code == 2800179) {\n\tmsg  = \"You must upgrade amanda on the client to \"\n                                    \"specify a diskdevice in the disklist\"\n                                    \"or don't specify a diskdevice in the disklist\";\n    } else if (message->code == 2800180) {\n\tmsg  = \"%{hostname}:%{diskname} (%{device}): sendbackup does not support device\";\n\thint = \"You must upgrade amanda on the client to \"\n                                    \"specify a diskdevice in the disklist\"\n                                    \"or don't specify a diskdevice in the disklist\";\n    } else if (message->code == 2800181) {\n\tmsg  = \"You must upgrade amanda on the client to \"\n                                    \"specify a diskdevice in the disklist\"\n                                    \"or don't specify a diskdevice in the disklist\";\n    } else if (message->code == 2800182) {\n\tmsg  = \"Client %{hostname} does not support %{data-path} data-path\";\n    } else if (message->code == 2800183) {\n\tmsg  = \"Client %{hostname} does not support directtcp data-path\";\n    } else if (message->code == 2800184) {\n\tmsg  = \"%{hostname}:%{diskname} does not support DUMP\";\n\thint = \"You must upgrade amanda on the client to use DUMP \"\n                                    \"or you can use another program\";\n    } else if (message->code == 2800185) {\n\tmsg  = \"You must upgrade amanda on the client to use DUMP \"\n                                    \"or you can use another program\";\n    } else if (message->code == 2800186) {\n\tmsg  = \"%{hostname}:%{diskname} does not support GNUTAR\";\n\thint = \"You must upgrade amanda on the client to use GNUTAR \"\n                                    \"or you can use another program\";\n    } else if (message->code == 2800187) {\n\tmsg  = \"You must upgrade amanda on the client to use GNUTAR \"\n                                    \"or you can use another program\";\n    } else if (message->code == 2800188) {\n\tmsg  = \"%{hostname}:%{diskname} does not support CALCSIZE for estimate, using CLIENT\";\n\thint = \"You must upgrade amanda on the client to use \"\n                                    \"CALCSIZE for estimate or don't use CALCSIZE for estimate\";\n    } else if (message->code == 2800189) {\n\tmsg  = \"You must upgrade amanda on the client to use \"\n                                    \"CALCSIZE for estimate or don't use CALCSIZE for estimate\";\n    } else if (message->code == 2800180) {\n\tmsg  = \"Client %{hostname} does not support custom compression\";\n\thint = \"You must upgrade amanda on the client to use custom compression\\n\"\n\t       \"Otherwise you can use the default client compression program\";\n    } else if (message->code == 2800191) {\n\tmsg  = \"You must upgrade amanda on the client to use custom compression\";\n    } else if (message->code == 2800192) {\n\tmsg  = \"Otherwise you can use the default client compression program\";\n    } else if (message->code == 2800193) {\n\tmsg  = \"Client %{hostname} does not support data encryption\";\n\thint = \"You must upgrade amanda on the client to use encryption program\";\n    } else if (message->code == 2800194) {\n\tmsg  = \"You must upgrade amanda on the client to use encryption program\";\n    } else if (message->code == 2800195) {\n\tmsg  = \"%{hostname}: Client encryption with server compression is not supported\";\n\thint = \"See amanda.conf(5) for detail\";\n    } else if (message->code == 2800196) {\n\tmsg  = \"%{hostname}:%{diskname} does not support APPLICATION-API\";\n\thint = \"Dumptype configuration is not GNUTAR or DUMP. It is case sensitive\";\n    } else if (message->code == 2800197) {\n\tmsg  = \"Dumptype configuration is not GNUTAR or DUMP. It is case sensitive\";\n    } else if (message->code == 2800198) {\n\tmsg  = \"application '%{application}' not found\";\n    } else if (message->code == 2800199) {\n\tmsg  = \"%{hostname}:%{diskname} does not support client-name in application\";\n    } else if (message->code == 2800200) {\n\tmsg  = \"%{hostname}:%{diskname} does not support SCRIPT-API\";\n    } else if (message->code == 2800201) {\n\tmsg  = \"WARNING: %{hostname}:%{diskname} does not support client-name in script\";\n    } else if (message->code == 2800202) {\n\tmsg  = \"Amanda Backup Client Hosts Check\";\n    } else if (message->code == 2800203) {\n\tmsg  = \"--------------------------------\";\n    } else if (message->code == 2800204) {\n\tint hostcount = atoi(message_get_argument(message, \"hostcount\"));\n\tint remote_errors = atoi(message_get_argument(message, \"remote_errors\"));\n\tchar *a = plural(\"Client check: %{hostcount} host checked in %{seconds} seconds.\",\n                         \"Client check: %{hostcount} hosts checked in %{seconds} seconds.\",\n                         hostcount);\n\tchar *b = plural(\"  %{remote_errors} problem found.\",\n                         \"  %{remote_errors} problems found.\",\n                         remote_errors);\n\tmsg  = g_strdup_printf(\"%s%s\", a, b);\n    } else if (message->code == 2800206) {\n\tmsg  = \"%{hostname}: selfcheck request failed: %{errstr}\";\n    } else if (message->code == 2800207) {\n\tmsg  = \"%{hostname}: bad features value: '%{features}'\";\n\thint = \"The amfeature in the reply packet is invalid\";\n    } else if (message->code == 2800208) {\n\tmsg  = \"The amfeature in the reply packet is invalid\";\n    } else if (message->code == 2800209) {\n\tmsg  = \"%{dle_hostname}\";\n    } else if (message->code == 2800210) {\n\tmsg  = \"%{ok_line}\";\n    } else if (message->code == 2800211) {\n\tmsg  = \"%{type}%{hostname}: %{errstr}\";\n    } else if (message->code == 2800212) {\n\tmsg  = \"%{hostname}: unknown response: %{errstr}\";\n    } else if (message->code == 2800213) {\n\tmsg  = \"Could not find security driver '%{auth}' for host '%{hostname}'. auth for this dle is invalid\";\n    } else if (message->code == 2800214) {\n    } else if (message->code == 2800215) {\n\tmsg  = \"amanda.conf has dump user configured to '%{dumpuser}', but that user does not exist\";\n    } else if (message->code == 2800216) {\n\tmsg  = \"cannot get username for running user, uid %{uid} is not in your user database\";\n    } else if (message->code == 2800217) {\n\tmsg  = \"must be executed as the '%{expected_user}' user instead of the '%{running_user}' user\";\n\thint = \"Change user to '%{expected_user}' or change dumpuser to '%{running_user}' in amanda.conf\";\n    } else if (message->code == 2800218) {\n\tmsg  = \"could not open temporary amcheck output file %{filename}: %{errnostr}\";\n\thint = \"Check permissions\";\n    } else if (message->code == 2800219) {\n\tmsg  = \"could not open amcheck output file %{filename}: %{errnostr}\";\n\thint = \"Check permissions\";\n    } else if (message->code == 2800220) {\n\tmsg = \"seek temp file: %{errnostr}\";\n    } else if (message->code == 2800221) {\n\tmsg = \"fseek main file: %{errnostr}\";\n    } else if (message->code == 2800222) {\n\tmsg = \"mailfd write: %{errnostr}\";\n    } else if (message->code == 2800223) {\n\tmsg = \"mailfd write: wrote %{size:write_size} instead of %{size:expected_size}\";\n    } else if (message->code == 2800224) {\n\tmsg = \"Can't fdopen: %{errnostr}\";\n    } else if (message->code == 2800225) {\n\tmsg = \"error running mailer %{mailer}: %{errmsg}\";\n    } else if (message->code == 2800226) {\n\tmsg = \"could not spawn a process for checking the server: %{errnostr}\";\n    } else if (message->code == 2800227) {\n\tmsg = \"nullfd: /dev/null: %{errnostr}\";\n    } else if (message->code == 2800228) {\n\tmsg = \"errors processing config file\";\n    } else if (message->code == 2800229) {\n\tmsg = \"Invalid mailto address '%{mailto}'\";\n    } else if (message->code == 2800230) {\n\tmsg = \"Can't open '%{filename}' for reading: %{errnostr}\";\n    } else if (message->code == 2800231) {\n\tmsg = \"Multiple DLE's for host '%{hostname}' use different auth methods\";\n\thint = \"Please ensure that all DLE's for the host use the same auth method, including skipped ones\";\n    } else if (message->code == 2800232) {\n\tmsg = \"Multiple DLE's for host '%{hostname}' use different maxdumps values\";\n\thint = \"Please ensure that all DLE's for the host use the same maxdumps value, including skipped ones\";\n    } else if (message->code == 2800233) {\n\tmsg = \"%{hostname} %{diskname}: The tag '%{tag}' match none of the storage dump_selection\";\n    } else if (message->code == 2800234) {\n\tmsg = \"%{hostname} %{diskname}: holdingdisk NEVER with tags matching more than one storage, will be dumped to only one storage\";\n    } else if (message->code == 2900000) {\n\tmsg = \"The Application '%{application}' failed: %{errmsg}\";\n    } else if (message->code == 2900001) {\n\tmsg = \"Can't execute application '%{application}'\";\n    } else if (message->code == 2900002) {\n\tmsg = \"The application '%{application}' does not support the '%{method}' method\";\n    } else if (message->code == 2900003) {\n\tmsg = \"%{service} only works with application\";\n    } else if (message->code == 2900004) {\n\tmsg = \"Missing OPTIONS line in %{service} request\";\n    } else if (message->code == 2900005) {\n\tmsg = \"Application '%{application}': can't create pipe\";\n    } else if (message->code == 2900006) {\n\tmsg = \"Can't dup2: %{errno} %{errnocode} %{errnostr}\";\n    } else if (message->code == 2900007) {\n\tmsg = \"%{service} require fe_req_xml\";\n    } else if (message->code == 2900008) {\n\tmsg = \"no valid %{service} request\";\n    } else if (message->code == 2900009) {\n\tmsg = \"no valid %{service} request\";\n    } else if (message->code == 2900010) {\n\tmsg = \"fork of '%{application} failed: %{errno} %{errnocode} %{errnostr}\";\n    } else if (message->code == 2900011) {\n\tmsg = \"Can't fdopen: %{errno} %{errnocode} %{errnostr}\";\n    } else if (message->code == 2900012) {\n\tmsg = \"%{application} failed: %{errmsg}\";\n    } else if (message->code == 2900013) {\n\tmsg = \"REQ XML error: %{errmsg}\";\n    } else if (message->code == 2900014) {\n\tmsg = \"One DLE required in XML REQ packet\";\n    } else if (message->code == 2900015) {\n\tmsg = \"Only one DLE allowed in XML REQ packet\";\n    } else if (message->code == 2900016) {\n\tmsg = \"Application '%{application}' (pid %{pid}) got signal %{signal}\";\n    } else if (message->code == 2900017) {\n\tmsg = \"Application '%{application}' (pid %{pid}) returned %{return_code}\";\n    } else if (message->code == 2900018) {\n\tmsg = \"%{name}: %{errmsg}\";\n\n    } else if (message->code == 3100005) {\n\tmsg = \"senddiscover result\";\n    } else if (message->code == 3100006) {\n\tmsg = \"no senddiscover result to list\";\n\n    } else if (message->code == 3600000) {\n\tmsg = \"version '%{version}\";\n    } else if (message->code == 3600001) {\n\tmsg = \"distro %{distro}\";\n    } else if (message->code == 3600002) {\n\tmsg = \"platform %{platform}\";\n    } else if (message->code == 3600003) {\n\tmsg = \"Multiple OPTIONS line in selfcheck input\";\n    } else if (message->code == 3600004) {\n\tmsg = \"OPTIONS features=%{features};hostname=%{hostname};\";\n    } else if (message->code == 3600005) {\n\tmsg = \"%{errstr}\";\n    } else if (message->code == 3600006) {\n\tmsg = \"Missing OPTIONS line in selfcheck input\";\n    } else if (message->code == 3600007) {\n\tmsg = \"FORMAT ERROR IN REQUEST PACKET %{err_extra}\";\n    } else if (message->code == 3600008) {\n\tmsg = \"FORMAT ERROR IN REQUEST PACKET\";\n    } else if (message->code == 3600009) {\n\tmsg = \"samba support only one exclude file\";\n    } else if (message->code == 3600010) {\n\tmsg = \"samba does not support exclude list\";\n    } else if (message->code == 3600011) {\n\tmsg = \"samba does not support include file\";\n    } else if (message->code == 3600012) {\n\tmsg = \"samba does not support include list\";\n    } else if (message->code == 3600013) {\n\tmsg = \"DUMP does not support exclude file\";\n    } else if (message->code == 3600014) {\n\tmsg = \"DUMP does not support exclude list\";\n    } else if (message->code == 3600015) {\n\tmsg = \"DUMP does not support include file\";\n    } else if (message->code == 3600016) {\n\tmsg = \"DUMP does not support include list\";\n    } else if (message->code == 3600017) {\n\tmsg = \"client configured for auth=%{auth} while server requested '%{auth-requested}'\";\n    } else if (message->code == 3600018) {\n\tmsg = \"The auth in ~/.ssh/authorized_keys should be \\\"--auth=ssh\\\", or use another auth for the DLE\";\n    } else if (message->code == 3600019) {\n\tmsg = \"The auth in the inetd/xinetd configuration must be the same as the DLE\";\n    } else if (message->code == 3600020) {\n\tmsg = \"%{device}: Can't use CALCSIZE for samba estimate, use CLIENT\";\n    } else if (message->code == 3600021) {\n\tmsg = \"%{device}: cannot parse for share/subdir disk entry\";\n    } else if (message->code == 3600022) {\n\tmsg = \"%{device}: subdirectory specified but samba is not v2 or better\";\n    } else if (message->code == 3600023) {\n\tmsg = \"%{device}: cannot find password\";\n    } else if (message->code == 3600024) {\n\tmsg = \"%{device}: password field not 'user%%pass'\";\n    } else if (message->code == 3600025) {\n\tmsg = \"%{device}: cannot make share name\";\n    } else if (message->code == 3600026) {\n\tmsg = \"%{device}: Cannot access /dev/null: %{errnostr}\";\n    } else if (message->code == 3600027) {\n\tmsg = \"%{device}: password write failed: %{errnostr}\";\n    } else if (message->code == 3600028) {\n\tmsg = \"%{device}: Can't fdopen ferr: %{errnostr}\";\n    } else if (message->code == 3600029) {\n\tmsg = \"%{device}: samba access error:\";\n    } else if (message->code == 3600030) {\n\tmsg = \"%{device}: This client is not configured for samba\";\n    } else if (message->code == 3600031) {\n\tmsg = \"%{device}: The DUMP program cannot handle samba shares, use the amsamba application\";\n    } else if (message->code == 3600032) {\n\tmsg = \"%{device}: Application '%{application}': %{errstr}\";\n    } else if (message->code == 3600033) {\n\tmsg = \"%{device}: Application '%{application}': can't run 'support' command\";\n    } else if (message->code == 3600034) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support amanda data-path\";\n    } else if (message->code == 3600035) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support directtcp data-path\";\n    } else if (message->code == 3600036) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support calcsize estimate\";\n    } else if (message->code == 3600037) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support include-file\";\n    } else if (message->code == 3600038) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support include-list\";\n    } else if (message->code == 3600039) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support optional include\";\n    } else if (message->code == 3600040) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support exclude-file\";\n    } else if (message->code == 3600041) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support exclude-list\";\n    } else if (message->code == 3600042) {\n\tmsg = \"%{device}: Application '%{application}': doesn't support optional exclude\";\n    } else if (message->code == 3600043) {\n\tmsg = \"%{device}: Application '%{application}': can't create pipe: %{errnostr}\";\n    } else if (message->code == 3600044) {\n\tmsg = \"%{device}: Application '%{application}': fork failed: %{errnostr}\";\n    } else if (message->code == 3600045) {\n\tmsg = \"%{device}: Can't execute '%{cmd}': %{errnostr}\";\n    } else if (message->code == 3600046) {\n\tmsg = \"%{device}: Can't fdopen app_stderr: %{errnostr}\";\n    } else if (message->code == 3600047) {\n\tmsg = \"%{device}: Application '%{application}': %{errstr}\";\n    } else if (message->code == 3600048) {\n\tmsg = \"%{device}: waitpid failed: %{errnostr}\";\n    } else if (message->code == 3600049) {\n\tmsg = \"%{device}: Application '%{application}': exited with signal %{signal}\";\n    } else if (message->code == 3600050) {\n\tmsg = \"%{device}: Application '%{application}': exited with status %{exit_status}\";\n    } else if (message->code == 3600051) {\n\tmsg = \"%{hostname}: Could not %{type} %{disk} (%{device}): %{errnostr}\";\n    } else if (message->code == 3600052) {\n\tmsg = \"%{disk}\";\n    } else if (message->code == 3600053) {\n\tmsg = \"%{amdevice}\";\n    } else if (message->code == 3600054) {\n\tmsg = \"%{device}\";\n    } else if (message->code == 3600055) {\n\tmsg = \"%{device}: Can't fdopen app_stdout: %{errnostr}\";\n    } else if (message->code == 3600056) {\n\tmsg = \"%{ok_line}\";\n    } else if (message->code == 3600057) {\n\tmsg = \"%{error_line}\";\n    } else if (message->code == 3600058) {\n\tmsg = \"%{errstr}\";\n    } else if (message->code == 3600059) {\n\tmsg = \"%{filename} is not a file\";\n    } else if (message->code == 3600060) {\n\tmsg = \"can not stat '%{filename}': %{errnostr}\";\n    } else if (message->code == 3600061) {\n\tmsg = \"%{dirname} is not a directory\";\n    } else if (message->code == 3600062) {\n\tmsg = \"can not stat '%{dirname}': %{errnostr}\";\n    } else if (message->code == 3600063) {\n\tmsg = \"can not %{noun} '%{ilename}': %{errnostr} (ruid:%{ruid} euid:%{euid})\";\n    } else if (message->code == 3600064) {\n\tmsg = \"%{filename} %{adjective} (ruid:%{ruid} euid:%{euid})\";\n    } else if (message->code == 3600065) {\n\tmsg = \"%{filename} is not owned by root\";\n    } else if (message->code == 3600066) {\n\tmsg = \"%{filename} is not SUID root\";\n    } else if (message->code == 3600067) {\n\tmsg = \"can not stat '%{filename}': %{errnostr}\";\n    } else if (message->code == 3600068) {\n\tmsg = \"cannot get filesystem usage for '%{dirname}: %{errnostr}\";\n    } else if (message->code == 3600069) {\n\tmsg = \"dir '%{dirname}' needs %{size:required}, has nothing available\";\n    } else if (message->code == 3600070) {\n\tmsg = \"dir '%{dirname}' needs %{size:required}, only has %{size:avail} available\";\n    } else if (message->code == 3600071) {\n\tmsg = \"dir '%{dirname}' has more than %{size:avail} available\";\n    } else if (message->code == 3600072) {\n\tmsg = \"DUMP program not available\";\n    } else if (message->code == 3600073) {\n\tmsg = \"RESTORE program not available\";\n    } else if (message->code == 3600074) {\n\tmsg = \"VDUMP program not available\";\n    } else if (message->code == 3600075) {\n\tmsg = \"VRESTORE program not available\";\n    } else if (message->code == 3600076) {\n\tmsg = \"XFSDUMP program not available\";\n    } else if (message->code == 3600077) {\n\tmsg = \"XFSRESTORE program not available\";\n    } else if (message->code == 3600078) {\n\tmsg = \"VXDUMP program not available\";\n    } else if (message->code == 3600079) {\n\tmsg = \"VXRESTORE program not available\";\n    } else if (message->code == 3600080) {\n\tmsg = \"GNUTAR program not available\";\n    } else if (message->code == 3600081) {\n\tmsg = \"SMBCLIENT program not available\";\n    } else if (message->code == 3600082) {\n\tmsg = \"/etc/amandapass is world readable!\";\n    } else if (message->code == 3600083) {\n\tmsg = \"/etc/amandapass is readable, but not by all\";\n    } else if (message->code == 3600084) {\n\tmsg = \"unable to stat /etc/amandapass: %{errnostr}\";\n    } else if (message->code == 3600085) {\n\tmsg = \"unable to open /etc/amandapass: %{errnostr}\";\n    } else if (message->code == 3600086) {\n\tmsg = \"dump will not be able to create the /etc/dumpdates file: %{errnostr}\";\n    } else if (message->code == 3600087) {\n\tmsg = \"%{device}: samba access error: %{errmsg}\";\n    } else if (message->code == 3600088) {\n\tmsg = \"file/dir '%{filename}' is not owned by root\";\n    } else if (message->code == 3600089) {\n\tmsg = \"file/dir '%{filename}' is writable by everyone\";\n    } else if (message->code == 3600090) {\n\tmsg = \"file/dir '%{filename}' is writable by the group\";\n    } else if (message->code == 3700000) {\n\tmsg = \"%{disk}\";\n    } else if (message->code == 3700001) {\n\tmsg = \"amgtar version %{version}\";\n    } else if (message->code == 3700002) {\n\tmsg = \"amgtar gtar-version %{gtar-version}\";\n    } else if (message->code == 3700003) {\n\tmsg = \"Can't get %{gtar-path} version\";\n    } else if (message->code == 3700004) {\n\tmsg = \"amgtar\";\n    } else if (message->code == 3700005) {\n\tmsg = \"GNUTAR program not available\";\n    } else if (message->code == 3700006) {\n\tmsg = \"No GNUTAR-LISTDIR\";\n    } else if (message->code == 3700007) {\n\tmsg = \"bad ONE-FILE-SYSTEM property value '%{value}'\";\n    } else if (message->code == 3700008) {\n\tmsg = \"bad SPARSE property value '%{value}'\";\n    } else if (message->code == 3700009) {\n\tmsg = \"bad ATIME-PRESERVE property value '%{value}'\";\n    } else if (message->code == 3700010) {\n\tmsg = \"bad CHECK-DEVICE property value '%{value}'\";\n    } else if (message->code == 3700011) {\n\tmsg = \"bad NO-UNQUOTE property value '%{value}'\";\n    } else if (message->code == 3700012) {\n\tmsg = \"Can't open disk '%{diskname}': %{errnostr}\";\n    } else if (message->code == 3700013) {\n\tmsg = \"Cannot stat the disk '%{diskname}': %{errnostr}\";\n\n    } else if (message->code == 4600000) {\n\tmsg = \"%{errmsg}\";\n    } else if (message->code == 4600001) {\n\tmsg = \"ERROR %{errmsg}\";\n\n    } else {\n\tmsg = \"no message for code '%{code}'\";\n    }\n\n    result = fix_message_string(message, want_quoted, msg);\n    if (want_quoted) {\n\tif (result) {\n\t    message->quoted_msg = g_string_free(result, FALSE);\n\t}\n    } else {\n\tif (result) {\n\t    message->msg = g_string_free(result, FALSE);\n\t}\n\tresult = fix_message_string(message, FALSE, hint);\n\tif (result) {\n\t    message->hint = g_string_free(result, FALSE);\n\t}\n    }\n}",
        "target": 1,
        "cwe": [
            "CWE-77"
        ],
        "project": "amanda",
        "commit_id": "29bae2e271093cd8d06ea98f73a474c685c5a314",
        "hash": 102052175607217112202478347877068970091,
        "size": 857,
        "message": "* application-src/ambsdtar.c, application-src/amgtar.c,\n  application-src/amstar.c: Filter option from COMMAND-OPTIONS\n* common-src/ammessage.c: Add message.\n\n\ngit-svn-id: https://svn.code.sf.net/p/amanda/code/amanda/trunk@6483 a8d146d6-cc15-0410-8900-af154a0219e0"
    },
    {
        "func": "static bool is_sb_event(struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\n\tif (event->parent)\n\t\treturn false;\n\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\treturn false;\n\n\tif (attr->mmap || attr->mmap_data || attr->mmap2 ||\n\t    attr->comm || attr->comm_exec ||\n\t    attr->task ||\n\t    attr->context_switch)\n\t\treturn true;\n\treturn false;\n}",
        "target": 0,
        "cwe": [
            "CWE-362",
            "CWE-125"
        ],
        "project": "linux",
        "commit_id": "321027c1fe77f892f4ea07846aeae08cefbbb290",
        "hash": 64389704270349549641772613941567805043,
        "size": 17,
        "message": "perf/core: Fix concurrent sys_perf_event_open() vs. 'move_group' race\n\nDi Shen reported a race between two concurrent sys_perf_event_open()\ncalls where both try and move the same pre-existing software group\ninto a hardware context.\n\nThe problem is exactly that described in commit:\n\n  f63a8daa5812 (\"perf: Fix event->ctx locking\")\n\n... where, while we wait for a ctx->mutex acquisition, the event->ctx\nrelation can have changed under us.\n\nThat very same commit failed to recognise sys_perf_event_context() as an\nexternal access vector to the events and thereby didn't apply the\nestablished locking rules correctly.\n\nSo while one sys_perf_event_open() call is stuck waiting on\nmutex_lock_double(), the other (which owns said locks) moves the group\nabout. So by the time the former sys_perf_event_open() acquires the\nlocks, the context we've acquired is stale (and possibly dead).\n\nApply the established locking rules as per perf_event_ctx_lock_nested()\nto the mutex_lock_double() for the 'move_group' case. This obviously means\nwe need to validate state after we acquire the locks.\n\nReported-by: Di Shen (Keen Lab)\nTested-by: John Dias <joaodias@google.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Alexander Shishkin <alexander.shishkin@linux.intel.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Kees Cook <keescook@chromium.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Min Chong <mchong@google.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nFixes: f63a8daa5812 (\"perf: Fix event->ctx locking\")\nLink: http://lkml.kernel.org/r/20170106131444.GZ3174@twins.programming.kicks-ass.net\nSigned-off-by: Ingo Molnar <mingo@kernel.org>"
    },
    {
        "func": "static void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}",
        "target": 0,
        "cwe": [
            "CWE-416",
            "CWE-125"
        ],
        "project": "FreeRDP",
        "commit_id": "2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6",
        "hash": 165539780088458940009859887807905907675,
        "size": 14,
        "message": "Fixed CVE-2018-8789\n\nThanks to Eyal Itkin from Check Point Software Technologies."
    },
    {
        "func": "static NOINLINE int send_renew(uint32_t xid, uint32_t server, uint32_t ciaddr)\n{\n\tstruct dhcp_packet packet;\n\tstruct in_addr temp_addr;\n\n/*\n * RFC 2131 4.3.2 DHCPREQUEST message\n * ...\n * DHCPREQUEST generated during RENEWING state:\n *\n * 'server identifier' MUST NOT be filled in, 'requested IP address'\n * option MUST NOT be filled in, 'ciaddr' MUST be filled in with\n * client's IP address. In this situation, the client is completely\n * configured, and is trying to extend its lease. This message will\n * be unicast, so no relay agents will be involved in its\n * transmission.  Because 'giaddr' is therefore not filled in, the\n * DHCP server will trust the value in 'ciaddr', and use it when\n * replying to the client.\n */\n\t/* Fill in: op, htype, hlen, cookie, chaddr fields,\n\t * random xid field (we override it below),\n\t * client-id option (unless -C), message type option:\n\t */\n\tinit_packet(&packet, DHCPREQUEST);\n\n\tpacket.xid = xid;\n\tpacket.ciaddr = ciaddr;\n\n\t/* Add options: maxsize,\n\t * optionally: hostname, fqdn, vendorclass,\n\t * \"param req\" option according to -O, and options specified with -x\n\t */\n\tadd_client_options(&packet);\n\n\ttemp_addr.s_addr = server;\n\tbb_error_msg(\"sending renew to %s\", inet_ntoa(temp_addr));\n\treturn bcast_or_ucast(&packet, ciaddr, server);\n}",
        "target": 0,
        "cwe": [
            "CWE-125"
        ],
        "project": "busybox",
        "commit_id": "6d3b4bb24da9a07c263f3c1acf8df85382ff562c",
        "hash": 192216650192534646511779935224127282434,
        "size": 38,
        "message": "udhcpc: check that 4-byte options are indeed 4-byte, closes 11506\n\nfunction                                             old     new   delta\nudhcp_get_option32                                     -      27     +27\nudhcp_get_option                                     231     248     +17\n------------------------------------------------------------------------------\n(add/remove: 1/0 grow/shrink: 1/0 up/down: 44/0)               Total: 44 bytes\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>"
    },
    {
        "func": "static CURLcode findprotocol(struct SessionHandle *data,\n                             struct connectdata *conn,\n                             const char *protostr)\n{\n  const struct Curl_handler * const *pp;\n  const struct Curl_handler *p;\n\n  /* Scan protocol handler table and match against 'protostr' to set a few\n     variables based on the URL. Now that the handler may be changed later\n     when the protocol specific setup function is called. */\n  for(pp = protocols; (p = *pp) != NULL; pp++) {\n    if(Curl_raw_equal(p->scheme, protostr)) {\n      /* Protocol found in table. Check if allowed */\n      if(!(data->set.allowed_protocols & p->protocol))\n        /* nope, get out */\n        break;\n\n      /* it is allowed for \"normal\" request, now do an extra check if this is\n         the result of a redirect */\n      if(data->state.this_is_a_follow &&\n         !(data->set.redir_protocols & p->protocol))\n        /* nope, get out */\n        break;\n\n      /* Perform setup complement if some. */\n      conn->handler = conn->given = p;\n\n      /* 'port' and 'remote_port' are set in setup_connection_internals() */\n      return CURLE_OK;\n    }\n  }\n\n\n  /* The protocol was not found in the table, but we don't have to assign it\n     to anything since it is already assigned to a dummy-struct in the\n     create_conn() function when the connectdata struct is allocated. */\n  failf(data, \"Protocol \\\"%s\\\" not supported or disabled in \" LIBCURL_NAME,\n        protostr);\n\n  return CURLE_UNSUPPORTED_PROTOCOL;\n}",
        "target": 0,
        "cwe": [
            "CWE-200"
        ],
        "project": "curl",
        "commit_id": "b3875606925536f82fc61f3114ac42f29eaf6945",
        "hash": 235410384733787586497579864857492751737,
        "size": 41,
        "message": "curl_easy_duphandle: CURLOPT_COPYPOSTFIELDS read out of bounds\n\nWhen duplicating a handle, the data to post was duplicated using\nstrdup() when it could be binary and contain zeroes and it was not even\nzero terminated! This caused read out of bounds crashes/segfaults.\n\nSince the lib/strdup.c file no longer is easily shared with the curl\ntool with this change, it now uses its own version instead.\n\nBug: http://curl.haxx.se/docs/adv_20141105.html\nCVE: CVE-2014-3707\nReported-By: Symeon Paraschoudis"
    },
    {
        "func": "static void GTextFieldDrawDDCursor(GTextField *gt, int pos) {\n    GRect old;\n    int x, y, l;\n\n    l = GTextFieldFindLine(gt,pos);\n    if ( l<gt->loff_top || l>=gt->loff_top + (gt->g.inner.height/gt->fh))\nreturn;\n    _gt_cursor_pos(gt,pos,&x,&y);\n    if ( x<0 || x>=gt->g.inner.width )\nreturn;\n\n    GDrawPushClip(gt->g.base,&gt->g.inner,&old);\n    GDrawSetDifferenceMode(gt->g.base);\n    GDrawSetFont(gt->g.base,gt->font);\n    GDrawSetLineWidth(gt->g.base,0);\n    GDrawSetDashedLine(gt->g.base,2,2,0);\n    GDrawDrawLine(gt->g.base,gt->g.inner.x+x,gt->g.inner.y+y,\n\t    gt->g.inner.x+x,gt->g.inner.y+y+gt->fh,\n\t    COLOR_WHITE);\n    GDrawPopClip(gt->g.base,&old);\n    GDrawSetDashedLine(gt->g.base,0,0,0);\n    gt->has_dd_cursor = !gt->has_dd_cursor;\n    gt->dd_cursor_pos = pos;\n}",
        "target": 0,
        "cwe": [
            "CWE-119",
            "CWE-787"
        ],
        "project": "fontforge",
        "commit_id": "626f751752875a0ddd74b9e217b6f4828713573c",
        "hash": 195880771460868498804906864311465007981,
        "size": 24,
        "message": "Warn users before discarding their unsaved scripts (#3852)\n\n* Warn users before discarding their unsaved scripts\r\n\r\nThis closes #3846."
    },
    {
        "func": "static int gtextfield_mouse(GGadget *g, GEvent *event) {\n    GTextField *gt = (GTextField *) g;\n    GListField *ge = (GListField *) g;\n    unichar_t *end=NULL, *end1, *end2;\n    int i=0,ll,curlen;\n\n    if ( gt->hidden_cursor ) {\n\tGDrawSetCursor(gt->g.base,gt->old_cursor);\n\tgt->hidden_cursor = false;\n\t_GWidget_ClearGrabGadget(g);\n    }\n    if ( !g->takes_input || (g->state!=gs_enabled && g->state!=gs_active && g->state!=gs_focused ))\nreturn( false );\n    if ( event->type == et_crossing )\nreturn( false );\n    if ( gt->completionfield && ((GCompletionField *) gt)->choice_popup!=NULL &&\n\t    event->type==et_mousedown )\n\tGCompletionDestroy((GCompletionField *) gt);\n    if (( gt->listfield && event->u.mouse.x>=ge->buttonrect.x &&\n\t    event->u.mouse.x<ge->buttonrect.x+ge->buttonrect.width &&\n\t    event->u.mouse.y>=ge->buttonrect.y &&\n\t    event->u.mouse.y<ge->buttonrect.y+ge->buttonrect.height ) ||\n\t( gt->listfield && ge->popup!=NULL ))\nreturn( glistfield_mouse(ge,event));\n    if ( gt->numericfield && event->u.mouse.x>=ge->buttonrect.x &&\n\t    event->u.mouse.x<ge->buttonrect.x+ge->buttonrect.width &&\n\t    event->u.mouse.y>=ge->buttonrect.y &&\n\t    event->u.mouse.y<ge->buttonrect.y+ge->buttonrect.height )\nreturn( gnumericfield_mouse(gt,event));\n    if (( event->type==et_mouseup || event->type==et_mousedown ) &&\n\t    (event->u.mouse.button>=4 && event->u.mouse.button<=7)) {\n\tint isv = event->u.mouse.button<=5;\n\tif ( event->u.mouse.state&ksm_shift ) isv = !isv;\n\tif ( isv && gt->vsb!=NULL )\nreturn( GGadgetDispatchEvent(&gt->vsb->g,event));\n\telse if ( !isv && gt->hsb!=NULL )\nreturn( GGadgetDispatchEvent(&gt->hsb->g,event));\n\telse\nreturn( true );\n    }\n\n    if ( gt->pressed==NULL && event->type == et_mousemove && g->popup_msg!=NULL &&\n\t    GGadgetWithin(g,event->u.mouse.x,event->u.mouse.y))\n\tGGadgetPreparePopup(g->base,g->popup_msg);\n\n    curlen = u_strlen(gt->text);\n\n    if ( event->type == et_mousedown || gt->pressed ) {\n\ti = (event->u.mouse.y-g->inner.y)/gt->fh + gt->loff_top;\n\tif ( i<0 ) i = 0;\n\tif ( !gt->multi_line ) i = 0;\n\tif ( i>=gt->lcnt ) {\n\t    end = gt->text+curlen;\n\t    i = gt->lcnt - 1;\n\t    if (i < 0) i = 0; // Can lcnt ever be 0?\n\t} else\n\t    end = GTextFieldGetPtFromPos(gt,i,event->u.mouse.x);\n    }\n\n    if ( event->type == et_mousedown ) {\n\tint end8;\n\tif ( event->u.mouse.button==3 &&\n\t\tGGadgetWithin(g,event->u.mouse.x,event->u.mouse.y)) {\n\t    GTFPopupMenu(gt,event);\nreturn( true );\n\t}\n\n\tll = gt->lines8[i+1]==-1?-1:gt->lines8[i+1]-gt->lines8[i]-1;\n\tGDrawLayoutInit(gt->g.base,gt->utf8_text+gt->lines8[i],ll,NULL);\n\tend8 = GDrawLayoutXYToIndex(gt->g.base,event->u.mouse.x-g->inner.x+gt->xoff_left,0);\n\tend1 = end2 = gt->text + gt->lines[i] + utf82u_index(end8,gt->utf8_text+gt->lines8[i]);\n\n\tgt->wordsel = gt->linesel = false;\n\tif ( event->u.mouse.button==1 && event->u.mouse.clicks>=3 ) {\n\t    gt->sel_start = gt->lines[i]; gt->sel_end = gt->lines[i+1];\n\t    if ( gt->sel_end==-1 ) gt->sel_end = curlen;\n\t    gt->wordsel = false; gt->linesel = true;\n\t} else if ( event->u.mouse.button==1 && event->u.mouse.clicks==2 ) {\n\t    gt->sel_start = gt->sel_end = gt->sel_base = end-gt->text;\n\t    gt->wordsel = true;\n\t    GTextFieldSelectWords(gt,gt->sel_base);\n\t} else if ( end1-gt->text>=gt->sel_start && end2-gt->text<gt->sel_end &&\n\t\tgt->sel_start!=gt->sel_end &&\n\t\tevent->u.mouse.button==1 ) {\n\t    gt->drag_and_drop = true;\n\t    if ( !gt->hidden_cursor )\n\t\tgt->old_cursor = GDrawGetCursor(gt->g.base);\n\t    GDrawSetCursor(gt->g.base,ct_draganddrop);\n\t} else if ( /*event->u.mouse.button!=3 &&*/ !(event->u.mouse.state&ksm_shift) ) {\n\t    if ( event->u.mouse.button==1 )\n\t\tGTextFieldGrabPrimarySelection(gt);\n\t    gt->sel_start = gt->sel_end = gt->sel_base = end-gt->text;\n\t} else if ( end-gt->text>gt->sel_base ) {\n\t    gt->sel_start = gt->sel_base;\n\t    gt->sel_end = end-gt->text;\n\t} else {\n\t    gt->sel_start = gt->sel_base = gt->sel_end = end-gt->text;\n\t}\n\n\tif ( gt->pressed==NULL )\n\t    gt->pressed = GDrawRequestTimer(gt->g.base,200,100,NULL);\n\tif ( gt->sel_start > curlen )\t/* Ok to have selection at end, but beyond is an error */\n\t    fprintf( stderr, \"About to crash\\n\" );\n\t_ggadget_redraw(g);\nreturn( true );\n    } else if ( gt->pressed && (event->type == et_mousemove || event->type == et_mouseup )) {\n\tint refresh = true;\n\n\tif ( gt->drag_and_drop ) {\n\t    refresh = GTextFieldDoDrop(gt,event,end-gt->text);\n\t    // curlen may be inaccurate now, but we recalculate after this guard set.\n\t} else if ( gt->linesel ) {\n\t    int j;\n\t    for ( j=i; j>0 && gt->text[gt->lines[j]-1] != '\\n'; --j )\n\t\t;\n\t    gt->sel_start = gt->lines[j];\n\t    for ( j=i+1; gt->lines[j]!=-1 && gt->text[gt->lines[j]-1] != '\\n'; ++j )\n\t\t;\n\t    gt->sel_end = gt->lines[j]!=-1 ? gt->lines[j]-1 : curlen;\n\t} else if ( gt->wordsel )\n\t    GTextFieldSelectWords(gt,end-gt->text);\n\telse if ( event->u.mouse.button!=2 ) {\n\t    int e = end-gt->text;\n\t    if ( e>gt->sel_base ) {\n\t\tgt->sel_start = gt->sel_base; gt->sel_end = e;\n\t    } else {\n\t\tgt->sel_start = e; gt->sel_end = gt->sel_base;\n\t    }\n\t}\n\tif ( event->type==et_mouseup ) {\n\t    GDrawCancelTimer(gt->pressed); gt->pressed = NULL;\n\t    if ( event->u.mouse.button==2 )\n\t\tGTextFieldPaste(gt,sn_primary);\n\t    if ( gt->sel_start==gt->sel_end )\n\t\tGTextField_Show(gt,gt->sel_start);\n\t    GTextFieldChanged(gt,-1);\n\t    if ( gt->sel_start<gt->sel_end && _GDraw_InsCharHook!=NULL && !gt->donthook )\n\t\t(_GDraw_InsCharHook)(GDrawGetDisplayOfWindow(gt->g.base),\n\t\t\tgt->text[gt->sel_start]);\n\t}\n\tif ( gt->sel_end > u_strlen(gt->text) )\n\t    fprintf( stderr, \"About to crash\\n\" );\n\tif ( refresh )\n\t    _ggadget_redraw(g);\nreturn( true );\n    }\nreturn( false );\n}",
        "target": 0,
        "cwe": [
            "CWE-119",
            "CWE-787"
        ],
        "project": "fontforge",
        "commit_id": "626f751752875a0ddd74b9e217b6f4828713573c",
        "hash": 181769650376696665210923170273088306489,
        "size": 148,
        "message": "Warn users before discarding their unsaved scripts (#3852)\n\n* Warn users before discarding their unsaved scripts\r\n\r\nThis closes #3846."
    },
    {
        "func": "static int RsaMGF1(enum wc_HashType hType, byte* seed, word32 seedSz,\n                                        byte* out, word32 outSz, void* heap)\n{\n    byte* tmp;\n    /* needs to be large enough for seed size plus counter(4) */\n    byte  tmpA[WC_MAX_DIGEST_SIZE + 4];\n    byte   tmpF;     /* 1 if dynamic memory needs freed */\n    word32 tmpSz;\n    int hLen;\n    int ret;\n    word32 counter;\n    word32 idx;\n    hLen    = wc_HashGetDigestSize(hType);\n    counter = 0;\n    idx     = 0;\n\n    (void)heap;\n\n    /* check error return of wc_HashGetDigestSize */\n    if (hLen < 0) {\n        return hLen;\n    }\n\n    /* if tmp is not large enough than use some dynamic memory */\n    if ((seedSz + 4) > sizeof(tmpA) || (word32)hLen > sizeof(tmpA)) {\n        /* find largest amount of memory needed which will be the max of\n         * hLen and (seedSz + 4) since tmp is used to store the hash digest */\n        tmpSz = ((seedSz + 4) > (word32)hLen)? seedSz + 4: (word32)hLen;\n        tmp = (byte*)XMALLOC(tmpSz, heap, DYNAMIC_TYPE_RSA_BUFFER);\n        if (tmp == NULL) {\n            return MEMORY_E;\n        }\n        tmpF = 1; /* make sure to free memory when done */\n    }\n    else {\n        /* use array on the stack */\n        tmpSz = sizeof(tmpA);\n        tmp  = tmpA;\n        tmpF = 0; /* no need to free memory at end */\n    }\n\n    do {\n        int i = 0;\n        XMEMCPY(tmp, seed, seedSz);\n\n        /* counter to byte array appended to tmp */\n        tmp[seedSz]     = (byte)((counter >> 24) & 0xFF);\n        tmp[seedSz + 1] = (byte)((counter >> 16) & 0xFF);\n        tmp[seedSz + 2] = (byte)((counter >>  8) & 0xFF);\n        tmp[seedSz + 3] = (byte)((counter)       & 0xFF);\n\n        /* hash and append to existing output */\n        if ((ret = wc_Hash(hType, tmp, (seedSz + 4), tmp, tmpSz)) != 0) {\n            /* check for if dynamic memory was needed, then free */\n            if (tmpF) {\n                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);\n            }\n            return ret;\n        }\n\n        for (i = 0; i < hLen && idx < outSz; i++) {\n            out[idx++] = tmp[i];\n        }\n        counter++;\n    } while (idx < outSz);\n\n    /* check for if dynamic memory was needed, then free */\n    if (tmpF) {\n        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);\n    }\n\n    return 0;\n}",
        "target": 0,
        "cwe": [
            "CWE-310",
            "CWE-787"
        ],
        "project": "wolfssl",
        "commit_id": "fb2288c46dd4c864b78f00a47a364b96a09a5c0f",
        "hash": 240374952479055456730091939746304144514,
        "size": 73,
        "message": "RSA-PSS: Handle edge case with encoding message to hash\n\nWhen the key is small relative to the digest (1024-bit key, 64-byte\nhash, 61-byte salt length), the internal message to hash is larger than\nthe output size.\nAllocate a buffer for the message when this happens."
    },
    {
        "func": "static int _server_handle_vMustReplyEmpty(libgdbr_t *g) {\n\tif (send_ack (g) < 0) {\n\t\treturn -1;\n\t}\n\treturn send_msg (g, \"\");\n}",
        "target": 0,
        "cwe": [
            "CWE-703",
            "CWE-787"
        ],
        "project": "radare2",
        "commit_id": "796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191",
        "hash": 188157995348361195939568312538969106485,
        "size": 6,
        "message": "Fix ext2 buffer overflow in r2_sbu_grub_memmove"
    },
    {
        "func": "void Item::set_name(THD *thd, const char *str, uint length, CHARSET_INFO *cs)\n{\n  if (!length)\n  {\n    /* Empty string, used by AS or internal function like last_insert_id() */\n    name= (char*) str;\n    name_length= 0;\n    return;\n  }\n\n  const char *str_start= str;\n  if (!cs->ctype || cs->mbminlen > 1)\n  {\n    str+= cs->cset->scan(cs, str, str + length, MY_SEQ_SPACES);\n    length-= (uint)(str - str_start);\n  }\n  else\n  {\n    /*\n      This will probably need a better implementation in the future:\n      a function in CHARSET_INFO structure.\n    */\n    while (length && !my_isgraph(cs,*str))\n    {\t\t\t\t\t\t// Fix problem with yacc\n      length--;\n      str++;\n    }\n  }\n  if (str != str_start && !is_autogenerated_name)\n  {\n    char buff[SAFE_NAME_LEN];\n\n    strmake(buff, str_start,\n            MY_MIN(sizeof(buff)-1, length + (int) (str-str_start)));\n\n    if (length == 0)\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                          ER_NAME_BECOMES_EMPTY,\n                          ER_THD(thd, ER_NAME_BECOMES_EMPTY),\n                          buff);\n    else\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                          ER_REMOVED_SPACES, ER_THD(thd, ER_REMOVED_SPACES),\n                          buff);\n  }\n  if (!my_charset_same(cs, system_charset_info))\n  {\n    size_t res_length;\n    name= sql_strmake_with_convert(thd, str, length, cs,\n\t\t\t\t   MAX_ALIAS_NAME, system_charset_info,\n\t\t\t\t   &res_length);\n    name_length= res_length;\n  }\n  else\n    name= thd->strmake(str, (name_length= MY_MIN(length,MAX_ALIAS_NAME)));\n}",
        "target": 0,
        "cwe": [
            "CWE-89"
        ],
        "project": "server",
        "commit_id": "b5e16a6e0381b28b598da80b414168ce9a5016e5",
        "hash": 43882862378040007680133612310164382043,
        "size": 56,
        "message": "MDEV-26061 MariaDB server crash at Field::set_default\n\n* Item_default_value::fix_fields creates a copy of its argument's field.\n* Field::default_value is changed when its expression is prepared in\n  unpack_vcol_info_from_frm()\n\nThis means we must unpack any vcol expression that includes DEFAULT(x)\nstrictly after unpacking x->default_value.\n\nTo avoid building and solving this dependency graph on every table open,\nwe update Item_default_value::field->default_value after all vcols\nare unpacked and fixed."
    },
    {
        "func": "mb_regex_groups_iter(const OnigUChar* name, const OnigUChar* name_end, int ngroup_num, int* group_nums, regex_t* reg, void* parg)\n{\n\tmb_regex_groups_iter_args *args = (mb_regex_groups_iter_args *) parg;\n\tint gn, beg, end;\n\n\t/*\n\t * In case of duplicate groups, keep only the last succeeding one\n\t * to be consistent with preg_match with the PCRE_DUPNAMES option.\n\t */\n\tgn = onig_name_to_backref_number(reg, name, name_end, args->region);\n\tbeg = args->region->beg[gn];\n\tend = args->region->end[gn];\n\tif (beg >= 0 && beg < end && end <= args->search_len) {\n\t\tadd_assoc_stringl_ex(args->groups, (char *)name, name_end - name, &args->search_str[beg], end - beg);\n\t} else {\n\t\tadd_assoc_bool_ex(args->groups, (char *)name, name_end - name, 0);\n\t}\n\n\treturn 0;\n}",
        "target": 0,
        "cwe": [
            "CWE-125"
        ],
        "project": "php-src",
        "commit_id": "e617f03066ce81d26f56c06d6bd7787c7de08703",
        "hash": 185002587819755177423724961186492087021,
        "size": 20,
        "message": "Fix #77367: Negative size parameter in mb_split\n\nWhen adding the last element to the result value of `mb_split`, the\n`chunk_pos` may point beyond the end of the string, in which case the\nunsigned `n` would underflow.  Therefore, we check whether this is the\ncase in the first place, and only calculate `n` otherwise.  Since `n`\nis no longer used outside the block, we move its declaration inside."
    },
    {
        "func": "gboolean\nmono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n{\n\treturn TRUE;",
        "target": 0,
        "cwe": [
            "CWE-20"
        ],
        "project": "mono",
        "commit_id": "4905ef1130feb26c3150b28b97e4a96752e0d399",
        "hash": 213648723358266919023564267408018007362,
        "size": 4,
        "message": "Handle invalid instantiation of generic methods.\n\n\t* verify.c: Add new function to internal verifier API to check\n\tmethod instantiations.\n\n\t* reflection.c (mono_reflection_bind_generic_method_parameters):\n\tCheck the instantiation before returning it.\n\n\tFixes #655847"
    },
    {
        "func": "static unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}",
        "target": 0,
        "cwe": [
            "CWE-119",
            "CWE-787"
        ],
        "project": "linux",
        "commit_id": "0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd",
        "hash": 6952299071088195073926920648327169091,
        "size": 6,
        "message": "NLS: improve UTF8 -> UTF16 string conversion routine\n\nThe utf8s_to_utf16s conversion routine needs to be improved.  Unlike\nits utf16s_to_utf8s sibling, it doesn't accept arguments specifying\nthe maximum length of the output buffer or the endianness of its\n16-bit output.\n\nThis patch (as1501) adds the two missing arguments, and adjusts the\nonly two places in the kernel where the function is called.  A\nfollow-on patch will add a third caller that does utilize the new\ncapabilities.\n\nThe two conversion routines are still annoyingly inconsistent in the\nway they handle invalid byte combinations.  But that's a subject for a\ndifferent patch.\n\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nCC: Clemens Ladisch <clemens@ladisch.de>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>"
    },
    {
        "func": "bool has_fs_type(const char *path, fs_type_magic magic_val)\n{\n\tint ret;\n\tstruct statfs sb;\n\n\tret = statfs(path, &sb);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn is_fs_type(&sb, magic_val);\n}",
        "target": 0,
        "cwe": [
            "CWE-78"
        ],
        "project": "lxc",
        "commit_id": "6400238d08cdf1ca20d49bafb85f4e224348bf9d",
        "hash": 329188275802201869149758502908817808802,
        "size": 11,
        "message": "CVE-2019-5736 (runC): rexec callers as memfd\n\nAdam Iwaniuk and Borys Pop\u0142awski discovered that an attacker can compromise the\nrunC host binary from inside a privileged runC container. As a result, this\ncould be exploited to gain root access on the host. runC is used as the default\nruntime for containers with Docker, containerd, Podman, and CRI-O.\n\nThe attack can be made when attaching to a running container or when starting a\ncontainer running a specially crafted image.  For example, when runC attaches\nto a container the attacker can trick it into executing itself. This could be\ndone by replacing the target binary inside the container with a custom binary\npointing back at the runC binary itself. As an example, if the target binary\nwas /bin/bash, this could be replaced with an executable script specifying the\ninterpreter path #!/proc/self/exe (/proc/self/exec is a symbolic link created\nby the kernel for every process which points to the binary that was executed\nfor that process). As such when /bin/bash is executed inside the container,\ninstead the target of /proc/self/exe will be executed - which will point to the\nrunc binary on the host. The attacker can then proceed to write to the target\nof /proc/self/exe to try and overwrite the runC binary on the host. However in\ngeneral, this will not succeed as the kernel will not permit it to be\noverwritten whilst runC is executing. To overcome this, the attacker can\ninstead open a file descriptor to /proc/self/exe using the O_PATH flag and then\nproceed to reopen the binary as O_WRONLY through /proc/self/fd/<nr> and try to\nwrite to it in a busy loop from a separate process. Ultimately it will succeed\nwhen the runC binary exits. After this the runC binary is compromised and can\nbe used to attack other containers or the host itself.\n\nThis attack is only possible with privileged containers since it requires root\nprivilege on the host to overwrite the runC binary. Unprivileged containers\nwith a non-identity ID mapping do not have the permission to write to the host\nbinary and therefore are unaffected by this attack.\n\nLXC is also impacted in a similar manner by this vulnerability, however as the\nLXC project considers privileged containers to be unsafe no CVE has been\nassigned for this issue for LXC. Quoting from the\nhttps://linuxcontainers.org/lxc/security/ project's Security information page:\n\n\"As privileged containers are considered unsafe, we typically will not consider\nnew container escape exploits to be security issues worthy of a CVE and quick\nfix. We will however try to mitigate those issues so that accidental damage to\nthe host is prevented.\"\n\nTo prevent this attack, LXC has been patched to create a temporary copy of the\ncalling binary itself when it starts or attaches to containers. To do this LXC\ncreates an anonymous, in-memory file using the memfd_create() system call and\ncopies itself into the temporary in-memory file, which is then sealed to\nprevent further modifications. LXC then executes this sealed, in-memory file\ninstead of the original on-disk binary. Any compromising write operations from\na privileged container to the host LXC binary will then write to the temporary\nin-memory binary and not to the host binary on-disk, preserving the integrity\nof the host LXC binary. Also as the temporary, in-memory LXC binary is sealed,\nwrites to this will also fail.\n\nNote: memfd_create() was added to the Linux kernel in the 3.17 release.\n\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>\nCo-Developed-by: Alesa Sarai <asarai@suse.de>\nAcked-by: Serge Hallyn <serge@hallyn.com>\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>"
    },
    {
        "func": "int gdImageSelectiveBlur( gdImagePtr src)\n{\n\tint         x, y, i, j;\n\tfloat       new_r, new_g, new_b;\n\tint         new_pxl, cpxl, pxl, new_a=0;\n\tfloat flt_r [3][3];\n\tfloat flt_g [3][3];\n\tfloat flt_b [3][3];\n\tfloat flt_r_sum, flt_g_sum, flt_b_sum;\n\n\tgdImagePtr srcback;\n\ttypedef int (*FuncPtr)(gdImagePtr, int, int);\n\tFuncPtr f;\n\n\tif (src==NULL) {\n\t\treturn 0;\n\t}\n\t\n\t/* We need the orinal image with each safe neoghb. pixel */\n\tsrcback = gdImageCreateTrueColor (src->sx, src->sy);\n\tgdImageCopy(srcback, src,0,0,0,0,src->sx,src->sy);\n  \n\tif (srcback==NULL) {\n\t\treturn 0;\n\t}\n\n\tf = GET_PIXEL_FUNCTION(src);\n\n\tfor(y = 0; y<src->sy; y++) {\n\t\tfor (x=0; x<src->sx; x++) {\n\t\t      flt_r_sum = flt_g_sum = flt_b_sum = 0.0;\n\t\t\tcpxl = f(src, x, y); \n\n\t\t\tfor (j=0; j<3; j++) {\n\t\t\t\tfor (i=0; i<3; i++) {\n\t\t\t\t\tif ((j == 1) && (i == 1)) {\n\t\t\t\t\t\tflt_r[1][1] = flt_g[1][1] = flt_b[1][1] = 0.5;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpxl = f(src, x-(3>>1)+i, y-(3>>1)+j); \n\t\t\t\t\t\tnew_a = gdImageAlpha(srcback, pxl);\n\n\t\t\t\t\t\tnew_r = ((float)gdImageRed(srcback, cpxl)) - ((float)gdImageRed (srcback, pxl));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (new_r < 0.0f) {\n\t\t\t\t\t\t\tnew_r = -new_r;\n\t\t\t\t\t\t}\t\n\t\t\t\t\t\tif (new_r != 0) {\n\t\t\t\t\t\t\tflt_r[j][i] = 1.0f/new_r;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflt_r[j][i] = 1.0f;\n\t\t\t\t\t\t}\t\n\n\t\t\t\t\t\tnew_g = ((float)gdImageGreen(srcback, cpxl)) - ((float)gdImageGreen(srcback, pxl));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (new_g < 0.0f) {\n\t\t\t\t\t\t\tnew_g = -new_g;\n\t\t\t\t\t\t}\t\n\t\t\t\t\t\tif (new_g != 0) {\n\t\t\t\t\t\t\tflt_g[j][i] = 1.0f/new_g;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflt_g[j][i] = 1.0f;\n\t\t\t\t\t\t}\t\n\n\t\t\t\t\t\tnew_b = ((float)gdImageBlue(srcback, cpxl)) - ((float)gdImageBlue(srcback, pxl));\n\n\t\t\t\t\t\tif (new_b < 0.0f) {\n\t\t\t\t\t\t\tnew_b = -new_b;\n\t\t\t\t\t\t}\t\n\t\t\t\t\t\tif (new_b != 0) {\n\t\t\t\t\t\t\tflt_b[j][i] = 1.0f/new_b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflt_b[j][i] = 1.0f;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tflt_r_sum += flt_r[j][i];\n\t\t\t\t\tflt_g_sum += flt_g[j][i];\n\t\t\t\t\tflt_b_sum += flt_b [j][i];\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\tfor (j=0; j<3; j++) {\n\t\t\t\tfor (i=0; i<3; i++) {\n\t\t\t\t\tif (flt_r_sum != 0.0) {\n\t\t\t\t\t\tflt_r[j][i] /= flt_r_sum;\n\t\t\t\t\t}\t\n\t\t\t\t\tif (flt_g_sum != 0.0) {\n\t\t\t\t\t\tflt_g[j][i] /= flt_g_sum;\n\t\t\t\t\t}\t\n\t\t\t\t\tif (flt_b_sum != 0.0) {\n\t\t\t\t\t\tflt_b [j][i] /= flt_b_sum;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnew_r = new_g = new_b = 0.0;\n\t\t\t\n\t\t\tfor (j=0; j<3; j++) {\n\t\t\t\tfor (i=0; i<3; i++) {\n\t\t\t\t\tpxl = f(src, x-(3>>1)+i, y-(3>>1)+j);\n\t\t\t\t\tnew_r += (float)gdImageRed(srcback, pxl) * flt_r[j][i];\n\t\t\t\t\tnew_g += (float)gdImageGreen(srcback, pxl) * flt_g[j][i];\n\t\t\t\t\tnew_b += (float)gdImageBlue(srcback, pxl) * flt_b[j][i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnew_r = (new_r > 255.0f)? 255.0f : ((new_r < 0.0f)? 0.0f:new_r);\n\t\t\tnew_g = (new_g > 255.0f)? 255.0f : ((new_g < 0.0f)? 0.0f:new_g);\n\t\t\tnew_b = (new_b > 255.0f)? 255.0f : ((new_b < 0.0f)? 0.0f:new_b);\n\t\t\tnew_pxl = gdImageColorAllocateAlpha(src, (int)new_r, (int)new_g, (int)new_b, new_a);\n\t\t\tif (new_pxl == -1) {\n\t\t\t\tnew_pxl = gdImageColorClosestAlpha(src, (int)new_r, (int)new_g, (int)new_b, new_a);\n\t\t\t}\n\t\t\tif ((y >= 0) && (y < src->sy)) {\n\t\t\t\tgdImageSetPixel (src, x, y, new_pxl);\n\t\t\t}      \n\t\t}\n\t}\n\tgdImageDestroy(srcback);\n\treturn 1;\n}",
        "target": 0,
        "cwe": [
            "CWE-119"
        ],
        "project": "php-src",
        "commit_id": "feba44546c27b0158f9ac20e72040a224b918c75",
        "hash": 149324539417360135478033846784708274590,
        "size": 121,
        "message": "Fixed bug #22965 (Crash in gd lib's ImageFillToBorder())."
    },
    {
        "func": "static inline void mpeg4_encode_dc(PutBitContext *s, int level, int n)\n{\n    /* DC will overflow if level is outside the [-255,255] range. */\n    level += 256;\n    if (n < 4) {\n        /* luminance */\n        put_bits(s, uni_DCtab_lum_len[level], uni_DCtab_lum_bits[level]);\n    } else {\n        /* chrominance */\n        put_bits(s, uni_DCtab_chrom_len[level], uni_DCtab_chrom_bits[level]);\n    }\n}",
        "target": 0,
        "cwe": [
            "CWE-20"
        ],
        "project": "FFmpeg",
        "commit_id": "e1182fac1afba92a4975917823a5f644bee7e6e8",
        "hash": 192790528395163675250581563379451336920,
        "size": 12,
        "message": "avcodec/mpeg4videoenc: Use 64 bit for times in mpeg4_encode_gop_header()\n\nFixes truncation\nFixes Assertion n <= 31 && value < (1U << n) failed at libavcodec/put_bits.h:169\nFixes: ffmpeg_crash_2.avi\n\nFound-by: Thuan Pham <thuanpv@comp.nus.edu.sg>, Marcel B\u00f6hme, Andrew Santosa and Alexandru RazvanCaciulescu with AFLSmart\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>"
    },
    {
        "func": "static inline void debug_hrtimer_activate(struct hrtimer *timer)\n{\n\tdebug_object_activate(timer, &hrtimer_debug_descr);\n}",
        "target": 0,
        "cwe": [
            "CWE-200"
        ],
        "project": "tip",
        "commit_id": "dfb4357da6ddbdf57d583ba64361c9d792b0e0b1",
        "hash": 332740417457195729646636112023696171592,
        "size": 4,
        "message": "time: Remove CONFIG_TIMER_STATS\n\nCurrently CONFIG_TIMER_STATS exposes process information across namespaces:\n\nkernel/time/timer_list.c print_timer():\n\n        SEQ_printf(m, \", %s/%d\", tmp, timer->start_pid);\n\n/proc/timer_list:\n\n #11: <0000000000000000>, hrtimer_wakeup, S:01, do_nanosleep, cron/2570\n\nGiven that the tracer can give the same information, this patch entirely\nremoves CONFIG_TIMER_STATS.\n\nSuggested-by: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: Kees Cook <keescook@chromium.org>\nAcked-by: John Stultz <john.stultz@linaro.org>\nCc: Nicolas Pitre <nicolas.pitre@linaro.org>\nCc: linux-doc@vger.kernel.org\nCc: Lai Jiangshan <jiangshanlai@gmail.com>\nCc: Shuah Khan <shuah@kernel.org>\nCc: Xing Gao <xgao01@email.wm.edu>\nCc: Jonathan Corbet <corbet@lwn.net>\nCc: Jessica Frazelle <me@jessfraz.com>\nCc: kernel-hardening@lists.openwall.com\nCc: Nicolas Iooss <nicolas.iooss_linux@m4x.org>\nCc: \"Paul E. McKenney\" <paulmck@linux.vnet.ibm.com>\nCc: Petr Mladek <pmladek@suse.com>\nCc: Richard Cochran <richardcochran@gmail.com>\nCc: Tejun Heo <tj@kernel.org>\nCc: Michal Marek <mmarek@suse.com>\nCc: Josh Poimboeuf <jpoimboe@redhat.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: Olof Johansson <olof@lixom.net>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: linux-api@vger.kernel.org\nCc: Arjan van de Ven <arjan@linux.intel.com>\nLink: http://lkml.kernel.org/r/20170208192659.GA32582@beast\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>"
    },
    {
        "func": "int kvm_xen_hvm_get_attr(struct kvm *kvm, struct kvm_xen_hvm_attr *data)\n{\n\tint r = -ENOENT;\n\n\tmutex_lock(&kvm->lock);\n\n\tswitch (data->type) {\n\tcase KVM_XEN_ATTR_TYPE_LONG_MODE:\n\t\tdata->u.long_mode = kvm->arch.xen.long_mode;\n\t\tr = 0;\n\t\tbreak;\n\n\tcase KVM_XEN_ATTR_TYPE_SHARED_INFO:\n\t\tif (kvm->arch.xen.shinfo_cache.active)\n\t\t\tdata->u.shared_info.gfn = gpa_to_gfn(kvm->arch.xen.shinfo_cache.gpa);\n\t\telse\n\t\t\tdata->u.shared_info.gfn = GPA_INVALID;\n\t\tr = 0;\n\t\tbreak;\n\n\tcase KVM_XEN_ATTR_TYPE_UPCALL_VECTOR:\n\t\tdata->u.vector = kvm->arch.xen.upcall_vector;\n\t\tr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
        "target": 0,
        "cwe": [
            "CWE-476"
        ],
        "project": "linux",
        "commit_id": "55749769fe608fa3f4a075e42e89d237c8e37637",
        "hash": 151694373812579516845217766360443902328,
        "size": 32,
        "message": "KVM: x86: Fix wall clock writes in Xen shared_info not to mark page dirty\n\nWhen dirty ring logging is enabled, any dirty logging without an active\nvCPU context will cause a kernel oops. But we've already declared that\nthe shared_info page doesn't get dirty tracking anyway, since it would\nbe kind of insane to mark it dirty every time we deliver an event channel\ninterrupt. Userspace is supposed to just assume it's always dirty any\ntime a vCPU can run or event channels are routed.\n\nSo stop using the generic kvm_write_wall_clock() and just write directly\nthrough the gfn_to_pfn_cache that we already have set up.\n\nWe can make kvm_write_wall_clock() static in x86.c again now, but let's\nnot remove the 'sec_hi_ofs' argument even though it's not used yet. At\nsome point we *will* want to use that for KVM guests too.\n\nFixes: 629b5348841a (\"KVM: x86/xen: update wallclock region\")\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nSigned-off-by: David Woodhouse <dwmw@amazon.co.uk>\nMessage-Id: <20211210163625.2886-6-dwmw2@infradead.org>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>"
    },
    {
        "func": "msg_screen_putchar(int c, int attr)\n{\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_putchar(c, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tif (--msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tif (++msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n}",
        "target": 0,
        "cwe": [
            "CWE-416"
        ],
        "project": "vim",
        "commit_id": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
        "hash": 210780825398178238505878802174823188801,
        "size": 23,
        "message": "patch 8.2.4040: keeping track of allocated lines is too complicated\n\nProblem:    Keeping track of allocated lines in user functions is too\n            complicated.\nSolution:   Instead of freeing individual lines keep them all until the end."
    },
    {
        "func": "inline int MatchingElementsSize(const RuntimeShape& shape,\n                                const RuntimeShape& check_shape_0) {\n  const int size_1 = shape.FlatSize();\n  const int size_2 = check_shape_0.FlatSize();\n  TFLITE_CHECK_EQ(size_1, size_2);\n  return size_1;\n}",
        "target": 0,
        "cwe": [
            "CWE-125",
            "CWE-787"
        ],
        "project": "tensorflow",
        "commit_id": "8ee24e7949a203d234489f9da2c5bf45a7d5157d",
        "hash": 261286778320997521637055809842007118277,
        "size": 7,
        "message": "[tflite] Ensure `MatchingDim` does not allow buffer overflow.\n\nWe check in `MatchingDim` that both arguments have the same dimensionality, however that is a `DCHECK` only enabled if building in debug mode. Hence, it could be possible to cause buffer overflows by passing in a tensor with larger dimensions as the second argument. To fix, we now make `MatchingDim` return the minimum of the two sizes.\n\nA much better fix would be to return a status object but that requires refactoring a large part of the codebase for minor benefits.\n\nPiperOrigin-RevId: 332526127\nChange-Id: If627d0d2c80a685217b6e0d1e64b0872dbf1c5e4"
    },
    {
        "func": "static int ixgbe_set_vf_macvlan_msg(struct ixgbe_adapter *adapter,\n\t\t\t\t    u32 *msgbuf, u32 vf)\n{\n\tu8 *new_mac = ((u8 *)(&msgbuf[1]));\n\tint index = (msgbuf[0] & IXGBE_VT_MSGINFO_MASK) >>\n\t\t    IXGBE_VT_MSGINFO_SHIFT;\n\tint err;\n\n\tif (adapter->vfinfo[vf].pf_set_mac && !adapter->vfinfo[vf].trusted &&\n\t    index > 0) {\n\t\te_warn(drv,\n\t\t       \"VF %d requested MACVLAN filter but is administratively denied\\n\",\n\t\t       vf);\n\t\treturn -1;\n\t}\n\n\t/* An non-zero index indicates the VF is setting a filter */\n\tif (index) {\n\t\tif (!is_valid_ether_addr(new_mac)) {\n\t\t\te_warn(drv, \"VF %d attempted to set invalid mac\\n\", vf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * If the VF is allowed to set MAC filters then turn off\n\t\t * anti-spoofing to avoid false positives.\n\t\t */\n\t\tif (adapter->vfinfo[vf].spoofchk_enabled) {\n\t\t\tstruct ixgbe_hw *hw = &adapter->hw;\n\n\t\t\thw->mac.ops.set_mac_anti_spoofing(hw, false, vf);\n\t\t\thw->mac.ops.set_vlan_anti_spoofing(hw, false, vf);\n\t\t}\n\t}\n\n\terr = ixgbe_set_vf_macvlan(adapter, vf, index, new_mac);\n\tif (err == -ENOSPC)\n\t\te_warn(drv,\n\t\t       \"VF %d has requested a MACVLAN filter but there is no space for it\\n\",\n\t\t       vf);\n\n\treturn err < 0;\n}",
        "target": 0,
        "cwe": [
            "CWE-20"
        ],
        "project": "linux",
        "commit_id": "63e39d29b3da02e901349f6cd71159818a4737a6",
        "hash": 43854494850513666637898013960892066884,
        "size": 43,
        "message": "ixgbe: fix large MTU request from VF\n\nCheck that the MTU value requested by the VF is in the supported\nrange of MTUs before attempting to set the VF large packet enable,\notherwise reject the request. This also avoids unnecessary\nregister updates in the case of the 82599 controller.\n\nFixes: 872844ddb9e4 (\"ixgbe: Enable jumbo frames support w/ SR-IOV\")\nCo-developed-by: Piotr Skajewski <piotrx.skajewski@intel.com>\nSigned-off-by: Piotr Skajewski <piotrx.skajewski@intel.com>\nSigned-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>\nCo-developed-by: Mateusz Palczewski <mateusz.palczewski@intel.com>\nSigned-off-by: Mateusz Palczewski <mateusz.palczewski@intel.com>\nTested-by: Konrad Jankowski <konrad0.jankowski@intel.com>\nSigned-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"
    }
]
