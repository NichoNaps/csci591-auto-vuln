project,commit_id,target,func,idx
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,1,"  LOG_DEBUG(5, 'Extracting: ' << path);

  return extract(*SystemUtilities::oopen(path));
",8731
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,1,"  pri->filter.push(*this->stream);
}


TarFileReader::~TarFileReader() {
  delete pri;
}


bool TarFileReader::hasMore() {
  if (!didReadHeader) {
    SysError::clear();
    if (!readHeader(pri->filter))
      THROW('Tar file read failed: ' << SysError());
    didReadHeader = true;
  }

  return !isEOF();
}


bool TarFileReader::next() {
  if (didReadHeader) {
    skipFile(pri->filter);
    didReadHeader = false;
  }

  return hasMore();
}


std::string TarFileReader::extract(const string &_path) {
  if (_path.empty()) THROW('path cannot be empty');
  if (!hasMore()) THROW('No more tar files');

  string path = _path;
  if (SystemUtilities::isDirectory(path)) path += '/' + getFilename();

  LOG_DEBUG(5, 'Extracting: ' << path);

  return extract(*SystemUtilities::oopen(path));
}
",8732
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,1,"
  LOG_DEBUG(5, 'Extracting: ' << path);

  return extract(*SystemUtilities::oopen(path));
}

",8733
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,1,"
  string path = _path;
  if (SystemUtilities::isDirectory(path)) path += '/' + getFilename();
",8734
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,1,"  LOG_DEBUG(5, 'Extracting: ' << path);

  return extract(*SystemUtilities::oopen(path));
",8735
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,0,"

TarFileReader::~TarFileReader() {
",8736
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,0,"  if (!hasMore()) THROW('No more tar files');

  string path = _path;
",8737
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,0,"
",8738
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,0,"    didReadHeader = true;
  }

",8739
CauldronDevelopmentLLC/cbang,1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7,0,"
bool TarFileReader::hasMore() {
  if (!didReadHeader) {
    SysError::clear();
    if (!readHeader(pri->filter))
      THROW('Tar file read failed: ' << SysError());
    didReadHeader = true;
  }

  return !isEOF();
}


",8740
dinhviethoa/libetpan,1fe8fbc032ccda1db9af66d93016b49c16c1f22d,1,"static int mailimf_group_parse(const char * message, size_t length,
			       size_t * indx,
			       struct mailimf_group ** result)
{
  size_t cur_token;
  char * display_name;
  struct mailimf_mailbox_list * mailbox_list;
  struct mailimf_group * group;
  int r;
  int res;

  cur_token = * indx;

  mailbox_list = NULL;

  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto err;
  }

  r = mailimf_colon_parse(message, length, &cur_token);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto free_display_name;
  }

  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);
  switch (r) {
  case MAILIMF_NO_ERROR:
    break;
  case MAILIMF_ERROR_PARSE:
    r = mailimf_cfws_parse(message, length, &cur_token);
    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {
      res = r;
      goto free_display_name;
    }
    break;
  default:
    res = r;
    goto free_display_name;
  }

  r = mailimf_semi_colon_parse(message, length, &cur_token);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto free_mailbox_list;
  }

  group = mailimf_group_new(display_name, mailbox_list);
  if (group == NULL) {
    res = MAILIMF_ERROR_MEMORY;
    goto free_mailbox_list;
  }

  * indx = cur_token;
  * result = group;

  return MAILIMF_NO_ERROR;

 free_mailbox_list:
  if (mailbox_list != NULL) {
    mailimf_mailbox_list_free(mailbox_list);
  }
 free_display_name:
  mailimf_display_name_free(display_name);
 err:
  return res;
}
",8741
dinhviethoa/libetpan,1fe8fbc032ccda1db9af66d93016b49c16c1f22d,0,"static int mailimf_second_parse(const char * message, size_t length,
				size_t * indx, int * result)
{
  uint32_t second;
  int r;

  r = mailimf_number_parse(message, length, indx, &second);
  if (r != MAILIMF_NO_ERROR)
    return r;

  * result = second;

  return MAILIMF_NO_ERROR;
}
",8742
FFmpeg/FFmpeg,2960576378d17d71cc8dccc926352ce568b5eec1,1,"static int g2m_init_buffers(G2MContext *c)
{
    int aligned_height;

    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {
        c->framebuf_stride = FFALIGN(c->width * 3, 16);
        aligned_height     = FFALIGN(c->height,    16);
        av_free(c->framebuf);
        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);
        if (!c->framebuf)
            return AVERROR(ENOMEM);
    }
    if (!c->synth_tile || !c->jpeg_tile ||
        c->old_tile_w < c->tile_width ||
        c->old_tile_h < c->tile_height) {
        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;
        aligned_height = FFALIGN(c->tile_height,    16);
        av_free(c->synth_tile);
        av_free(c->jpeg_tile);
        av_free(c->kempf_buf);
        av_free(c->kempf_flags);
        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);
        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);
        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height
                                    + FF_INPUT_BUFFER_PADDING_SIZE);
        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);
        if (!c->synth_tile || !c->jpeg_tile ||
            !c->kempf_buf || !c->kempf_flags)
            return AVERROR(ENOMEM);
    }

    return 0;
}
",8743
FFmpeg/FFmpeg,2960576378d17d71cc8dccc926352ce568b5eec1,1,"static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,
                             const uint8_t *src, int src_size)
{
    int width, height;
    int hdr, zsize, npal, tidx = -1, ret;
    int i, j;
    const uint8_t *src_end = src + src_size;
    uint8_t pal[768], transp[3];
    uLongf dlen = (c->tile_width + 1) * c->tile_height;
    int sub_type;
    int nblocks, cblocks, bstride;
    int bits, bitbuf, coded;
    uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +
                   tile_y * c->tile_height * c->framebuf_stride;

    if (src_size < 2)
        return AVERROR_INVALIDDATA;

    width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);
    height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);

    hdr = *src++;
    sub_type = hdr >> 5;
    if (sub_type == 0) {
        int j;
        memcpy(transp, src, 3);
        src += 3;
        for (j = 0; j < height; j++, dst += c->framebuf_stride)
            for (i = 0; i < width; i++)
                memcpy(dst + i * 3, transp, 3);
        return 0;
    } else if (sub_type == 1) {
        return jpg_decode_data(&c->jc, width, height, src, src_end - src,
                               dst, c->framebuf_stride, NULL, 0, 0, 0);
    }

    if (sub_type != 2) {
        memcpy(transp, src, 3);
        src += 3;
    }
    npal = *src++ + 1;
    memcpy(pal, src, npal * 3); src += npal * 3;
    if (sub_type != 2) {
        for (i = 0; i < npal; i++) {
            if (!memcmp(pal + i * 3, transp, 3)) {
               tidx = i;
               break;
            }
        }
    }

    if (src_end - src < 2)
        return 0;
    zsize = (src[0] << 8) | src[1]; src += 2;

    if (src_end - src < zsize)
        return AVERROR_INVALIDDATA;

    ret = uncompress(c->kempf_buf, &dlen, src, zsize);
    if (ret)
        return AVERROR_INVALIDDATA;
    src += zsize;

    if (sub_type == 2) {
        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,
                          NULL, 0, width, height, pal, npal, tidx);
        return 0;
    }

    nblocks = *src++ + 1;
    cblocks = 0;
    bstride = FFALIGN(width, 16) >> 4;
    // blocks are coded LSB and we need normal bitreader for JPEG data
    bits = 0;
    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {
        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {
            if (!bits) {
                bitbuf = *src++;
                bits   = 8;
            }
            coded = bitbuf & 1;
            bits--;
            bitbuf >>= 1;
            cblocks += coded;
            if (cblocks > nblocks)
                return AVERROR_INVALIDDATA;
            c->kempf_flags[j + i * bstride] = coded;
        }
    }

    memset(c->jpeg_tile, 0, c->tile_stride * height);
    jpg_decode_data(&c->jc, width, height, src, src_end - src,
                    c->jpeg_tile, c->tile_stride,
                    c->kempf_flags, bstride, nblocks, 0);

    kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,
                      c->jpeg_tile, c->tile_stride,
                      width, height, pal, npal, tidx);

    return 0;
}
",8744
FFmpeg/FFmpeg,2960576378d17d71cc8dccc926352ce568b5eec1,0,"    25, 32, 39, 44, 52, 61, 60, 51,
    36, 46, 48, 49, 56, 50, 52, 50
};

static const uint8_t chroma_quant[64] = {
",8745
FFmpeg/FFmpeg,2960576378d17d71cc8dccc926352ce568b5eec1,0,"#include 'get_bits.h'
#include 'internal.h'
#include 'mjpeg.h'

enum ChunkType {
    FRAME_INFO = 0xC8,
    TILE_DATA,
    CURSOR_POS,
    CURSOR_SHAPE,
",8746
LibreDWG/libredwg,dac8fcc4be1007ccf4412ae5e90303e335fdb412,1,"        {
          len++;
          if (len > maxlen)
",8747
LibreDWG/libredwg,dac8fcc4be1007ccf4412ae5e90303e335fdb412,1,"      }
    return len;
  }
",8748
LibreDWG/libredwg,dac8fcc4be1007ccf4412ae5e90303e335fdb412,1,"void
bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)
{
  int i, j;
  int negative;
  unsigned char byte[5];
  BITCODE_UMC mask;
  BITCODE_UMC value;

  value = val;
  mask = 0x0000007f;
  for (i = 4, j = 0; i >= 0; i--, j += 7)
    {
      byte[i] = (unsigned char)((value & mask) >> j);
      byte[i] |= 0x80;
      mask = mask << 7;
    }
  for (i = 0; i < 4; i++)
    if (byte[i] & 0x7f)
      break;

  if (byte[i] & 0x40)
    i--;
  byte[i] &= 0x7f;
  for (j = 4; j >= i; j--)
    bit_write_RC (dat, byte[j]);
}
",8749
LibreDWG/libredwg,dac8fcc4be1007ccf4412ae5e90303e335fdb412,0,"uint16_t
bit_write_CRC (Bit_Chain *dat, long unsigned int start_address, uint16_t seed)
{
  uint16_t crc;
  long size;
  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;

  while (dat->bit > 0)
    bit_write_B (dat, 0);

  if (start_address > dat->byte || dat->byte >= dat->size)
    {
      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
      LOG_ERROR ('%s buffer overflow at pos %lu-%lu, size %lu', __FUNCTION__,
                 start_address, dat->byte, dat->size)
      return 0;
    }
  size = dat->byte - start_address;
  crc = bit_calc_CRC (seed, &dat->chain[start_address], size);

  LOG_TRACE ('write CRC %04X from %lu-%lu = %ld\n', crc, start_address,
             dat->byte, size);
  bit_write_RS (dat, crc);
  return crc;
}
",8750
LibreDWG/libredwg,dac8fcc4be1007ccf4412ae5e90303e335fdb412,0,"      byte = dat->chain[dat->byte + 1];
      remainder = byte & (0xff >> dat->bit);
      dat->chain[dat->byte + 1] = remainder | (value << (8 - dat->bit));
",8751
LibreDWG/libredwg,dac8fcc4be1007ccf4412ae5e90303e335fdb412,0,"  bit_write_RL (dat, value & 0xFFFFFFFF);
  bit_write_RL (dat, value >> 32);
}
",8752
ntop/nDPI,b7e666e465f138ae48ab81976726e67deed12701,1,"    if(flow->http.user_agent[0] != '\0')
      fprintf(out, '[UserAgent: %s]', flow->http.user_agent);
  }
",8753
ntop/nDPI,b7e666e465f138ae48ab81976726e67deed12701,1,"static void printFlow(u_int16_t id, struct ndpi_flow_info *flow, u_int16_t thread_id) {
  FILE *out = results_file ? results_file : stdout;
  u_int8_t known_tls;
  char buf[32], buf1[64];
  u_int i;

  double dos_ge_score;
  double dos_slow_score;
  double dos_hulk_score;
  double ddos_score;

  double hearthbleed_score;

  double ftp_patator_score;
  double ssh_patator_score;

  double inf_score;

  if(csv_fp != NULL) {
    float data_ratio = ndpi_data_ratio(flow->src2dst_bytes, flow->dst2src_bytes);
    double f = (double)flow->first_seen, l = (double)flow->last_seen;

    /* PLEASE KEEP IN SYNC WITH printCSVHeader() */
    dos_ge_score = Dos_goldeneye_score(flow);
    
    dos_slow_score = Dos_slow_score(flow);
    dos_hulk_score = Dos_hulk_score(flow);
    ddos_score = Ddos_score(flow);

    hearthbleed_score = Hearthbleed_score(flow);

    ftp_patator_score = Ftp_patator_score(flow);
    ssh_patator_score = Ssh_patator_score(flow);

    inf_score = Infiltration_score(flow);
   
    double benign_score = dos_ge_score < 1 && dos_slow_score < 1 && \
    dos_hulk_score < 1 && ddos_score < 1 && hearthbleed_score < 1 && \
    ftp_patator_score < 1 && ssh_patator_score < 1 && inf_score < 1 ? 1.1 : 0;

    fprintf(csv_fp, '%u,%u,%.3f,%.3f,%.3f,%s,%u,%s,%u,',
	    flow->flow_id,
	    flow->protocol,
	    f/1000.0, l/1000.0,
	    (l-f)/1000.0,
	    flow->src_name, ntohs(flow->src_port),
	    flow->dst_name, ntohs(flow->dst_port)
	    );

    fprintf(csv_fp, '%s,',
	    ndpi_protocol2id(ndpi_thread_info[thread_id].workflow->ndpi_struct,
			     flow->detected_protocol, buf, sizeof(buf)));

    fprintf(csv_fp, '%s,%s,',
	    ndpi_protocol2name(ndpi_thread_info[thread_id].workflow->ndpi_struct,
			       flow->detected_protocol, buf, sizeof(buf)),
	    flow->host_server_name);
    
    fprintf(csv_fp, '%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,', \
	    benign_score, dos_slow_score, dos_ge_score, dos_hulk_score, \
	    ddos_score, hearthbleed_score, ftp_patator_score,		\
	    ssh_patator_score, inf_score);
    
    fprintf(csv_fp, '%u,%llu,%llu,', flow->src2dst_packets,
	    (long long unsigned int) flow->src2dst_bytes, (long long unsigned int) flow->src2dst_goodput_bytes);
    fprintf(csv_fp, '%u,%llu,%llu,', flow->dst2src_packets,
	    (long long unsigned int) flow->dst2src_bytes, (long long unsigned int) flow->dst2src_goodput_bytes);
    fprintf(csv_fp, '%.3f,%s,', data_ratio, ndpi_data_ratio2str(data_ratio));
    fprintf(csv_fp, '%.1f,%.1f,', 100.0*((float)flow->src2dst_goodput_bytes / (float)(flow->src2dst_bytes+1)),
	    100.0*((float)flow->dst2src_goodput_bytes / (float)(flow->dst2src_bytes+1)));
    
    /* IAT (Inter Arrival Time) */
    fprintf(csv_fp, '%u,%.1f,%u,%.1f,',
	    ndpi_data_min(flow->iat_flow), ndpi_data_average(flow->iat_flow), ndpi_data_max(flow->iat_flow), ndpi_data_stddev(flow->iat_flow));

    fprintf(csv_fp, '%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,',
	    ndpi_data_min(flow->iat_c_to_s), ndpi_data_average(flow->iat_c_to_s), ndpi_data_max(flow->iat_c_to_s), ndpi_data_stddev(flow->iat_c_to_s),
	    ndpi_data_min(flow->iat_s_to_c), ndpi_data_average(flow->iat_s_to_c), ndpi_data_max(flow->iat_s_to_c), ndpi_data_stddev(flow->iat_s_to_c));

    /* Packet Length */
    fprintf(csv_fp, '%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,',
	    ndpi_data_min(flow->pktlen_c_to_s), ndpi_data_average(flow->pktlen_c_to_s), ndpi_data_max(flow->pktlen_c_to_s), ndpi_data_stddev(flow->pktlen_c_to_s),
	    ndpi_data_min(flow->pktlen_s_to_c), ndpi_data_average(flow->pktlen_s_to_c), ndpi_data_max(flow->pktlen_s_to_c), ndpi_data_stddev(flow->pktlen_s_to_c));

    /* TCP flags */
   fprintf(csv_fp, '%d,%d,%d,%d,%d,%d,%d,%d,', flow->cwr_count, flow->ece_count, flow->urg_count, flow->ack_count, flow->psh_count, flow->rst_count, flow->syn_count, flow->fin_count);

   fprintf(csv_fp, '%d,%d,%d,%d,%d,%d,%d,%d,', flow->src2dst_cwr_count, flow->src2dst_ece_count, flow->src2dst_urg_count, flow->src2dst_ack_count, flow->src2dst_psh_count, flow->src2dst_rst_count, flow->src2dst_syn_count, flow->src2dst_fin_count);

   fprintf(csv_fp, '%d,%d,%d,%d,%d,%d,%d,%d,', flow->dst2src_cwr_count, flow->ece_count, flow->urg_count, flow->ack_count, flow->psh_count, flow->rst_count, flow->syn_count, flow->fin_count);

   /* TCP window */
   fprintf(csv_fp, '%u,%u,', flow->c_to_s_init_win, flow->s_to_c_init_win);

    fprintf(csv_fp, '%s,%s,',
	    (flow->ssh_tls.client_requested_server_name[0] != '\0')  ? flow->ssh_tls.client_requested_server_name : '',
	    (flow->ssh_tls.server_info[0] != '\0')  ? flow->ssh_tls.server_info : '');

    fprintf(csv_fp, '%s,%s,%s,%s,%s,',
	    (flow->ssh_tls.ssl_version != 0)        ? ndpi_ssl_version2str(flow->ssh_tls.ssl_version, &known_tls) : '0',
	    (flow->ssh_tls.ja3_client[0] != '\0')   ? flow->ssh_tls.ja3_client : '',
	    (flow->ssh_tls.ja3_client[0] != '\0')   ? is_unsafe_cipher(flow->ssh_tls.client_unsafe_cipher) : '0',
	    (flow->ssh_tls.ja3_server[0] != '\0')   ? flow->ssh_tls.ja3_server : '',
	    (flow->ssh_tls.ja3_server[0] != '\0')   ? is_unsafe_cipher(flow->ssh_tls.server_unsafe_cipher) : '0');
    
    fprintf(csv_fp, '%s,%s,',
	    flow->ssh_tls.tls_alpn                  ? flow->ssh_tls.tls_alpn : '',
	    flow->ssh_tls.tls_supported_versions    ? flow->ssh_tls.tls_supported_versions : '' 
	    );
    fprintf(csv_fp, '%s,%s,',
	    flow->ssh_tls.tls_issuerDN              ? flow->ssh_tls.tls_issuerDN : '',
	    flow->ssh_tls.tls_subjectDN             ? flow->ssh_tls.tls_subjectDN : '' 
	    );
    fprintf(csv_fp, '%s,%s',
	    (flow->ssh_tls.client_hassh[0] != '\0') ? flow->ssh_tls.client_hassh : '',
	    (flow->ssh_tls.server_hassh[0] != '\0') ? flow->ssh_tls.server_hassh : ''
	    );

    fprintf(csv_fp, ',%s', flow->info);
  }

  if((verbose != 1) && (verbose != 2)) {
    if(csv_fp && enable_joy_stats) {
      flowGetBDMeanandVariance(flow);
    }

    if(csv_fp)
      fprintf(csv_fp, '\n');
    return;
  }

  if(csv_fp || (verbose > 1)) {
#if 1
  fprintf(out, '\t%u', id);
#else
  fprintf(out, '\t%u(%u)', id, flow->flow_id);
#endif

  fprintf(out, '\t%s ', ipProto2Name(flow->protocol));

  fprintf(out, '%s%s%s:%u %s %s%s%s:%u ',
	  (flow->ip_version == 6) ? '[' : '',
	  flow->src_name, (flow->ip_version == 6) ? ']' : '', ntohs(flow->src_port),
	  flow->bidirectional ? '<->' : '->',
	  (flow->ip_version == 6) ? '[' : '',
	  flow->dst_name, (flow->ip_version == 6) ? ']' : '', ntohs(flow->dst_port)
	  );

  if(flow->vlan_id > 0) fprintf(out, '[VLAN: %u]', flow->vlan_id);
  if(enable_payload_analyzer) fprintf(out, '[flowId: %u]', flow->flow_id);
  }
  
  if(enable_joy_stats) {
    /* Print entropy values for monitored flows. */
    flowGetBDMeanandVariance(flow);
    fflush(out);
    fprintf(out, '[score: %.4f]', flow->entropy.score);
  }
	
  if(csv_fp) fprintf(csv_fp, '\n');
    
  fprintf(out, '[proto: ');
  if(flow->tunnel_type != ndpi_no_tunnel)
    fprintf(out, '%s:', ndpi_tunnel2str(flow->tunnel_type));

  fprintf(out, '%s/%s]',
	  ndpi_protocol2id(ndpi_thread_info[thread_id].workflow->ndpi_struct,
			   flow->detected_protocol, buf, sizeof(buf)),
	  ndpi_protocol2name(ndpi_thread_info[thread_id].workflow->ndpi_struct,
			     flow->detected_protocol, buf1, sizeof(buf1)));

  if(flow->detected_protocol.category != 0)
    fprintf(out, '[cat: %s/%u]',
	    ndpi_category_get_name(ndpi_thread_info[thread_id].workflow->ndpi_struct,
				   flow->detected_protocol.category),
	    (unsigned int)flow->detected_protocol.category);

  fprintf(out, '[%u pkts/%llu bytes ', flow->src2dst_packets, (long long unsigned int) flow->src2dst_bytes);
  fprintf(out, '%s %u pkts/%llu bytes]',
	  (flow->dst2src_packets > 0) ? '<->' : '->',
	  flow->dst2src_packets, (long long unsigned int) flow->dst2src_bytes);

  fprintf(out, '[Goodput ratio: %.0f/%.0f]',
	  100.0*((float)flow->src2dst_goodput_bytes / (float)(flow->src2dst_bytes+1)),
	  100.0*((float)flow->dst2src_goodput_bytes / (float)(flow->dst2src_bytes+1)));

  if(flow->last_seen > flow->first_seen)
    fprintf(out, '[%.2f sec]', ((float)(flow->last_seen - flow->first_seen))/(float)1000);
  else
    fprintf(out, '[< 1 sec]');

  if(flow->telnet.username[0] != '\0')  fprintf(out, '[Username: %s]', flow->telnet.username);
  if(flow->telnet.password[0] != '\0')  fprintf(out, '[Password: %s]', flow->telnet.password);
  if(flow->host_server_name[0] != '\0') fprintf(out, '[Host: %s]', flow->host_server_name);

  if(flow->info[0] != '\0') fprintf(out, '[%s]', flow->info);
  if(flow->flow_extra_info[0] != '\0') fprintf(out, '[%s]', flow->flow_extra_info);

  if((flow->src2dst_packets+flow->dst2src_packets) > 5) {
    if(flow->iat_c_to_s && flow->iat_s_to_c) {
      float data_ratio = ndpi_data_ratio(flow->src2dst_bytes, flow->dst2src_bytes);

      fprintf(out, '[bytes ratio: %.3f (%s)]', data_ratio, ndpi_data_ratio2str(data_ratio));

      /* IAT (Inter Arrival Time) */
      fprintf(out, '[IAT c2s/s2c min/avg/max/stddev: %u/%u %.0f/%.0f %u/%u %.0f/%.0f]',
	      ndpi_data_min(flow->iat_c_to_s),     ndpi_data_min(flow->iat_s_to_c),
	      (float)ndpi_data_average(flow->iat_c_to_s), (float)ndpi_data_average(flow->iat_s_to_c),
	      ndpi_data_max(flow->iat_c_to_s),     ndpi_data_max(flow->iat_s_to_c),
	      (float)ndpi_data_stddev(flow->iat_c_to_s),  (float)ndpi_data_stddev(flow->iat_s_to_c));

      /* Packet Length */
      fprintf(out, '[Pkt Len c2s/s2c min/avg/max/stddev: %u/%u %.0f/%.0f %u/%u %.0f/%.0f]',
	      ndpi_data_min(flow->pktlen_c_to_s), ndpi_data_min(flow->pktlen_s_to_c),
	      ndpi_data_average(flow->pktlen_c_to_s), ndpi_data_average(flow->pktlen_s_to_c),
	      ndpi_data_max(flow->pktlen_c_to_s), ndpi_data_max(flow->pktlen_s_to_c),
	      ndpi_data_stddev(flow->pktlen_c_to_s),  ndpi_data_stddev(flow->pktlen_s_to_c));
    }
  }

  if(flow->http.url[0] != '\0') {
    ndpi_risk_enum risk = ndpi_validate_url(flow->http.url);

    if(risk != NDPI_NO_RISK)
      NDPI_SET_BIT(flow->risk, risk);
    
    fprintf(out, '[URL: %s[StatusCode: %u]',
	    flow->http.url, flow->http.response_status_code);

    if(flow->http.content_type[0] != '\0')
      fprintf(out, '[ContentType: %s]', flow->http.content_type);

    if(flow->http.user_agent[0] != '\0')
      fprintf(out, '[UserAgent: %s]', flow->http.user_agent);
  }

  if(flow->risk) {
    u_int i;
    
    fprintf(out, '[Risk: ');

    for(i=0; i<NDPI_MAX_RISK; i++)
      if(NDPI_ISSET_BIT(flow->risk, i))
	fprintf(out, '** %s **', ndpi_risk2str(i));
    
    fprintf(out, ']');
  }
  
  if(flow->ssh_tls.ssl_version != 0) fprintf(out, '[%s]', ndpi_ssl_version2str(flow->ssh_tls.ssl_version, &known_tls));
  if(flow->ssh_tls.client_requested_server_name[0] != '\0') fprintf(out, '[Client: %s]', flow->ssh_tls.client_requested_server_name);
  if(flow->ssh_tls.client_hassh[0] != '\0') fprintf(out, '[HASSH-C: %s]', flow->ssh_tls.client_hassh);

  if(flow->ssh_tls.ja3_client[0] != '\0') fprintf(out, '[JA3C: %s%s]', flow->ssh_tls.ja3_client,
						  print_cipher(flow->ssh_tls.client_unsafe_cipher));

  if(flow->ssh_tls.server_info[0] != '\0') fprintf(out, '[Server: %s]', flow->ssh_tls.server_info);

  if(flow->ssh_tls.server_names) fprintf(out, '[ServerNames: %s]', flow->ssh_tls.server_names);
  if(flow->ssh_tls.server_hassh[0] != '\0') fprintf(out, '[HASSH-S: %s]', flow->ssh_tls.server_hassh);

  if(flow->ssh_tls.ja3_server[0] != '\0') fprintf(out, '[JA3S: %s%s]', flow->ssh_tls.ja3_server,
						  print_cipher(flow->ssh_tls.server_unsafe_cipher));

  if(flow->ssh_tls.tls_issuerDN)  fprintf(out, '[Issuer: %s]', flow->ssh_tls.tls_issuerDN);
  if(flow->ssh_tls.tls_subjectDN) fprintf(out, '[Subject: %s]', flow->ssh_tls.tls_subjectDN);

  if((flow->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS)
     || (flow->detected_protocol.app_protocol == NDPI_PROTOCOL_TLS)) {
    if(flow->ssh_tls.sha1_cert_fingerprint_set) {
      fprintf(out, '[Certificate SHA-1: ');
      for(i=0; i<20; i++)
	fprintf(out, '%s%02X', (i > 0) ? ':' : '',
		flow->ssh_tls.sha1_cert_fingerprint[i] & 0xFF);
      fprintf(out, ']');
    }
  }

  if(flow->ssh_tls.notBefore && flow->ssh_tls.notAfter) {
    char notBefore[32], notAfter[32];
    struct tm a, b;
    struct tm *before = gmtime_r(&flow->ssh_tls.notBefore, &a);
    struct tm *after  = gmtime_r(&flow->ssh_tls.notAfter, &b);

    strftime(notBefore, sizeof(notBefore), '%F %T', before);
    strftime(notAfter, sizeof(notAfter), '%F %T', after);

    fprintf(out, '[Validity: %s - %s]', notBefore, notAfter);
  }

  if(flow->ssh_tls.server_cipher != '\0') fprintf(out, '[Cipher: %s]', ndpi_cipher2str(flow->ssh_tls.server_cipher));
  if(flow->bittorent_hash[0] != '\0') fprintf(out, '[BT Hash: %s]', flow->bittorent_hash);
  if(flow->dhcp_fingerprint[0] != '\0') fprintf(out, '[DHCP Fingerprint: %s]', flow->dhcp_fingerprint);

  if(flow->has_human_readeable_strings) fprintf(out, '[PLAIN TEXT (%s)]', flow->human_readeable_string_buffer);

  fprintf(out, '\n');
}
",8754
ntop/nDPI,b7e666e465f138ae48ab81976726e67deed12701,1,"void ndpi_search_h323(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  u_int16_t dport = 0, sport = 0;

  NDPI_LOG_DBG(ndpi_struct, 'search H323\n');

  /*
    The TPKT protocol is used by ISO 8072 (on port 102)
    and H.323. So this check below is to avoid ambiguities
  */
  if((packet->tcp != NULL) && (packet->tcp->dest != ntohs(102))) {
    NDPI_LOG_DBG2(ndpi_struct, 'calculated dport over tcp\n');

    /* H323  */
    if(packet->payload_packet_len >= 4
       && (packet->payload[0] == 0x03)
       && (packet->payload[1] == 0x00)) {
	struct tpkt *t = (struct tpkt*)packet->payload;
	u_int16_t len = ntohs(t->len);

	if(packet->payload_packet_len == len) {
	  /*
	    We need to check if this packet is in reality
	    a RDP (Remote Desktop) packet encapsulated on TPTK
	   */

	  if(packet->payload[4] == (packet->payload_packet_len - sizeof(struct tpkt) - 1)) {
	    /* ISO 8073/X.224 */
	    if((packet->payload[5] == 0xE0 /* CC Connect Request */)
	       || (packet->payload[5] == 0xD0 /* CC Connect Confirm */)) {
	      NDPI_LOG_INFO(ndpi_struct, 'found RDP\n');
	      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_RDP, NDPI_PROTOCOL_UNKNOWN);
	      return;
	    }
	  }

	  flow->l4.tcp.h323_valid_packets++;

	  if(flow->l4.tcp.h323_valid_packets >= 2) {
	    NDPI_LOG_INFO(ndpi_struct, 'found H323 broadcast\n');
	    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
	  }
	} else {
	  /* This is not H.323 */
	  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
	  return;
	}
      }
  } else if(packet->udp != NULL) {
    sport = ntohs(packet->udp->source), dport = ntohs(packet->udp->dest);
    NDPI_LOG_DBG2(ndpi_struct, 'calculated dport over udp\n');

    if(packet->payload_packet_len >= 6 && packet->payload[0] == 0x80 && packet->payload[1] == 0x08 &&
       (packet->payload[2] == 0xe7 || packet->payload[2] == 0x26) &&
       packet->payload[4] == 0x00 && packet->payload[5] == 0x00)
      {
	NDPI_LOG_INFO(ndpi_struct, 'found H323 broadcast\n');
	ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
	return;
      }
    /* H323  */
    if(sport == 1719 || dport == 1719)
      {
        if(packet->payload[0] == 0x16 && packet->payload[1] == 0x80 && packet->payload[4] == 0x06 && packet->payload[5] == 0x00)
	  {
	    NDPI_LOG_INFO(ndpi_struct, 'found H323 broadcast\n');
	    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
	    return;
	  }
        else if(packet->payload_packet_len >= 20 && packet->payload_packet_len <= 117)
	  {
	    NDPI_LOG_INFO(ndpi_struct, 'found H323 broadcast\n');
	    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);
	    return;
	  }
        else
	  {
	    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
	    return;
	  }
      }
  }

}
",8755
ntop/nDPI,b7e666e465f138ae48ab81976726e67deed12701,0,"void bpf_filter_port_array_init(int array[], int size) {
  int i;
  for(i=0; i<size; i++)
    array[i] = INIT_VAL;
}
",8756
ntop/nDPI,b7e666e465f138ae48ab81976726e67deed12701,0," */
static void mergeTables(struct receiver **primary, struct receiver **secondary) {
  struct receiver *r, *s, *tmp;
",8757
ntop/nDPI,b7e666e465f138ae48ab81976726e67deed12701,0,"  if(ndpi_thread_info[thread_id].num_idle_flows == IDLE_SCAN_BUDGET) /* TODO optimise with a budget-based walk */
    return;

",8758
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,1,"void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {
  char uint32_buffer[5];
  Trackage track = {0};

  AtomicInfo *mvhdAtom = APar_FindAtom('moov.mvhd', false, VERSIONED_ATOM, 0);
  if (mvhdAtom != NULL) {
    APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);
    fprintf(stdout,
            'Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate '
            '(*=approximate)\n',
            movie_info.seconds,
            secsTOtime(movie_info.seconds),
            movie_info.simple_bitrate_calc);
    if (optional_output & SHOW_DATE_INFO) {
      fprintf(stdout,
              '  Presentation Creation Date (UTC):     %s\n',
              APar_extract_UTC(movie_info.creation_time));
      fprintf(stdout,
              '  Presentation Modification Date (UTC): %s\n',
              APar_extract_UTC(movie_info.modified_time));
    }
  }

  AtomicInfo *iodsAtom = APar_FindAtom('moov.iods', false, VERSIONED_ATOM, 0);
  if (iodsAtom != NULL) {
    movie_info.contains_iods = true;
    APar_Extract_iods_Info(isofile, iodsAtom);
  }

  if (optional_output & SHOW_TRACK_INFO) {
    APar_TrackLevelInfo(&track,
                        NULL); // With track_num set to 0, it will return the
                               // total trak atom into total_tracks here.

    fprintf(
        stdout, 'Low-level details. Total tracks: %u\n', track.total_tracks);
    fprintf(stdout,
            'Trk  Type  Handler                    Kind  Lang  Bytes\n');

    if (track.total_tracks > 0) {
      while (track.total_tracks > track.track_num) {
        track.track_num += 1;
        TrackInfo track_info = {0};

        // tracknum, handler type, handler name
        APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);
        uint16_t more_whitespace =
            purge_extraneous_characters(track_info.track_hdlr_name);

        if (strlen(track_info.track_hdlr_name) == 0) {
          memcpy(track_info.track_hdlr_name, '[none listed]', 13);
        }
        fprintf(stdout,
                '%u    %s  %s',
                track.track_num,
                uint32tochar4(track_info.track_type, uint32_buffer),
                track_info.track_hdlr_name);

        uint16_t handler_len = strlen(track_info.track_hdlr_name);
        if (handler_len < 25 + more_whitespace) {
          for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {
            fprintf(stdout, ' ');
          }
        }

        // codec, language
        fprintf(stdout,
                '  %s  %s   %' PRIu64,
                uint32tochar4(track_info.track_codec, uint32_buffer),
                track_info.unpacked_lang,
                track_info.sample_aggregate);

        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {
          purge_extraneous_characters(track_info.encoder_name);
          fprintf(stdout, '   Encoder: %s', track_info.encoder_name);
        }
        if (track_info.type_of_track & DRM_PROTECTED_TRACK) {
          fprintf(stdout,
                  ' (protected %s)',
                  uint32tochar4(track_info.protected_codec, uint32_buffer));
        }

        fprintf(stdout, '\n');
        /*---------------------------------*/

        if (track_info.type_of_track & VIDEO_TRACK ||
            track_info.type_of_track & AUDIO_TRACK) {
          APar_Print_TrackDetails(&track_info);
        }

        if (optional_output & SHOW_DATE_INFO) {
          fprintf(stdout,
                  '       Creation Date (UTC):     %s\n',
                  APar_extract_UTC(track_info.creation_time));
          fprintf(stdout,
                  '       Modification Date (UTC): %s\n',
                  APar_extract_UTC(track_info.modified_time));
        }
      }
    }
  }
}
",8759
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,1,"    memset(track_info->track_hdlr_name, 0, 100);
    APar_readX(track_info->track_hdlr_name,
               isofile,
",8760
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,1,"               parsedAtoms[track->track_atom].AtomicLength - 32);
  }

",8761
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,1,"void APar_ExtractTrackDetails(char *uint32_buffer,
                              FILE *isofile,
                              Trackage *track,
                              TrackInfo *track_info) {
  uint64_t _offset = 0;

  APar_TrackLevelInfo(track, 'tkhd');
  if (APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 8) ==
      0) {
    if (APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 11) &
        1) {
      track_info->track_enabled = true;
    }
    track_info->creation_time =
        APar_read32(uint32_buffer,
                    isofile,
                    parsedAtoms[track->track_atom].AtomicStart + 12);
    track_info->modified_time =
        APar_read32(uint32_buffer,
                    isofile,
                    parsedAtoms[track->track_atom].AtomicStart + 16);
    track_info->duration =
        APar_read32(uint32_buffer,
                    isofile,
                    parsedAtoms[track->track_atom].AtomicStart + 28);
  } else {
    track_info->creation_time =
        APar_read64(uint32_buffer,
                    isofile,
                    parsedAtoms[track->track_atom].AtomicStart + 12);
    track_info->modified_time =
        APar_read64(uint32_buffer,
                    isofile,
                    parsedAtoms[track->track_atom].AtomicStart + 20);
    track_info->duration =
        APar_read64(uint32_buffer,
                    isofile,
                    parsedAtoms[track->track_atom].AtomicStart + 36);
  }

  // language code
  APar_TrackLevelInfo(track, 'mdhd');
  memset(uint32_buffer, 0, 5);
  uint16_t packed_language = APar_read16(
      uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 28);
  memset(track_info->unpacked_lang, 0, 4);
  APar_UnpackLanguage(
      track_info->unpacked_lang,
      packed_language); // http://www.w3.org/WAI/ER/IG/ert/iso639.htm

  // track handler type
  APar_TrackLevelInfo(track, 'hdlr');
  memset(uint32_buffer, 0, 5);
  track_info->track_type = APar_read32(
      uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 16);
  if (track_info->track_type == 0x736F756E) { // soun
    track_info->type_of_track = AUDIO_TRACK;
  } else if (track_info->track_type == 0x76696465) { // vide
    track_info->type_of_track = VIDEO_TRACK;
  }
  if (parsedAtoms[track->track_atom].AtomicLength > 34) {
    memset(track_info->track_hdlr_name, 0, 100);
    APar_readX(track_info->track_hdlr_name,
               isofile,
               parsedAtoms[track->track_atom].AtomicStart + 32,
               parsedAtoms[track->track_atom].AtomicLength - 32);
  }

  // codec section
  APar_TrackLevelInfo(track, 'stsd');
  memset(uint32_buffer, 0, 5);
  track_info->track_codec = APar_read32(
      uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 20);

  if (track_info->type_of_track & VIDEO_TRACK) { // vide
    track_info->video_width =
        APar_read16(uint32_buffer,
                    isofile,
                    parsedAtoms[track->track_atom + 1].AtomicStart + 32);
    track_info->video_height =
        APar_read16(uint32_buffer,
                    isofile,
                    parsedAtoms[track->track_atom + 1].AtomicStart + 34);
    track_info->macroblocks =
        (track_info->video_width / 16) * (track_info->video_height / 16);

    // avc profile & level
    if (track_info->track_codec == 0x61766331 ||
        track_info->track_codec == 0x64726D69) { // avc1 or drmi
      track_info->contains_esds = false;
      APar_TrackLevelInfo(track, 'avcC');
      // get avc1 profile/level; atom 'avcC' is :
      // byte 1	configurationVersion    byte 2	AVCProfileIndication byte 3
      // profile_compatibility    byte 4	AVCLevelIndication
      track_info->avc_version =
          APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 8);
      if (track_info->avc_version == 1) {
        track_info->profile =
            APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 9);
        // uint8_t profile_compatibility = APar_read8(isofile,
        // parsedAtoms[track.track_atom].AtomicStart + 10); /* is this reserved
        // ?? */
        track_info->level = APar_read8(
            isofile, parsedAtoms[track->track_atom].AtomicStart + 11);
      }

      // avc1 doesn't have a hardcoded bitrate, so calculate it (off of stsz
      // table summing) later
    } else if (track_info->track_codec == 0x73323633) { // s263
      APar_TrackLevelInfo(track, 'd263');
      if (memcmp(parsedAtoms[track->track_atom].AtomicName, 'd263', 4) == 0) {
        APar_Extract_d263_Info(
            uint32_buffer, isofile, track->track_atom, track_info);
      }

    } else { // mp4v
      APar_TrackLevelInfo(track, 'esds');
      if (memcmp(parsedAtoms[track->track_atom].AtomicName, 'esds', 4) == 0) {
        APar_Extract_esds_Info(
            uint32_buffer,
            isofile,
            track->track_atom - 1,
            track_info); // right, backtrack to the atom before 'esds' so we can
                         // offset_into_stsd++
      } else if (track_info->track_codec == 0x73323633) { // s263
        track_info->type_of_track = VIDEO_TRACK;
      } else if (track_info->track_codec == 0x73616D72 ||
                 track_info->track_codec == 0x73617762 ||
                 track_info->track_codec == 0x73617770 ||
                 track_info->track_codec ==
                     0x73766D72) { // samr, sawb, sawp & svmr
        track_info->type_of_track = AUDIO_TRACK;
      } else {
        track_info->type_of_track = OTHER_TRACK; // a 'jpeg' track will fall
                                                 // here
      }
    }

  } else if (track_info->type_of_track & AUDIO_TRACK) {
    if (track_info->track_codec == 0x73616D72 ||
        track_info->track_codec == 0x73617762 ||
        track_info->track_codec == 0x73617770 ||
        track_info->track_codec ==
            0x73766D72) { // samr,sawb, svmr (sawp doesn't contain modes)
      APar_Extract_AMR_Info(
          uint32_buffer, isofile, track->track_atom + 2, track_info);

    } else if (track_info->track_codec == 0x73657663) { // sevc
      APar_TrackLevelInfo(track, 'devc');
      if (memcmp(parsedAtoms[track->track_atom].AtomicName, 'devc', 4) == 0) {
        APar_Extract_devc_Info(isofile, track->track_atom, track_info);
      }

    } else if (track_info->track_codec == 0x73716370) { // sqcp
      APar_TrackLevelInfo(track, 'dqcp');
      if (memcmp(parsedAtoms[track->track_atom].AtomicName, 'dqcp', 4) == 0) {
        APar_Extract_devc_Info(isofile,
                               track->track_atom,
                               track_info); // its the same thing
      }

    } else if (track_info->track_codec == 0x73736D76) { // ssmv
      APar_TrackLevelInfo(track, 'dsmv');
      if (memcmp(parsedAtoms[track->track_atom].AtomicName, 'dsmv', 4) == 0) {
        APar_Extract_devc_Info(isofile,
                               track->track_atom,
                               track_info); // its the same thing
      }

    } else {
      APar_Extract_esds_Info(
          uint32_buffer, isofile, track->track_atom, track_info);
    }
  }

  // in case bitrate isn't found, manually determine it off of stsz summing
  if ((track_info->type_of_track & AUDIO_TRACK ||
       track_info->type_of_track & VIDEO_TRACK) &&
      track_info->avg_bitrate == 0) {
    if (track_info->track_codec == 0x616C6163) { // alac
      track_info->channels =
          APar_read16(uint32_buffer,
                      isofile,
                      parsedAtoms[track->track_atom + 1].AtomicStart + 24);
    }
  }

  APar_TrackLevelInfo(track, 'stsz');
  if (memcmp(parsedAtoms[track->track_atom].AtomicName, 'stsz', 4) == 0) {
    track_info->sample_aggregate =
        calcuate_sample_size(uint32_buffer, isofile, track->track_atom);
  }

  // get what exactly 'drmX' stands in for
  if (track_info->track_codec >= 0x64726D00 &&
      track_info->track_codec <= 0x64726DFF) {
    track_info->type_of_track += DRM_PROTECTED_TRACK;
    APar_TrackLevelInfo(track, 'frma');
    memset(uint32_buffer, 0, 5);
    track_info->protected_codec = APar_read32(
        uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 8);
  }

  // Encoder string; occasionally, it appears under stsd for a video track; it
  // is typcally preceded by ' ²' (1st char is unprintable) or 0x01B2
  if (track_info->contains_esds) {
    APar_TrackLevelInfo(track, 'esds');

    // technically, user_data_start_code should be tested aginst 0x000001B2;
    // TODO: it should only be read up to section 3's length too
    _offset = APar_FindValueInAtom(
        uint32_buffer, isofile, track->track_atom, 24, 0x01B2);

    if (_offset > 0 && _offset < parsedAtoms[track->track_atom].AtomicLength) {
      _offset += 2;
      memset(track_info->encoder_name,
             0,
             parsedAtoms[track->track_atom].AtomicLength - _offset);
      APar_readX(track_info->encoder_name,
                 isofile,
                 parsedAtoms[track->track_atom].AtomicStart + _offset,
                 parsedAtoms[track->track_atom].AtomicLength - _offset);
    }
  }
  return;
}
",8762
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,1,"void APar_ShowObjectProfileInfo(uint8_t track_type, TrackInfo *track_info) {
  if (track_info->contains_esds) {
    switch (track_info->ObjectTypeIndication) {
    // 0x00 es Lambada/Verboten/Forbidden
    case 0x01:
    case 0x02: {
      fprintf(stdout, '  MPEG-4 Systems (BIFS/ObjDesc)');
      break;
    }
    case 0x03: {
      fprintf(stdout, '  Interaction Stream');
      break;
    }
    case 0x04: {
      fprintf(stdout, '  MPEG-4 Systems Extended BIFS');
      break;
    }
    case 0x05: {
      fprintf(stdout, '  MPEG-4 Systems AFX');
      break;
    }
    case 0x06: {
      fprintf(stdout, '  Font Data Stream');
      break;
    }
    case 0x08: {
      fprintf(stdout, '  Synthesized Texture Stream');
      break;
    }
    case 0x07: {
      fprintf(stdout, '  Streaming Text Stream');
      break;
    }
    // 0x09-0x1F reserved
    case 0x20: {
      APar_ShowMPEG4VisualProfileInfo(track_info);
      break;
    }

    case 0x40: { // vererable mpeg-4 aac
      APar_ShowMPEG4AACProfileInfo(track_info);
      break;
    }

    // 0x41-0x5F reserved
    case 0x60: {
      fprintf(stdout,
              '  MPEG-2 Visual Simple Profile'); //'Visual ISO/IEC 13818-2
                                                 // Simple Profile'
      break;
    }
    case 0x61: {
      fprintf(stdout, '  MPEG-2 Visual Main Profile'); //'Visual ISO/IEC 13818-2
                                                       // Main Profile'
      break;
    }
    case 0x62: {
      fprintf(
          stdout,
          '  MPEG-2 Visual SNR Profile'); //'Visual ISO/IEC 13818-2 SNR Profile'
      break;
    }
    case 0x63: {
      fprintf(stdout,
              '  MPEG-2 Visual Spatial Profile'); //'Visual ISO/IEC 13818-2
                                                  // Spatial Profile'
      break;
    }
    case 0x64: {
      fprintf(stdout, '  MPEG-2 Visual High Profile'); //'Visual ISO/IEC 13818-2
                                                       // High Profile'
      break;
    }
    case 0x65: {
      fprintf(stdout, '  MPEG-2 Visual 4:2:2 Profile'); //'Visual ISO/IEC
                                                        // 13818-2 422 Profile'
      break;
    }
    case 0x66: {
      fprintf(
          stdout,
          '  MPEG-2 AAC Main Profile'); //'Audio ISO/IEC 13818-7 Main Profile'
      break;
    }
    case 0x67: {
      fprintf(stdout,
              '  MPEG-2 AAC Low Complexity Profile'); // Audio ISO/IEC 13818-7
                                                      // LowComplexity Profile
      break;
    }
    case 0x68: {
      fprintf(
          stdout,
          '  MPEG-2 AAC Scaleable Sample Rate Profile'); //'Audio ISO/IEC
                                                         // 13818-7 Scaleable
                                                         // Sampling Rate
                                                         // Profile'
      break;
    }
    case 0x69: {
      fprintf(stdout, '  MPEG-2 Audio'); //'Audio ISO/IEC 13818-3'
      break;
    }
    case 0x6A: {
      fprintf(stdout, '  MPEG-1 Visual'); //'Visual ISO/IEC 11172-2'
      break;
    }
    case 0x6B: {
      fprintf(stdout, '  MPEG-1 Audio'); //'Audio ISO/IEC 11172-3'
      break;
    }
    case 0x6C: {
      fprintf(stdout, '  JPEG'); //'Visual ISO/IEC 10918-1'
      break;
    }
    case 0x6D: {
      fprintf(stdout, '  PNG'); // http://www.mp4ra.org/object.html
      break;
    }
    case 0x6E: {
      fprintf(stdout, '  JPEG2000'); //'Visual ISO/IEC 15444-1'
      break;
    }
    case 0xA0: {
      fprintf(stdout, '  3GPP2 EVRC Voice'); // http://www.mp4ra.org/object.html
      break;
    }
    case 0xA1: {
      fprintf(stdout, '  3GPP2 SMV Voice'); // http://www.mp4ra.org/object.html
      break;
    }
    case 0xA2: {
      fprintf(
          stdout,
          '  3GPP2 Compact Multimedia Format'); // http://www.mp4ra.org/object.html
      break;
    }

    // 0xC0-0xE0 user private
    case 0xE1: {
      fprintf(stdout,
              '  3GPP2 QCELP (14K Voice)'); // http://www.mp4ra.org/object.html
      break;
    }
      // 0xE2-0xFE user private
      // 0xFF no object type specified

    default: {
      // so many profiles, so little desire to list them all (in 14496-2 which I
      // don't have)
      if (movie_info.contains_iods && iods_info.audio_profile == 0xFE) {
        fprintf(stdout,
                '  Private user object: 0x%X',
                track_info->ObjectTypeIndication);
      } else {
        fprintf(
            stdout,
            '  Object Type Indicator: 0x%X  Description Ojbect Type ID: 0x%X\n',
            track_info->ObjectTypeIndication,
            track_info->descriptor_object_typeID);
      }
      break;
    }
    }

  } else if (track_type == AVC1_TRACK) {
    // profiles & levels are in the 14496-10 pdf (which I don't have access to),
    // so... http://lists.mpegif.org/pipermail/mp4-tech/2006-January/006255.html
    // http://iphome.hhi.de/suehring/tml/doc/lenc/html/configfile_8c-source.html
    // 66=baseline, 77=main, 88=extended; 100=High, 110=High 10, 122=High 4:2:2,
    // 144=High 4:4:4

    switch (track_info->profile) {
    case 66: {
      fprintf(stdout, '  AVC Baseline Profile');
      break;
    }
    case 77: {
      fprintf(stdout, '  AVC Main Profile');
      break;
    }
    case 88: {
      fprintf(stdout, '  AVC Extended Profile');
      break;
    }
    case 100: {
      fprintf(stdout, '  AVC High Profile');
      break;
    }
    case 110: {
      fprintf(stdout, '  AVC High 10 Profile');
      break;
    }
    case 122: {
      fprintf(stdout, '  AVC High 4:2:2 Profile');
      break;
    }
    case 144: {
      fprintf(stdout, '  AVC High 4:4:4 Profile');
      break;
    }
    default: {
      fprintf(stdout, '  Unknown Profile: %u', track_info->profile);
      break;
    }
    } // end profile switch

    // Don't have access to levels either, but working off of:
    // http://iphome.hhi.de/suehring/tml/doc/lenc/html/configfile_8c-source.html

    // and the 15 levels it says here:
    // http://www.chiariglione.org/mpeg/technologies/mp04-avc/index.htm (1b in
    // http://en.wikipedia.org/wiki/H.264 seems nonsensical) working backwards,
    // we get... a simple 2 digit number (with '20' just drop the 0; with 21,
    // put in a decimal)
    if (track_info->level > 0) {
      switch (track_info->level) {
      case 10:
      case 20:
      case 30:
      case 40:
      case 50: {
        fprintf(stdout, ',  Level %u', track_info->level / 10);
        break;
      }
      case 11:
      case 12:
      case 13:
      case 21:
      case 22:
      case 31:
      case 32:
      case 41:
      case 42:
      case 51: {
        fprintf(stdout,
                ',  Level %u.%u',
                track_info->level / 10,
                track_info->level % 10);
        break;
      }
      default: {
        fprintf(stdout,
                ', Unknown level %u.%u',
                track_info->level / 10,
                track_info->level % 10);
      }

      } // end switch
    }   // end level if
  } else if (track_type == S_AMR_TRACK) {
    char *amr_modes = (char *)calloc(1, sizeof(char) * 500);
    if (track_info->track_codec == 0x73616D72 ||
        track_info->track_codec == 0x73617762) {
      if (track_info->amr_modes & 0x0001)
        mem_append('0', amr_modes);
      if (track_info->amr_modes & 0x0002)
        mem_append('1', amr_modes);
      if (track_info->amr_modes & 0x0004)
        mem_append('2', amr_modes);
      if (track_info->amr_modes & 0x0008)
        mem_append('3', amr_modes);
      if (track_info->amr_modes & 0x0010)
        mem_append('4', amr_modes);
      if (track_info->amr_modes & 0x0020)
        mem_append('5', amr_modes);
      if (track_info->amr_modes & 0x0040)
        mem_append('6', amr_modes);
      if (track_info->amr_modes & 0x0080)
        mem_append('7', amr_modes);
      if (track_info->amr_modes & 0x0100)
        mem_append('8', amr_modes);
      if (strlen(amr_modes) == 0)
        memcpy(amr_modes, 'none', 4);
    } else if (track_info->track_codec == 0x73766D72) {
      if (track_info->amr_modes & 0x0001)
        mem_append('VMR-WB Mode 0, ', amr_modes);
      if (track_info->amr_modes & 0x0002)
        mem_append('VMR-WB Mode 1, ', amr_modes);
      if (track_info->amr_modes & 0x0004)
        mem_append('VMR-WB Mode 2, ', amr_modes);
      if (track_info->amr_modes & 0x0008)
        mem_append('VMR-WB Mode 3 (AMR-WB interoperable mode), ', amr_modes);
      if (track_info->amr_modes & 0x0010)
        mem_append('VMR-WB Mode 4, ', amr_modes);
      if (track_info->amr_modes & 0x0020)
        mem_append('VMR-WB Mode 2 with maximum half-rate, ', amr_modes);
      if (track_info->amr_modes & 0x0040)
        mem_append('VMR-WB Mode 4 with maximum half-rate, ', amr_modes);
      uint16_t amr_modes_len = strlen(amr_modes);
      if (amr_modes_len > 0)
        memset(amr_modes + (amr_modes_len - 1), 0, 2);
    }

    if (track_info->track_codec == 0x73616D72) { // samr
      fprintf(stdout,
              '  AMR Narrow-Band. Modes: %s. Encoder vendor code: %s\n',
              amr_modes,
              track_info->encoder_name);
    } else if (track_info->track_codec == 0x73617762) { // sawb
      fprintf(stdout,
              '  AMR Wide-Band. Modes: %s. Encoder vendor code: %s\n',
              amr_modes,
              track_info->encoder_name);
    } else if (track_info->track_codec == 0x73617770) { // sawp
      fprintf(stdout,
              '  AMR Wide-Band WB+. Encoder vendor code: %s\n',
              track_info->encoder_name);
    } else if (track_info->track_codec == 0x73766D72) { // svmr
      fprintf(stdout,
              '  AMR VBR Wide-Band. Encoder vendor code: %s\n',
              track_info->encoder_name);
    }
    free(amr_modes);
    amr_modes = NULL;

  } else if (track_type == EVRC_TRACK) {
    fprintf(stdout,
            '  EVRC (Enhanced Variable Rate Coder). Encoder vendor code: %s\n',
            track_info->encoder_name);

  } else if (track_type == QCELP_TRACK) {
    fprintf(stdout,
            '  QCELP (Qualcomm Code Excited Linear Prediction). Encoder vendor '
            'code: %s\n',
            track_info->encoder_name);

  } else if (track_type == S263_TRACK) {
    if (track_info->profile == 0) {
      fprintf(stdout,
              '  H.263 Baseline Profile, Level %u. Encoder vendor code: %s',
              track_info->level,
              track_info->encoder_name);
    } else {
      fprintf(stdout,
              '  H.263 Profile: %u, Level %u. Encoder vendor code: %s',
              track_info->profile,
              track_info->level,
              track_info->encoder_name);
    }
  }
  if (track_type == AUDIO_TRACK) {
    if (track_info->section5_length == 0) {
      fprintf(stdout, '    channels: (%u)\n', track_info->channels);
    } else {
      fprintf(stdout, '    channels: [%u]\n', track_info->channels);
    }
  }
  return;
}
",8763
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,1,"void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {
  char *uint32_buffer = (char *)malloc(sizeof(char) * 5);
  Trackage track = {0};

  AtomicInfo *mvhdAtom = APar_FindAtom('moov.mvhd', false, VERSIONED_ATOM, 0);
  if (mvhdAtom != NULL) {
    APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);
    fprintf(stdout,
            'Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate '
            '(*=approximate)\n',
            movie_info.seconds,
            secsTOtime(movie_info.seconds),
            movie_info.simple_bitrate_calc);
    if (optional_output & SHOW_DATE_INFO) {
      fprintf(stdout,
              '  Presentation Creation Date (UTC):     %s\n',
              APar_extract_UTC(movie_info.creation_time));
      fprintf(stdout,
              '  Presentation Modification Date (UTC): %s\n',
              APar_extract_UTC(movie_info.modified_time));
    }
  }

  AtomicInfo *iodsAtom = APar_FindAtom('moov.iods', false, VERSIONED_ATOM, 0);
  if (iodsAtom != NULL) {
    movie_info.contains_iods = true;
    APar_Extract_iods_Info(isofile, iodsAtom);
  }

  if (optional_output & SHOW_TRACK_INFO) {
    APar_TrackLevelInfo(&track,
                        NULL); // With track_num set to 0, it will return the
                               // total trak atom into total_tracks here.

    fprintf(
        stdout, 'Low-level details. Total tracks: %u\n', track.total_tracks);
    fprintf(stdout,
            'Trk  Type  Handler                    Kind  Lang  Bytes\n');

    if (track.total_tracks > 0) {
      while (track.total_tracks > track.track_num) {
        track.track_num += 1;
        TrackInfo track_info = {0};

        // tracknum, handler type, handler name
        APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);
        uint16_t more_whitespace =
            purge_extraneous_characters(track_info.track_hdlr_name);

        if (strlen(track_info.track_hdlr_name) == 0) {
          memcpy(track_info.track_hdlr_name, '[none listed]', 13);
        }
        fprintf(stdout,
                '%u    %s  %s',
                track.track_num,
                uint32tochar4(track_info.track_type, uint32_buffer),
                track_info.track_hdlr_name);

        uint16_t handler_len = strlen(track_info.track_hdlr_name);
        if (handler_len < 25 + more_whitespace) {
          for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {
            fprintf(stdout, ' ');
          }
        }

        // codec, language
        fprintf(stdout,
                '  %s  %s   %' PRIu64,
                uint32tochar4(track_info.track_codec, uint32_buffer),
                track_info.unpacked_lang,
                track_info.sample_aggregate);

        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {
          purge_extraneous_characters(track_info.encoder_name);
          fprintf(stdout, '   Encoder: %s', track_info.encoder_name);
        }
        if (track_info.type_of_track & DRM_PROTECTED_TRACK) {
          fprintf(stdout,
                  ' (protected %s)',
                  uint32tochar4(track_info.protected_codec, uint32_buffer));
        }

        fprintf(stdout, '\n');
        /*---------------------------------*/

        if (track_info.type_of_track & VIDEO_TRACK ||
            track_info.type_of_track & AUDIO_TRACK) {
          APar_Print_TrackDetails(&track_info);
        }

        if (optional_output & SHOW_DATE_INFO) {
          fprintf(stdout,
                  '       Creation Date (UTC):     %s\n',
                  APar_extract_UTC(track_info.creation_time));
          fprintf(stdout,
                  '       Modification Date (UTC): %s\n',
                  APar_extract_UTC(track_info.modified_time));
        }
      }
    }
  }
  return;
}
",8764
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,1,"void APar_ExtractBrands(char *filepath) {
  FILE *a_file = APar_OpenISOBaseMediaFile(filepath, true);
  char *buffer = (char *)calloc(1, sizeof(char) * 16);
  uint32_t atom_length = 0;
  uint8_t file_type_offset = 0;
  uint32_t compatible_brand = 0;
  bool cb_V2ISOBMFF = false;

  APar_read32(buffer, a_file, 4);
  if (memcmp(buffer, 'ftyp', 4) == 0) {
    atom_length = APar_read32(buffer, a_file, 0);
  } else {
    APar_readX(buffer, a_file, 0, 12);
    if (memcmp(buffer,
               '\x00\x00\x00\x0C\x6A\x50\x20\x20\x0D\x0A\x87\x0A',
               12) == 0) {
      APar_readX(buffer, a_file, 12, 12);
      if (memcmp(buffer + 4, 'ftypmjp2', 8) == 0 ||
          memcmp(buffer + 4, 'ftypmj2s', 8) == 0) {
        atom_length = UInt32FromBigEndian(buffer);
        file_type_offset = 12;
      }
    }
  }

  if (atom_length > 0) {
    memset(buffer, 0, 16);
    APar_readX(buffer, a_file, 8 + file_type_offset, 4);
    printBOM();
    fprintf(stdout, ' Major Brand: %s', buffer);
    APar_IdentifyBrand(buffer);

    if (memcmp(buffer, 'isom', 4) == 0) {
      APar_ScanAtoms(filepath); // scan_file = true;
    }

    uint32_t minor_version = APar_read32(buffer, a_file, 12 + file_type_offset);
    fprintf(stdout, '  -  version %' PRIu32 '\n', minor_version);

    fprintf(stdout, ' Compatible Brands:');
    for (uint64_t i = 16 + file_type_offset; i < atom_length; i += 4) {
      APar_readX(buffer, a_file, i, 4);
      compatible_brand = UInt32FromBigEndian(buffer);
      if (compatible_brand != 0) {
        fprintf(stdout, ' %s', buffer);
        if (compatible_brand == 0x6D703432 || compatible_brand == 0x69736F32) {
          cb_V2ISOBMFF = true;
        }
      }
    }
    fprintf(stdout, '\n');
  }

  APar_OpenISOBaseMediaFile(filepath, false);

  fprintf(stdout, ' Tagging schemes available:\n');
  switch (metadata_style) {
  case ITUNES_STYLE: {
    fprintf(stdout, '   iTunes-style metadata allowed.\n');
    break;
  }
  case THIRD_GEN_PARTNER:
  case THIRD_GEN_PARTNER_VER1_REL6:
  case THIRD_GEN_PARTNER_VER1_REL7:
  case THIRD_GEN_PARTNER_VER2: {
    fprintf(stdout, '   3GP-style asset metadata allowed.\n');
    break;
  }
  case THIRD_GEN_PARTNER_VER2_REL_A: {
    fprintf(stdout,
            '   3GP-style asset metadata allowed [& unimplemented GAD '
            '(Geographical Area Description) asset].\n');
    break;
  }
  }
  if (cb_V2ISOBMFF || metadata_style == THIRD_GEN_PARTNER_VER1_REL7) {
    fprintf(stdout,
            '   ID3 tags on ID32 atoms @ file/movie/track level allowed.\n');
  }
  fprintf(stdout,
          '   ISO-copyright notices @ movie and/or track level '
          'allowed.\n   uuid private user extension tags allowed.\n');

  free(buffer);
  buffer = NULL;
  return;
}
",8765
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,0,"  data[2] = (lnum >> 8) & 0xff;
  data[3] = (lnum >> 0) & 0xff;
  return data;
",8766
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,0,"uint8_t APar_ExtractChannelInfo(FILE *isofile, uint32_t pos) {
  uint8_t packed_channels = APar_read8(isofile, pos);
  uint8_t unpacked_channels =
      (packed_channels << 1); // just shift the first bit off the table
  unpacked_channels =
      (unpacked_channels >> 4); // and slide it on over back on the uint8_t
  return unpacked_channels;
}
",8767
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,0,"            movie_info.simple_bitrate_calc);
    if (optional_output & SHOW_DATE_INFO) {
      fprintf(stdout,
",8768
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,0,"                track_info.sample_aggregate);

        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {
",8769
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,0,"  // get what exactly 'drmX' stands in for
  if (track_info->track_codec >= 0x64726D00 &&
      track_info->track_codec <= 0x64726DFF) {
",8770
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,0,"void APar_Print_TrackDetails(TrackInfo *track_info) {
  if (track_info->max_bitrate > 0 && track_info->avg_bitrate > 0) {
    fprintf(stdout, '     %.2f kbp/s', (float)track_info->avg_bitrate / 1000.0);
  } else { // some ffmpeg encodings have avg_bitrate set to 0, but an inexact
           // max_bitrate - actually, their esds seems a mess to me
#if defined(_MSC_VER)
    fprintf(stdout,
            '     %.2lf* kbp/s',
            ((double)((__int64)track_info->sample_aggregate) /
             ((double)((__int64)track_info->duration) /
              (double)((__int64)movie_info.timescale))) /
                1000.0 * 8);
    fprintf(stdout,
            '  %.3f sec',
            (float)track_info->duration / (float)movie_info.timescale);
#else
    fprintf(stdout,
            '     %.2lf* kbp/s',
            ((double)track_info->sample_aggregate /
             ((double)track_info->duration / (double)movie_info.timescale)) /
                1000.0 * 8);
    fprintf(stdout,
            '  %.3f sec',
            (float)track_info->duration / (float)movie_info.timescale);
#endif
  }

  if (track_info->track_codec == 0x6D703476) { // mp4v profile
    APar_ShowObjectProfileInfo(MP4V_TRACK, track_info);
  } else if (track_info->track_codec == 0x6D703461 ||
             track_info->protected_codec == 0x6D703461) { // mp4a profile
    APar_ShowObjectProfileInfo(AUDIO_TRACK, track_info);
  } else if (track_info->track_codec ==
             0x616C6163) { // alac - can't figure out a hardcoded bitrate either
    fprintf(
        stdout, '  Apple Lossless    channels: [%u]\n', track_info->channels);
  } else if (track_info->track_codec == 0x61766331 ||
             track_info->protected_codec == 0x61766331) {
    if (track_info->avc_version == 1) { // avc profile & level
      APar_ShowObjectProfileInfo(AVC1_TRACK, track_info);
    }
  } else if (track_info->track_codec == 0x73323633) { // s263 in 3gp
    APar_ShowObjectProfileInfo(S263_TRACK, track_info);
  } else if (track_info->track_codec == 0x73616D72 ||
             track_info->track_codec == 0x73617762 ||
             track_info->track_codec == 0x73617770 ||
             track_info->track_codec ==
                 0x73766D72) { // samr,sawb,sawp & svmr in 3gp
    track_info->type_of_track = S_AMR_TRACK;
    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);
  } else if (track_info->track_codec == 0x73657663) { // evrc in 3gp
    track_info->type_of_track = EVRC_TRACK;
    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);
  } else if (track_info->track_codec == 0x73716370) { // qcelp in 3gp
    track_info->type_of_track = QCELP_TRACK;
    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);
  } else if (track_info->track_codec == 0x73736D76) { // smv in 3gp
    track_info->type_of_track = SMV_TRACK;
    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);
  } else { // unknown everything, 0 hardcoded bitrate
    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);
    fprintf(stdout, '\n');
  }

  if (track_info->type_of_track & VIDEO_TRACK &&
      ((track_info->max_bitrate > 0 &&
        track_info->ObjectTypeIndication == 0x20) ||
       track_info->avc_version == 1 || track_info->protected_codec != 0)) {
    fprintf(stdout,
            '  %ux%u  (%' PRIu32 ' macroblocks)\n',
            track_info->video_width,
            track_info->video_height,
            track_info->macroblocks);
  } else if (track_info->type_of_track & VIDEO_TRACK) {
    fprintf(stdout, '\n');
  }
  return;
}
",8771
wez/atomicparsley,abbce70ecf54a8bbc6e84d3ad8ca5d98f9476e1d,0,"}

void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {
",8772
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,1,"rfbBool
ReadFromRFBServer(rfbClient* client, char *out, unsigned int n)
{
#undef DEBUG_READ_EXACT
#ifdef DEBUG_READ_EXACT
	char* oout=out;
	unsigned int nn=n;
	rfbClientLog('ReadFromRFBServer %d bytes\n',n);
#endif

  /* Handle attempts to write to NULL out buffer that might occur
     when an outside malloc() fails. For instance, memcpy() to NULL
     results in undefined behaviour and probably memory corruption.*/
  if(!out)
    return FALSE;

  if (client->serverPort==-1) {
    /* vncrec playing */
    rfbVNCRec* rec = client->vncRec;
    struct timeval tv;

    if (rec->readTimestamp) {
      rec->readTimestamp = FALSE;
      if (!fread(&tv,sizeof(struct timeval),1,rec->file))
        return FALSE;

      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);
      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);

      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {
        struct timeval diff;
        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;
        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;
        if(diff.tv_usec<0) {
	  diff.tv_sec--;
	  diff.tv_usec+=1000000;
        }
#ifndef WIN32
        sleep (diff.tv_sec);
        usleep (diff.tv_usec);
#else
	Sleep (diff.tv_sec * 1000 + diff.tv_usec/1000);
#endif
      }

      rec->tv=tv;
    }
    
    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);
  }
  
  if (n <= client->buffered) {
    memcpy(out, client->bufoutptr, n);
    client->bufoutptr += n;
    client->buffered -= n;
#ifdef DEBUG_READ_EXACT
    goto hexdump;
#endif
    return TRUE;
  }

  memcpy(out, client->bufoutptr, client->buffered);

  out += client->buffered;
  n -= client->buffered;

  client->bufoutptr = client->buf;
  client->buffered = 0;

  if (n <= RFB_BUF_SIZE) {

    while (client->buffered < n) {
      int i;
      if (client->tlsSession)
        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);
      else
#ifdef LIBVNCSERVER_HAVE_SASL
      if (client->saslconn)
        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);
      else {
#endif /* LIBVNCSERVER_HAVE_SASL */
        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);
#ifdef WIN32
	if (i < 0) errno=WSAGetLastError();
#endif
#ifdef LIBVNCSERVER_HAVE_SASL
      }
#endif
  
      if (i <= 0) {
	if (i < 0) {
	  if (errno == EWOULDBLOCK || errno == EAGAIN) {
	    /* TODO:
	       ProcessXtEvents();
	    */
	    WaitForMessage(client, 100000);
	    i = 0;
	  } else {
	    rfbClientErr('read (%d: %s)\n',errno,strerror(errno));
	    return FALSE;
	  }
	} else {
	  if (errorMessageOnReadFailure) {
	    rfbClientLog('VNC server closed connection\n');
	  }
	  return FALSE;
	}
      }
      client->buffered += i;
    }

    memcpy(out, client->bufoutptr, n);
    client->bufoutptr += n;
    client->buffered -= n;

  } else {

    while (n > 0) {
      int i;
      if (client->tlsSession)
        i = ReadFromTLS(client, out, n);
      else
#ifdef LIBVNCSERVER_HAVE_SASL
      if (client->saslconn)
        i = ReadFromSASL(client, out, n);
      else
#endif
        i = read(client->sock, out, n);

      if (i <= 0) {
	if (i < 0) {
#ifdef WIN32
	  errno=WSAGetLastError();
#endif
	  if (errno == EWOULDBLOCK || errno == EAGAIN) {
	    /* TODO:
	       ProcessXtEvents();
	    */
	    WaitForMessage(client, 100000);
	    i = 0;
	  } else {
	    rfbClientErr('read (%s)\n',strerror(errno));
	    return FALSE;
	  }
	} else {
	  if (errorMessageOnReadFailure) {
	    rfbClientLog('VNC server closed connection\n');
	  }
	  return FALSE;
	}
      }
      out += i;
      n -= i;
    }
  }

#ifdef DEBUG_READ_EXACT
hexdump:
  { unsigned int ii;
    for(ii=0;ii<nn;ii++)
      fprintf(stderr,'%02x ',(unsigned char)oout[ii]);
    fprintf(stderr,'\n');
  }
#endif

  return TRUE;
}
",8773
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,1,"static rfbBool
webSocketsHandshake(rfbClientPtr cl, char *scheme)
{
    char *buf, *response, *line;
    int n, linestart = 0, len = 0, llen, base64 = TRUE;
    char prefix[5], trailer[17];
    char *path = NULL, *host = NULL, *origin = NULL, *protocol = NULL;
    char *key1 = NULL, *key2 = NULL, *key3 = NULL;
    char *sec_ws_origin = NULL;
    char *sec_ws_key = NULL;
    char sec_ws_version = 0;
    ws_ctx_t *wsctx = NULL;

    buf = (char *) malloc(WEBSOCKETS_MAX_HANDSHAKE_LEN);
    if (!buf) {
        rfbLogPerror('webSocketsHandshake: malloc');
        return FALSE;
    }
    response = (char *) malloc(WEBSOCKETS_MAX_HANDSHAKE_LEN);
    if (!response) {
        free(buf);
        rfbLogPerror('webSocketsHandshake: malloc');
        return FALSE;
    }

    while (len < WEBSOCKETS_MAX_HANDSHAKE_LEN-1) {
        if ((n = rfbReadExactTimeout(cl, buf+len, 1,
                                     WEBSOCKETS_CLIENT_SEND_WAIT_MS)) <= 0) {
            if ((n < 0) && (errno == ETIMEDOUT)) {
                break;
            }
            if (n == 0)
                rfbLog('webSocketsHandshake: client gone\n');
            else
                rfbLogPerror('webSocketsHandshake: read');
            free(response);
            free(buf);
            return FALSE;
        }

        len += 1;
        llen = len - linestart;
        if (((llen >= 2)) && (buf[len-1] == '\n')) {
            line = buf+linestart;
            if ((llen == 2) && (strncmp('\r\n', line, 2) == 0)) {
                if (key1 && key2) {
                    if ((n = rfbReadExact(cl, buf+len, 8)) <= 0) {
                        if ((n < 0) && (errno == ETIMEDOUT)) {
                            break;
                        }
                        if (n == 0)
                            rfbLog('webSocketsHandshake: client gone\n');
                        else
                            rfbLogPerror('webSocketsHandshake: read');
                        free(response);
                        free(buf);
                        return FALSE;
                    }
                    rfbLog('Got key3\n');
                    key3 = buf+len;
                    len += 8;
                } else {
                    buf[len] = '\0';
                }
                break;
            } else if ((llen >= 16) && ((strncmp('GET ', line, min(llen,4))) == 0)) {
                /* 16 = 4 ('GET ') + 1 ('/.*') + 11 (' HTTP/1.1\r\n') */
                path = line+4;
                buf[len-11] = '\0'; /* Trim trailing ' HTTP/1.1\r\n' */
                cl->wspath = strdup(path);
                /* rfbLog('Got path: %s\n', path); */
            } else if ((strncasecmp('host: ', line, min(llen,6))) == 0) {
                host = line+6;
                buf[len-2] = '\0';
                /* rfbLog('Got host: %s\n', host); */
            } else if ((strncasecmp('origin: ', line, min(llen,8))) == 0) {
                origin = line+8;
                buf[len-2] = '\0';
                /* rfbLog('Got origin: %s\n', origin); */
            } else if ((strncasecmp('sec-websocket-key1: ', line, min(llen,20))) == 0) {
                key1 = line+20;
                buf[len-2] = '\0';
                /* rfbLog('Got key1: %s\n', key1); */
            } else if ((strncasecmp('sec-websocket-key2: ', line, min(llen,20))) == 0) {
                key2 = line+20;
                buf[len-2] = '\0';
                /* rfbLog('Got key2: %s\n', key2); */
            /* HyBI */

	    } else if ((strncasecmp('sec-websocket-protocol: ', line, min(llen,24))) == 0) {
                protocol = line+24;
                buf[len-2] = '\0';
                rfbLog('Got protocol: %s\n', protocol);
            } else if ((strncasecmp('sec-websocket-origin: ', line, min(llen,22))) == 0) {
		sec_ws_origin = line+22;
                buf[len-2] = '\0';
            } else if ((strncasecmp('sec-websocket-key: ', line, min(llen,19))) == 0) {
		sec_ws_key = line+19;
                buf[len-2] = '\0';
            } else if ((strncasecmp('sec-websocket-version: ', line, min(llen,23))) == 0) {
		sec_ws_version = strtol(line+23, NULL, 10);
                buf[len-2] = '\0';
	    }

            linestart = len;
        }
    }

    if (!(path && host && (origin || sec_ws_origin))) {
        rfbErr('webSocketsHandshake: incomplete client handshake\n');
        free(response);
        free(buf);
        return FALSE;
    }

    if ((protocol) && (strstr(protocol, 'binary'))) {
        if (! sec_ws_version) {
            rfbErr('webSocketsHandshake: 'binary' protocol not supported with Hixie\n');
            free(response);
            free(buf);
            return FALSE;
        }
        rfbLog('  - webSocketsHandshake: using binary/raw encoding\n');
        base64 = FALSE;
        protocol = 'binary';
    } else {
        rfbLog('  - webSocketsHandshake: using base64 encoding\n');
        base64 = TRUE;
        if ((protocol) && (strstr(protocol, 'base64'))) {
            protocol = 'base64';
        } else {
            protocol = '';
        }
    }

    /*
     * Generate the WebSockets server response based on the the headers sent
     * by the client.
     */

    if (sec_ws_version) {
	char accept[B64LEN(SHA1_HASH_SIZE) + 1];
	rfbLog('  - WebSockets client version hybi-%02d\n', sec_ws_version);
	webSocketsGenSha1Key(accept, sizeof(accept), sec_ws_key);
        if(strlen(protocol) > 0)
            len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,
	                   SERVER_HANDSHAKE_HYBI, accept, protocol);
        else
            len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,
                           SERVER_HANDSHAKE_HYBI_NO_PROTOCOL, accept);
    } else {
	/* older hixie handshake, this could be removed if
	 * a final standard is established */
	if (!(key1 && key2 && key3)) {
	    rfbLog('  - WebSockets client version hixie-75\n');
	    prefix[0] = '\0';
	    trailer[0] = '\0';
	} else {
	    rfbLog('  - WebSockets client version hixie-76\n');
	    snprintf(prefix, 5, 'Sec-');
	    webSocketsGenMd5(trailer, key1, key2, key3);
	}
	len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,
		 SERVER_HANDSHAKE_HIXIE, prefix, origin, prefix, scheme,
		 host, path, prefix, protocol, trailer);
    }

    if (rfbWriteExact(cl, response, len) < 0) {
        rfbErr('webSocketsHandshake: failed sending WebSockets response\n');
        free(response);
        free(buf);
        return FALSE;
    }
    /* rfbLog('webSocketsHandshake: %s\n', response); */
    free(response);
    free(buf);


    wsctx = calloc(1, sizeof(ws_ctx_t));
    if (sec_ws_version) {
	wsctx->version = WEBSOCKETS_VERSION_HYBI;
	wsctx->encode = webSocketsEncodeHybi;
	wsctx->decode = webSocketsDecodeHybi;
    } else {
	wsctx->version = WEBSOCKETS_VERSION_HIXIE;
	wsctx->encode = webSocketsEncodeHixie;
	wsctx->decode = webSocketsDecodeHixie;
    }
    wsctx->base64 = base64;
    cl->wsctx = (wsCtx *)wsctx;
    return TRUE;
}
",8774
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,1,"static int
webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len)
{
    char *buf, *payload;
    uint32_t *payload32;
    int ret = -1, result = -1;
    int total = 0;
    ws_mask_t mask;
    ws_header_t *header;
    int i;
    unsigned char opcode;
    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;
    int flength, fhlen;
    /* int fin; */ /* not used atm */ 

    /* rfbLog(' <== %s[%d]: %d cl: %p, wsctx: %p-%p (%d)\n', __func__, gettid(), len, cl, wsctx, (char *)wsctx + sizeof(ws_ctx_t), sizeof(ws_ctx_t)); */

    if (wsctx->readbuflen) {
      /* simply return what we have */
      if (wsctx->readbuflen > len) {
	memcpy(dst, wsctx->readbuf +  wsctx->readbufstart, len);
	result = len;
	wsctx->readbuflen -= len;
	wsctx->readbufstart += len;
      } else {
	memcpy(dst, wsctx->readbuf +  wsctx->readbufstart, wsctx->readbuflen);
	result = wsctx->readbuflen;
	wsctx->readbuflen = 0;
	wsctx->readbufstart = 0;
      }
      goto spor;
    }

    buf = wsctx->codeBufDecode;
    header = (ws_header_t *)wsctx->codeBufDecode;

    ret = ws_peek(cl, buf, B64LEN(len) + WSHLENMAX);

    if (ret < 2) {
        /* save errno because rfbErr() will tamper it */
        if (-1 == ret) {
            int olderrno = errno;
            rfbErr('%s: peek; %m\n', __func__);
            errno = olderrno;
        } else if (0 == ret) {
            result = 0;
        } else {
            errno = EAGAIN;
        }
        goto spor;
    }

    opcode = header->b0 & 0x0f;
    /* fin = (header->b0 & 0x80) >> 7; */ /* not used atm */
    flength = header->b1 & 0x7f;

    /*
     * 4.3. Client-to-Server Masking
     *
     * The client MUST mask all frames sent to the server.  A server MUST
     * close the connection upon receiving a frame with the MASK bit set to 0.
    **/
    if (!(header->b1 & 0x80)) {
	rfbErr('%s: got frame without mask\n', __func__, ret);
	errno = EIO;
	goto spor;
    }

    if (flength < 126) {
	fhlen = 2;
	mask = header->u.m;
    } else if (flength == 126 && 4 <= ret) {
	flength = WS_NTOH16(header->u.s16.l16);
	fhlen = 4;
	mask = header->u.s16.m16;
    } else if (flength == 127 && 10 <= ret) {
	flength = WS_NTOH64(header->u.s64.l64);
	fhlen = 10;
	mask = header->u.s64.m64;
    } else {
      /* Incomplete frame header */
      rfbErr('%s: incomplete frame header\n', __func__, ret);
      errno = EIO;
      goto spor;
    }

    /* absolute length of frame */
    total = fhlen + flength + 4;
    payload = buf + fhlen + 4; /* header length + mask */

    if (-1 == (ret = ws_read(cl, buf, total))) {
      int olderrno = errno;
      rfbErr('%s: read; %m', __func__);
      errno = olderrno;
      return ret;
    } else if (ret < total) {
      /* GT TODO: hmm? */
      rfbLog('%s: read; got partial data\n', __func__);
    } else {
      buf[ret] = '\0';
    }

    /* process 1 frame (32 bit op) */
    payload32 = (uint32_t *)payload;
    for (i = 0; i < flength / 4; i++) {
	payload32[i] ^= mask.u;
    }
    /* process the remaining bytes (if any) */
    for (i*=4; i < flength; i++) {
	payload[i] ^= mask.c[i % 4];
    }

    switch (opcode) {
      case WS_OPCODE_CLOSE:
	rfbLog('got closure, reason %d\n', WS_NTOH16(((uint16_t *)payload)[0]));
	errno = ECONNRESET;
	break;
      case WS_OPCODE_TEXT_FRAME:
	if (-1 == (flength = b64_pton(payload, (unsigned char *)wsctx->codeBufDecode, sizeof(wsctx->codeBufDecode)))) {
	  rfbErr('%s: Base64 decode error; %m\n', __func__);
	  break;
	}
	payload = wsctx->codeBufDecode;
	/* fall through */
      case WS_OPCODE_BINARY_FRAME:
	if (flength > len) {
	  memcpy(wsctx->readbuf, payload + len, flength - len);
	  wsctx->readbufstart = 0;
	  wsctx->readbuflen = flength - len;
	  flength = len;
	}
	memcpy(dst, payload, flength);
	result = flength;
	break;
      default:
	rfbErr('%s: unhandled opcode %d, b0: %02x, b1: %02x\n', __func__, (int)opcode, header->b0, header->b1);
    }

    /* single point of return, if someone has questions :-) */
spor:
    /* rfbLog('%s: ret: %d/%d\n', __func__, result, len); */
    return result;
}
",8775
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,1,"rfbBool
webSocketsHasDataInBuffer(rfbClientPtr cl)
{
    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;

    if (wsctx && wsctx->readbuflen)
      return TRUE;

    return (cl->sslctx && rfbssl_pending(cl) > 0);
}
",8776
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,1,"int
ConnectClientToUnixSock(const char *sockFile)
{
#ifdef WIN32
  rfbClientErr('Windows doesn't support UNIX sockets\n');
  return -1;
#else
  int sock;
  struct sockaddr_un addr;
  addr.sun_family = AF_UNIX;
  strcpy(addr.sun_path, sockFile);

  sock = socket(AF_UNIX, SOCK_STREAM, 0);
  if (sock < 0) {
    rfbClientErr('ConnectToUnixSock: socket (%s)\n',strerror(errno));
    return -1;
  }

  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {
    rfbClientErr('ConnectToUnixSock: connect\n');
    close(sock);
    return -1;
  }

  return sock;
#endif
}
",8777
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,0,"rfbSocket
ListenAtTcpPort(int port)
{
  return ListenAtTcpPortAndAddress(port, NULL);
}
",8778
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,0,"static int
webSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len)
{
    int retlen = 0, n, i, avail, modlen, needlen;
    char *buf, *end = NULL;
    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;

    buf = wsctx->codeBufDecode;

    n = ws_peek(cl, buf, len*2+2);

    if (n <= 0) {
        /* save errno because rfbErr() will tamper it */
        int olderrno = errno;
        rfbErr('%s: peek (%d) %m\n', __func__, errno);
        errno = olderrno;
        return n;
    }


    /* Base64 encoded WebSockets stream */

    if (buf[0] == '\xff') {
        i = ws_read(cl, buf, 1); /* Consume marker */
        buf++;
        n--;
    }
    if (n == 0) {
        errno = EAGAIN;
        return -1;
    }
    if (buf[0] == '\x00') {
        i = ws_read(cl, buf, 1); /* Consume marker */
        buf++;
        n--;
    }
    if (n == 0) {
        errno = EAGAIN;
        return -1;
    }

    /* end = memchr(buf, '\xff', len*2+2); */
    end = memchr(buf, '\xff', n);
    if (!end) {
        end = buf + n;
    }
    avail = end - buf;

    len -= wsctx->carrylen;

    /* Determine how much base64 data we need */
    modlen = len + (len+2)/3;
    needlen = modlen;
    if (needlen % 4) {
        needlen += 4 - (needlen % 4);
    }

    if (needlen > avail) {
        /* rfbLog('Waiting for more base64 data\n'); */
        errno = EAGAIN;
        return -1;
    }

    /* Any carryover from previous decode */
    for (i=0; i < wsctx->carrylen; i++) {
        /* rfbLog('Adding carryover %d\n', wsctx->carryBuf[i]); */
        dst[i] = wsctx->carryBuf[i];
        retlen += 1;
    }

    /* Decode the rest of what we need */
    buf[needlen] = '\x00';  /* Replace end marker with end of string */
    /* rfbLog('buf: %s\n', buf); */
    n = b64_pton(buf, (unsigned char *)dst+retlen, 2+len);
    if (n < len) {
        rfbErr('Base64 decode error\n');
        errno = EIO;
        return -1;
    }
    retlen += n;

    /* Consume the data from socket */
    i = ws_read(cl, buf, needlen);

    wsctx->carrylen = n - len;
    retlen -= wsctx->carrylen;
    for (i=0; i < wsctx->carrylen; i++) {
        /* rfbLog('Saving carryover %d\n', dst[retlen + i]); */
        wsctx->carryBuf[i] = dst[retlen + i];
    }

    /* rfbLog('<< webSocketsDecode, retlen: %d\n', retlen); */
    return retlen;
}
",8779
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,0,"int
ListenAtTcpPortAndAddress(int port, const char *address)
{
  int sock;
  int one = 1;
#ifndef LIBVNCSERVER_IPv6
  struct sockaddr_in addr;

  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  if (address) {
    addr.sin_addr.s_addr = inet_addr(address);
  } else {
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
  }

  if (!initSockets())
    return -1;

  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock < 0) {
    rfbClientErr('ListenAtTcpPort: socket\n');
    return -1;
  }

  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
		 (const char *)&one, sizeof(one)) < 0) {
    rfbClientErr('ListenAtTcpPort: setsockopt\n');
    close(sock);
    return -1;
  }

  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
    rfbClientErr('ListenAtTcpPort: bind\n');
    close(sock);
    return -1;
  }

#else
  int rv;
  struct addrinfo hints, *servinfo, *p;
  char port_str[8];

  snprintf(port_str, 8, '%d', port);

  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE; /* fill in wildcard address if address == NULL */

  if (!initSockets())
    return -1;

  if ((rv = getaddrinfo(address, port_str, &hints, &servinfo)) != 0) {
    rfbClientErr('ListenAtTcpPortAndAddress: error in getaddrinfo: %s\n', gai_strerror(rv));
    return -1;
  }

  /* loop through all the results and bind to the first we can */
  for(p = servinfo; p != NULL; p = p->ai_next) {
    if ((sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) {
      continue;
    }

#ifdef IPV6_V6ONLY
    /* we have separate IPv4 and IPv6 sockets since some OS's do not support dual binding */
    if (p->ai_family == AF_INET6 && setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {
      rfbClientErr('ListenAtTcpPortAndAddress: error in setsockopt IPV6_V6ONLY: %s\n', strerror(errno));
      close(sock);
      freeaddrinfo(servinfo);
      return -1;
    }
#endif

    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {
      rfbClientErr('ListenAtTcpPortAndAddress: error in setsockopt SO_REUSEADDR: %s\n', strerror(errno));
      close(sock);
      freeaddrinfo(servinfo);
      return -1;
    }

    if (bind(sock, p->ai_addr, p->ai_addrlen) < 0) {
      close(sock);
      continue;
    }

    break;
  }

  if (p == NULL)  {
    rfbClientErr('ListenAtTcpPortAndAddress: error in bind: %s\n', strerror(errno));
    return -1;
  }

  /* all done with this structure now */
  freeaddrinfo(servinfo);
#endif

  if (listen(sock, 5) < 0) {
    rfbClientErr('ListenAtTcpPort: listen\n');
    close(sock);
    return -1;
  }

  return sock;
}
",8780
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,0,"static rfbBool WaitForConnected(int socket, unsigned int secs)
{
  fd_set writefds;
  fd_set exceptfds;
  struct timeval timeout;

  timeout.tv_sec=secs;
  timeout.tv_usec=0;

  FD_ZERO(&writefds);
  FD_SET(socket, &writefds);
  FD_ZERO(&exceptfds);
  FD_SET(socket, &exceptfds);
  if (select(socket+1, NULL, &writefds, &exceptfds, &timeout)==1) {
#ifdef WIN32
    if (FD_ISSET(socket, &exceptfds))
      return FALSE;
#else
    int so_error;
    socklen_t len = sizeof so_error;
    getsockopt(socket, SOL_SOCKET, SO_ERROR, &so_error, &len);
    if (so_error!=0)
      return FALSE;
#endif
    return TRUE;
  }

  return FALSE;
}
",8781
LibVNC/libvncserver,3fd03977c9b35800d73a865f167338cb4d05b0c1,0,"static int
ws_read(rfbClientPtr cl, char *buf, int len)
{
    int n;
    if (cl->sslctx) {
	n = rfbssl_read(cl, buf, len);
    } else {
	n = read(cl->sock, buf, len);
    }
    return n;
}
",8782
opencv/opencv,d1615ba11a93062b1429fce9f0f638d1572d3418,1,"TEST(DenseOpticalFlow_VariationalRefinement, ReferenceAccuracy)
{
    Mat frame1, frame2, GT;
    ASSERT_TRUE(readRubberWhale(frame1, frame2, GT));
    float target_RMSE = 0.86f;
    cvtColor(frame1, frame1, COLOR_BGR2GRAY);
    cvtColor(frame2, frame2, COLOR_BGR2GRAY);

    Ptr<VariationalRefinement> var_ref;
    var_ref = VariationalRefinement::create();
    var_ref->setAlpha(20.0f);
    var_ref->setDelta(5.0f);
    var_ref->setGamma(10.0f);
    var_ref->setSorIterations(25);
    var_ref->setFixedPointIterations(25);
    Mat flow(frame1.size(), CV_32FC2);
    flow.setTo(0.0f);
    var_ref->calc(frame1, frame2, flow);
    ASSERT_EQ(GT.rows, flow.rows);
    ASSERT_EQ(GT.cols, flow.cols);
    EXPECT_LE(calcRMSE(GT, flow), target_RMSE);
}
",8783
opencv/opencv,d1615ba11a93062b1429fce9f0f638d1572d3418,0,"bool readRubberWhale(Mat &dst_frame_1, Mat &dst_frame_2, Mat &dst_GT)
{
    const string frame1_path = getRubberWhaleFrame1();
    const string frame2_path = getRubberWhaleFrame2();
    const string gt_flow_path = getRubberWhaleGroundTruth();

    dst_frame_1 = imread(frame1_path);
    dst_frame_2 = imread(frame2_path);
    dst_GT = readOpticalFlow(gt_flow_path);

    if (dst_frame_1.empty() || dst_frame_2.empty() || dst_GT.empty())
        return false;
    else
        return true;
}
",8784
LawnGnome/php-radius,13c149b051f82b709e8d7cc32111e84b49d57234,1,"int
rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)
{
	struct vendor_attribute *attr;

	attr = (struct vendor_attribute *)*data;
	*vendor = ntohl(attr->vendor_value);
	*data = attr->attrib_data;
	*len = attr->attrib_len - 2;

	return (attr->attrib_type);
}
",8785
LawnGnome/php-radius,13c149b051f82b709e8d7cc32111e84b49d57234,0,"int
rad_init_send_request(struct rad_handle *h, int *fd, struct timeval *tv)
{
	int srv;

	/* Make sure we have a socket to use */
	if (h->fd == -1) {
		struct sockaddr_in sin;

		if ((h->fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
#ifdef PHP_WIN32
			generr(h, 'Cannot create socket: %d', WSAGetLastError());
#else
			generr(h, 'Cannot create socket: %s', strerror(errno));
#endif
			return -1;
		}
		memset(&sin, 0, sizeof sin);
		sin.sin_family = AF_INET;
		sin.sin_addr.s_addr = INADDR_ANY;
		sin.sin_port = htons(0);
		if (bind(h->fd, (const struct sockaddr *)&sin,
		    sizeof sin) == -1) {
#ifdef PHP_WIN32
			generr(h, 'bind: %d', WSAGetLastError());
#else
			generr(h, 'bind: %s', strerror(errno));
#endif
			close(h->fd);
			h->fd = -1;
			return -1;
		}
	}

	if (h->request[POS_CODE] == RAD_ACCOUNTING_REQUEST) {
		/* Make sure no password given */
		if (h->pass_pos || h->chap_pass) {
			generr(h, 'User or Chap Password in accounting request');
			return -1;
		}
	} else {
		/* Make sure the user gave us a password */
		if (h->pass_pos == 0 && !h->chap_pass) {
			generr(h, 'No User or Chap Password attributes given');
			return -1;
		}
		if (h->pass_pos != 0 && h->chap_pass) {
			generr(h, 'Both User and Chap Password attributes given');
			return -1;
		}
	}

	/* Fill in the length field in the message */
	h->request[POS_LENGTH] = h->req_len >> 8;
	h->request[POS_LENGTH+1] = h->req_len;

	/*
	 * Count the total number of tries we will make, and zero the
	 * counter for each server.
	 */
	h->total_tries = 0;
	for (srv = 0;  srv < h->num_servers;  srv++) {
		h->total_tries += h->servers[srv].max_tries;
		h->servers[srv].num_tries = 0;
	}
	if (h->total_tries == 0) {
		generr(h, 'No RADIUS servers specified');
		return -1;
	}

	h->try = h->srv = 0;

	return rad_continue_send_request(h, 0, fd, tv);
}
",8786
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"mod_ty
string_object_to_c_ast(const char *s, PyObject *filename, int start,
                             PyCompilerFlags *flags, int feature_version,
                             PyArena *arena)
{
    mod_ty mod;
    PyCompilerFlags localflags;
    perrdetail err;
    int iflags = PARSER_FLAGS(flags);

    node *n = Ta3Parser_ParseStringObject(s, filename,
                                         &_Ta3Parser_Grammar, start, &err,
                                         &iflags);
    if (flags == NULL) {
        localflags.cf_flags = 0;
        flags = &localflags;
    }
    if (n) {
        flags->cf_flags |= iflags & PyCF_MASK;
        mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);
        Ta3Node_Free(n);
    }
    else {
        err_input(&err);
        mod = NULL;
    }
    err_free(&err);
    return mod;
}
",8787
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static expr_ty
ast_for_atom(struct compiling *c, const node *n)
{
    /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [listmaker] ']'
       | '{' [dictmaker] '}' | '`' testlist '`' | NAME | NUMBER | STRING+
    */
    node *ch = CHILD(n, 0);

    switch (TYPE(ch)) {
    case NAME: {
        /* All names start in Load context, but may later be
           changed. */
        PyObject *name = NEW_IDENTIFIER(ch);
        if (!name)
            return NULL;
        return Name(name, Load, LINENO(n), n->n_col_offset, c->c_arena);
    }
    case STRING: {
        PyObject *kind, *str = parsestrplus(c, n);
        const char *raw, *s = STR(CHILD(n, 0));
        int quote = Py_CHARMASK(*s);
        /* currently Python allows up to 2 string modifiers */
        char *ch, s_kind[3] = {0, 0, 0};
        ch = s_kind;
        raw = s;
        while (*raw && *raw != '\'' && *raw != ''') {
            *ch++ = *raw++;
        }
        kind = PyUnicode_FromString(s_kind);
        if (!kind) {
            return NULL;
        }
        if (!str) {
#ifdef Py_USING_UNICODE
            if (PyErr_ExceptionMatches(PyExc_UnicodeError)){
                PyObject *type, *value, *tback, *errstr;
                PyErr_Fetch(&type, &value, &tback);
                errstr = PyObject_Str(value);
                if (errstr) {
                    char *s = '';
                    char buf[128];
                    s = _PyUnicode_AsString(errstr);
                    PyOS_snprintf(buf, sizeof(buf), '(unicode error) %s', s);
                    ast_error(n, buf);
                    Py_DECREF(errstr);
                } else {
                    ast_error(n, '(unicode error) unknown error');
                }
                Py_DECREF(type);
                Py_DECREF(value);
                Py_XDECREF(tback);
            }
#endif
            return NULL;
        }
        PyArena_AddPyObject(c->c_arena, str);
        return Str(str, kind, LINENO(n), n->n_col_offset, c->c_arena);
    }
    case NUMBER: {
        PyObject *pynum = parsenumber(c, STR(ch));
        if (!pynum)
            return NULL;

        PyArena_AddPyObject(c->c_arena, pynum);
        return Num(pynum, LINENO(n), n->n_col_offset, c->c_arena);
    }
    case LPAR: /* some parenthesized expressions */
        ch = CHILD(n, 1);

        if (TYPE(ch) == RPAR)
            return Tuple(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

        if (TYPE(ch) == yield_expr)
            return ast_for_expr(c, ch);

        return ast_for_testlist_comp(c, ch);
    case LSQB: /* list (or list comprehension) */
        ch = CHILD(n, 1);

        if (TYPE(ch) == RSQB)
            return List(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

        REQ(ch, listmaker);
        if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {
            asdl_seq *elts = seq_for_testlist(c, ch);
            if (!elts)
                return NULL;

            return List(elts, Load, LINENO(n), n->n_col_offset, c->c_arena);
        }
        else
            return ast_for_listcomp(c, ch);
    case LBRACE: {
        /* dictorsetmaker:
         *    (test ':' test (comp_for | (',' test ':' test)* [','])) |
         *    (test (comp_for | (',' test)* [',']))
         */
        int i, size;
        asdl_seq *keys, *values;

        ch = CHILD(n, 1);
        if (TYPE(ch) == RBRACE) {
            /* it's an empty dict */
            return Dict(NULL, NULL, LINENO(n), n->n_col_offset, c->c_arena);
        } else if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {
            /* it's a simple set */
            asdl_seq *elts;
            size = (NCH(ch) + 1) / 2; /* +1 in case no trailing comma */
            elts = asdl_seq_new(size, c->c_arena);
            if (!elts)
                return NULL;
            for (i = 0; i < NCH(ch); i += 2) {
                expr_ty expression;
                expression = ast_for_expr(c, CHILD(ch, i));
                if (!expression)
                    return NULL;
                asdl_seq_SET(elts, i / 2, expression);
            }
            return Set(elts, LINENO(n), n->n_col_offset, c->c_arena);
        } else if (TYPE(CHILD(ch, 1)) == comp_for) {
            /* it's a set comprehension */
            return ast_for_setcomp(c, ch);
        } else if (NCH(ch) > 3 && TYPE(CHILD(ch, 3)) == comp_for) {
            return ast_for_dictcomp(c, ch);
        } else {
            /* it's a dict */
            size = (NCH(ch) + 1) / 4; /* +1 in case no trailing comma */
            keys = asdl_seq_new(size, c->c_arena);
            if (!keys)
                return NULL;

            values = asdl_seq_new(size, c->c_arena);
            if (!values)
                return NULL;

            for (i = 0; i < NCH(ch); i += 4) {
                expr_ty expression;

                expression = ast_for_expr(c, CHILD(ch, i));
                if (!expression)
                    return NULL;

                asdl_seq_SET(keys, i / 4, expression);

                expression = ast_for_expr(c, CHILD(ch, i + 2));
                if (!expression)
                    return NULL;

                asdl_seq_SET(values, i / 4, expression);
            }
            return Dict(keys, values, LINENO(n), n->n_col_offset, c->c_arena);
        }
    }
    case BACKQUOTE: { /* repr */
        expr_ty expression;
        if (Py_Py3kWarningFlag &&
            !ast_warn(c, n, 'backquote not supported in 3.x; use repr()'))
            return NULL;
        expression = ast_for_testlist(c, CHILD(n, 1));
        if (!expression)
            return NULL;

        return Repr(expression, LINENO(n), n->n_col_offset, c->c_arena);
    }
    default:
        PyErr_Format(PyExc_SystemError, 'unhandled atom %d', TYPE(ch));
        return NULL;
    }
}
",8788
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static expr_ty
ast_for_call(struct compiling *c, const node *n, expr_ty func)
{
    /*
      arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
               | '**' test)
      argument: [test '='] test [comp_for]        # Really [keyword '='] test
    */

    int i, nargs, nkeywords, ngens;
    asdl_seq *args;
    asdl_seq *keywords;
    expr_ty vararg = NULL, kwarg = NULL;

    REQ(n, arglist);

    nargs = 0;
    nkeywords = 0;
    ngens = 0;
    for (i = 0; i < NCH(n); i++) {
        node *ch = CHILD(n, i);
        if (TYPE(ch) == argument) {
            if (NCH(ch) == 1)
                nargs++;
            else if (TYPE(CHILD(ch, 1)) == comp_for)
                ngens++;
            else
                nkeywords++;
        }
    }
    if (ngens > 1 || (ngens && (nargs || nkeywords))) {
        ast_error(n, 'Generator expression must be parenthesized '
                  'if not sole argument');
        return NULL;
    }

    if (nargs + nkeywords + ngens > 255) {
      ast_error(n, 'more than 255 arguments');
      return NULL;
    }

    args = asdl_seq_new(nargs + ngens, c->c_arena);
    if (!args)
        return NULL;
    keywords = asdl_seq_new(nkeywords, c->c_arena);
    if (!keywords)
        return NULL;
    nargs = 0;
    nkeywords = 0;
    for (i = 0; i < NCH(n); i++) {
        node *ch = CHILD(n, i);
        if (TYPE(ch) == argument) {
            expr_ty e;
            if (NCH(ch) == 1) {
                if (nkeywords) {
                    ast_error(CHILD(ch, 0),
                              'non-keyword arg after keyword arg');
                    return NULL;
                }
                if (vararg) {
                    ast_error(CHILD(ch, 0),
                              'only named arguments may follow *expression');
                    return NULL;
                }
                e = ast_for_expr(c, CHILD(ch, 0));
                if (!e)
                    return NULL;
                asdl_seq_SET(args, nargs++, e);
            }
            else if (TYPE(CHILD(ch, 1)) == comp_for) {
                e = ast_for_genexp(c, ch);
                if (!e)
                    return NULL;
                asdl_seq_SET(args, nargs++, e);
            }
            else {
                keyword_ty kw;
                identifier key;
                int k;
                char *tmp;

                /* CHILD(ch, 0) is test, but must be an identifier? */
                e = ast_for_expr(c, CHILD(ch, 0));
                if (!e)
                    return NULL;
                /* f(lambda x: x[0] = 3) ends up getting parsed with
                 * LHS test = lambda x: x[0], and RHS test = 3.
                 * SF bug 132313 points out that complaining about a keyword
                 * then is very confusing.
                 */
                if (e->kind == Lambda_kind) {
                    ast_error(CHILD(ch, 0),
                              'lambda cannot contain assignment');
                    return NULL;
                } else if (e->kind != Name_kind) {
                    ast_error(CHILD(ch, 0), 'keyword can't be an expression');
                    return NULL;
                }
                key = e->v.Name.id;
                if (!forbidden_check(c, CHILD(ch, 0), PyUnicode_AsUTF8(key)))
                    return NULL;
                for (k = 0; k < nkeywords; k++) {
                    tmp = _PyUnicode_AsString(
                        ((keyword_ty)asdl_seq_GET(keywords, k))->arg);
                    if (!strcmp(tmp, _PyUnicode_AsString(key))) {
                        ast_error(CHILD(ch, 0), 'keyword argument repeated');
                        return NULL;
                    }
                }
                e = ast_for_expr(c, CHILD(ch, 2));
                if (!e)
                    return NULL;
                kw = keyword(key, e, c->c_arena);
                if (!kw)
                    return NULL;
                asdl_seq_SET(keywords, nkeywords++, kw);
            }
        }
        else if (TYPE(ch) == STAR) {
            vararg = ast_for_expr(c, CHILD(n, i+1));
            if (!vararg)
                return NULL;
            i++;
        }
        else if (TYPE(ch) == DOUBLESTAR) {
            kwarg = ast_for_expr(c, CHILD(n, i+1));
            if (!kwarg)
                return NULL;
            i++;
        }
    }

    return Call(func, args, keywords, vararg, kwarg, func->lineno,
                func->col_offset, c->c_arena);
}
",8789
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static void
ast_dealloc(AST_object *self)
{
    Py_CLEAR(self->dict);
    Py_TYPE(self)->tp_free(self);
}
",8790
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static void
ast_clear(AST_object *self)
{
    Py_CLEAR(self->dict);
}
",8791
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
ast_type_init(PyObject *self, PyObject *args, PyObject *kw)
{
    _Py_IDENTIFIER(_fields);
    Py_ssize_t i, numfields = 0;
    int res = -1;
    PyObject *key, *value, *fields;
    fields = _PyObject_GetAttrId((PyObject*)Py_TYPE(self), &PyId__fields);
    if (!fields)
        PyErr_Clear();
    if (fields) {
        numfields = PySequence_Size(fields);
        if (numfields == -1)
            goto cleanup;
    }
    res = 0; /* if no error occurs, this stays 0 to the end */
    if (PyTuple_GET_SIZE(args) > 0) {
        if (numfields != PyTuple_GET_SIZE(args)) {
            PyErr_Format(PyExc_TypeError, '%.400s constructor takes %s'
                         '%zd positional argument%s',
                         Py_TYPE(self)->tp_name,
                         numfields == 0 ? '' : 'either 0 or ',
                         numfields, numfields == 1 ? '' : 's');
            res = -1;
            goto cleanup;
        }
        for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
            /* cannot be reached when fields is NULL */
            PyObject *name = PySequence_GetItem(fields, i);
            if (!name) {
                res = -1;
                goto cleanup;
            }
            res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));
            Py_DECREF(name);
            if (res < 0)
                goto cleanup;
        }
    }
    if (kw) {
        i = 0;  /* needed by PyDict_Next */
        while (PyDict_Next(kw, &i, &key, &value)) {
            res = PyObject_SetAttr(self, key, value);
            if (res < 0)
                goto cleanup;
        }
    }
  cleanup:
    Py_XDECREF(fields);
    return res;
}
",8792
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static PyObject *
ast_type_reduce(PyObject *self, PyObject *unused)
{
    PyObject *res;
    _Py_IDENTIFIER(__dict__);
    PyObject *dict = _PyObject_GetAttrId(self, &PyId___dict__);
    if (dict == NULL) {
        if (PyErr_ExceptionMatches(PyExc_AttributeError))
            PyErr_Clear();
        else
            return NULL;
    }
    if (dict) {
        res = Py_BuildValue('O()O', Py_TYPE(self), dict);
        Py_DECREF(dict);
        return res;
    }
    return Py_BuildValue('O()', Py_TYPE(self));
}
",8793
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static PyTypeObject* make_type(char *type, PyTypeObject* base, char**fields, int num_fields)
{
    PyObject *fnames, *result;
    int i;
    fnames = PyTuple_New(num_fields);
    if (!fnames) return NULL;
    for (i = 0; i < num_fields; i++) {
        PyObject *field = PyUnicode_FromString(fields[i]);
        if (!field) {
            Py_DECREF(fnames);
            return NULL;
        }
        PyTuple_SET_ITEM(fnames, i, field);
    }
    result = PyObject_CallFunction((PyObject*)&PyType_Type, 's(O){sOss}',
                    type, base, '_fields', fnames, '__module__', '_ast3');
    Py_DECREF(fnames);
    return (PyTypeObject*)result;
}
",8794
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int add_attributes(PyTypeObject* type, char**attrs, int num_fields)
{
    int i, result;
    _Py_IDENTIFIER(_attributes);
    PyObject *s, *l = PyTuple_New(num_fields);
    if (!l)
        return 0;
    for (i = 0; i < num_fields; i++) {
        s = PyUnicode_FromString(attrs[i]);
        if (!s) {
            Py_DECREF(l);
            return 0;
        }
        PyTuple_SET_ITEM(l, i, s);
    }
    result = _PyObject_SetAttrId((PyObject*)type, &PyId__attributes, l) >= 0;
    Py_DECREF(l);
    return result;
}
",8795
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int add_ast_fields(void)
{
    PyObject *empty_tuple, *d;
    if (PyType_Ready(&AST_type) < 0)
        return -1;
    d = AST_type.tp_dict;
    empty_tuple = PyTuple_New(0);
    if (!empty_tuple ||
        PyDict_SetItemString(d, '_fields', empty_tuple) < 0 ||
        PyDict_SetItemString(d, '_attributes', empty_tuple) < 0) {
        Py_XDECREF(empty_tuple);
        return -1;
    }
    Py_DECREF(empty_tuple);
    return 0;
}
",8796
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_mod(void* _o)
{
    mod_ty o = (mod_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case Module_kind:
        result = PyType_GenericNew(Module_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Module.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Module.type_ignores, ast2obj_type_ignore);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_ignores, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Interactive_kind:
        result = PyType_GenericNew(Interactive_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Interactive.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Expression_kind:
        result = PyType_GenericNew(Expression_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Expression.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case FunctionType_kind:
        result = PyType_GenericNew(FunctionType_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.FunctionType.argtypes, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_argtypes, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FunctionType.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Suite_kind:
        result = PyType_GenericNew(Suite_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Suite.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8797
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_stmt(void* _o)
{
    stmt_ty o = (stmt_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case FunctionDef_kind:
        result = PyType_GenericNew(FunctionDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.FunctionDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_arguments(o->v.FunctionDef.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.FunctionDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.FunctionDef.decorator_list, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FunctionDef.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.FunctionDef.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncFunctionDef_kind:
        result = PyType_GenericNew(AsyncFunctionDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.AsyncFunctionDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_arguments(o->v.AsyncFunctionDef.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFunctionDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFunctionDef.decorator_list,
                             ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AsyncFunctionDef.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncFunctionDef.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ClassDef_kind:
        result = PyType_GenericNew(ClassDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.ClassDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.bases, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_bases, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.keywords, ast2obj_keyword);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keywords, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.decorator_list, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Return_kind:
        result = PyType_GenericNew(Return_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Return.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Delete_kind:
        result = PyType_GenericNew(Delete_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Delete.targets, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_targets, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assign_kind:
        result = PyType_GenericNew(Assign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Assign.targets, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_targets, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Assign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.Assign.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AugAssign_kind:
        result = PyType_GenericNew(AugAssign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AugAssign.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_operator(o->v.AugAssign.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AugAssign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AnnAssign_kind:
        result = PyType_GenericNew(AnnAssign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AnnAssign.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AnnAssign.annotation);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_annotation, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AnnAssign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.AnnAssign.simple);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_simple, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case For_kind:
        result = PyType_GenericNew(For_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.For.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.For.iter);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.For.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.For.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.For.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncFor_kind:
        result = PyType_GenericNew(AsyncFor_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AsyncFor.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AsyncFor.iter);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFor.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFor.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncFor.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case While_kind:
        result = PyType_GenericNew(While_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.While.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.While.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.While.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case If_kind:
        result = PyType_GenericNew(If_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.If.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.If.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.If.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case With_kind:
        result = PyType_GenericNew(With_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.With.items, ast2obj_withitem);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_items, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.With.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.With.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncWith_kind:
        result = PyType_GenericNew(AsyncWith_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.AsyncWith.items, ast2obj_withitem);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_items, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncWith.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncWith.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Raise_kind:
        result = PyType_GenericNew(Raise_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Raise.exc);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_exc, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Raise.cause);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_cause, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Try_kind:
        result = PyType_GenericNew(Try_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Try.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.handlers, ast2obj_excepthandler);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_handlers, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.finalbody, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_finalbody, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assert_kind:
        result = PyType_GenericNew(Assert_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Assert.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Assert.msg);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_msg, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Import_kind:
        result = PyType_GenericNew(Import_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Import.names, ast2obj_alias);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ImportFrom_kind:
        result = PyType_GenericNew(ImportFrom_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.ImportFrom.module);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_module, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ImportFrom.names, ast2obj_alias);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.ImportFrom.level);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_level, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Global_kind:
        result = PyType_GenericNew(Global_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Global.names, ast2obj_identifier);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Nonlocal_kind:
        result = PyType_GenericNew(Nonlocal_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Nonlocal.names, ast2obj_identifier);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Expr_kind:
        result = PyType_GenericNew(Expr_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Expr.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Pass_kind:
        result = PyType_GenericNew(Pass_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Break_kind:
        result = PyType_GenericNew(Break_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Continue_kind:
        result = PyType_GenericNew(Continue_type, NULL, NULL);
        if (!result) goto failed;
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8798
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_expr(void* _o)
{
    expr_ty o = (expr_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case BoolOp_kind:
        result = PyType_GenericNew(BoolOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_boolop(o->v.BoolOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.BoolOp.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case BinOp_kind:
        result = PyType_GenericNew(BinOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.BinOp.left);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_left, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_operator(o->v.BinOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.BinOp.right);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_right, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case UnaryOp_kind:
        result = PyType_GenericNew(UnaryOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_unaryop(o->v.UnaryOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.UnaryOp.operand);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_operand, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Lambda_kind:
        result = PyType_GenericNew(Lambda_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_arguments(o->v.Lambda.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Lambda.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case IfExp_kind:
        result = PyType_GenericNew(IfExp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.IfExp.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.IfExp.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.IfExp.orelse);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Dict_kind:
        result = PyType_GenericNew(Dict_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Dict.keys, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keys, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Dict.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Set_kind:
        result = PyType_GenericNew(Set_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Set.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ListComp_kind:
        result = PyType_GenericNew(ListComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.ListComp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ListComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case SetComp_kind:
        result = PyType_GenericNew(SetComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.SetComp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.SetComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case DictComp_kind:
        result = PyType_GenericNew(DictComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.DictComp.key);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_key, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.DictComp.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.DictComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case GeneratorExp_kind:
        result = PyType_GenericNew(GeneratorExp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.GeneratorExp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.GeneratorExp.generators,
                             ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Await_kind:
        result = PyType_GenericNew(Await_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Await.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Yield_kind:
        result = PyType_GenericNew(Yield_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Yield.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case YieldFrom_kind:
        result = PyType_GenericNew(YieldFrom_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.YieldFrom.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Compare_kind:
        result = PyType_GenericNew(Compare_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Compare.left);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_left, value) == -1)
            goto failed;
        Py_DECREF(value);
        {
            Py_ssize_t i, n = asdl_seq_LEN(o->v.Compare.ops);
            value = PyList_New(n);
            if (!value) goto failed;
            for(i = 0; i < n; i++)
                PyList_SET_ITEM(value, i, ast2obj_cmpop((cmpop_ty)asdl_seq_GET(o->v.Compare.ops, i)));
        }
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ops, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Compare.comparators, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_comparators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Call_kind:
        result = PyType_GenericNew(Call_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Call.func);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_func, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Call.args, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Call.keywords, ast2obj_keyword);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keywords, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Num_kind:
        result = PyType_GenericNew(Num_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_object(o->v.Num.n);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_n, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Str_kind:
        result = PyType_GenericNew(Str_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_string(o->v.Str.s);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_s, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.Str.kind);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_kind, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case FormattedValue_kind:
        result = PyType_GenericNew(FormattedValue_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.FormattedValue.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.FormattedValue.conversion);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_conversion, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FormattedValue.format_spec);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_format_spec, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case JoinedStr_kind:
        result = PyType_GenericNew(JoinedStr_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.JoinedStr.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Bytes_kind:
        result = PyType_GenericNew(Bytes_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_bytes(o->v.Bytes.s);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_s, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case NameConstant_kind:
        result = PyType_GenericNew(NameConstant_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_singleton(o->v.NameConstant.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Ellipsis_kind:
        result = PyType_GenericNew(Ellipsis_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Constant_kind:
        result = PyType_GenericNew(Constant_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_constant(o->v.Constant.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Attribute_kind:
        result = PyType_GenericNew(Attribute_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Attribute.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->v.Attribute.attr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_attr, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Attribute.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Subscript_kind:
        result = PyType_GenericNew(Subscript_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Subscript.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_slice(o->v.Subscript.slice);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_slice, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Subscript.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Starred_kind:
        result = PyType_GenericNew(Starred_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Starred.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Starred.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Name_kind:
        result = PyType_GenericNew(Name_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.Name.id);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_id, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Name.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case List_kind:
        result = PyType_GenericNew(List_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.List.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.List.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Tuple_kind:
        result = PyType_GenericNew(Tuple_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Tuple.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Tuple.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8799
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_slice(void* _o)
{
    slice_ty o = (slice_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case Slice_kind:
        result = PyType_GenericNew(Slice_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Slice.lower);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_lower, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Slice.upper);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_upper, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Slice.step);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_step, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ExtSlice_kind:
        result = PyType_GenericNew(ExtSlice_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.ExtSlice.dims, ast2obj_slice);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_dims, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Index_kind:
        result = PyType_GenericNew(Index_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Index.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8800
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_comprehension(void* _o)
{
    comprehension_ty o = (comprehension_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(comprehension_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_expr(o->target);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->iter);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->ifs, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_ifs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->is_async);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_is_async, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8801
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_excepthandler(void* _o)
{
    excepthandler_ty o = (excepthandler_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case ExceptHandler_kind:
        result = PyType_GenericNew(ExceptHandler_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.ExceptHandler.type);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->v.ExceptHandler.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ExceptHandler.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8802
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_arguments(void* _o)
{
    arguments_ty o = (arguments_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(arguments_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_list(o->args, ast2obj_arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_arg(o->vararg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_vararg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->kwonlyargs, ast2obj_arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kwonlyargs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->kw_defaults, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kw_defaults, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_arg(o->kwarg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kwarg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->defaults, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_defaults, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8803
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_arg(void* _o)
{
    arg_ty o = (arg_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(arg_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->annotation);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_annotation, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_string(o->type_comment);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8804
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_keyword(void* _o)
{
    keyword_ty o = (keyword_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(keyword_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->value);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8805
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_alias(void* _o)
{
    alias_ty o = (alias_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(alias_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->name);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_identifier(o->asname);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_asname, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8806
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_withitem(void* _o)
{
    withitem_ty o = (withitem_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(withitem_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_expr(o->context_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_context_expr, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->optional_vars);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_optional_vars, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8807
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_type_ignore(void* _o)
{
    type_ignore_ty o = (type_ignore_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case TypeIgnore_kind:
        result = PyType_GenericNew(TypeIgnore_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_int(o->v.TypeIgnore.lineno);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_lineno, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8808
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_mod(PyObject* obj, mod_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Module_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;
        asdl_seq* type_ignores;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Module field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Module field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Module');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_type_ignores)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_type_ignores);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Module field \'type_ignores\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            type_ignores = _Ta3_asdl_seq_new(len, arena);
            if (type_ignores == NULL) goto failed;
            for (i = 0; i < len; i++) {
                type_ignore_ty value;
                res = obj2ast_type_ignore(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Module field \'type_ignores\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(type_ignores, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'type_ignores\' missing from Module');
            return 1;
        }
        *out = Module(body, type_ignores, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Interactive_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Interactive field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Interactive field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Interactive');
            return 1;
        }
        *out = Interactive(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Expression_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Expression');
            return 1;
        }
        *out = Expression(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)FunctionType_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* argtypes;
        expr_ty returns;

        if (_PyObject_HasAttrId(obj, &PyId_argtypes)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_argtypes);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'FunctionType field \'argtypes\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            argtypes = _Ta3_asdl_seq_new(len, arena);
            if (argtypes == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'FunctionType field \'argtypes\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(argtypes, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'argtypes\' missing from FunctionType');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_returns)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_returns);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &returns, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'returns\' missing from FunctionType');
            return 1;
        }
        *out = FunctionType(argtypes, returns, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Suite_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Suite field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Suite field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Suite');
            return 1;
        }
        *out = Suite(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of mod, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8809
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_expr(PyObject* obj, expr_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    int lineno;
    int col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from expr');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from expr');
        return 1;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)BoolOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        boolop_ty op;
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_boolop(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from BoolOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'BoolOp field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'BoolOp field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from BoolOp');
            return 1;
        }
        *out = BoolOp(op, values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)BinOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty left;
        operator_ty op;
        expr_ty right;

        if (_PyObject_HasAttrId(obj, &PyId_left)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_left);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &left, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'left\' missing from BinOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_operator(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from BinOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_right)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_right);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &right, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'right\' missing from BinOp');
            return 1;
        }
        *out = BinOp(left, op, right, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)UnaryOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        unaryop_ty op;
        expr_ty operand;

        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_unaryop(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from UnaryOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_operand)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_operand);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &operand, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'operand\' missing from UnaryOp');
            return 1;
        }
        *out = UnaryOp(op, operand, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Lambda_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        arguments_ty args;
        expr_ty body;

        if (_PyObject_HasAttrId(obj, &PyId_args)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_args);
            if (tmp == NULL) goto failed;
            res = obj2ast_arguments(tmp, &args, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from Lambda');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Lambda');
            return 1;
        }
        *out = Lambda(args, body, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)IfExp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty test;
        expr_ty body;
        expr_ty orelse;

        if (_PyObject_HasAttrId(obj, &PyId_test)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_test);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &test, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'test\' missing from IfExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from IfExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_orelse)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_orelse);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &orelse, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'orelse\' missing from IfExp');
            return 1;
        }
        *out = IfExp(test, body, orelse, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Dict_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* keys;
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_keys)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_keys);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Dict field \'keys\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keys = _Ta3_asdl_seq_new(len, arena);
            if (keys == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Dict field \'keys\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(keys, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'keys\' missing from Dict');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Dict field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Dict field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from Dict');
            return 1;
        }
        *out = Dict(keys, values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Set_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Set field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Set field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from Set');
            return 1;
        }
        *out = Set(elts, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ListComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from ListComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ListComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ListComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from ListComp');
            return 1;
        }
        *out = ListComp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)SetComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from SetComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'SetComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'SetComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from SetComp');
            return 1;
        }
        *out = SetComp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)DictComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty key;
        expr_ty value;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_key)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_key);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &key, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'key\' missing from DictComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from DictComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'DictComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'DictComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from DictComp');
            return 1;
        }
        *out = DictComp(key, value, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)GeneratorExp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from GeneratorExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'GeneratorExp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'GeneratorExp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from GeneratorExp');
            return 1;
        }
        *out = GeneratorExp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Await_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Await');
            return 1;
        }
        *out = Await(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Yield_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (exists_not_none(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            value = NULL;
        }
        *out = Yield(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)YieldFrom_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from YieldFrom');
            return 1;
        }
        *out = YieldFrom(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Compare_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty left;
        asdl_int_seq* ops;
        asdl_seq* comparators;

        if (_PyObject_HasAttrId(obj, &PyId_left)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_left);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &left, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'left\' missing from Compare');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ops)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_ops);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Compare field \'ops\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            ops = _Ta3_asdl_int_seq_new(len, arena);
            if (ops == NULL) goto failed;
            for (i = 0; i < len; i++) {
                cmpop_ty value;
                res = obj2ast_cmpop(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Compare field \'ops\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(ops, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ops\' missing from Compare');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_comparators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_comparators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Compare field \'comparators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            comparators = _Ta3_asdl_seq_new(len, arena);
            if (comparators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Compare field \'comparators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(comparators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'comparators\' missing from Compare');
            return 1;
        }
        *out = Compare(left, ops, comparators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Call_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty func;
        asdl_seq* args;
        asdl_seq* keywords;

        if (_PyObject_HasAttrId(obj, &PyId_func)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_func);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &func, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'func\' missing from Call');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_args)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_args);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Call field \'args\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            args = _Ta3_asdl_seq_new(len, arena);
            if (args == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Call field \'args\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(args, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from Call');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_keywords)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_keywords);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Call field \'keywords\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keywords = _Ta3_asdl_seq_new(len, arena);
            if (keywords == NULL) goto failed;
            for (i = 0; i < len; i++) {
                keyword_ty value;
                res = obj2ast_keyword(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Call field \'keywords\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(keywords, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'keywords\' missing from Call');
            return 1;
        }
        *out = Call(func, args, keywords, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Num_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        object n;

        if (_PyObject_HasAttrId(obj, &PyId_n)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_n);
            if (tmp == NULL) goto failed;
            res = obj2ast_object(tmp, &n, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'n\' missing from Num');
            return 1;
        }
        *out = Num(n, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Str_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        string s;
        string kind;

        if (_PyObject_HasAttrId(obj, &PyId_s)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_s);
            if (tmp == NULL) goto failed;
            res = obj2ast_string(tmp, &s, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'s\' missing from Str');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_kind)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_kind);
            if (tmp == NULL) goto failed;
            res = obj2ast_string(tmp, &kind, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'kind\' missing from Str');
            return 1;
        }
        *out = Str(s, kind, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)FormattedValue_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        int conversion;
        expr_ty format_spec;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from FormattedValue');
            return 1;
        }
        if (exists_not_none(obj, &PyId_conversion)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_conversion);
            if (tmp == NULL) goto failed;
            res = obj2ast_int(tmp, &conversion, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            conversion = 0;
        }
        if (exists_not_none(obj, &PyId_format_spec)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_format_spec);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &format_spec, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            format_spec = NULL;
        }
        *out = FormattedValue(value, conversion, format_spec, lineno,
                              col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)JoinedStr_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'JoinedStr field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'JoinedStr field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from JoinedStr');
            return 1;
        }
        *out = JoinedStr(values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Bytes_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        bytes s;

        if (_PyObject_HasAttrId(obj, &PyId_s)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_s);
            if (tmp == NULL) goto failed;
            res = obj2ast_bytes(tmp, &s, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'s\' missing from Bytes');
            return 1;
        }
        *out = Bytes(s, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)NameConstant_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        singleton value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_singleton(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from NameConstant');
            return 1;
        }
        *out = NameConstant(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Ellipsis_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {

        *out = Ellipsis(lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Constant_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        constant value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_constant(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Constant');
            return 1;
        }
        *out = Constant(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Attribute_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        identifier attr;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Attribute');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_attr)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_attr);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &attr, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'attr\' missing from Attribute');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Attribute');
            return 1;
        }
        *out = Attribute(value, attr, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Subscript_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        slice_ty slice;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Subscript');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_slice)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_slice);
            if (tmp == NULL) goto failed;
            res = obj2ast_slice(tmp, &slice, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'slice\' missing from Subscript');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Subscript');
            return 1;
        }
        *out = Subscript(value, slice, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Starred_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Starred');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Starred');
            return 1;
        }
        *out = Starred(value, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Name_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        identifier id;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_id)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_id);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &id, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'id\' missing from Name');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Name');
            return 1;
        }
        *out = Name(id, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)List_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'List field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'List field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from List');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from List');
            return 1;
        }
        *out = List(elts, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Tuple_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Tuple field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Tuple field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from Tuple');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Tuple');
            return 1;
        }
        *out = Tuple(elts, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of expr, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8811
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_slice(PyObject* obj, slice_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Slice_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty lower;
        expr_ty upper;
        expr_ty step;

        if (exists_not_none(obj, &PyId_lower)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_lower);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &lower, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            lower = NULL;
        }
        if (exists_not_none(obj, &PyId_upper)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_upper);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &upper, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            upper = NULL;
        }
        if (exists_not_none(obj, &PyId_step)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_step);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &step, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            step = NULL;
        }
        *out = Slice(lower, upper, step, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ExtSlice_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* dims;

        if (_PyObject_HasAttrId(obj, &PyId_dims)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_dims);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ExtSlice field \'dims\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            dims = _Ta3_asdl_seq_new(len, arena);
            if (dims == NULL) goto failed;
            for (i = 0; i < len; i++) {
                slice_ty value;
                res = obj2ast_slice(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ExtSlice field \'dims\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(dims, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'dims\' missing from ExtSlice');
            return 1;
        }
        *out = ExtSlice(dims, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Index_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Index');
            return 1;
        }
        *out = Index(value, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of slice, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8812
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_comprehension(PyObject* obj, comprehension_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    expr_ty target;
    expr_ty iter;
    asdl_seq* ifs;
    int is_async;

    if (_PyObject_HasAttrId(obj, &PyId_target)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_target);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &target, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'target\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_iter)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_iter);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &iter, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'iter\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_ifs)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_ifs);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'comprehension field \'ifs\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        ifs = _Ta3_asdl_seq_new(len, arena);
        if (ifs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'comprehension field \'ifs\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(ifs, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'ifs\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_is_async)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_is_async);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &is_async, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'is_async\' missing from comprehension');
        return 1;
    }
    *out = comprehension(target, iter, ifs, is_async, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8813
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_excepthandler(PyObject* obj, excepthandler_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    int lineno;
    int col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from excepthandler');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from excepthandler');
        return 1;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ExceptHandler_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty type;
        identifier name;
        asdl_seq* body;

        if (exists_not_none(obj, &PyId_type)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_type);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &type, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            type = NULL;
        }
        if (exists_not_none(obj, &PyId_name)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_name);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &name, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            name = NULL;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ExceptHandler field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ExceptHandler field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from ExceptHandler');
            return 1;
        }
        *out = ExceptHandler(type, name, body, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of excepthandler, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8814
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_arguments(PyObject* obj, arguments_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    asdl_seq* args;
    arg_ty vararg;
    asdl_seq* kwonlyargs;
    asdl_seq* kw_defaults;
    arg_ty kwarg;
    asdl_seq* defaults;

    if (_PyObject_HasAttrId(obj, &PyId_args)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_args);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'args\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        args = _Ta3_asdl_seq_new(len, arena);
        if (args == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty value;
            res = obj2ast_arg(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'args\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(args, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from arguments');
        return 1;
    }
    if (exists_not_none(obj, &PyId_vararg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_vararg);
        if (tmp == NULL) goto failed;
        res = obj2ast_arg(tmp, &vararg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        vararg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_kwonlyargs)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_kwonlyargs);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'kwonlyargs\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        kwonlyargs = _Ta3_asdl_seq_new(len, arena);
        if (kwonlyargs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty value;
            res = obj2ast_arg(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'kwonlyargs\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(kwonlyargs, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'kwonlyargs\' missing from arguments');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_kw_defaults)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_kw_defaults);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'kw_defaults\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        kw_defaults = _Ta3_asdl_seq_new(len, arena);
        if (kw_defaults == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'kw_defaults\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(kw_defaults, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'kw_defaults\' missing from arguments');
        return 1;
    }
    if (exists_not_none(obj, &PyId_kwarg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_kwarg);
        if (tmp == NULL) goto failed;
        res = obj2ast_arg(tmp, &kwarg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        kwarg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_defaults)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_defaults);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'defaults\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        defaults = _Ta3_asdl_seq_new(len, arena);
        if (defaults == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'defaults\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(defaults, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'defaults\' missing from arguments');
        return 1;
    }
    *out = arguments(args, vararg, kwonlyargs, kw_defaults, kwarg, defaults,
                     arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8815
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_arg(PyObject* obj, arg_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier arg;
    expr_ty annotation;
    string type_comment;
    int lineno;
    int col_offset;

    if (_PyObject_HasAttrId(obj, &PyId_arg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_arg);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &arg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'arg\' missing from arg');
        return 1;
    }
    if (exists_not_none(obj, &PyId_annotation)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_annotation);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &annotation, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        annotation = NULL;
    }
    if (exists_not_none(obj, &PyId_type_comment)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_type_comment);
        if (tmp == NULL) goto failed;
        res = obj2ast_string(tmp, &type_comment, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        type_comment = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from arg');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from arg');
        return 1;
    }
    *out = arg(arg, annotation, type_comment, lineno, col_offset, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8816
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_keyword(PyObject* obj, keyword_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier arg;
    expr_ty value;

    if (exists_not_none(obj, &PyId_arg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_arg);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &arg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        arg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_value)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_value);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &value, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from keyword');
        return 1;
    }
    *out = keyword(arg, value, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8817
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_alias(PyObject* obj, alias_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier name;
    identifier asname;

    if (_PyObject_HasAttrId(obj, &PyId_name)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_name);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &name, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'name\' missing from alias');
        return 1;
    }
    if (exists_not_none(obj, &PyId_asname)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_asname);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &asname, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        asname = NULL;
    }
    *out = alias(name, asname, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8818
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    expr_ty context_expr;
    expr_ty optional_vars;

    if (_PyObject_HasAttrId(obj, &PyId_context_expr)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_context_expr);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &context_expr, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'context_expr\' missing from withitem');
        return 1;
    }
    if (exists_not_none(obj, &PyId_optional_vars)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_optional_vars);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &optional_vars, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        optional_vars = NULL;
    }
    *out = withitem(context_expr, optional_vars, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8819
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_type_ignore(PyObject* obj, type_ignore_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)TypeIgnore_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        int lineno;

        if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
            if (tmp == NULL) goto failed;
            res = obj2ast_int(tmp, &lineno, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from TypeIgnore');
            return 1;
        }
        *out = TypeIgnore(lineno, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of type_ignore, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8820
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyMODINIT_FUNC
PyInit__ast3(void)
{
    PyObject *m, *d;
    if (!init_types()) return NULL;
    m = PyModule_Create(&_astmodule3);
    if (!m) return NULL;
    d = PyModule_GetDict(m);
    if (PyDict_SetItemString(d, 'AST', (PyObject*)&AST_type) < 0) return NULL;
    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'mod', (PyObject*)mod_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Module', (PyObject*)Module_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Interactive', (PyObject*)Interactive_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Expression', (PyObject*)Expression_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'FunctionType', (PyObject*)FunctionType_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Suite', (PyObject*)Suite_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'stmt', (PyObject*)stmt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'FunctionDef', (PyObject*)FunctionDef_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncFunctionDef',
        (PyObject*)AsyncFunctionDef_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'ClassDef', (PyObject*)ClassDef_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Return', (PyObject*)Return_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Delete', (PyObject*)Delete_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Assign', (PyObject*)Assign_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'AugAssign', (PyObject*)AugAssign_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'AnnAssign', (PyObject*)AnnAssign_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'For', (PyObject*)For_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncFor', (PyObject*)AsyncFor_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'While', (PyObject*)While_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'If', (PyObject*)If_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'With', (PyObject*)With_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncWith', (PyObject*)AsyncWith_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Raise', (PyObject*)Raise_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Try', (PyObject*)Try_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Assert', (PyObject*)Assert_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Import', (PyObject*)Import_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'ImportFrom', (PyObject*)ImportFrom_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Global', (PyObject*)Global_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Nonlocal', (PyObject*)Nonlocal_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Expr', (PyObject*)Expr_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Pass', (PyObject*)Pass_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Break', (PyObject*)Break_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Continue', (PyObject*)Continue_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'expr', (PyObject*)expr_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'BoolOp', (PyObject*)BoolOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BinOp', (PyObject*)BinOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'UnaryOp', (PyObject*)UnaryOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Lambda', (PyObject*)Lambda_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'IfExp', (PyObject*)IfExp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Dict', (PyObject*)Dict_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Set', (PyObject*)Set_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'ListComp', (PyObject*)ListComp_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'SetComp', (PyObject*)SetComp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'DictComp', (PyObject*)DictComp_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'GeneratorExp', (PyObject*)GeneratorExp_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Await', (PyObject*)Await_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Yield', (PyObject*)Yield_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'YieldFrom', (PyObject*)YieldFrom_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Compare', (PyObject*)Compare_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Call', (PyObject*)Call_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Num', (PyObject*)Num_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Str', (PyObject*)Str_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'FormattedValue',
        (PyObject*)FormattedValue_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'JoinedStr', (PyObject*)JoinedStr_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Bytes', (PyObject*)Bytes_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'NameConstant', (PyObject*)NameConstant_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Ellipsis', (PyObject*)Ellipsis_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Constant', (PyObject*)Constant_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Attribute', (PyObject*)Attribute_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Subscript', (PyObject*)Subscript_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Starred', (PyObject*)Starred_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Name', (PyObject*)Name_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'List', (PyObject*)List_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Tuple', (PyObject*)Tuple_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'expr_context', (PyObject*)expr_context_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Load', (PyObject*)Load_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Store', (PyObject*)Store_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Del', (PyObject*)Del_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AugLoad', (PyObject*)AugLoad_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'AugStore', (PyObject*)AugStore_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Param', (PyObject*)Param_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'slice', (PyObject*)slice_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Slice', (PyObject*)Slice_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'ExtSlice', (PyObject*)ExtSlice_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Index', (PyObject*)Index_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'boolop', (PyObject*)boolop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'And', (PyObject*)And_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Or', (PyObject*)Or_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'operator', (PyObject*)operator_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Add', (PyObject*)Add_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Sub', (PyObject*)Sub_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Mult', (PyObject*)Mult_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'MatMult', (PyObject*)MatMult_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Div', (PyObject*)Div_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Mod', (PyObject*)Mod_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Pow', (PyObject*)Pow_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'LShift', (PyObject*)LShift_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'RShift', (PyObject*)RShift_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitOr', (PyObject*)BitOr_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitXor', (PyObject*)BitXor_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitAnd', (PyObject*)BitAnd_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'FloorDiv', (PyObject*)FloorDiv_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'unaryop', (PyObject*)unaryop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Invert', (PyObject*)Invert_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Not', (PyObject*)Not_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'UAdd', (PyObject*)UAdd_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'USub', (PyObject*)USub_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'cmpop', (PyObject*)cmpop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Eq', (PyObject*)Eq_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'NotEq', (PyObject*)NotEq_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Lt', (PyObject*)Lt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'LtE', (PyObject*)LtE_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Gt', (PyObject*)Gt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'GtE', (PyObject*)GtE_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Is', (PyObject*)Is_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'IsNot', (PyObject*)IsNot_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'In', (PyObject*)In_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'NotIn', (PyObject*)NotIn_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'comprehension', (PyObject*)comprehension_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'excepthandler', (PyObject*)excepthandler_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'ExceptHandler', (PyObject*)ExceptHandler_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'arguments', (PyObject*)arguments_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'arg', (PyObject*)arg_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'keyword', (PyObject*)keyword_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'alias', (PyObject*)alias_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'withitem', (PyObject*)withitem_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'type_ignore', (PyObject*)type_ignore_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'TypeIgnore', (PyObject*)TypeIgnore_type) < 0)
        return NULL;
    return m;
}
",8821
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"mod_ty
string_object_to_c_ast(const char *s, PyObject *filename, int start,
                             PyCompilerFlags *flags, int feature_version,
                             PyArena *arena)
{
    mod_ty mod;
    PyCompilerFlags localflags;
    perrdetail err;
    int iflags = PARSER_FLAGS(flags);

    node *n = Ta3Parser_ParseStringObject(s, filename,
                                         &_Ta3Parser_Grammar, start, &err,
                                         &iflags);
    if (flags == NULL) {
        localflags.cf_flags = 0;
        flags = &localflags;
    }
    if (n) {
        flags->cf_flags |= iflags & PyCF_MASK;
        mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);
        Ta3Node_Free(n);
    }
    else {
        err_input(&err);
        mod = NULL;
    }
    err_free(&err);
    return mod;
}
",8822
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
handle_keywordonly_args(struct compiling *c, const node *n, int start,
                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)
{
    PyObject *argname;
    node *ch;
    expr_ty expression, annotation;
    arg_ty arg = NULL;
    int i = start;
    int j = 0; /* index for kwdefaults and kwonlyargs */

    if (kwonlyargs == NULL) {
        ast_error(c, CHILD(n, start), 'named arguments must follow bare *');
        return -1;
    }
    assert(kwdefaults != NULL);
    while (i < NCH(n)) {
        ch = CHILD(n, i);
        switch (TYPE(ch)) {
            case vfpdef:
            case tfpdef:
                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {
                    expression = ast_for_expr(c, CHILD(n, i + 2));
                    if (!expression)
                        goto error;
                    asdl_seq_SET(kwdefaults, j, expression);
                    i += 2; /* '=' and test */
                }
                else { /* setting NULL if no default value exists */
                    asdl_seq_SET(kwdefaults, j, NULL);
                }
                if (NCH(ch) == 3) {
                    /* ch is NAME ':' test */
                    annotation = ast_for_expr(c, CHILD(ch, 2));
                    if (!annotation)
                        goto error;
                }
                else {
                    annotation = NULL;
                }
                ch = CHILD(ch, 0);
                argname = NEW_IDENTIFIER(ch);
                if (!argname)
                    goto error;
                if (forbidden_name(c, argname, ch, 0))
                    goto error;
                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,
                          c->c_arena);
                if (!arg)
                    goto error;
                asdl_seq_SET(kwonlyargs, j++, arg);
                i += 1; /* the name */
                if (TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                break;
            case TYPE_COMMENT:
                /* arg will be equal to the last argument processed */
                arg->type_comment = NEW_TYPE_COMMENT(ch);
                if (!arg->type_comment)
                    goto error;
                i += 1;
                break;
            case DOUBLESTAR:
                return i;
            default:
                ast_error(c, ch, 'unexpected node');
                goto error;
        }
    }
    return i;
 error:
    return -1;
}
",8823
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static arguments_ty
ast_for_arguments(struct compiling *c, const node *n)
{
    /* This function handles both typedargslist (function definition)
       and varargslist (lambda definition).

       parameters: '(' [typedargslist] ')'
       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [
               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
             | '**' tfpdef [',']]]
         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
         | '**' tfpdef [','])
       tfpdef: NAME [':' test]
       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [
               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
             | '**' vfpdef [',']]]
         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
         | '**' vfpdef [',']
       )
       vfpdef: NAME

    */
    int i, j, k, nposargs = 0, nkwonlyargs = 0;
    int nposdefaults = 0, found_default = 0;
    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;
    arg_ty vararg = NULL, kwarg = NULL;
    arg_ty arg = NULL;
    node *ch;

    if (TYPE(n) == parameters) {
        if (NCH(n) == 2) /* () as argument list */
            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);
        n = CHILD(n, 1);
    }
    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);

    /* First count the number of positional args & defaults.  The
       variable i is the loop index for this for loop and the next.
       The next loop picks up where the first leaves off.
    */
    for (i = 0; i < NCH(n); i++) {
        ch = CHILD(n, i);
        if (TYPE(ch) == STAR) {
            /* skip star */
            i++;
            if (i < NCH(n) && /* skip argument following star */
                (TYPE(CHILD(n, i)) == tfpdef ||
                 TYPE(CHILD(n, i)) == vfpdef)) {
                i++;
            }
            break;
        }
        if (TYPE(ch) == DOUBLESTAR) break;
        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;
        if (TYPE(ch) == EQUAL) nposdefaults++;
    }
    /* count the number of keyword only args &
       defaults for keyword only args */
    for ( ; i < NCH(n); ++i) {
        ch = CHILD(n, i);
        if (TYPE(ch) == DOUBLESTAR) break;
        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;
    }
    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);
    if (!posargs && nposargs)
        return NULL;
    kwonlyargs = (nkwonlyargs ?
                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);
    if (!kwonlyargs && nkwonlyargs)
        return NULL;
    posdefaults = (nposdefaults ?
                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);
    if (!posdefaults && nposdefaults)
        return NULL;
    /* The length of kwonlyargs and kwdefaults are same
       since we set NULL as default for keyword only argument w/o default
       - we have sequence data structure, but no dictionary */
    kwdefaults = (nkwonlyargs ?
                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);
    if (!kwdefaults && nkwonlyargs)
        return NULL;

    /* tfpdef: NAME [':' test]
       vfpdef: NAME
    */
    i = 0;
    j = 0;  /* index for defaults */
    k = 0;  /* index for args */
    while (i < NCH(n)) {
        ch = CHILD(n, i);
        switch (TYPE(ch)) {
            case tfpdef:
            case vfpdef:
                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is
                   anything other than EQUAL or a comma? */
                /* XXX Should NCH(n) check be made a separate check? */
                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {
                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));
                    if (!expression)
                        return NULL;
                    assert(posdefaults != NULL);
                    asdl_seq_SET(posdefaults, j++, expression);
                    i += 2;
                    found_default = 1;
                }
                else if (found_default) {
                    ast_error(c, n,
                             'non-default argument follows default argument');
                    return NULL;
                }
                arg = ast_for_arg(c, ch);
                if (!arg)
                    return NULL;
                asdl_seq_SET(posargs, k++, arg);
                i += 1; /* the name */
                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                break;
            case STAR:
                if (i+1 >= NCH(n) ||
                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA
                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {
                    ast_error(c, CHILD(n, i),
                        'named arguments must follow bare *');
                    return NULL;
                }
                ch = CHILD(n, i+1);  /* tfpdef or COMMA */
                if (TYPE(ch) == COMMA) {
                    int res = 0;
                    i += 2; /* now follows keyword only arguments */

                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
                        ast_error(c, CHILD(n, i),
                                'bare * has associated type comment');
                        return NULL;
                    }

                    res = handle_keywordonly_args(c, n, i,
                                                  kwonlyargs, kwdefaults);
                    if (res == -1) return NULL;
                    i = res; /* res has new position to process */
                }
                else {
                    vararg = ast_for_arg(c, ch);
                    if (!vararg)
                        return NULL;

                    i += 2; /* the star and the name */
                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                        i += 1; /* the comma, if present */

                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));
                        if (!vararg->type_comment)
                            return NULL;
                        i += 1;
                    }

                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef
                                    || TYPE(CHILD(n, i)) == vfpdef)) {
                        int res = 0;
                        res = handle_keywordonly_args(c, n, i,
                                                      kwonlyargs, kwdefaults);
                        if (res == -1) return NULL;
                        i = res; /* res has new position to process */
                    }
                }
                break;
            case DOUBLESTAR:
                ch = CHILD(n, i+1);  /* tfpdef */
                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);
                kwarg = ast_for_arg(c, ch);
                if (!kwarg)
                    return NULL;
                i += 2; /* the double star and the name */
                if (TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                break;
            case TYPE_COMMENT:
                assert(i);

                if (kwarg)
                    arg = kwarg;

                /* arg will be equal to the last argument processed */
                arg->type_comment = NEW_TYPE_COMMENT(ch);
                if (!arg->type_comment)
                    return NULL;
                i += 1;
                break;
            default:
                PyErr_Format(PyExc_SystemError,
                             'unexpected node in varargslist: %d @ %d',
                             TYPE(ch), i);
                return NULL;
        }
    }
    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);
}
",8824
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"dfa *
Ta3Grammar_FindDFA(grammar *g, int type)
{
    dfa *d;
#if 1
    /* Massive speed-up */
    d = &g->g_dfa[type - NT_OFFSET];
    assert(d->d_type == type);
    return d;
#else
    /* Old, slow version */
    int i;

    for (i = g->g_ndfas, d = g->g_dfa; --i >= 0; d++) {
        if (d->d_type == type)
            return d;
    }
    assert(0);
    /* NOTREACHED */
#endif
}
",8825
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"node *
Ta3Parser_ParseStringObject(const char *s, PyObject *filename,
                           grammar *g, int start,
                           perrdetail *err_ret, int *flags)
{
    struct tok_state *tok;
    int exec_input = start == file_input;

    if (initerr(err_ret, filename) < 0)
        return NULL;

    if (*flags & PyPARSE_IGNORE_COOKIE)
        tok = Ta3Tokenizer_FromUTF8(s, exec_input);
    else
        tok = Ta3Tokenizer_FromString(s, exec_input);
    if (tok == NULL) {
        err_ret->error = PyErr_Occurred() ? E_DECODE : E_NOMEM;
        return NULL;
    }

#ifndef PGEN
    Py_INCREF(err_ret->filename);
    tok->filename = err_ret->filename;
#endif
    return parsetok(tok, g, start, err_ret, flags);
}
",8826
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static node *
parsetok(struct tok_state *tok, grammar *g, int start, perrdetail *err_ret,
         int *flags)
{
    parser_state *ps;
    node *n;
    int started = 0;

    growable_int_array type_ignores;
    if (!growable_int_array_init(&type_ignores, 10)) {
        err_ret->error = E_NOMEM;
        Ta3Tokenizer_Free(tok);
        return NULL;
    }

    if ((ps = Ta3Parser_New(g, start)) == NULL) {
        err_ret->error = E_NOMEM;
        Ta3Tokenizer_Free(tok);
        return NULL;
    }
#ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
    if (*flags & PyPARSE_BARRY_AS_BDFL)
        ps->p_flags |= CO_FUTURE_BARRY_AS_BDFL;
#endif

    for (;;) {
        char *a, *b;
        int type;
        size_t len;
        char *str;
        int col_offset;

        type = Ta3Tokenizer_Get(tok, &a, &b);
        if (type == ERRORTOKEN) {
            err_ret->error = tok->done;
            break;
        }
        if (type == ENDMARKER && started) {
            type = NEWLINE; /* Add an extra newline */
            started = 0;
            /* Add the right number of dedent tokens,
               except if a certain flag is given --
               codeop.py uses this. */
            if (tok->indent &&
                !(*flags & PyPARSE_DONT_IMPLY_DEDENT))
            {
                tok->pendin = -tok->indent;
                tok->indent = 0;
            }
        }
        else
            started = 1;
        len = b - a; /* XXX this may compute NULL - NULL */
        str = (char *) PyObject_MALLOC(len + 1);
        if (str == NULL) {
            err_ret->error = E_NOMEM;
            break;
        }
        if (len > 0)
            strncpy(str, a, len);
        str[len] = '\0';

#ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
        if (type == NOTEQUAL) {
            if (!(ps->p_flags & CO_FUTURE_BARRY_AS_BDFL) &&
                            strcmp(str, '!=')) {
                PyObject_FREE(str);
                err_ret->error = E_SYNTAX;
                break;
            }
            else if ((ps->p_flags & CO_FUTURE_BARRY_AS_BDFL) &&
                            strcmp(str, '<>')) {
                PyObject_FREE(str);
                err_ret->text = 'with Barry as BDFL, use '<>' '
                                'instead of '!='';
                err_ret->error = E_SYNTAX;
                break;
            }
        }
#endif
        if (a >= tok->line_start)
            col_offset = Py_SAFE_DOWNCAST(a - tok->line_start,
                                          intptr_t, int);
        else
            col_offset = -1;

        if (type == TYPE_IGNORE) {
            if (!growable_int_array_add(&type_ignores, tok->lineno)) {
                err_ret->error = E_NOMEM;
                break;
            }
            continue;
        }

        if ((err_ret->error =
             Ta3Parser_AddToken(ps, (int)type, str,
                               tok->lineno, col_offset,
                               &(err_ret->expected))) != E_OK) {
            if (err_ret->error != E_DONE) {
                PyObject_FREE(str);
                err_ret->token = type;
            }
            break;
        }
    }

    if (err_ret->error == E_DONE) {
        n = ps->p_tree;
        ps->p_tree = NULL;

        if (n->n_type == file_input) {
            /* Put type_ignore nodes in the ENDMARKER of file_input. */
            int num;
            node *ch;
            size_t i;

            num = NCH(n);
            ch = CHILD(n, num - 1);
            REQ(ch, ENDMARKER);

            for (i = 0; i < type_ignores.num_items; i++) {
                Ta3Node_AddChild(ch, TYPE_IGNORE, NULL, type_ignores.items[i], 0);
            }
        }
        growable_int_array_deallocate(&type_ignores);

#ifndef PGEN
        /* Check that the source for a single input statement really
           is a single statement by looking at what is left in the
           buffer after parsing.  Trailing whitespace and comments
           are OK.  */
        if (start == single_input) {
            char *cur = tok->cur;
            char c = *tok->cur;

            for (;;) {
                while (c == ' ' || c == '\t' || c == '\n' || c == '\014')
                    c = *++cur;

                if (!c)
                    break;

                if (c != '#') {
                    err_ret->error = E_BADSINGLE;
                    Ta3Node_Free(n);
                    n = NULL;
                    break;
                }

                /* Suck up comment. */
                while (c && c != '\n')
                    c = *++cur;
            }
        }
#endif
    }
    else
        n = NULL;

#ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
    *flags = ps->p_flags;
#endif
    Ta3Parser_Delete(ps);

    if (n == NULL) {
        if (tok->done == E_EOF)
            err_ret->error = E_EOF;
        err_ret->lineno = tok->lineno;
        if (tok->buf != NULL) {
            size_t len;
            assert(tok->cur - tok->buf < INT_MAX);
            err_ret->offset = (int)(tok->cur - tok->buf);
            len = tok->inp - tok->buf;
            err_ret->text = (char *) PyObject_MALLOC(len + 1);
            if (err_ret->text != NULL) {
                if (len > 0)
                    strncpy(err_ret->text, tok->buf, len);
                err_ret->text[len] = '\0';
            }
        }
    } else if (tok->encoding != NULL) {
        /* 'nodes->n_str' uses PyObject_*, while 'tok->encoding' was
         * allocated using PyMem_
         */
        node* r = Ta3Node_New(encoding_decl);
        if (r)
            r->n_str = PyObject_MALLOC(strlen(tok->encoding)+1);
        if (!r || !r->n_str) {
            err_ret->error = E_NOMEM;
            if (r)
                PyObject_FREE(r);
            n = NULL;
            goto done;
        }
        strcpy(r->n_str, tok->encoding);
        PyMem_FREE(tok->encoding);
        tok->encoding = NULL;
        r->n_nchildren = 1;
        r->n_child = n;
        n = r;
    }

done:
    Ta3Tokenizer_Free(tok);

    return n;
}
",8827
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static void
ast_dealloc(AST_object *self)
{
    Py_CLEAR(self->dict);
    Py_TYPE(self)->tp_free(self);
}
",8828
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static void
ast_clear(AST_object *self)
{
    Py_CLEAR(self->dict);
}
",8829
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
ast_type_init(PyObject *self, PyObject *args, PyObject *kw)
{
    _Py_IDENTIFIER(_fields);
    Py_ssize_t i, numfields = 0;
    int res = -1;
    PyObject *key, *value, *fields;
    fields = _PyObject_GetAttrId((PyObject*)Py_TYPE(self), &PyId__fields);
    if (!fields)
        PyErr_Clear();
    if (fields) {
        numfields = PySequence_Size(fields);
        if (numfields == -1)
            goto cleanup;
    }
    res = 0; /* if no error occurs, this stays 0 to the end */
    if (PyTuple_GET_SIZE(args) > 0) {
        if (numfields != PyTuple_GET_SIZE(args)) {
            PyErr_Format(PyExc_TypeError, '%.400s constructor takes %s'
                         '%zd positional argument%s',
                         Py_TYPE(self)->tp_name,
                         numfields == 0 ? '' : 'either 0 or ',
                         numfields, numfields == 1 ? '' : 's');
            res = -1;
            goto cleanup;
        }
        for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
            /* cannot be reached when fields is NULL */
            PyObject *name = PySequence_GetItem(fields, i);
            if (!name) {
                res = -1;
                goto cleanup;
            }
            res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));
            Py_DECREF(name);
            if (res < 0)
                goto cleanup;
        }
    }
    if (kw) {
        i = 0;  /* needed by PyDict_Next */
        while (PyDict_Next(kw, &i, &key, &value)) {
            res = PyObject_SetAttr(self, key, value);
            if (res < 0)
                goto cleanup;
        }
    }
  cleanup:
    Py_XDECREF(fields);
    return res;
}
",8830
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static PyObject *
ast_type_reduce(PyObject *self, PyObject *unused)
{
    PyObject *res;
    _Py_IDENTIFIER(__dict__);
    PyObject *dict = _PyObject_GetAttrId(self, &PyId___dict__);
    if (dict == NULL) {
        if (PyErr_ExceptionMatches(PyExc_AttributeError))
            PyErr_Clear();
        else
            return NULL;
    }
    if (dict) {
        res = Py_BuildValue('O()O', Py_TYPE(self), dict);
        Py_DECREF(dict);
        return res;
    }
    return Py_BuildValue('O()', Py_TYPE(self));
}
",8831
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static PyTypeObject* make_type(char *type, PyTypeObject* base, char**fields, int num_fields)
{
    PyObject *fnames, *result;
    int i;
    fnames = PyTuple_New(num_fields);
    if (!fnames) return NULL;
    for (i = 0; i < num_fields; i++) {
        PyObject *field = PyUnicode_FromString(fields[i]);
        if (!field) {
            Py_DECREF(fnames);
            return NULL;
        }
        PyTuple_SET_ITEM(fnames, i, field);
    }
    result = PyObject_CallFunction((PyObject*)&PyType_Type, 's(O){sOss}',
                    type, base, '_fields', fnames, '__module__', '_ast3');
    Py_DECREF(fnames);
    return (PyTypeObject*)result;
}
",8832
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int add_attributes(PyTypeObject* type, char**attrs, int num_fields)
{
    int i, result;
    _Py_IDENTIFIER(_attributes);
    PyObject *s, *l = PyTuple_New(num_fields);
    if (!l)
        return 0;
    for (i = 0; i < num_fields; i++) {
        s = PyUnicode_FromString(attrs[i]);
        if (!s) {
            Py_DECREF(l);
            return 0;
        }
        PyTuple_SET_ITEM(l, i, s);
    }
    result = _PyObject_SetAttrId((PyObject*)type, &PyId__attributes, l) >= 0;
    Py_DECREF(l);
    return result;
}
",8833
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int add_ast_fields(void)
{
    PyObject *empty_tuple, *d;
    if (PyType_Ready(&AST_type) < 0)
        return -1;
    d = AST_type.tp_dict;
    empty_tuple = PyTuple_New(0);
    if (!empty_tuple ||
        PyDict_SetItemString(d, '_fields', empty_tuple) < 0 ||
        PyDict_SetItemString(d, '_attributes', empty_tuple) < 0) {
        Py_XDECREF(empty_tuple);
        return -1;
    }
    Py_DECREF(empty_tuple);
    return 0;
}
",8834
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_mod(void* _o)
{
    mod_ty o = (mod_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case Module_kind:
        result = PyType_GenericNew(Module_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Module.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Module.type_ignores, ast2obj_type_ignore);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_ignores, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Interactive_kind:
        result = PyType_GenericNew(Interactive_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Interactive.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Expression_kind:
        result = PyType_GenericNew(Expression_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Expression.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case FunctionType_kind:
        result = PyType_GenericNew(FunctionType_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.FunctionType.argtypes, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_argtypes, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FunctionType.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Suite_kind:
        result = PyType_GenericNew(Suite_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Suite.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8835
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_stmt(void* _o)
{
    stmt_ty o = (stmt_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case FunctionDef_kind:
        result = PyType_GenericNew(FunctionDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.FunctionDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_arguments(o->v.FunctionDef.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.FunctionDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.FunctionDef.decorator_list, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FunctionDef.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.FunctionDef.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncFunctionDef_kind:
        result = PyType_GenericNew(AsyncFunctionDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.AsyncFunctionDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_arguments(o->v.AsyncFunctionDef.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFunctionDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFunctionDef.decorator_list,
                             ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AsyncFunctionDef.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncFunctionDef.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ClassDef_kind:
        result = PyType_GenericNew(ClassDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.ClassDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.bases, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_bases, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.keywords, ast2obj_keyword);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keywords, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.decorator_list, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Return_kind:
        result = PyType_GenericNew(Return_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Return.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Delete_kind:
        result = PyType_GenericNew(Delete_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Delete.targets, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_targets, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assign_kind:
        result = PyType_GenericNew(Assign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Assign.targets, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_targets, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Assign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.Assign.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AugAssign_kind:
        result = PyType_GenericNew(AugAssign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AugAssign.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_operator(o->v.AugAssign.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AugAssign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AnnAssign_kind:
        result = PyType_GenericNew(AnnAssign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AnnAssign.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AnnAssign.annotation);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_annotation, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AnnAssign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.AnnAssign.simple);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_simple, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case For_kind:
        result = PyType_GenericNew(For_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.For.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.For.iter);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.For.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.For.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.For.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncFor_kind:
        result = PyType_GenericNew(AsyncFor_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AsyncFor.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AsyncFor.iter);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFor.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFor.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncFor.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case While_kind:
        result = PyType_GenericNew(While_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.While.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.While.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.While.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case If_kind:
        result = PyType_GenericNew(If_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.If.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.If.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.If.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case With_kind:
        result = PyType_GenericNew(With_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.With.items, ast2obj_withitem);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_items, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.With.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.With.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncWith_kind:
        result = PyType_GenericNew(AsyncWith_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.AsyncWith.items, ast2obj_withitem);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_items, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncWith.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncWith.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Raise_kind:
        result = PyType_GenericNew(Raise_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Raise.exc);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_exc, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Raise.cause);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_cause, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Try_kind:
        result = PyType_GenericNew(Try_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Try.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.handlers, ast2obj_excepthandler);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_handlers, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.finalbody, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_finalbody, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assert_kind:
        result = PyType_GenericNew(Assert_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Assert.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Assert.msg);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_msg, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Import_kind:
        result = PyType_GenericNew(Import_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Import.names, ast2obj_alias);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ImportFrom_kind:
        result = PyType_GenericNew(ImportFrom_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.ImportFrom.module);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_module, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ImportFrom.names, ast2obj_alias);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.ImportFrom.level);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_level, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Global_kind:
        result = PyType_GenericNew(Global_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Global.names, ast2obj_identifier);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Nonlocal_kind:
        result = PyType_GenericNew(Nonlocal_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Nonlocal.names, ast2obj_identifier);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Expr_kind:
        result = PyType_GenericNew(Expr_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Expr.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Pass_kind:
        result = PyType_GenericNew(Pass_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Break_kind:
        result = PyType_GenericNew(Break_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Continue_kind:
        result = PyType_GenericNew(Continue_type, NULL, NULL);
        if (!result) goto failed;
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8836
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_expr(void* _o)
{
    expr_ty o = (expr_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case BoolOp_kind:
        result = PyType_GenericNew(BoolOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_boolop(o->v.BoolOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.BoolOp.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case BinOp_kind:
        result = PyType_GenericNew(BinOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.BinOp.left);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_left, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_operator(o->v.BinOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.BinOp.right);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_right, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case UnaryOp_kind:
        result = PyType_GenericNew(UnaryOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_unaryop(o->v.UnaryOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.UnaryOp.operand);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_operand, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Lambda_kind:
        result = PyType_GenericNew(Lambda_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_arguments(o->v.Lambda.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Lambda.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case IfExp_kind:
        result = PyType_GenericNew(IfExp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.IfExp.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.IfExp.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.IfExp.orelse);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Dict_kind:
        result = PyType_GenericNew(Dict_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Dict.keys, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keys, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Dict.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Set_kind:
        result = PyType_GenericNew(Set_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Set.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ListComp_kind:
        result = PyType_GenericNew(ListComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.ListComp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ListComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case SetComp_kind:
        result = PyType_GenericNew(SetComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.SetComp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.SetComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case DictComp_kind:
        result = PyType_GenericNew(DictComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.DictComp.key);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_key, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.DictComp.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.DictComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case GeneratorExp_kind:
        result = PyType_GenericNew(GeneratorExp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.GeneratorExp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.GeneratorExp.generators,
                             ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Await_kind:
        result = PyType_GenericNew(Await_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Await.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Yield_kind:
        result = PyType_GenericNew(Yield_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Yield.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case YieldFrom_kind:
        result = PyType_GenericNew(YieldFrom_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.YieldFrom.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Compare_kind:
        result = PyType_GenericNew(Compare_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Compare.left);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_left, value) == -1)
            goto failed;
        Py_DECREF(value);
        {
            Py_ssize_t i, n = asdl_seq_LEN(o->v.Compare.ops);
            value = PyList_New(n);
            if (!value) goto failed;
            for(i = 0; i < n; i++)
                PyList_SET_ITEM(value, i, ast2obj_cmpop((cmpop_ty)asdl_seq_GET(o->v.Compare.ops, i)));
        }
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ops, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Compare.comparators, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_comparators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Call_kind:
        result = PyType_GenericNew(Call_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Call.func);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_func, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Call.args, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Call.keywords, ast2obj_keyword);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keywords, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Num_kind:
        result = PyType_GenericNew(Num_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_object(o->v.Num.n);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_n, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Str_kind:
        result = PyType_GenericNew(Str_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_string(o->v.Str.s);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_s, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.Str.kind);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_kind, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case FormattedValue_kind:
        result = PyType_GenericNew(FormattedValue_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.FormattedValue.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.FormattedValue.conversion);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_conversion, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FormattedValue.format_spec);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_format_spec, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case JoinedStr_kind:
        result = PyType_GenericNew(JoinedStr_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.JoinedStr.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Bytes_kind:
        result = PyType_GenericNew(Bytes_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_bytes(o->v.Bytes.s);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_s, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case NameConstant_kind:
        result = PyType_GenericNew(NameConstant_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_singleton(o->v.NameConstant.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Ellipsis_kind:
        result = PyType_GenericNew(Ellipsis_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Constant_kind:
        result = PyType_GenericNew(Constant_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_constant(o->v.Constant.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Attribute_kind:
        result = PyType_GenericNew(Attribute_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Attribute.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->v.Attribute.attr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_attr, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Attribute.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Subscript_kind:
        result = PyType_GenericNew(Subscript_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Subscript.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_slice(o->v.Subscript.slice);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_slice, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Subscript.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Starred_kind:
        result = PyType_GenericNew(Starred_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Starred.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Starred.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Name_kind:
        result = PyType_GenericNew(Name_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.Name.id);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_id, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Name.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case List_kind:
        result = PyType_GenericNew(List_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.List.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.List.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Tuple_kind:
        result = PyType_GenericNew(Tuple_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Tuple.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Tuple.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8837
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_slice(void* _o)
{
    slice_ty o = (slice_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case Slice_kind:
        result = PyType_GenericNew(Slice_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Slice.lower);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_lower, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Slice.upper);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_upper, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Slice.step);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_step, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ExtSlice_kind:
        result = PyType_GenericNew(ExtSlice_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.ExtSlice.dims, ast2obj_slice);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_dims, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Index_kind:
        result = PyType_GenericNew(Index_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Index.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8838
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_comprehension(void* _o)
{
    comprehension_ty o = (comprehension_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(comprehension_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_expr(o->target);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->iter);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->ifs, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_ifs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->is_async);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_is_async, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8839
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_excepthandler(void* _o)
{
    excepthandler_ty o = (excepthandler_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case ExceptHandler_kind:
        result = PyType_GenericNew(ExceptHandler_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.ExceptHandler.type);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->v.ExceptHandler.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ExceptHandler.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8840
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_arguments(void* _o)
{
    arguments_ty o = (arguments_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(arguments_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_list(o->args, ast2obj_arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_arg(o->vararg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_vararg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->kwonlyargs, ast2obj_arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kwonlyargs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->kw_defaults, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kw_defaults, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_arg(o->kwarg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kwarg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->defaults, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_defaults, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8841
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_arg(void* _o)
{
    arg_ty o = (arg_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(arg_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->annotation);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_annotation, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_string(o->type_comment);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8842
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_keyword(void* _o)
{
    keyword_ty o = (keyword_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(keyword_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->value);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8843
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_alias(void* _o)
{
    alias_ty o = (alias_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(alias_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->name);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_identifier(o->asname);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_asname, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8844
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_withitem(void* _o)
{
    withitem_ty o = (withitem_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(withitem_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_expr(o->context_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_context_expr, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->optional_vars);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_optional_vars, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8845
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_type_ignore(void* _o)
{
    type_ignore_ty o = (type_ignore_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case TypeIgnore_kind:
        result = PyType_GenericNew(TypeIgnore_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_int(o->v.TypeIgnore.lineno);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_lineno, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8846
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_mod(PyObject* obj, mod_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Module_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;
        asdl_seq* type_ignores;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Module field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Module field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Module');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_type_ignores)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_type_ignores);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Module field \'type_ignores\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            type_ignores = _Ta3_asdl_seq_new(len, arena);
            if (type_ignores == NULL) goto failed;
            for (i = 0; i < len; i++) {
                type_ignore_ty value;
                res = obj2ast_type_ignore(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Module field \'type_ignores\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(type_ignores, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'type_ignores\' missing from Module');
            return 1;
        }
        *out = Module(body, type_ignores, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Interactive_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Interactive field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Interactive field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Interactive');
            return 1;
        }
        *out = Interactive(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Expression_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Expression');
            return 1;
        }
        *out = Expression(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)FunctionType_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* argtypes;
        expr_ty returns;

        if (_PyObject_HasAttrId(obj, &PyId_argtypes)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_argtypes);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'FunctionType field \'argtypes\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            argtypes = _Ta3_asdl_seq_new(len, arena);
            if (argtypes == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'FunctionType field \'argtypes\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(argtypes, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'argtypes\' missing from FunctionType');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_returns)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_returns);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &returns, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'returns\' missing from FunctionType');
            return 1;
        }
        *out = FunctionType(argtypes, returns, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Suite_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Suite field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Suite field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Suite');
            return 1;
        }
        *out = Suite(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of mod, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8847
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_expr(PyObject* obj, expr_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    int lineno;
    int col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from expr');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from expr');
        return 1;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)BoolOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        boolop_ty op;
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_boolop(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from BoolOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'BoolOp field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'BoolOp field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from BoolOp');
            return 1;
        }
        *out = BoolOp(op, values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)BinOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty left;
        operator_ty op;
        expr_ty right;

        if (_PyObject_HasAttrId(obj, &PyId_left)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_left);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &left, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'left\' missing from BinOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_operator(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from BinOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_right)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_right);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &right, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'right\' missing from BinOp');
            return 1;
        }
        *out = BinOp(left, op, right, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)UnaryOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        unaryop_ty op;
        expr_ty operand;

        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_unaryop(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from UnaryOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_operand)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_operand);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &operand, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'operand\' missing from UnaryOp');
            return 1;
        }
        *out = UnaryOp(op, operand, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Lambda_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        arguments_ty args;
        expr_ty body;

        if (_PyObject_HasAttrId(obj, &PyId_args)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_args);
            if (tmp == NULL) goto failed;
            res = obj2ast_arguments(tmp, &args, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from Lambda');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Lambda');
            return 1;
        }
        *out = Lambda(args, body, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)IfExp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty test;
        expr_ty body;
        expr_ty orelse;

        if (_PyObject_HasAttrId(obj, &PyId_test)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_test);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &test, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'test\' missing from IfExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from IfExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_orelse)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_orelse);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &orelse, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'orelse\' missing from IfExp');
            return 1;
        }
        *out = IfExp(test, body, orelse, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Dict_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* keys;
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_keys)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_keys);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Dict field \'keys\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keys = _Ta3_asdl_seq_new(len, arena);
            if (keys == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Dict field \'keys\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(keys, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'keys\' missing from Dict');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Dict field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Dict field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from Dict');
            return 1;
        }
        *out = Dict(keys, values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Set_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Set field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Set field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from Set');
            return 1;
        }
        *out = Set(elts, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ListComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from ListComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ListComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ListComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from ListComp');
            return 1;
        }
        *out = ListComp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)SetComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from SetComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'SetComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'SetComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from SetComp');
            return 1;
        }
        *out = SetComp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)DictComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty key;
        expr_ty value;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_key)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_key);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &key, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'key\' missing from DictComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from DictComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'DictComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'DictComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from DictComp');
            return 1;
        }
        *out = DictComp(key, value, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)GeneratorExp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from GeneratorExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'GeneratorExp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'GeneratorExp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from GeneratorExp');
            return 1;
        }
        *out = GeneratorExp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Await_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Await');
            return 1;
        }
        *out = Await(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Yield_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (exists_not_none(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            value = NULL;
        }
        *out = Yield(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)YieldFrom_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from YieldFrom');
            return 1;
        }
        *out = YieldFrom(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Compare_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty left;
        asdl_int_seq* ops;
        asdl_seq* comparators;

        if (_PyObject_HasAttrId(obj, &PyId_left)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_left);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &left, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'left\' missing from Compare');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ops)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_ops);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Compare field \'ops\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            ops = _Ta3_asdl_int_seq_new(len, arena);
            if (ops == NULL) goto failed;
            for (i = 0; i < len; i++) {
                cmpop_ty value;
                res = obj2ast_cmpop(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Compare field \'ops\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(ops, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ops\' missing from Compare');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_comparators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_comparators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Compare field \'comparators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            comparators = _Ta3_asdl_seq_new(len, arena);
            if (comparators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Compare field \'comparators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(comparators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'comparators\' missing from Compare');
            return 1;
        }
        *out = Compare(left, ops, comparators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Call_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty func;
        asdl_seq* args;
        asdl_seq* keywords;

        if (_PyObject_HasAttrId(obj, &PyId_func)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_func);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &func, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'func\' missing from Call');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_args)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_args);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Call field \'args\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            args = _Ta3_asdl_seq_new(len, arena);
            if (args == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Call field \'args\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(args, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from Call');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_keywords)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_keywords);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Call field \'keywords\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keywords = _Ta3_asdl_seq_new(len, arena);
            if (keywords == NULL) goto failed;
            for (i = 0; i < len; i++) {
                keyword_ty value;
                res = obj2ast_keyword(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Call field \'keywords\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(keywords, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'keywords\' missing from Call');
            return 1;
        }
        *out = Call(func, args, keywords, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Num_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        object n;

        if (_PyObject_HasAttrId(obj, &PyId_n)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_n);
            if (tmp == NULL) goto failed;
            res = obj2ast_object(tmp, &n, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'n\' missing from Num');
            return 1;
        }
        *out = Num(n, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Str_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        string s;
        string kind;

        if (_PyObject_HasAttrId(obj, &PyId_s)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_s);
            if (tmp == NULL) goto failed;
            res = obj2ast_string(tmp, &s, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'s\' missing from Str');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_kind)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_kind);
            if (tmp == NULL) goto failed;
            res = obj2ast_string(tmp, &kind, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'kind\' missing from Str');
            return 1;
        }
        *out = Str(s, kind, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)FormattedValue_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        int conversion;
        expr_ty format_spec;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from FormattedValue');
            return 1;
        }
        if (exists_not_none(obj, &PyId_conversion)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_conversion);
            if (tmp == NULL) goto failed;
            res = obj2ast_int(tmp, &conversion, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            conversion = 0;
        }
        if (exists_not_none(obj, &PyId_format_spec)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_format_spec);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &format_spec, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            format_spec = NULL;
        }
        *out = FormattedValue(value, conversion, format_spec, lineno,
                              col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)JoinedStr_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'JoinedStr field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'JoinedStr field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from JoinedStr');
            return 1;
        }
        *out = JoinedStr(values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Bytes_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        bytes s;

        if (_PyObject_HasAttrId(obj, &PyId_s)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_s);
            if (tmp == NULL) goto failed;
            res = obj2ast_bytes(tmp, &s, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'s\' missing from Bytes');
            return 1;
        }
        *out = Bytes(s, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)NameConstant_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        singleton value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_singleton(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from NameConstant');
            return 1;
        }
        *out = NameConstant(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Ellipsis_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {

        *out = Ellipsis(lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Constant_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        constant value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_constant(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Constant');
            return 1;
        }
        *out = Constant(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Attribute_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        identifier attr;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Attribute');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_attr)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_attr);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &attr, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'attr\' missing from Attribute');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Attribute');
            return 1;
        }
        *out = Attribute(value, attr, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Subscript_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        slice_ty slice;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Subscript');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_slice)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_slice);
            if (tmp == NULL) goto failed;
            res = obj2ast_slice(tmp, &slice, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'slice\' missing from Subscript');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Subscript');
            return 1;
        }
        *out = Subscript(value, slice, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Starred_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Starred');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Starred');
            return 1;
        }
        *out = Starred(value, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Name_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        identifier id;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_id)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_id);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &id, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'id\' missing from Name');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Name');
            return 1;
        }
        *out = Name(id, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)List_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'List field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'List field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from List');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from List');
            return 1;
        }
        *out = List(elts, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Tuple_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Tuple field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Tuple field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from Tuple');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Tuple');
            return 1;
        }
        *out = Tuple(elts, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of expr, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8849
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_slice(PyObject* obj, slice_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Slice_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty lower;
        expr_ty upper;
        expr_ty step;

        if (exists_not_none(obj, &PyId_lower)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_lower);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &lower, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            lower = NULL;
        }
        if (exists_not_none(obj, &PyId_upper)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_upper);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &upper, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            upper = NULL;
        }
        if (exists_not_none(obj, &PyId_step)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_step);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &step, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            step = NULL;
        }
        *out = Slice(lower, upper, step, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ExtSlice_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* dims;

        if (_PyObject_HasAttrId(obj, &PyId_dims)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_dims);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ExtSlice field \'dims\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            dims = _Ta3_asdl_seq_new(len, arena);
            if (dims == NULL) goto failed;
            for (i = 0; i < len; i++) {
                slice_ty value;
                res = obj2ast_slice(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ExtSlice field \'dims\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(dims, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'dims\' missing from ExtSlice');
            return 1;
        }
        *out = ExtSlice(dims, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Index_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Index');
            return 1;
        }
        *out = Index(value, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of slice, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8850
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_comprehension(PyObject* obj, comprehension_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    expr_ty target;
    expr_ty iter;
    asdl_seq* ifs;
    int is_async;

    if (_PyObject_HasAttrId(obj, &PyId_target)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_target);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &target, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'target\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_iter)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_iter);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &iter, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'iter\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_ifs)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_ifs);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'comprehension field \'ifs\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        ifs = _Ta3_asdl_seq_new(len, arena);
        if (ifs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'comprehension field \'ifs\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(ifs, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'ifs\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_is_async)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_is_async);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &is_async, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'is_async\' missing from comprehension');
        return 1;
    }
    *out = comprehension(target, iter, ifs, is_async, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8851
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_excepthandler(PyObject* obj, excepthandler_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    int lineno;
    int col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from excepthandler');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from excepthandler');
        return 1;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ExceptHandler_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty type;
        identifier name;
        asdl_seq* body;

        if (exists_not_none(obj, &PyId_type)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_type);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &type, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            type = NULL;
        }
        if (exists_not_none(obj, &PyId_name)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_name);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &name, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            name = NULL;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ExceptHandler field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ExceptHandler field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from ExceptHandler');
            return 1;
        }
        *out = ExceptHandler(type, name, body, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of excepthandler, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8852
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_arguments(PyObject* obj, arguments_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    asdl_seq* args;
    arg_ty vararg;
    asdl_seq* kwonlyargs;
    asdl_seq* kw_defaults;
    arg_ty kwarg;
    asdl_seq* defaults;

    if (_PyObject_HasAttrId(obj, &PyId_args)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_args);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'args\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        args = _Ta3_asdl_seq_new(len, arena);
        if (args == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty value;
            res = obj2ast_arg(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'args\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(args, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from arguments');
        return 1;
    }
    if (exists_not_none(obj, &PyId_vararg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_vararg);
        if (tmp == NULL) goto failed;
        res = obj2ast_arg(tmp, &vararg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        vararg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_kwonlyargs)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_kwonlyargs);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'kwonlyargs\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        kwonlyargs = _Ta3_asdl_seq_new(len, arena);
        if (kwonlyargs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty value;
            res = obj2ast_arg(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'kwonlyargs\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(kwonlyargs, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'kwonlyargs\' missing from arguments');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_kw_defaults)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_kw_defaults);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'kw_defaults\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        kw_defaults = _Ta3_asdl_seq_new(len, arena);
        if (kw_defaults == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'kw_defaults\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(kw_defaults, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'kw_defaults\' missing from arguments');
        return 1;
    }
    if (exists_not_none(obj, &PyId_kwarg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_kwarg);
        if (tmp == NULL) goto failed;
        res = obj2ast_arg(tmp, &kwarg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        kwarg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_defaults)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_defaults);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'defaults\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        defaults = _Ta3_asdl_seq_new(len, arena);
        if (defaults == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'defaults\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(defaults, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'defaults\' missing from arguments');
        return 1;
    }
    *out = arguments(args, vararg, kwonlyargs, kw_defaults, kwarg, defaults,
                     arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8853
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_arg(PyObject* obj, arg_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier arg;
    expr_ty annotation;
    string type_comment;
    int lineno;
    int col_offset;

    if (_PyObject_HasAttrId(obj, &PyId_arg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_arg);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &arg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'arg\' missing from arg');
        return 1;
    }
    if (exists_not_none(obj, &PyId_annotation)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_annotation);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &annotation, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        annotation = NULL;
    }
    if (exists_not_none(obj, &PyId_type_comment)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_type_comment);
        if (tmp == NULL) goto failed;
        res = obj2ast_string(tmp, &type_comment, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        type_comment = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from arg');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from arg');
        return 1;
    }
    *out = arg(arg, annotation, type_comment, lineno, col_offset, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8854
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_keyword(PyObject* obj, keyword_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier arg;
    expr_ty value;

    if (exists_not_none(obj, &PyId_arg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_arg);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &arg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        arg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_value)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_value);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &value, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from keyword');
        return 1;
    }
    *out = keyword(arg, value, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8855
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_alias(PyObject* obj, alias_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier name;
    identifier asname;

    if (_PyObject_HasAttrId(obj, &PyId_name)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_name);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &name, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'name\' missing from alias');
        return 1;
    }
    if (exists_not_none(obj, &PyId_asname)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_asname);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &asname, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        asname = NULL;
    }
    *out = alias(name, asname, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8856
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    expr_ty context_expr;
    expr_ty optional_vars;

    if (_PyObject_HasAttrId(obj, &PyId_context_expr)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_context_expr);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &context_expr, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'context_expr\' missing from withitem');
        return 1;
    }
    if (exists_not_none(obj, &PyId_optional_vars)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_optional_vars);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &optional_vars, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        optional_vars = NULL;
    }
    *out = withitem(context_expr, optional_vars, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8857
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_type_ignore(PyObject* obj, type_ignore_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)TypeIgnore_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        int lineno;

        if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
            if (tmp == NULL) goto failed;
            res = obj2ast_int(tmp, &lineno, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from TypeIgnore');
            return 1;
        }
        *out = TypeIgnore(lineno, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of type_ignore, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8858
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyMODINIT_FUNC
PyInit__ast3(void)
{
    PyObject *m, *d;
    if (!init_types()) return NULL;
    m = PyModule_Create(&_astmodule3);
    if (!m) return NULL;
    d = PyModule_GetDict(m);
    if (PyDict_SetItemString(d, 'AST', (PyObject*)&AST_type) < 0) return NULL;
    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'mod', (PyObject*)mod_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Module', (PyObject*)Module_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Interactive', (PyObject*)Interactive_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Expression', (PyObject*)Expression_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'FunctionType', (PyObject*)FunctionType_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Suite', (PyObject*)Suite_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'stmt', (PyObject*)stmt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'FunctionDef', (PyObject*)FunctionDef_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncFunctionDef',
        (PyObject*)AsyncFunctionDef_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'ClassDef', (PyObject*)ClassDef_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Return', (PyObject*)Return_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Delete', (PyObject*)Delete_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Assign', (PyObject*)Assign_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'AugAssign', (PyObject*)AugAssign_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'AnnAssign', (PyObject*)AnnAssign_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'For', (PyObject*)For_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncFor', (PyObject*)AsyncFor_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'While', (PyObject*)While_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'If', (PyObject*)If_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'With', (PyObject*)With_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncWith', (PyObject*)AsyncWith_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Raise', (PyObject*)Raise_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Try', (PyObject*)Try_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Assert', (PyObject*)Assert_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Import', (PyObject*)Import_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'ImportFrom', (PyObject*)ImportFrom_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Global', (PyObject*)Global_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Nonlocal', (PyObject*)Nonlocal_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Expr', (PyObject*)Expr_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Pass', (PyObject*)Pass_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Break', (PyObject*)Break_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Continue', (PyObject*)Continue_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'expr', (PyObject*)expr_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'BoolOp', (PyObject*)BoolOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BinOp', (PyObject*)BinOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'UnaryOp', (PyObject*)UnaryOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Lambda', (PyObject*)Lambda_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'IfExp', (PyObject*)IfExp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Dict', (PyObject*)Dict_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Set', (PyObject*)Set_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'ListComp', (PyObject*)ListComp_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'SetComp', (PyObject*)SetComp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'DictComp', (PyObject*)DictComp_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'GeneratorExp', (PyObject*)GeneratorExp_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Await', (PyObject*)Await_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Yield', (PyObject*)Yield_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'YieldFrom', (PyObject*)YieldFrom_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Compare', (PyObject*)Compare_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Call', (PyObject*)Call_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Num', (PyObject*)Num_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Str', (PyObject*)Str_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'FormattedValue',
        (PyObject*)FormattedValue_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'JoinedStr', (PyObject*)JoinedStr_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Bytes', (PyObject*)Bytes_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'NameConstant', (PyObject*)NameConstant_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Ellipsis', (PyObject*)Ellipsis_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Constant', (PyObject*)Constant_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Attribute', (PyObject*)Attribute_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Subscript', (PyObject*)Subscript_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Starred', (PyObject*)Starred_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Name', (PyObject*)Name_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'List', (PyObject*)List_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Tuple', (PyObject*)Tuple_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'expr_context', (PyObject*)expr_context_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Load', (PyObject*)Load_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Store', (PyObject*)Store_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Del', (PyObject*)Del_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AugLoad', (PyObject*)AugLoad_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'AugStore', (PyObject*)AugStore_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Param', (PyObject*)Param_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'slice', (PyObject*)slice_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Slice', (PyObject*)Slice_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'ExtSlice', (PyObject*)ExtSlice_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Index', (PyObject*)Index_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'boolop', (PyObject*)boolop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'And', (PyObject*)And_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Or', (PyObject*)Or_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'operator', (PyObject*)operator_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Add', (PyObject*)Add_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Sub', (PyObject*)Sub_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Mult', (PyObject*)Mult_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'MatMult', (PyObject*)MatMult_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Div', (PyObject*)Div_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Mod', (PyObject*)Mod_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Pow', (PyObject*)Pow_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'LShift', (PyObject*)LShift_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'RShift', (PyObject*)RShift_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitOr', (PyObject*)BitOr_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitXor', (PyObject*)BitXor_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitAnd', (PyObject*)BitAnd_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'FloorDiv', (PyObject*)FloorDiv_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'unaryop', (PyObject*)unaryop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Invert', (PyObject*)Invert_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Not', (PyObject*)Not_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'UAdd', (PyObject*)UAdd_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'USub', (PyObject*)USub_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'cmpop', (PyObject*)cmpop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Eq', (PyObject*)Eq_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'NotEq', (PyObject*)NotEq_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Lt', (PyObject*)Lt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'LtE', (PyObject*)LtE_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Gt', (PyObject*)Gt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'GtE', (PyObject*)GtE_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Is', (PyObject*)Is_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'IsNot', (PyObject*)IsNot_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'In', (PyObject*)In_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'NotIn', (PyObject*)NotIn_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'comprehension', (PyObject*)comprehension_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'excepthandler', (PyObject*)excepthandler_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'ExceptHandler', (PyObject*)ExceptHandler_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'arguments', (PyObject*)arguments_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'arg', (PyObject*)arg_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'keyword', (PyObject*)keyword_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'alias', (PyObject*)alias_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'withitem', (PyObject*)withitem_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'type_ignore', (PyObject*)type_ignore_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'TypeIgnore', (PyObject*)TypeIgnore_type) < 0)
        return NULL;
    return m;
}
",8859
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static struct tok_state *
tok_new(void)
{
    struct tok_state *tok = (struct tok_state *)PyMem_MALLOC(
                                            sizeof(struct tok_state));
    if (tok == NULL)
        return NULL;
    tok->buf = tok->cur = tok->end = tok->inp = tok->start = NULL;
    tok->done = E_OK;
    tok->fp = NULL;
    tok->input = NULL;
    tok->tabsize = TABSIZE;
    tok->indent = 0;
    tok->indstack[0] = 0;

    tok->atbol = 1;
    tok->pendin = 0;
    tok->prompt = tok->nextprompt = NULL;
    tok->lineno = 0;
    tok->level = 0;
    tok->altwarning = 1;
    tok->alterror = 1;
    tok->alttabsize = 1;
    tok->altindstack[0] = 0;
    tok->decoding_state = STATE_INIT;
    tok->decoding_erred = 0;
    tok->read_coding_spec = 0;
    tok->enc = NULL;
    tok->encoding = NULL;
    tok->cont_line = 0;
#ifndef PGEN
    tok->filename = NULL;
    tok->decoding_readline = NULL;
    tok->decoding_buffer = NULL;
#endif

    tok->async_def = 0;
    tok->async_def_indent = 0;
    tok->async_def_nl = 0;

    return tok;
}
",8860
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static char *
fp_readl(char *s, int size, struct tok_state *tok)
{
    PyObject* bufobj;
    const char *buf;
    Py_ssize_t buflen;

    /* Ask for one less byte so we can terminate it */
    assert(size > 0);
    size--;

    if (tok->decoding_buffer) {
        bufobj = tok->decoding_buffer;
        Py_INCREF(bufobj);
    }
    else
    {
        bufobj = PyObject_CallObject(tok->decoding_readline, NULL);
        if (bufobj == NULL)
            goto error;
    }
    if (PyUnicode_CheckExact(bufobj))
    {
        buf = PyUnicode_AsUTF8AndSize(bufobj, &buflen);
        if (buf == NULL) {
            goto error;
        }
    }
    else
    {
        buf = PyByteArray_AsString(bufobj);
        if (buf == NULL) {
            goto error;
        }
        buflen = PyByteArray_GET_SIZE(bufobj);
    }

    Py_XDECREF(tok->decoding_buffer);
    if (buflen > size) {
        /* Too many chars, the rest goes into tok->decoding_buffer */
        tok->decoding_buffer = PyByteArray_FromStringAndSize(buf+size,
                                                         buflen-size);
        if (tok->decoding_buffer == NULL)
            goto error;
        buflen = size;
    }
    else
        tok->decoding_buffer = NULL;

    memcpy(s, buf, buflen);
    s[buflen] = '\0';
    if (buflen == 0) /* EOF */
        s = NULL;
    Py_DECREF(bufobj);
    return s;

error:
    Py_XDECREF(bufobj);
    return error_ret(tok);
}
",8861
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
fp_setreadl(struct tok_state *tok, const char* enc)
{
    PyObject *readline, *io, *stream;
    _Py_IDENTIFIER(open);
    _Py_IDENTIFIER(readline);
    int fd;
    long pos;

    fd = fileno(tok->fp);
    /* Due to buffering the file offset for fd can be different from the file
     * position of tok->fp.  If tok->fp was opened in text mode on Windows,
     * its file position counts CRLF as one char and can't be directly mapped
     * to the file offset for fd.  Instead we step back one byte and read to
     * the end of line.*/
    pos = ftell(tok->fp);
    if (pos == -1 ||
        lseek(fd, (off_t)(pos > 0 ? pos - 1 : pos), SEEK_SET) == (off_t)-1) {
        PyErr_SetFromErrnoWithFilename(PyExc_OSError, NULL);
        return 0;
    }

    io = PyImport_ImportModuleNoBlock('io');
    if (io == NULL)
        return 0;

    stream = _PyObject_CallMethodId(io, &PyId_open, 'isisOOO',
                    fd, 'r', -1, enc, Py_None, Py_None, Py_False);
    Py_DECREF(io);
    if (stream == NULL)
        return 0;

    readline = _PyObject_GetAttrId(stream, &PyId_readline);
    Py_DECREF(stream);
    if (readline == NULL)
        return 0;
    Py_XSETREF(tok->decoding_readline, readline);

    if (pos > 0) {
        PyObject *bufobj = PyObject_CallObject(readline, NULL);
        if (bufobj == NULL)
            return 0;
        Py_DECREF(bufobj);
    }

    return 1;
}
",8862
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
decoding_feof(struct tok_state *tok)
{
    if (tok->decoding_state != STATE_NORMAL) {
        return feof(tok->fp);
    } else {
        PyObject* buf = tok->decoding_buffer;
        if (buf == NULL) {
            buf = PyObject_CallObject(tok->decoding_readline, NULL);
            if (buf == NULL) {
                error_ret(tok);
                return 1;
            } else {
                tok->decoding_buffer = buf;
            }
        }
        return PyObject_Length(buf) == 0;
    }
}
",8863
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
tok_nextc(struct tok_state *tok)
{
    for (;;) {
        if (tok->cur != tok->inp) {
            return Py_CHARMASK(*tok->cur++); /* Fast path */
        }
        if (tok->done != E_OK)
            return EOF;
        if (tok->fp == NULL) {
            char *end = strchr(tok->inp, '\n');
            if (end != NULL)
                end++;
            else {
                end = strchr(tok->inp, '\0');
                if (end == tok->inp) {
                    tok->done = E_EOF;
                    return EOF;
                }
            }
            if (tok->start == NULL)
                tok->buf = tok->cur;
            tok->line_start = tok->cur;
            tok->lineno++;
            tok->inp = end;
            return Py_CHARMASK(*tok->cur++);
        }
        if (tok->prompt != NULL) {
            char *newtok = PyOS_Readline(stdin, stdout, tok->prompt);
#ifndef PGEN
            if (newtok != NULL) {
                char *translated = translate_newlines(newtok, 0, tok);
                PyMem_FREE(newtok);
                if (translated == NULL)
                    return EOF;
                newtok = translated;
            }
            if (tok->encoding && newtok && *newtok) {
                /* Recode to UTF-8 */
                Py_ssize_t buflen;
                const char* buf;
                PyObject *u = translate_into_utf8(newtok, tok->encoding);
                PyMem_FREE(newtok);
                if (!u) {
                    tok->done = E_DECODE;
                    return EOF;
                }
                buflen = PyBytes_GET_SIZE(u);
                buf = PyBytes_AS_STRING(u);
                newtok = PyMem_MALLOC(buflen+1);
                strcpy(newtok, buf);
                Py_DECREF(u);
            }
#endif
            if (tok->nextprompt != NULL)
                tok->prompt = tok->nextprompt;
            if (newtok == NULL)
                tok->done = E_INTR;
            else if (*newtok == '\0') {
                PyMem_FREE(newtok);
                tok->done = E_EOF;
            }
            else if (tok->start != NULL) {
                size_t start = tok->start - tok->buf;
                size_t oldlen = tok->cur - tok->buf;
                size_t newlen = oldlen + strlen(newtok);
                char *buf = tok->buf;
                buf = (char *)PyMem_REALLOC(buf, newlen+1);
                tok->lineno++;
                if (buf == NULL) {
                    PyMem_FREE(tok->buf);
                    tok->buf = NULL;
                    PyMem_FREE(newtok);
                    tok->done = E_NOMEM;
                    return EOF;
                }
                tok->buf = buf;
                tok->cur = tok->buf + oldlen;
                tok->line_start = tok->cur;
                strcpy(tok->buf + oldlen, newtok);
                PyMem_FREE(newtok);
                tok->inp = tok->buf + newlen;
                tok->end = tok->inp + 1;
                tok->start = tok->buf + start;
            }
            else {
                tok->lineno++;
                if (tok->buf != NULL)
                    PyMem_FREE(tok->buf);
                tok->buf = newtok;
                tok->cur = tok->buf;
                tok->line_start = tok->buf;
                tok->inp = strchr(tok->buf, '\0');
                tok->end = tok->inp + 1;
            }
        }
        else {
            int done = 0;
            Py_ssize_t cur = 0;
            char *pt;
            if (tok->start == NULL) {
                if (tok->buf == NULL) {
                    tok->buf = (char *)
                        PyMem_MALLOC(BUFSIZ);
                    if (tok->buf == NULL) {
                        tok->done = E_NOMEM;
                        return EOF;
                    }
                    tok->end = tok->buf + BUFSIZ;
                }
                if (decoding_fgets(tok->buf, (int)(tok->end - tok->buf),
                          tok) == NULL) {
                    if (!tok->decoding_erred)
                        tok->done = E_EOF;
                    done = 1;
                }
                else {
                    tok->done = E_OK;
                    tok->inp = strchr(tok->buf, '\0');
                    done = tok->inp == tok->buf || tok->inp[-1] == '\n';
                }
            }
            else {
                cur = tok->cur - tok->buf;
                if (decoding_feof(tok)) {
                    tok->done = E_EOF;
                    done = 1;
                }
                else
                    tok->done = E_OK;
            }
            tok->lineno++;
            /* Read until '\n' or EOF */
            while (!done) {
                Py_ssize_t curstart = tok->start == NULL ? -1 :
                          tok->start - tok->buf;
                Py_ssize_t curvalid = tok->inp - tok->buf;
                Py_ssize_t newsize = curvalid + BUFSIZ;
                char *newbuf = tok->buf;
                newbuf = (char *)PyMem_REALLOC(newbuf,
                                               newsize);
                if (newbuf == NULL) {
                    tok->done = E_NOMEM;
                    tok->cur = tok->inp;
                    return EOF;
                }
                tok->buf = newbuf;
                tok->cur = tok->buf + cur;
                tok->line_start = tok->cur;
                tok->inp = tok->buf + curvalid;
                tok->end = tok->buf + newsize;
                tok->start = curstart < 0 ? NULL :
                         tok->buf + curstart;
                if (decoding_fgets(tok->inp,
                               (int)(tok->end - tok->inp),
                               tok) == NULL) {
                    /* Break out early on decoding
                       errors, as tok->buf will be NULL
                     */
                    if (tok->decoding_erred)
                        return EOF;
                    /* Last line does not end in \n,
                       fake one */
                    strcpy(tok->inp, '\n');
                }
                tok->inp = strchr(tok->inp, '\0');
                done = tok->inp[-1] == '\n';
            }
            if (tok->buf != NULL) {
                tok->cur = tok->buf + cur;
                tok->line_start = tok->cur;
                /* replace '\r\n' with '\n' */
                /* For Mac leave the \r, giving a syntax error */
                pt = tok->inp - 2;
                if (pt >= tok->buf && *pt == '\r') {
                    *pt++ = '\n';
                    *pt = '\0';
                    tok->inp = pt;
                }
            }
        }
        if (tok->done != E_OK) {
            if (tok->prompt != NULL)
                PySys_WriteStderr('\n');
            tok->cur = tok->inp;
            return EOF;
        }
    }
    /*NOTREACHED*/
}
",8864
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
indenterror(struct tok_state *tok)
{
    if (tok->alterror) {
        tok->done = E_TABSPACE;
        tok->cur = tok->inp;
        return 1;
    }
    if (tok->altwarning) {
#ifdef PGEN
        PySys_WriteStderr('inconsistent use of tabs and spaces '
                          'in indentation\n');
#else
        PySys_FormatStderr('%U: inconsistent use of tabs and spaces '
                          'in indentation\n', tok->filename);
#endif
        tok->altwarning = 0;
    }
    return 0;
}
",8865
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
tok_get(struct tok_state *tok, char **p_start, char **p_end)
{
    int c;
    int blankline, nonascii;

    *p_start = *p_end = NULL;
  nextline:
    tok->start = NULL;
    blankline = 0;

    /* Get indentation level */
    if (tok->atbol) {
        int col = 0;
        int altcol = 0;
        tok->atbol = 0;
        for (;;) {
            c = tok_nextc(tok);
            if (c == ' ') {
                col++, altcol++;
            }
            else if (c == '\t') {
                col = (col/tok->tabsize + 1) * tok->tabsize;
                altcol = (altcol/tok->alttabsize + 1)
                    * tok->alttabsize;
            }
            else if (c == '\014')  {/* Control-L (formfeed) */
                col = altcol = 0; /* For Emacs users */
            }
            else {
                break;
            }
        }
        tok_backup(tok, c);
        if (c == '#' || c == '\n') {
            /* Lines with only whitespace and/or comments
               shouldn't affect the indentation and are
               not passed to the parser as NEWLINE tokens,
               except *totally* empty lines in interactive
               mode, which signal the end of a command group. */
            if (col == 0 && c == '\n' && tok->prompt != NULL) {
                blankline = 0; /* Let it through */
            }
            else {
                blankline = 1; /* Ignore completely */
            }
            /* We can't jump back right here since we still
               may need to skip to the end of a comment */
        }
        if (!blankline && tok->level == 0) {
            if (col == tok->indstack[tok->indent]) {
                /* No change */
                if (altcol != tok->altindstack[tok->indent]) {
                    if (indenterror(tok)) {
                        return ERRORTOKEN;
                    }
                }
            }
            else if (col > tok->indstack[tok->indent]) {
                /* Indent -- always one */
                if (tok->indent+1 >= MAXINDENT) {
                    tok->done = E_TOODEEP;
                    tok->cur = tok->inp;
                    return ERRORTOKEN;
                }
                if (altcol <= tok->altindstack[tok->indent]) {
                    if (indenterror(tok)) {
                        return ERRORTOKEN;
                    }
                }
                tok->pendin++;
                tok->indstack[++tok->indent] = col;
                tok->altindstack[tok->indent] = altcol;
            }
            else /* col < tok->indstack[tok->indent] */ {
                /* Dedent -- any number, must be consistent */
                while (tok->indent > 0 &&
                    col < tok->indstack[tok->indent]) {
                    tok->pendin--;
                    tok->indent--;
                }
                if (col != tok->indstack[tok->indent]) {
                    tok->done = E_DEDENT;
                    tok->cur = tok->inp;
                    return ERRORTOKEN;
                }
                if (altcol != tok->altindstack[tok->indent]) {
                    if (indenterror(tok)) {
                        return ERRORTOKEN;
                    }
                }
            }
        }
    }

    tok->start = tok->cur;

    /* Return pending indents/dedents */
    if (tok->pendin != 0) {
        if (tok->pendin < 0) {
            tok->pendin++;
            return DEDENT;
        }
        else {
            tok->pendin--;
            return INDENT;
        }
    }

    if (tok->async_def
        && !blankline
        && tok->level == 0
        /* There was a NEWLINE after ASYNC DEF,
           so we're past the signature. */
        && tok->async_def_nl
        /* Current indentation level is less than where
           the async function was defined */
        && tok->async_def_indent >= tok->indent)
    {
        tok->async_def = 0;
        tok->async_def_indent = 0;
        tok->async_def_nl = 0;
    }

 again:
    tok->start = NULL;
    /* Skip spaces */
    do {
        c = tok_nextc(tok);
    } while (c == ' ' || c == '\t' || c == '\014');

    /* Set start of current token */
    tok->start = tok->cur - 1;

    /* Skip comment, unless it's a type comment */
    if (c == '#') {
        const char *prefix, *p, *type_start;

        while (c != EOF && c != '\n')
            c = tok_nextc(tok);

        p = tok->start;
        prefix = type_comment_prefix;
        while (*prefix && p < tok->cur) {
            if (*prefix == ' ') {
                while (*p == ' ' || *p == '\t')
                    p++;
            } else if (*prefix == *p) {
                p++;
            } else {
                break;
            }

            prefix++;
        }

        /* This is a type comment if we matched all of type_comment_prefix. */
        if (!*prefix) {
            int is_type_ignore = 1;
            tok_backup(tok, c);  /* don't eat the newline or EOF */

            type_start = p;

            is_type_ignore = tok->cur >= p + 6 && memcmp(p, 'ignore', 6) == 0;
            p += 6;
            while (is_type_ignore && p < tok->cur) {
              if (*p == '#')
                  break;
              is_type_ignore = is_type_ignore && (*p == ' ' || *p == '\t');
              p++;
            }

            if (is_type_ignore) {
                /* If this type ignore is the only thing on the line, consume the newline also. */
                if (blankline) {
                    tok_nextc(tok);
                    tok->atbol = 1;
                }
                return TYPE_IGNORE;
            } else {
                *p_start = (char *) type_start;  /* after type_comment_prefix */
                *p_end = tok->cur;
                return TYPE_COMMENT;
            }
        }
    }

    /* Check for EOF and errors now */
    if (c == EOF) {
        return tok->done == E_EOF ? ENDMARKER : ERRORTOKEN;
    }

    /* Identifier (most frequent token!) */
    nonascii = 0;
    if (is_potential_identifier_start(c)) {
        /* Process b'', r'', u'', br'' and rb'' */
        int saw_b = 0, saw_r = 0, saw_u = 0, saw_f = 0;
        while (1) {
            if (!(saw_b || saw_u || saw_f) && (c == 'b' || c == 'B'))
                saw_b = 1;
            /* Since this is a backwards compatibility support literal we don't
               want to support it in arbitrary order like byte literals. */
            else if (!(saw_b || saw_u || saw_r || saw_f)
                     && (c == 'u'|| c == 'U')) {
                saw_u = 1;
            }
            /* ur'' and ru'' are not supported */
            else if (!(saw_r || saw_u) && (c == 'r' || c == 'R')) {
                saw_r = 1;
            }
            else if (!(saw_f || saw_b || saw_u) && (c == 'f' || c == 'F')) {
                saw_f = 1;
            }
            else {
                break;
            }
            c = tok_nextc(tok);
            if (c == ''' || c == '\'') {
                goto letter_quote;
            }
        }
        while (is_potential_identifier_char(c)) {
            if (c >= 128) {
                nonascii = 1;
            }
            c = tok_nextc(tok);
        }
        tok_backup(tok, c);
        if (nonascii && !verify_identifier(tok)) {
            return ERRORTOKEN;
        }
        *p_start = tok->start;
        *p_end = tok->cur;

        /* async/await parsing block. */
        if (tok->cur - tok->start == 5) {
            /* Current token length is 5. */
            if (tok->async_def) {
                /* We're inside an 'async def' function. */
                if (memcmp(tok->start, 'async', 5) == 0) {
                    return ASYNC;
                }
                if (memcmp(tok->start, 'await', 5) == 0) {
                    return AWAIT;
                }
            }
            else if (memcmp(tok->start, 'async', 5) == 0) {
                /* The current token is 'async'.
                   Look ahead one token.*/

                struct tok_state ahead_tok;
                char *ahead_tok_start = NULL, *ahead_tok_end = NULL;
                int ahead_tok_kind;

                memcpy(&ahead_tok, tok, sizeof(ahead_tok));
                ahead_tok_kind = tok_get(&ahead_tok, &ahead_tok_start,
                                         &ahead_tok_end);

                if (ahead_tok_kind == NAME
                    && ahead_tok.cur - ahead_tok.start == 3
                    && memcmp(ahead_tok.start, 'def', 3) == 0)
                {
                    /* The next token is going to be 'def', so instead of
                       returning 'async' NAME token, we return ASYNC. */
                    tok->async_def_indent = tok->indent;
                    tok->async_def = 1;
                    return ASYNC;
                }
            }
        }

        return NAME;
    }

    /* Newline */
    if (c == '\n') {
        tok->atbol = 1;
        if (blankline || tok->level > 0) {
            goto nextline;
        }
        *p_start = tok->start;
        *p_end = tok->cur - 1; /* Leave '\n' out of the string */
        tok->cont_line = 0;
        if (tok->async_def) {
            /* We're somewhere inside an 'async def' function, and
               we've encountered a NEWLINE after its signature. */
            tok->async_def_nl = 1;
        }
        return NEWLINE;
    }

    /* Period or number starting with period? */
    if (c == '.') {
        c = tok_nextc(tok);
        if (isdigit(c)) {
            goto fraction;
        } else if (c == '.') {
            c = tok_nextc(tok);
            if (c == '.') {
                *p_start = tok->start;
                *p_end = tok->cur;
                return ELLIPSIS;
            }
            else {
                tok_backup(tok, c);
            }
            tok_backup(tok, '.');
        }
        else {
            tok_backup(tok, c);
        }
        *p_start = tok->start;
        *p_end = tok->cur;
        return DOT;
    }

    /* Number */
    if (isdigit(c)) {
        if (c == '0') {
            /* Hex, octal or binary -- maybe. */
            c = tok_nextc(tok);
            if (c == 'x' || c == 'X') {
                /* Hex */
                c = tok_nextc(tok);
                do {
                    if (c == '_') {
                        c = tok_nextc(tok);
                    }
                    if (!isxdigit(c)) {
                        tok->done = E_TOKEN;
                        tok_backup(tok, c);
                        return ERRORTOKEN;
                    }
                    do {
                        c = tok_nextc(tok);
                    } while (isxdigit(c));
                } while (c == '_');
            }
            else if (c == 'o' || c == 'O') {
                /* Octal */
                c = tok_nextc(tok);
                do {
                    if (c == '_') {
                        c = tok_nextc(tok);
                    }
                    if (c < '0' || c >= '8') {
                        tok->done = E_TOKEN;
                        tok_backup(tok, c);
                        return ERRORTOKEN;
                    }
                    do {
                        c = tok_nextc(tok);
                    } while ('0' <= c && c < '8');
                } while (c == '_');
            }
            else if (c == 'b' || c == 'B') {
                /* Binary */
                c = tok_nextc(tok);
                do {
                    if (c == '_') {
                        c = tok_nextc(tok);
                    }
                    if (c != '0' && c != '1') {
                        tok->done = E_TOKEN;
                        tok_backup(tok, c);
                        return ERRORTOKEN;
                    }
                    do {
                        c = tok_nextc(tok);
                    } while (c == '0' || c == '1');
                } while (c == '_');
            }
            else {
                int nonzero = 0;
                /* maybe old-style octal; c is first char of it */
                /* in any case, allow '0' as a literal */
                while (1) {
                    if (c == '_') {
                        c = tok_nextc(tok);
                        if (!isdigit(c)) {
                            tok->done = E_TOKEN;
                            tok_backup(tok, c);
                            return ERRORTOKEN;
                        }
                    }
                    if (c != '0') {
                        break;
                    }
                    c = tok_nextc(tok);
                }
                if (isdigit(c)) {
                    nonzero = 1;
                    c = tok_decimal_tail(tok);
                    if (c == 0) {
                        return ERRORTOKEN;
                    }
                }
                if (c == '.') {
                    c = tok_nextc(tok);
                    goto fraction;
                }
                else if (c == 'e' || c == 'E') {
                    goto exponent;
                }
                else if (c == 'j' || c == 'J') {
                    goto imaginary;
                }
                else if (nonzero) {
                    /* Old-style octal: now disallowed. */
                    tok->done = E_TOKEN;
                    tok_backup(tok, c);
                    return ERRORTOKEN;
                }
            }
        }
        else {
            /* Decimal */
            c = tok_decimal_tail(tok);
            if (c == 0) {
                return ERRORTOKEN;
            }
            {
                /* Accept floating point numbers. */
                if (c == '.') {
                    c = tok_nextc(tok);
        fraction:
                    /* Fraction */
                    if (isdigit(c)) {
                        c = tok_decimal_tail(tok);
                        if (c == 0) {
                            return ERRORTOKEN;
                        }
                    }
                }
                if (c == 'e' || c == 'E') {
                    int e;
                  exponent:
                    e = c;
                    /* Exponent part */
                    c = tok_nextc(tok);
                    if (c == '+' || c == '-') {
                        c = tok_nextc(tok);
                        if (!isdigit(c)) {
                            tok->done = E_TOKEN;
                            tok_backup(tok, c);
                            return ERRORTOKEN;
                        }
                    } else if (!isdigit(c)) {
                        tok_backup(tok, c);
                        tok_backup(tok, e);
                        *p_start = tok->start;
                        *p_end = tok->cur;
                        return NUMBER;
                    }
                    c = tok_decimal_tail(tok);
                    if (c == 0) {
                        return ERRORTOKEN;
                    }
                }
                if (c == 'j' || c == 'J') {
                    /* Imaginary part */
        imaginary:
                    c = tok_nextc(tok);
                }
            }
        }
        tok_backup(tok, c);
        *p_start = tok->start;
        *p_end = tok->cur;
        return NUMBER;
    }

  letter_quote:
    /* String */
    if (c == '\'' || c == ''') {
        int quote = c;
        int quote_size = 1;             /* 1 or 3 */
        int end_quote_size = 0;

        /* Find the quote size and start of string */
        c = tok_nextc(tok);
        if (c == quote) {
            c = tok_nextc(tok);
            if (c == quote) {
                quote_size = 3;
            }
            else {
                end_quote_size = 1;     /* empty string found */
            }
        }
        if (c != quote) {
            tok_backup(tok, c);
        }

        /* Get rest of string */
        while (end_quote_size != quote_size) {
            c = tok_nextc(tok);
            if (c == EOF) {
                if (quote_size == 3) {
                    tok->done = E_EOFS;
                }
                else {
                    tok->done = E_EOLS;
                }
                tok->cur = tok->inp;
                return ERRORTOKEN;
            }
            if (quote_size == 1 && c == '\n') {
                tok->done = E_EOLS;
                tok->cur = tok->inp;
                return ERRORTOKEN;
            }
            if (c == quote) {
                end_quote_size += 1;
            }
            else {
                end_quote_size = 0;
                if (c == '\\') {
                    tok_nextc(tok);  /* skip escaped char */
                }
            }
        }

        *p_start = tok->start;
        *p_end = tok->cur;
        return STRING;
    }

    /* Line continuation */
    if (c == '\\') {
        c = tok_nextc(tok);
        if (c != '\n') {
            tok->done = E_LINECONT;
            tok->cur = tok->inp;
            return ERRORTOKEN;
        }
        tok->cont_line = 1;
        goto again; /* Read next line */
    }

    /* Check for two-character token */
    {
        int c2 = tok_nextc(tok);
        int token = Ta3Token_TwoChars(c, c2);
        if (token != OP) {
            int c3 = tok_nextc(tok);
            int token3 = Ta3Token_ThreeChars(c, c2, c3);
            if (token3 != OP) {
                token = token3;
            }
            else {
                tok_backup(tok, c3);
            }
            *p_start = tok->start;
            *p_end = tok->cur;
            return token;
        }
        tok_backup(tok, c2);
    }

    /* Keep track of parentheses nesting level */
    switch (c) {
    case '(':
    case '[':
    case '{':
        tok->level++;
        break;
    case ')':
    case ']':
    case '}':
        tok->level--;
        break;
    }

    /* Punctuation character */
    *p_start = tok->start;
    *p_end = tok->cur;
    return Ta3Token_OneChar(c);
}
",8866
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"char *
Ta3Tokenizer_FindEncodingFilename(int fd, PyObject *filename)
{
    struct tok_state *tok;
    FILE *fp;
    char *p_start =NULL , *p_end =NULL , *encoding = NULL;

#ifndef PGEN
#if PY_MINOR_VERSION >= 4
    fd = _Py_dup(fd);
#endif
#else
    fd = dup(fd);
#endif
    if (fd < 0) {
        return NULL;
    }

    fp = fdopen(fd, 'r');
    if (fp == NULL) {
        return NULL;
    }
    tok = Ta3Tokenizer_FromFile(fp, NULL, NULL, NULL);
    if (tok == NULL) {
        fclose(fp);
        return NULL;
    }
#ifndef PGEN
    if (filename != NULL) {
        Py_INCREF(filename);
        tok->filename = filename;
    }
    else {
        tok->filename = PyUnicode_FromString('<string>');
        if (tok->filename == NULL) {
            fclose(fp);
            Ta3Tokenizer_Free(tok);
            return encoding;
        }
    }
#endif
    while (tok->lineno < 2 && tok->done == E_OK) {
        Ta3Tokenizer_Get(tok, &p_start, &p_end);
    }
    fclose(fp);
    if (tok->encoding) {
        encoding = (char *)PyMem_MALLOC(strlen(tok->encoding) + 1);
        if (encoding)
        strcpy(encoding, tok->encoding);
    }
    Ta3Tokenizer_Free(tok);
    return encoding;
}
",8867
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static expr_ty
ast_for_atom(struct compiling *c, const node *n)
{
    /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [listmaker] ']'
       | '{' [dictmaker] '}' | '`' testlist '`' | NAME | NUMBER | STRING+
    */
    node *ch = CHILD(n, 0);

    switch (TYPE(ch)) {
    case NAME: {
        /* All names start in Load context, but may later be
           changed. */
        PyObject *name = NEW_IDENTIFIER(ch);
        if (!name)
            return NULL;
        return Name(name, Load, LINENO(n), n->n_col_offset, c->c_arena);
    }
    case STRING: {
        PyObject *kind, *str = parsestrplus(c, n);
        const char *raw, *s = STR(CHILD(n, 0));
        int quote = Py_CHARMASK(*s);
        /* currently Python allows up to 2 string modifiers */
        char *ch, s_kind[3] = {0, 0, 0};
        ch = s_kind;
        raw = s;
        while (*raw && *raw != '\'' && *raw != ''') {
            *ch++ = *raw++;
        }
        kind = PyUnicode_FromString(s_kind);
        if (!kind) {
            return NULL;
        }
        if (!str) {
#ifdef Py_USING_UNICODE
            if (PyErr_ExceptionMatches(PyExc_UnicodeError)){
                PyObject *type, *value, *tback, *errstr;
                PyErr_Fetch(&type, &value, &tback);
                errstr = PyObject_Str(value);
                if (errstr) {
                    char *s = '';
                    char buf[128];
                    s = _PyUnicode_AsString(errstr);
                    PyOS_snprintf(buf, sizeof(buf), '(unicode error) %s', s);
                    ast_error(n, buf);
                    Py_DECREF(errstr);
                } else {
                    ast_error(n, '(unicode error) unknown error');
                }
                Py_DECREF(type);
                Py_DECREF(value);
                Py_XDECREF(tback);
            }
#endif
            return NULL;
        }
        PyArena_AddPyObject(c->c_arena, str);
        return Str(str, kind, LINENO(n), n->n_col_offset, c->c_arena);
    }
    case NUMBER: {
        PyObject *pynum = parsenumber(c, STR(ch));
        if (!pynum)
            return NULL;

        PyArena_AddPyObject(c->c_arena, pynum);
        return Num(pynum, LINENO(n), n->n_col_offset, c->c_arena);
    }
    case LPAR: /* some parenthesized expressions */
        ch = CHILD(n, 1);

        if (TYPE(ch) == RPAR)
            return Tuple(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

        if (TYPE(ch) == yield_expr)
            return ast_for_expr(c, ch);

        return ast_for_testlist_comp(c, ch);
    case LSQB: /* list (or list comprehension) */
        ch = CHILD(n, 1);

        if (TYPE(ch) == RSQB)
            return List(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

        REQ(ch, listmaker);
        if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {
            asdl_seq *elts = seq_for_testlist(c, ch);
            if (!elts)
                return NULL;

            return List(elts, Load, LINENO(n), n->n_col_offset, c->c_arena);
        }
        else
            return ast_for_listcomp(c, ch);
    case LBRACE: {
        /* dictorsetmaker:
         *    (test ':' test (comp_for | (',' test ':' test)* [','])) |
         *    (test (comp_for | (',' test)* [',']))
         */
        int i, size;
        asdl_seq *keys, *values;

        ch = CHILD(n, 1);
        if (TYPE(ch) == RBRACE) {
            /* it's an empty dict */
            return Dict(NULL, NULL, LINENO(n), n->n_col_offset, c->c_arena);
        } else if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {
            /* it's a simple set */
            asdl_seq *elts;
            size = (NCH(ch) + 1) / 2; /* +1 in case no trailing comma */
            elts = asdl_seq_new(size, c->c_arena);
            if (!elts)
                return NULL;
            for (i = 0; i < NCH(ch); i += 2) {
                expr_ty expression;
                expression = ast_for_expr(c, CHILD(ch, i));
                if (!expression)
                    return NULL;
                asdl_seq_SET(elts, i / 2, expression);
            }
            return Set(elts, LINENO(n), n->n_col_offset, c->c_arena);
        } else if (TYPE(CHILD(ch, 1)) == comp_for) {
            /* it's a set comprehension */
            return ast_for_setcomp(c, ch);
        } else if (NCH(ch) > 3 && TYPE(CHILD(ch, 3)) == comp_for) {
            return ast_for_dictcomp(c, ch);
        } else {
            /* it's a dict */
            size = (NCH(ch) + 1) / 4; /* +1 in case no trailing comma */
            keys = asdl_seq_new(size, c->c_arena);
            if (!keys)
                return NULL;

            values = asdl_seq_new(size, c->c_arena);
            if (!values)
                return NULL;

            for (i = 0; i < NCH(ch); i += 4) {
                expr_ty expression;

                expression = ast_for_expr(c, CHILD(ch, i));
                if (!expression)
                    return NULL;

                asdl_seq_SET(keys, i / 4, expression);

                expression = ast_for_expr(c, CHILD(ch, i + 2));
                if (!expression)
                    return NULL;

                asdl_seq_SET(values, i / 4, expression);
            }
            return Dict(keys, values, LINENO(n), n->n_col_offset, c->c_arena);
        }
    }
    case BACKQUOTE: { /* repr */
        expr_ty expression;
        if (Py_Py3kWarningFlag &&
            !ast_warn(c, n, 'backquote not supported in 3.x; use repr()'))
            return NULL;
        expression = ast_for_testlist(c, CHILD(n, 1));
        if (!expression)
            return NULL;

        return Repr(expression, LINENO(n), n->n_col_offset, c->c_arena);
    }
    default:
        PyErr_Format(PyExc_SystemError, 'unhandled atom %d', TYPE(ch));
        return NULL;
    }
}
",8868
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static expr_ty
ast_for_call(struct compiling *c, const node *n, expr_ty func)
{
    /*
      arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
               | '**' test)
      argument: [test '='] test [comp_for]        # Really [keyword '='] test
    */

    int i, nargs, nkeywords, ngens;
    asdl_seq *args;
    asdl_seq *keywords;
    expr_ty vararg = NULL, kwarg = NULL;

    REQ(n, arglist);

    nargs = 0;
    nkeywords = 0;
    ngens = 0;
    for (i = 0; i < NCH(n); i++) {
        node *ch = CHILD(n, i);
        if (TYPE(ch) == argument) {
            if (NCH(ch) == 1)
                nargs++;
            else if (TYPE(CHILD(ch, 1)) == comp_for)
                ngens++;
            else
                nkeywords++;
        }
    }
    if (ngens > 1 || (ngens && (nargs || nkeywords))) {
        ast_error(n, 'Generator expression must be parenthesized '
                  'if not sole argument');
        return NULL;
    }

    if (nargs + nkeywords + ngens > 255) {
      ast_error(n, 'more than 255 arguments');
      return NULL;
    }

    args = asdl_seq_new(nargs + ngens, c->c_arena);
    if (!args)
        return NULL;
    keywords = asdl_seq_new(nkeywords, c->c_arena);
    if (!keywords)
        return NULL;
    nargs = 0;
    nkeywords = 0;
    for (i = 0; i < NCH(n); i++) {
        node *ch = CHILD(n, i);
        if (TYPE(ch) == argument) {
            expr_ty e;
            if (NCH(ch) == 1) {
                if (nkeywords) {
                    ast_error(CHILD(ch, 0),
                              'non-keyword arg after keyword arg');
                    return NULL;
                }
                if (vararg) {
                    ast_error(CHILD(ch, 0),
                              'only named arguments may follow *expression');
                    return NULL;
                }
                e = ast_for_expr(c, CHILD(ch, 0));
                if (!e)
                    return NULL;
                asdl_seq_SET(args, nargs++, e);
            }
            else if (TYPE(CHILD(ch, 1)) == comp_for) {
                e = ast_for_genexp(c, ch);
                if (!e)
                    return NULL;
                asdl_seq_SET(args, nargs++, e);
            }
            else {
                keyword_ty kw;
                identifier key;
                int k;
                char *tmp;

                /* CHILD(ch, 0) is test, but must be an identifier? */
                e = ast_for_expr(c, CHILD(ch, 0));
                if (!e)
                    return NULL;
                /* f(lambda x: x[0] = 3) ends up getting parsed with
                 * LHS test = lambda x: x[0], and RHS test = 3.
                 * SF bug 132313 points out that complaining about a keyword
                 * then is very confusing.
                 */
                if (e->kind == Lambda_kind) {
                    ast_error(CHILD(ch, 0),
                              'lambda cannot contain assignment');
                    return NULL;
                } else if (e->kind != Name_kind) {
                    ast_error(CHILD(ch, 0), 'keyword can't be an expression');
                    return NULL;
                }
                key = e->v.Name.id;
                if (!forbidden_check(c, CHILD(ch, 0), PyUnicode_AsUTF8(key)))
                    return NULL;
                for (k = 0; k < nkeywords; k++) {
                    tmp = _PyUnicode_AsString(
                        ((keyword_ty)asdl_seq_GET(keywords, k))->arg);
                    if (!strcmp(tmp, _PyUnicode_AsString(key))) {
                        ast_error(CHILD(ch, 0), 'keyword argument repeated');
                        return NULL;
                    }
                }
                e = ast_for_expr(c, CHILD(ch, 2));
                if (!e)
                    return NULL;
                kw = keyword(key, e, c->c_arena);
                if (!kw)
                    return NULL;
                asdl_seq_SET(keywords, nkeywords++, kw);
            }
        }
        else if (TYPE(ch) == STAR) {
            vararg = ast_for_expr(c, CHILD(n, i+1));
            if (!vararg)
                return NULL;
            i++;
        }
        else if (TYPE(ch) == DOUBLESTAR) {
            kwarg = ast_for_expr(c, CHILD(n, i+1));
            if (!kwarg)
                return NULL;
            i++;
        }
    }

    return Call(func, args, keywords, vararg, kwarg, func->lineno,
                func->col_offset, c->c_arena);
}
",8869
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static void
ast_dealloc(AST_object *self)
{
    Py_CLEAR(self->dict);
    Py_TYPE(self)->tp_free(self);
}
",8870
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static void
ast_clear(AST_object *self)
{
    Py_CLEAR(self->dict);
}
",8871
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
ast_type_init(PyObject *self, PyObject *args, PyObject *kw)
{
    _Py_IDENTIFIER(_fields);
    Py_ssize_t i, numfields = 0;
    int res = -1;
    PyObject *key, *value, *fields;
    fields = _PyObject_GetAttrId((PyObject*)Py_TYPE(self), &PyId__fields);
    if (!fields)
        PyErr_Clear();
    if (fields) {
        numfields = PySequence_Size(fields);
        if (numfields == -1)
            goto cleanup;
    }
    res = 0; /* if no error occurs, this stays 0 to the end */
    if (PyTuple_GET_SIZE(args) > 0) {
        if (numfields != PyTuple_GET_SIZE(args)) {
            PyErr_Format(PyExc_TypeError, '%.400s constructor takes %s'
                         '%zd positional argument%s',
                         Py_TYPE(self)->tp_name,
                         numfields == 0 ? '' : 'either 0 or ',
                         numfields, numfields == 1 ? '' : 's');
            res = -1;
            goto cleanup;
        }
        for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
            /* cannot be reached when fields is NULL */
            PyObject *name = PySequence_GetItem(fields, i);
            if (!name) {
                res = -1;
                goto cleanup;
            }
            res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));
            Py_DECREF(name);
            if (res < 0)
                goto cleanup;
        }
    }
    if (kw) {
        i = 0;  /* needed by PyDict_Next */
        while (PyDict_Next(kw, &i, &key, &value)) {
            res = PyObject_SetAttr(self, key, value);
            if (res < 0)
                goto cleanup;
        }
    }
  cleanup:
    Py_XDECREF(fields);
    return res;
}
",8872
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static PyObject *
ast_type_reduce(PyObject *self, PyObject *unused)
{
    PyObject *res;
    _Py_IDENTIFIER(__dict__);
    PyObject *dict = _PyObject_GetAttrId(self, &PyId___dict__);
    if (dict == NULL) {
        if (PyErr_ExceptionMatches(PyExc_AttributeError))
            PyErr_Clear();
        else
            return NULL;
    }
    if (dict) {
        res = Py_BuildValue('O()O', Py_TYPE(self), dict);
        Py_DECREF(dict);
        return res;
    }
    return Py_BuildValue('O()', Py_TYPE(self));
}
",8873
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static PyTypeObject* make_type(char *type, PyTypeObject* base, char**fields, int num_fields)
{
    PyObject *fnames, *result;
    int i;
    fnames = PyTuple_New(num_fields);
    if (!fnames) return NULL;
    for (i = 0; i < num_fields; i++) {
        PyObject *field = PyUnicode_FromString(fields[i]);
        if (!field) {
            Py_DECREF(fnames);
            return NULL;
        }
        PyTuple_SET_ITEM(fnames, i, field);
    }
    result = PyObject_CallFunction((PyObject*)&PyType_Type, 's(O){sOss}',
                    type, base, '_fields', fnames, '__module__', '_ast3');
    Py_DECREF(fnames);
    return (PyTypeObject*)result;
}
",8874
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int add_attributes(PyTypeObject* type, char**attrs, int num_fields)
{
    int i, result;
    _Py_IDENTIFIER(_attributes);
    PyObject *s, *l = PyTuple_New(num_fields);
    if (!l)
        return 0;
    for (i = 0; i < num_fields; i++) {
        s = PyUnicode_FromString(attrs[i]);
        if (!s) {
            Py_DECREF(l);
            return 0;
        }
        PyTuple_SET_ITEM(l, i, s);
    }
    result = _PyObject_SetAttrId((PyObject*)type, &PyId__attributes, l) >= 0;
    Py_DECREF(l);
    return result;
}
",8875
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int add_ast_fields(void)
{
    PyObject *empty_tuple, *d;
    if (PyType_Ready(&AST_type) < 0)
        return -1;
    d = AST_type.tp_dict;
    empty_tuple = PyTuple_New(0);
    if (!empty_tuple ||
        PyDict_SetItemString(d, '_fields', empty_tuple) < 0 ||
        PyDict_SetItemString(d, '_attributes', empty_tuple) < 0) {
        Py_XDECREF(empty_tuple);
        return -1;
    }
    Py_DECREF(empty_tuple);
    return 0;
}
",8876
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_mod(void* _o)
{
    mod_ty o = (mod_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case Module_kind:
        result = PyType_GenericNew(Module_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Module.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Module.type_ignores, ast2obj_type_ignore);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_ignores, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Interactive_kind:
        result = PyType_GenericNew(Interactive_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Interactive.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Expression_kind:
        result = PyType_GenericNew(Expression_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Expression.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case FunctionType_kind:
        result = PyType_GenericNew(FunctionType_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.FunctionType.argtypes, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_argtypes, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FunctionType.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Suite_kind:
        result = PyType_GenericNew(Suite_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Suite.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8877
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_stmt(void* _o)
{
    stmt_ty o = (stmt_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case FunctionDef_kind:
        result = PyType_GenericNew(FunctionDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.FunctionDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_arguments(o->v.FunctionDef.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.FunctionDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.FunctionDef.decorator_list, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FunctionDef.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.FunctionDef.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncFunctionDef_kind:
        result = PyType_GenericNew(AsyncFunctionDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.AsyncFunctionDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_arguments(o->v.AsyncFunctionDef.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFunctionDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFunctionDef.decorator_list,
                             ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AsyncFunctionDef.returns);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncFunctionDef.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ClassDef_kind:
        result = PyType_GenericNew(ClassDef_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.ClassDef.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.bases, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_bases, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.keywords, ast2obj_keyword);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keywords, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ClassDef.decorator_list, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Return_kind:
        result = PyType_GenericNew(Return_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Return.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Delete_kind:
        result = PyType_GenericNew(Delete_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Delete.targets, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_targets, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assign_kind:
        result = PyType_GenericNew(Assign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Assign.targets, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_targets, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Assign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.Assign.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AugAssign_kind:
        result = PyType_GenericNew(AugAssign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AugAssign.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_operator(o->v.AugAssign.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AugAssign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AnnAssign_kind:
        result = PyType_GenericNew(AnnAssign_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AnnAssign.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AnnAssign.annotation);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_annotation, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AnnAssign.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.AnnAssign.simple);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_simple, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case For_kind:
        result = PyType_GenericNew(For_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.For.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.For.iter);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.For.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.For.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.For.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncFor_kind:
        result = PyType_GenericNew(AsyncFor_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.AsyncFor.target);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.AsyncFor.iter);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFor.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncFor.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncFor.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case While_kind:
        result = PyType_GenericNew(While_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.While.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.While.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.While.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case If_kind:
        result = PyType_GenericNew(If_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.If.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.If.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.If.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case With_kind:
        result = PyType_GenericNew(With_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.With.items, ast2obj_withitem);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_items, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.With.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.With.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncWith_kind:
        result = PyType_GenericNew(AsyncWith_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.AsyncWith.items, ast2obj_withitem);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_items, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.AsyncWith.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.AsyncWith.type_comment);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Raise_kind:
        result = PyType_GenericNew(Raise_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Raise.exc);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_exc, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Raise.cause);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_cause, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Try_kind:
        result = PyType_GenericNew(Try_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Try.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.handlers, ast2obj_excepthandler);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_handlers, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Try.finalbody, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_finalbody, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assert_kind:
        result = PyType_GenericNew(Assert_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Assert.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Assert.msg);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_msg, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Import_kind:
        result = PyType_GenericNew(Import_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Import.names, ast2obj_alias);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ImportFrom_kind:
        result = PyType_GenericNew(ImportFrom_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.ImportFrom.module);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_module, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ImportFrom.names, ast2obj_alias);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.ImportFrom.level);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_level, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Global_kind:
        result = PyType_GenericNew(Global_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Global.names, ast2obj_identifier);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Nonlocal_kind:
        result = PyType_GenericNew(Nonlocal_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Nonlocal.names, ast2obj_identifier);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Expr_kind:
        result = PyType_GenericNew(Expr_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Expr.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Pass_kind:
        result = PyType_GenericNew(Pass_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Break_kind:
        result = PyType_GenericNew(Break_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Continue_kind:
        result = PyType_GenericNew(Continue_type, NULL, NULL);
        if (!result) goto failed;
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8878
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_expr(void* _o)
{
    expr_ty o = (expr_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case BoolOp_kind:
        result = PyType_GenericNew(BoolOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_boolop(o->v.BoolOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.BoolOp.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case BinOp_kind:
        result = PyType_GenericNew(BinOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.BinOp.left);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_left, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_operator(o->v.BinOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.BinOp.right);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_right, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case UnaryOp_kind:
        result = PyType_GenericNew(UnaryOp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_unaryop(o->v.UnaryOp.op);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.UnaryOp.operand);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_operand, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Lambda_kind:
        result = PyType_GenericNew(Lambda_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_arguments(o->v.Lambda.args);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Lambda.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case IfExp_kind:
        result = PyType_GenericNew(IfExp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.IfExp.test);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.IfExp.body);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.IfExp.orelse);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Dict_kind:
        result = PyType_GenericNew(Dict_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Dict.keys, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keys, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Dict.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Set_kind:
        result = PyType_GenericNew(Set_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Set.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ListComp_kind:
        result = PyType_GenericNew(ListComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.ListComp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ListComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case SetComp_kind:
        result = PyType_GenericNew(SetComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.SetComp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.SetComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case DictComp_kind:
        result = PyType_GenericNew(DictComp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.DictComp.key);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_key, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.DictComp.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.DictComp.generators, ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case GeneratorExp_kind:
        result = PyType_GenericNew(GeneratorExp_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.GeneratorExp.elt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.GeneratorExp.generators,
                             ast2obj_comprehension);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Await_kind:
        result = PyType_GenericNew(Await_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Await.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Yield_kind:
        result = PyType_GenericNew(Yield_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Yield.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case YieldFrom_kind:
        result = PyType_GenericNew(YieldFrom_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.YieldFrom.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Compare_kind:
        result = PyType_GenericNew(Compare_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Compare.left);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_left, value) == -1)
            goto failed;
        Py_DECREF(value);
        {
            Py_ssize_t i, n = asdl_seq_LEN(o->v.Compare.ops);
            value = PyList_New(n);
            if (!value) goto failed;
            for(i = 0; i < n; i++)
                PyList_SET_ITEM(value, i, ast2obj_cmpop((cmpop_ty)asdl_seq_GET(o->v.Compare.ops, i)));
        }
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ops, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Compare.comparators, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_comparators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Call_kind:
        result = PyType_GenericNew(Call_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Call.func);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_func, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Call.args, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.Call.keywords, ast2obj_keyword);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_keywords, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Num_kind:
        result = PyType_GenericNew(Num_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_object(o->v.Num.n);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_n, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Str_kind:
        result = PyType_GenericNew(Str_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_string(o->v.Str.s);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_s, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(o->v.Str.kind);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_kind, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case FormattedValue_kind:
        result = PyType_GenericNew(FormattedValue_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.FormattedValue.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->v.FormattedValue.conversion);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_conversion, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.FormattedValue.format_spec);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_format_spec, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case JoinedStr_kind:
        result = PyType_GenericNew(JoinedStr_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.JoinedStr.values, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Bytes_kind:
        result = PyType_GenericNew(Bytes_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_bytes(o->v.Bytes.s);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_s, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case NameConstant_kind:
        result = PyType_GenericNew(NameConstant_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_singleton(o->v.NameConstant.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Ellipsis_kind:
        result = PyType_GenericNew(Ellipsis_type, NULL, NULL);
        if (!result) goto failed;
        break;
    case Constant_kind:
        result = PyType_GenericNew(Constant_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_constant(o->v.Constant.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Attribute_kind:
        result = PyType_GenericNew(Attribute_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Attribute.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->v.Attribute.attr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_attr, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Attribute.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Subscript_kind:
        result = PyType_GenericNew(Subscript_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Subscript.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_slice(o->v.Subscript.slice);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_slice, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Subscript.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Starred_kind:
        result = PyType_GenericNew(Starred_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Starred.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Starred.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Name_kind:
        result = PyType_GenericNew(Name_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.Name.id);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_id, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Name.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case List_kind:
        result = PyType_GenericNew(List_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.List.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.List.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Tuple_kind:
        result = PyType_GenericNew(Tuple_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.Tuple.elts, ast2obj_expr);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(o->v.Tuple.ctx);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8879
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_slice(void* _o)
{
    slice_ty o = (slice_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case Slice_kind:
        result = PyType_GenericNew(Slice_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Slice.lower);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_lower, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Slice.upper);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_upper, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->v.Slice.step);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_step, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ExtSlice_kind:
        result = PyType_GenericNew(ExtSlice_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(o->v.ExtSlice.dims, ast2obj_slice);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_dims, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Index_kind:
        result = PyType_GenericNew(Index_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.Index.value);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8880
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_comprehension(void* _o)
{
    comprehension_ty o = (comprehension_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(comprehension_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_expr(o->target);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->iter);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->ifs, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_ifs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->is_async);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_is_async, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8881
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_excepthandler(void* _o)
{
    excepthandler_ty o = (excepthandler_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case ExceptHandler_kind:
        result = PyType_GenericNew(ExceptHandler_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(o->v.ExceptHandler.type);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_type, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->v.ExceptHandler.name);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->v.ExceptHandler.body, ast2obj_stmt);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8882
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_arguments(void* _o)
{
    arguments_ty o = (arguments_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(arguments_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_list(o->args, ast2obj_arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_arg(o->vararg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_vararg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->kwonlyargs, ast2obj_arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kwonlyargs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->kw_defaults, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kw_defaults, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_arg(o->kwarg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_kwarg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(o->defaults, ast2obj_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_defaults, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8883
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_arg(void* _o)
{
    arg_ty o = (arg_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(arg_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->annotation);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_annotation, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_string(o->type_comment);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_type_comment, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->lineno);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(o->col_offset);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8884
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_keyword(void* _o)
{
    keyword_ty o = (keyword_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(keyword_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->arg);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->value);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8885
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_alias(void* _o)
{
    alias_ty o = (alias_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(alias_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(o->name);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_identifier(o->asname);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_asname, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8886
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_withitem(void* _o)
{
    withitem_ty o = (withitem_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    result = PyType_GenericNew(withitem_type, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_expr(o->context_expr);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_context_expr, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(o->optional_vars);
    if (!value) goto failed;
    if (_PyObject_SetAttrId(result, &PyId_optional_vars, value) == -1)
        goto failed;
    Py_DECREF(value);
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8887
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyObject*
ast2obj_type_ignore(void* _o)
{
    type_ignore_ty o = (type_ignore_ty)_o;
    PyObject *result = NULL, *value = NULL;
    if (!o) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    switch (o->kind) {
    case TypeIgnore_kind:
        result = PyType_GenericNew(TypeIgnore_type, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_int(o->v.TypeIgnore.lineno);
        if (!value) goto failed;
        if (_PyObject_SetAttrId(result, &PyId_lineno, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}
",8888
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_mod(PyObject* obj, mod_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Module_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;
        asdl_seq* type_ignores;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Module field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Module field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Module');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_type_ignores)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_type_ignores);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Module field \'type_ignores\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            type_ignores = _Ta3_asdl_seq_new(len, arena);
            if (type_ignores == NULL) goto failed;
            for (i = 0; i < len; i++) {
                type_ignore_ty value;
                res = obj2ast_type_ignore(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Module field \'type_ignores\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(type_ignores, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'type_ignores\' missing from Module');
            return 1;
        }
        *out = Module(body, type_ignores, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Interactive_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Interactive field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Interactive field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Interactive');
            return 1;
        }
        *out = Interactive(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Expression_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Expression');
            return 1;
        }
        *out = Expression(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)FunctionType_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* argtypes;
        expr_ty returns;

        if (_PyObject_HasAttrId(obj, &PyId_argtypes)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_argtypes);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'FunctionType field \'argtypes\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            argtypes = _Ta3_asdl_seq_new(len, arena);
            if (argtypes == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'FunctionType field \'argtypes\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(argtypes, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'argtypes\' missing from FunctionType');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_returns)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_returns);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &returns, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'returns\' missing from FunctionType');
            return 1;
        }
        *out = FunctionType(argtypes, returns, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Suite_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* body;

        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Suite field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Suite field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Suite');
            return 1;
        }
        *out = Suite(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of mod, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8889
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_expr(PyObject* obj, expr_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    int lineno;
    int col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from expr');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from expr');
        return 1;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)BoolOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        boolop_ty op;
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_boolop(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from BoolOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'BoolOp field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'BoolOp field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from BoolOp');
            return 1;
        }
        *out = BoolOp(op, values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)BinOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty left;
        operator_ty op;
        expr_ty right;

        if (_PyObject_HasAttrId(obj, &PyId_left)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_left);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &left, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'left\' missing from BinOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_operator(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from BinOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_right)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_right);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &right, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'right\' missing from BinOp');
            return 1;
        }
        *out = BinOp(left, op, right, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)UnaryOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        unaryop_ty op;
        expr_ty operand;

        if (_PyObject_HasAttrId(obj, &PyId_op)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_op);
            if (tmp == NULL) goto failed;
            res = obj2ast_unaryop(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'op\' missing from UnaryOp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_operand)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_operand);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &operand, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'operand\' missing from UnaryOp');
            return 1;
        }
        *out = UnaryOp(op, operand, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Lambda_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        arguments_ty args;
        expr_ty body;

        if (_PyObject_HasAttrId(obj, &PyId_args)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_args);
            if (tmp == NULL) goto failed;
            res = obj2ast_arguments(tmp, &args, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from Lambda');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from Lambda');
            return 1;
        }
        *out = Lambda(args, body, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)IfExp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty test;
        expr_ty body;
        expr_ty orelse;

        if (_PyObject_HasAttrId(obj, &PyId_test)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_test);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &test, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'test\' missing from IfExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &body, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from IfExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_orelse)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_orelse);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &orelse, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'orelse\' missing from IfExp');
            return 1;
        }
        *out = IfExp(test, body, orelse, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Dict_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* keys;
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_keys)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_keys);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Dict field \'keys\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keys = _Ta3_asdl_seq_new(len, arena);
            if (keys == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Dict field \'keys\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(keys, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'keys\' missing from Dict');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Dict field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Dict field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from Dict');
            return 1;
        }
        *out = Dict(keys, values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Set_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Set field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Set field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from Set');
            return 1;
        }
        *out = Set(elts, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ListComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from ListComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ListComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ListComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from ListComp');
            return 1;
        }
        *out = ListComp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)SetComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from SetComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'SetComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'SetComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from SetComp');
            return 1;
        }
        *out = SetComp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)DictComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty key;
        expr_ty value;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_key)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_key);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &key, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'key\' missing from DictComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from DictComp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'DictComp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'DictComp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from DictComp');
            return 1;
        }
        *out = DictComp(key, value, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)GeneratorExp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty elt;
        asdl_seq* generators;

        if (_PyObject_HasAttrId(obj, &PyId_elt)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_elt);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &elt, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elt\' missing from GeneratorExp');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_generators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_generators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'GeneratorExp field \'generators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Ta3_asdl_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'GeneratorExp field \'generators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(generators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'generators\' missing from GeneratorExp');
            return 1;
        }
        *out = GeneratorExp(elt, generators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Await_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Await');
            return 1;
        }
        *out = Await(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Yield_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (exists_not_none(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            value = NULL;
        }
        *out = Yield(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)YieldFrom_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from YieldFrom');
            return 1;
        }
        *out = YieldFrom(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Compare_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty left;
        asdl_int_seq* ops;
        asdl_seq* comparators;

        if (_PyObject_HasAttrId(obj, &PyId_left)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_left);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &left, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'left\' missing from Compare');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ops)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_ops);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Compare field \'ops\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            ops = _Ta3_asdl_int_seq_new(len, arena);
            if (ops == NULL) goto failed;
            for (i = 0; i < len; i++) {
                cmpop_ty value;
                res = obj2ast_cmpop(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Compare field \'ops\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(ops, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ops\' missing from Compare');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_comparators)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_comparators);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Compare field \'comparators\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            comparators = _Ta3_asdl_seq_new(len, arena);
            if (comparators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Compare field \'comparators\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(comparators, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'comparators\' missing from Compare');
            return 1;
        }
        *out = Compare(left, ops, comparators, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Call_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty func;
        asdl_seq* args;
        asdl_seq* keywords;

        if (_PyObject_HasAttrId(obj, &PyId_func)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_func);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &func, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'func\' missing from Call');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_args)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_args);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Call field \'args\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            args = _Ta3_asdl_seq_new(len, arena);
            if (args == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Call field \'args\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(args, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from Call');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_keywords)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_keywords);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Call field \'keywords\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keywords = _Ta3_asdl_seq_new(len, arena);
            if (keywords == NULL) goto failed;
            for (i = 0; i < len; i++) {
                keyword_ty value;
                res = obj2ast_keyword(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Call field \'keywords\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(keywords, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'keywords\' missing from Call');
            return 1;
        }
        *out = Call(func, args, keywords, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Num_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        object n;

        if (_PyObject_HasAttrId(obj, &PyId_n)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_n);
            if (tmp == NULL) goto failed;
            res = obj2ast_object(tmp, &n, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'n\' missing from Num');
            return 1;
        }
        *out = Num(n, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Str_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        string s;
        string kind;

        if (_PyObject_HasAttrId(obj, &PyId_s)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_s);
            if (tmp == NULL) goto failed;
            res = obj2ast_string(tmp, &s, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'s\' missing from Str');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_kind)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_kind);
            if (tmp == NULL) goto failed;
            res = obj2ast_string(tmp, &kind, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'kind\' missing from Str');
            return 1;
        }
        *out = Str(s, kind, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)FormattedValue_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        int conversion;
        expr_ty format_spec;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from FormattedValue');
            return 1;
        }
        if (exists_not_none(obj, &PyId_conversion)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_conversion);
            if (tmp == NULL) goto failed;
            res = obj2ast_int(tmp, &conversion, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            conversion = 0;
        }
        if (exists_not_none(obj, &PyId_format_spec)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_format_spec);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &format_spec, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            format_spec = NULL;
        }
        *out = FormattedValue(value, conversion, format_spec, lineno,
                              col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)JoinedStr_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* values;

        if (_PyObject_HasAttrId(obj, &PyId_values)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_values);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'JoinedStr field \'values\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Ta3_asdl_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'JoinedStr field \'values\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(values, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'values\' missing from JoinedStr');
            return 1;
        }
        *out = JoinedStr(values, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Bytes_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        bytes s;

        if (_PyObject_HasAttrId(obj, &PyId_s)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_s);
            if (tmp == NULL) goto failed;
            res = obj2ast_bytes(tmp, &s, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'s\' missing from Bytes');
            return 1;
        }
        *out = Bytes(s, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)NameConstant_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        singleton value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_singleton(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from NameConstant');
            return 1;
        }
        *out = NameConstant(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Ellipsis_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {

        *out = Ellipsis(lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Constant_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        constant value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_constant(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Constant');
            return 1;
        }
        *out = Constant(value, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Attribute_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        identifier attr;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Attribute');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_attr)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_attr);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &attr, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'attr\' missing from Attribute');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Attribute');
            return 1;
        }
        *out = Attribute(value, attr, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Subscript_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        slice_ty slice;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Subscript');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_slice)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_slice);
            if (tmp == NULL) goto failed;
            res = obj2ast_slice(tmp, &slice, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'slice\' missing from Subscript');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Subscript');
            return 1;
        }
        *out = Subscript(value, slice, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Starred_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Starred');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Starred');
            return 1;
        }
        *out = Starred(value, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Name_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        identifier id;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_id)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_id);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &id, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'id\' missing from Name');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Name');
            return 1;
        }
        *out = Name(id, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)List_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'List field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'List field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from List');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from List');
            return 1;
        }
        *out = List(elts, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Tuple_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* elts;
        expr_context_ty ctx;

        if (_PyObject_HasAttrId(obj, &PyId_elts)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_elts);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'Tuple field \'elts\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Ta3_asdl_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'Tuple field \'elts\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(elts, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'elts\' missing from Tuple');
            return 1;
        }
        if (_PyObject_HasAttrId(obj, &PyId_ctx)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_ctx);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr_context(tmp, &ctx, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'ctx\' missing from Tuple');
            return 1;
        }
        *out = Tuple(elts, ctx, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of expr, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8891
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_slice(PyObject* obj, slice_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Slice_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty lower;
        expr_ty upper;
        expr_ty step;

        if (exists_not_none(obj, &PyId_lower)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_lower);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &lower, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            lower = NULL;
        }
        if (exists_not_none(obj, &PyId_upper)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_upper);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &upper, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            upper = NULL;
        }
        if (exists_not_none(obj, &PyId_step)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_step);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &step, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            step = NULL;
        }
        *out = Slice(lower, upper, step, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ExtSlice_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        asdl_seq* dims;

        if (_PyObject_HasAttrId(obj, &PyId_dims)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_dims);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ExtSlice field \'dims\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            dims = _Ta3_asdl_seq_new(len, arena);
            if (dims == NULL) goto failed;
            for (i = 0; i < len; i++) {
                slice_ty value;
                res = obj2ast_slice(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ExtSlice field \'dims\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(dims, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'dims\' missing from ExtSlice');
            return 1;
        }
        *out = ExtSlice(dims, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)Index_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty value;

        if (_PyObject_HasAttrId(obj, &PyId_value)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_value);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &value, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from Index');
            return 1;
        }
        *out = Index(value, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of slice, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8892
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_comprehension(PyObject* obj, comprehension_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    expr_ty target;
    expr_ty iter;
    asdl_seq* ifs;
    int is_async;

    if (_PyObject_HasAttrId(obj, &PyId_target)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_target);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &target, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'target\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_iter)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_iter);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &iter, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'iter\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_ifs)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_ifs);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'comprehension field \'ifs\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        ifs = _Ta3_asdl_seq_new(len, arena);
        if (ifs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'comprehension field \'ifs\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(ifs, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'ifs\' missing from comprehension');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_is_async)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_is_async);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &is_async, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'is_async\' missing from comprehension');
        return 1;
    }
    *out = comprehension(target, iter, ifs, is_async, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8893
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_excepthandler(PyObject* obj, excepthandler_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    int lineno;
    int col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from excepthandler');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from excepthandler');
        return 1;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)ExceptHandler_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        expr_ty type;
        identifier name;
        asdl_seq* body;

        if (exists_not_none(obj, &PyId_type)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_type);
            if (tmp == NULL) goto failed;
            res = obj2ast_expr(tmp, &type, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            type = NULL;
        }
        if (exists_not_none(obj, &PyId_name)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_name);
            if (tmp == NULL) goto failed;
            res = obj2ast_identifier(tmp, &name, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            name = NULL;
        }
        if (_PyObject_HasAttrId(obj, &PyId_body)) {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            tmp = _PyObject_GetAttrId(obj, &PyId_body);
            if (tmp == NULL) goto failed;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, 'ExceptHandler field \'body\' must be a list, not a %.200s', tmp->ob_type->tp_name);
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Ta3_asdl_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), &value, arena);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, 'ExceptHandler field \'body\' changed size during iteration');
                    goto failed;
                }
                asdl_seq_SET(body, i, value);
            }
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'body\' missing from ExceptHandler');
            return 1;
        }
        *out = ExceptHandler(type, name, body, lineno, col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of excepthandler, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8894
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_arguments(PyObject* obj, arguments_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    asdl_seq* args;
    arg_ty vararg;
    asdl_seq* kwonlyargs;
    asdl_seq* kw_defaults;
    arg_ty kwarg;
    asdl_seq* defaults;

    if (_PyObject_HasAttrId(obj, &PyId_args)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_args);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'args\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        args = _Ta3_asdl_seq_new(len, arena);
        if (args == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty value;
            res = obj2ast_arg(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'args\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(args, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'args\' missing from arguments');
        return 1;
    }
    if (exists_not_none(obj, &PyId_vararg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_vararg);
        if (tmp == NULL) goto failed;
        res = obj2ast_arg(tmp, &vararg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        vararg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_kwonlyargs)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_kwonlyargs);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'kwonlyargs\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        kwonlyargs = _Ta3_asdl_seq_new(len, arena);
        if (kwonlyargs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty value;
            res = obj2ast_arg(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'kwonlyargs\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(kwonlyargs, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'kwonlyargs\' missing from arguments');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_kw_defaults)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_kw_defaults);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'kw_defaults\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        kw_defaults = _Ta3_asdl_seq_new(len, arena);
        if (kw_defaults == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'kw_defaults\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(kw_defaults, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'kw_defaults\' missing from arguments');
        return 1;
    }
    if (exists_not_none(obj, &PyId_kwarg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_kwarg);
        if (tmp == NULL) goto failed;
        res = obj2ast_arg(tmp, &kwarg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        kwarg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_defaults)) {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        tmp = _PyObject_GetAttrId(obj, &PyId_defaults);
        if (tmp == NULL) goto failed;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, 'arguments field \'defaults\' must be a list, not a %.200s', tmp->ob_type->tp_name);
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        defaults = _Ta3_asdl_seq_new(len, arena);
        if (defaults == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), &value, arena);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, 'arguments field \'defaults\' changed size during iteration');
                goto failed;
            }
            asdl_seq_SET(defaults, i, value);
        }
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'defaults\' missing from arguments');
        return 1;
    }
    *out = arguments(args, vararg, kwonlyargs, kw_defaults, kwarg, defaults,
                     arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8895
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_arg(PyObject* obj, arg_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier arg;
    expr_ty annotation;
    string type_comment;
    int lineno;
    int col_offset;

    if (_PyObject_HasAttrId(obj, &PyId_arg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_arg);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &arg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'arg\' missing from arg');
        return 1;
    }
    if (exists_not_none(obj, &PyId_annotation)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_annotation);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &annotation, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        annotation = NULL;
    }
    if (exists_not_none(obj, &PyId_type_comment)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_type_comment);
        if (tmp == NULL) goto failed;
        res = obj2ast_string(tmp, &type_comment, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        type_comment = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &lineno, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from arg');
        return 1;
    }
    if (_PyObject_HasAttrId(obj, &PyId_col_offset)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_col_offset);
        if (tmp == NULL) goto failed;
        res = obj2ast_int(tmp, &col_offset, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'col_offset\' missing from arg');
        return 1;
    }
    *out = arg(arg, annotation, type_comment, lineno, col_offset, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8896
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_keyword(PyObject* obj, keyword_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier arg;
    expr_ty value;

    if (exists_not_none(obj, &PyId_arg)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_arg);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &arg, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        arg = NULL;
    }
    if (_PyObject_HasAttrId(obj, &PyId_value)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_value);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &value, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'value\' missing from keyword');
        return 1;
    }
    *out = keyword(arg, value, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8897
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_alias(PyObject* obj, alias_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier name;
    identifier asname;

    if (_PyObject_HasAttrId(obj, &PyId_name)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_name);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &name, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'name\' missing from alias');
        return 1;
    }
    if (exists_not_none(obj, &PyId_asname)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_asname);
        if (tmp == NULL) goto failed;
        res = obj2ast_identifier(tmp, &asname, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        asname = NULL;
    }
    *out = alias(name, asname, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8898
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    expr_ty context_expr;
    expr_ty optional_vars;

    if (_PyObject_HasAttrId(obj, &PyId_context_expr)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_context_expr);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &context_expr, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        PyErr_SetString(PyExc_TypeError, 'required field \'context_expr\' missing from withitem');
        return 1;
    }
    if (exists_not_none(obj, &PyId_optional_vars)) {
        int res;
        tmp = _PyObject_GetAttrId(obj, &PyId_optional_vars);
        if (tmp == NULL) goto failed;
        res = obj2ast_expr(tmp, &optional_vars, arena);
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    } else {
        optional_vars = NULL;
    }
    *out = withitem(context_expr, optional_vars, arena);
    return 0;
failed:
    Py_XDECREF(tmp);
    return 1;
}
",8899
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"int
obj2ast_type_ignore(PyObject* obj, type_ignore_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject*)TypeIgnore_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        int lineno;

        if (_PyObject_HasAttrId(obj, &PyId_lineno)) {
            int res;
            tmp = _PyObject_GetAttrId(obj, &PyId_lineno);
            if (tmp == NULL) goto failed;
            res = obj2ast_int(tmp, &lineno, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        } else {
            PyErr_SetString(PyExc_TypeError, 'required field \'lineno\' missing from TypeIgnore');
            return 1;
        }
        *out = TypeIgnore(lineno, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of type_ignore, but got %R', obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}
",8900
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"PyMODINIT_FUNC
PyInit__ast3(void)
{
    PyObject *m, *d;
    if (!init_types()) return NULL;
    m = PyModule_Create(&_astmodule3);
    if (!m) return NULL;
    d = PyModule_GetDict(m);
    if (PyDict_SetItemString(d, 'AST', (PyObject*)&AST_type) < 0) return NULL;
    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'mod', (PyObject*)mod_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Module', (PyObject*)Module_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Interactive', (PyObject*)Interactive_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Expression', (PyObject*)Expression_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'FunctionType', (PyObject*)FunctionType_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Suite', (PyObject*)Suite_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'stmt', (PyObject*)stmt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'FunctionDef', (PyObject*)FunctionDef_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncFunctionDef',
        (PyObject*)AsyncFunctionDef_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'ClassDef', (PyObject*)ClassDef_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Return', (PyObject*)Return_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Delete', (PyObject*)Delete_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Assign', (PyObject*)Assign_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'AugAssign', (PyObject*)AugAssign_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'AnnAssign', (PyObject*)AnnAssign_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'For', (PyObject*)For_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncFor', (PyObject*)AsyncFor_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'While', (PyObject*)While_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'If', (PyObject*)If_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'With', (PyObject*)With_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AsyncWith', (PyObject*)AsyncWith_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Raise', (PyObject*)Raise_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Try', (PyObject*)Try_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Assert', (PyObject*)Assert_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Import', (PyObject*)Import_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'ImportFrom', (PyObject*)ImportFrom_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Global', (PyObject*)Global_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Nonlocal', (PyObject*)Nonlocal_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Expr', (PyObject*)Expr_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Pass', (PyObject*)Pass_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Break', (PyObject*)Break_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Continue', (PyObject*)Continue_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'expr', (PyObject*)expr_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'BoolOp', (PyObject*)BoolOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BinOp', (PyObject*)BinOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'UnaryOp', (PyObject*)UnaryOp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Lambda', (PyObject*)Lambda_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'IfExp', (PyObject*)IfExp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Dict', (PyObject*)Dict_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Set', (PyObject*)Set_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'ListComp', (PyObject*)ListComp_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'SetComp', (PyObject*)SetComp_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'DictComp', (PyObject*)DictComp_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'GeneratorExp', (PyObject*)GeneratorExp_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Await', (PyObject*)Await_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Yield', (PyObject*)Yield_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'YieldFrom', (PyObject*)YieldFrom_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Compare', (PyObject*)Compare_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Call', (PyObject*)Call_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Num', (PyObject*)Num_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Str', (PyObject*)Str_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'FormattedValue',
        (PyObject*)FormattedValue_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'JoinedStr', (PyObject*)JoinedStr_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Bytes', (PyObject*)Bytes_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'NameConstant', (PyObject*)NameConstant_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Ellipsis', (PyObject*)Ellipsis_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Constant', (PyObject*)Constant_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Attribute', (PyObject*)Attribute_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Subscript', (PyObject*)Subscript_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Starred', (PyObject*)Starred_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Name', (PyObject*)Name_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'List', (PyObject*)List_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Tuple', (PyObject*)Tuple_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'expr_context', (PyObject*)expr_context_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'Load', (PyObject*)Load_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Store', (PyObject*)Store_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Del', (PyObject*)Del_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'AugLoad', (PyObject*)AugLoad_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'AugStore', (PyObject*)AugStore_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Param', (PyObject*)Param_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'slice', (PyObject*)slice_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Slice', (PyObject*)Slice_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'ExtSlice', (PyObject*)ExtSlice_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Index', (PyObject*)Index_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'boolop', (PyObject*)boolop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'And', (PyObject*)And_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Or', (PyObject*)Or_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'operator', (PyObject*)operator_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'Add', (PyObject*)Add_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Sub', (PyObject*)Sub_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Mult', (PyObject*)Mult_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'MatMult', (PyObject*)MatMult_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Div', (PyObject*)Div_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Mod', (PyObject*)Mod_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Pow', (PyObject*)Pow_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'LShift', (PyObject*)LShift_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'RShift', (PyObject*)RShift_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitOr', (PyObject*)BitOr_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitXor', (PyObject*)BitXor_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'BitAnd', (PyObject*)BitAnd_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'FloorDiv', (PyObject*)FloorDiv_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'unaryop', (PyObject*)unaryop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Invert', (PyObject*)Invert_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Not', (PyObject*)Not_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'UAdd', (PyObject*)UAdd_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'USub', (PyObject*)USub_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'cmpop', (PyObject*)cmpop_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Eq', (PyObject*)Eq_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'NotEq', (PyObject*)NotEq_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'Lt', (PyObject*)Lt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'LtE', (PyObject*)LtE_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Gt', (PyObject*)Gt_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'GtE', (PyObject*)GtE_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'Is', (PyObject*)Is_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'IsNot', (PyObject*)IsNot_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'In', (PyObject*)In_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'NotIn', (PyObject*)NotIn_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'comprehension', (PyObject*)comprehension_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'excepthandler', (PyObject*)excepthandler_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'ExceptHandler', (PyObject*)ExceptHandler_type)
        < 0) return NULL;
    if (PyDict_SetItemString(d, 'arguments', (PyObject*)arguments_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'arg', (PyObject*)arg_type) < 0) return NULL;
    if (PyDict_SetItemString(d, 'keyword', (PyObject*)keyword_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'alias', (PyObject*)alias_type) < 0) return
        NULL;
    if (PyDict_SetItemString(d, 'withitem', (PyObject*)withitem_type) < 0)
        return NULL;
    if (PyDict_SetItemString(d, 'type_ignore', (PyObject*)type_ignore_type) <
        0) return NULL;
    if (PyDict_SetItemString(d, 'TypeIgnore', (PyObject*)TypeIgnore_type) < 0)
        return NULL;
    return m;
}
",8901
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"mod_ty
string_object_to_c_ast(const char *s, PyObject *filename, int start,
                             PyCompilerFlags *flags, int feature_version,
                             PyArena *arena)
{
    mod_ty mod;
    PyCompilerFlags localflags;
    perrdetail err;
    int iflags = PARSER_FLAGS(flags);

    node *n = Ta3Parser_ParseStringObject(s, filename,
                                         &_Ta3Parser_Grammar, start, &err,
                                         &iflags);
    if (flags == NULL) {
        localflags.cf_flags = 0;
        flags = &localflags;
    }
    if (n) {
        flags->cf_flags |= iflags & PyCF_MASK;
        mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);
        Ta3Node_Free(n);
    }
    else {
        err_input(&err);
        mod = NULL;
    }
    err_free(&err);
    return mod;
}
",8902
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static int
handle_keywordonly_args(struct compiling *c, const node *n, int start,
                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)
{
    PyObject *argname;
    node *ch;
    expr_ty expression, annotation;
    arg_ty arg = NULL;
    int i = start;
    int j = 0; /* index for kwdefaults and kwonlyargs */

    if (kwonlyargs == NULL) {
        ast_error(c, CHILD(n, start), 'named arguments must follow bare *');
        return -1;
    }
    assert(kwdefaults != NULL);
    while (i < NCH(n)) {
        ch = CHILD(n, i);
        switch (TYPE(ch)) {
            case vfpdef:
            case tfpdef:
                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {
                    expression = ast_for_expr(c, CHILD(n, i + 2));
                    if (!expression)
                        goto error;
                    asdl_seq_SET(kwdefaults, j, expression);
                    i += 2; /* '=' and test */
                }
                else { /* setting NULL if no default value exists */
                    asdl_seq_SET(kwdefaults, j, NULL);
                }
                if (NCH(ch) == 3) {
                    /* ch is NAME ':' test */
                    annotation = ast_for_expr(c, CHILD(ch, 2));
                    if (!annotation)
                        goto error;
                }
                else {
                    annotation = NULL;
                }
                ch = CHILD(ch, 0);
                argname = NEW_IDENTIFIER(ch);
                if (!argname)
                    goto error;
                if (forbidden_name(c, argname, ch, 0))
                    goto error;
                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,
                          c->c_arena);
                if (!arg)
                    goto error;
                asdl_seq_SET(kwonlyargs, j++, arg);
                i += 1; /* the name */
                if (TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                break;
            case TYPE_COMMENT:
                /* arg will be equal to the last argument processed */
                arg->type_comment = NEW_TYPE_COMMENT(ch);
                if (!arg->type_comment)
                    goto error;
                i += 1;
                break;
            case DOUBLESTAR:
                return i;
            default:
                ast_error(c, ch, 'unexpected node');
                goto error;
        }
    }
    return i;
 error:
    return -1;
}
",8903
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,1,"static arguments_ty
ast_for_arguments(struct compiling *c, const node *n)
{
    /* This function handles both typedargslist (function definition)
       and varargslist (lambda definition).

       parameters: '(' [typedargslist] ')'
       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [
               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
             | '**' tfpdef [',']]]
         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
         | '**' tfpdef [','])
       tfpdef: NAME [':' test]
       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [
               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
             | '**' vfpdef [',']]]
         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
         | '**' vfpdef [',']
       )
       vfpdef: NAME

    */
    int i, j, k, nposargs = 0, nkwonlyargs = 0;
    int nposdefaults = 0, found_default = 0;
    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;
    arg_ty vararg = NULL, kwarg = NULL;
    arg_ty arg = NULL;
    node *ch;

    if (TYPE(n) == parameters) {
        if (NCH(n) == 2) /* () as argument list */
            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);
        n = CHILD(n, 1);
    }
    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);

    /* First count the number of positional args & defaults.  The
       variable i is the loop index for this for loop and the next.
       The next loop picks up where the first leaves off.
    */
    for (i = 0; i < NCH(n); i++) {
        ch = CHILD(n, i);
        if (TYPE(ch) == STAR) {
            /* skip star */
            i++;
            if (i < NCH(n) && /* skip argument following star */
                (TYPE(CHILD(n, i)) == tfpdef ||
                 TYPE(CHILD(n, i)) == vfpdef)) {
                i++;
            }
            break;
        }
        if (TYPE(ch) == DOUBLESTAR) break;
        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;
        if (TYPE(ch) == EQUAL) nposdefaults++;
    }
    /* count the number of keyword only args &
       defaults for keyword only args */
    for ( ; i < NCH(n); ++i) {
        ch = CHILD(n, i);
        if (TYPE(ch) == DOUBLESTAR) break;
        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;
    }
    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);
    if (!posargs && nposargs)
        return NULL;
    kwonlyargs = (nkwonlyargs ?
                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);
    if (!kwonlyargs && nkwonlyargs)
        return NULL;
    posdefaults = (nposdefaults ?
                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);
    if (!posdefaults && nposdefaults)
        return NULL;
    /* The length of kwonlyargs and kwdefaults are same
       since we set NULL as default for keyword only argument w/o default
       - we have sequence data structure, but no dictionary */
    kwdefaults = (nkwonlyargs ?
                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);
    if (!kwdefaults && nkwonlyargs)
        return NULL;

    /* tfpdef: NAME [':' test]
       vfpdef: NAME
    */
    i = 0;
    j = 0;  /* index for defaults */
    k = 0;  /* index for args */
    while (i < NCH(n)) {
        ch = CHILD(n, i);
        switch (TYPE(ch)) {
            case tfpdef:
            case vfpdef:
                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is
                   anything other than EQUAL or a comma? */
                /* XXX Should NCH(n) check be made a separate check? */
                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {
                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));
                    if (!expression)
                        return NULL;
                    assert(posdefaults != NULL);
                    asdl_seq_SET(posdefaults, j++, expression);
                    i += 2;
                    found_default = 1;
                }
                else if (found_default) {
                    ast_error(c, n,
                             'non-default argument follows default argument');
                    return NULL;
                }
                arg = ast_for_arg(c, ch);
                if (!arg)
                    return NULL;
                asdl_seq_SET(posargs, k++, arg);
                i += 1; /* the name */
                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                break;
            case STAR:
                if (i+1 >= NCH(n) ||
                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA
                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {
                    ast_error(c, CHILD(n, i),
                        'named arguments must follow bare *');
                    return NULL;
                }
                ch = CHILD(n, i+1);  /* tfpdef or COMMA */
                if (TYPE(ch) == COMMA) {
                    int res = 0;
                    i += 2; /* now follows keyword only arguments */

                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
                        ast_error(c, CHILD(n, i),
                                'bare * has associated type comment');
                        return NULL;
                    }

                    res = handle_keywordonly_args(c, n, i,
                                                  kwonlyargs, kwdefaults);
                    if (res == -1) return NULL;
                    i = res; /* res has new position to process */
                }
                else {
                    vararg = ast_for_arg(c, ch);
                    if (!vararg)
                        return NULL;

                    i += 2; /* the star and the name */
                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                        i += 1; /* the comma, if present */

                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));
                        if (!vararg->type_comment)
                            return NULL;
                        i += 1;
                    }

                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef
                                    || TYPE(CHILD(n, i)) == vfpdef)) {
                        int res = 0;
                        res = handle_keywordonly_args(c, n, i,
                                                      kwonlyargs, kwdefaults);
                        if (res == -1) return NULL;
                        i = res; /* res has new position to process */
                    }
                }
                break;
            case DOUBLESTAR:
                ch = CHILD(n, i+1);  /* tfpdef */
                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);
                kwarg = ast_for_arg(c, ch);
                if (!kwarg)
                    return NULL;
                i += 2; /* the double star and the name */
                if (TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                break;
            case TYPE_COMMENT:
                assert(i);

                if (kwarg)
                    arg = kwarg;

                /* arg will be equal to the last argument processed */
                arg->type_comment = NEW_TYPE_COMMENT(ch);
                if (!arg->type_comment)
                    return NULL;
                i += 1;
                break;
            default:
                PyErr_Format(PyExc_SystemError,
                             'unexpected node in varargslist: %d @ %d',
                             TYPE(ch), i);
                return NULL;
        }
    }
    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);
}
",8904
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_ifexpr(struct compiling *c, const node *n)
{
    /* test: or_test 'if' or_test 'else' test */
    expr_ty expression, body, orelse;

    assert(NCH(n) == 5);
    body = ast_for_expr(c, CHILD(n, 0));
    if (!body)
        return NULL;
    expression = ast_for_expr(c, CHILD(n, 2));
    if (!expression)
        return NULL;
    orelse = ast_for_expr(c, CHILD(n, 4));
    if (!orelse)
        return NULL;
    return IfExp(expression, body, orelse, LINENO(n), n->n_col_offset,
                 c->c_arena);
}
",8905
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject* ast2obj_object(void *o)
{
    if (!o)
        o = Py_None;
    Py_INCREF((PyObject*)o);
    return (PyObject*)o;
}
",8906
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
num_stmts(const node *n)
{
    int i, l;
    node *ch;

    switch (TYPE(n)) {
        case single_input:
            if (TYPE(CHILD(n, 0)) == NEWLINE)
                return 0;
            else
                return num_stmts(CHILD(n, 0));
        case file_input:
            l = 0;
            for (i = 0; i < NCH(n); i++) {
                ch = CHILD(n, i);
                if (TYPE(ch) == stmt)
                    l += num_stmts(ch);
            }
            return l;
        case stmt:
            return num_stmts(CHILD(n, 0));
        case compound_stmt:
            return 1;
        case simple_stmt:
            return NCH(n) / 2; /* Divide by 2 to remove count of semi-colons */
        case suite:
            /* suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT */
            if (NCH(n) == 1)
                return num_stmts(CHILD(n, 0));
            else {
                i = 2;
                l = 0;
                if (TYPE(CHILD(n, 1)) == TYPE_COMMENT)
                    i += 2;
                for (; i < (NCH(n) - 1); i++)
                    l += num_stmts(CHILD(n, i));
                return l;
            }
        default: {
            char buf[128];

            sprintf(buf, 'Non-statement found: %d %d',
                    TYPE(n), NCH(n));
            Py_FatalError(buf);
        }
    }
    assert(0);
    return 0;
}
",8907
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static stmt_ty
ast_for_import_stmt(struct compiling *c, const node *n)
{
    /*
      import_stmt: import_name | import_from
      import_name: 'import' dotted_as_names
      import_from: 'from' ('.'* dotted_name | '.') 'import'
                          ('*' | '(' import_as_names ')' | import_as_names)
    */
    int lineno;
    int col_offset;
    int i;
    asdl_seq *aliases;

    REQ(n, import_stmt);
    lineno = LINENO(n);
    col_offset = n->n_col_offset;
    n = CHILD(n, 0);
    if (TYPE(n) == import_name) {
        n = CHILD(n, 1);
        REQ(n, dotted_as_names);
        aliases = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);
        if (!aliases)
            return NULL;
        for (i = 0; i < NCH(n); i += 2) {
            alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);
            if (!import_alias)
                return NULL;
            asdl_seq_SET(aliases, i / 2, import_alias);
        }
        return Import(aliases, lineno, col_offset, c->c_arena);
    }
    else if (TYPE(n) == import_from) {
        int n_children;
        int idx, ndots = 0;
        alias_ty mod = NULL;
        identifier modname = NULL;

       /* Count the number of dots (for relative imports) and check for the
          optional module name */
        for (idx = 1; idx < NCH(n); idx++) {
            if (TYPE(CHILD(n, idx)) == dotted_name) {
                mod = alias_for_import_name(c, CHILD(n, idx), 0);
                if (!mod)
                    return NULL;
                idx++;
                break;
            } else if (TYPE(CHILD(n, idx)) != DOT) {
                break;
            }
            ndots++;
        }
        idx++; /* skip over the 'import' keyword */
        switch (TYPE(CHILD(n, idx))) {
        case STAR:
            /* from ... import * */
            n = CHILD(n, idx);
            n_children = 1;
            break;
        case LPAR:
            /* from ... import (x, y, z) */
            n = CHILD(n, idx + 1);
            n_children = NCH(n);
            break;
        case import_as_names:
            /* from ... import x, y, z */
            n = CHILD(n, idx);
            n_children = NCH(n);
            if (n_children % 2 == 0) {
                ast_error(n, 'trailing comma not allowed without'
                             ' surrounding parentheses');
                return NULL;
            }
            break;
        default:
            ast_error(n, 'Unexpected node-type in from-import');
            return NULL;
        }

        aliases = asdl_seq_new((n_children + 1) / 2, c->c_arena);
        if (!aliases)
            return NULL;

        /* handle 'from ... import *' special b/c there's no children */
        if (TYPE(n) == STAR) {
            alias_ty import_alias = alias_for_import_name(c, n, 1);
            if (!import_alias)
                return NULL;
                asdl_seq_SET(aliases, 0, import_alias);
        }
        else {
            for (i = 0; i < NCH(n); i += 2) {
                alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);
                if (!import_alias)
                    return NULL;
                    asdl_seq_SET(aliases, i / 2, import_alias);
            }
        }
        if (mod != NULL)
            modname = mod->name;
        return ImportFrom(modname, aliases, ndots, lineno, col_offset,
                          c->c_arena);
    }
    PyErr_Format(PyExc_SystemError,
                 'unknown import statement: starts with command '%s'',
                 STR(CHILD(n, 0)));
    return NULL;
}
",8908
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject *
decode_bytes_with_escapes(struct compiling *c, const node *n, const char *s,
                          size_t len)
{
    const char *first_invalid_escape;
    PyObject *result = _PyBytes_DecodeEscape(s, len, NULL, 0, NULL,
                                             &first_invalid_escape);
    if (result == NULL)
        return NULL;

    if (first_invalid_escape != NULL) {
        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) < 0) {
            Py_DECREF(result);
            return NULL;
        }
    }
    return result;
}
",8909
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static arg_ty
ast_for_arg(struct compiling *c, const node *n)
{
    identifier name;
    expr_ty annotation = NULL;
    node *ch;
    arg_ty ret;

    assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);
    ch = CHILD(n, 0);
    name = NEW_IDENTIFIER(ch);
    if (!name)
        return NULL;
    if (forbidden_name(c, name, ch, 0))
        return NULL;

    if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {
        annotation = ast_for_expr(c, CHILD(n, 2));
        if (!annotation)
            return NULL;
    }

    ret = arg(name, annotation, NULL, LINENO(n), n->n_col_offset, c->c_arena);
    if (!ret)
        return NULL;
    return ret;
}
",8910
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static alias_ty
alias_for_import_name(struct compiling *c, const node *n, int store)
{
    /*
      import_as_name: NAME ['as' NAME]
      dotted_as_name: dotted_name ['as' NAME]
      dotted_name: NAME ('.' NAME)*
    */
    PyObject *str, *name;

 loop:
    switch (TYPE(n)) {
         case import_as_name: {
            node *name_node = CHILD(n, 0);
            str = NULL;
            if (NCH(n) == 3) {
                node *str_node = CHILD(n, 2);
                if (store && !forbidden_check(c, str_node, STR(str_node)))
                    return NULL;
                str = NEW_IDENTIFIER(str_node);
                if (!str)
                    return NULL;
            }
            else {
                if (!forbidden_check(c, name_node, STR(name_node)))
                    return NULL;
            }
            name = NEW_IDENTIFIER(name_node);
            if (!name)
                return NULL;
            return alias(name, str, c->c_arena);
        }
        case dotted_as_name:
            if (NCH(n) == 1) {
                n = CHILD(n, 0);
                goto loop;
            }
            else {
                node *asname_node = CHILD(n, 2);
                alias_ty a = alias_for_import_name(c, CHILD(n, 0), 0);
                if (!a)
                    return NULL;
                assert(!a->asname);
                if (!forbidden_check(c, asname_node, STR(asname_node)))
                    return NULL;
                a->asname = NEW_IDENTIFIER(asname_node);
                if (!a->asname)
                    return NULL;
                return a;
            }
            break;
        case dotted_name:
            if (NCH(n) == 1) {
                node *name_node = CHILD(n, 0);
                if (store && !forbidden_check(c, name_node, STR(name_node)))
                    return NULL;
                name = NEW_IDENTIFIER(name_node);
                if (!name)
                    return NULL;
                return alias(name, NULL, c->c_arena);
            }
            else {
                /* Create a string of the form 'a.b.c' */
                int i;
                size_t len;
                char *s;
                PyObject *uni;

                len = 0;
                for (i = 0; i < NCH(n); i += 2)
                    /* length of string plus one for the dot */
                    len += strlen(STR(CHILD(n, i))) + 1;
                len--; /* the last name doesn't have a dot */
                str = PyBytes_FromStringAndSize(NULL, len);
                if (!str)
                    return NULL;
                s = PyBytes_AS_STRING(str);
                if (!s)
                    return NULL;
                for (i = 0; i < NCH(n); i += 2) {
                    char *sch = STR(CHILD(n, i));
                    strcpy(s, STR(CHILD(n, i)));
                    s += strlen(sch);
                    *s++ = '.';
                }
                --s;
                *s = '\0';
                uni = PyUnicode_DecodeUTF8(PyBytes_AS_STRING(str),
                                           PyBytes_GET_SIZE(str),
                                           NULL);
                Py_DECREF(str);
                if (!uni)
                    return NULL;
                str = uni;
                PyUnicode_InternInPlace(&str);
                if (PyArena_AddPyObject(c->c_arena, str) < 0) {
                    Py_DECREF(str);
                    return NULL;
                }
                return alias(str, NULL, c->c_arena);
            }
            break;
        case STAR:
            str = PyUnicode_InternFromString('*');
            if (PyArena_AddPyObject(c->c_arena, str) < 0) {
                Py_DECREF(str);
                return NULL;
            }
            return alias(str, NULL, c->c_arena);
        default:
            PyErr_Format(PyExc_SystemError,
                         'unexpected import name: %d', TYPE(n));
            return NULL;
    }

    PyErr_SetString(PyExc_SystemError, 'unhandled import name condition');
    return NULL;
}
",8911
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static stmt_ty
ast_for_if_stmt(struct compiling *c, const node *n)
{
    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
       ['else' ':' suite]
    */
    char *s;

    REQ(n, if_stmt);

    if (NCH(n) == 4) {
        expr_ty expression;
        asdl_seq *suite_seq;

        expression = ast_for_expr(c, CHILD(n, 1));
        if (!expression)
            return NULL;
        suite_seq = ast_for_suite(c, CHILD(n, 3));
        if (!suite_seq)
            return NULL;

        return If(expression, suite_seq, NULL, LINENO(n), n->n_col_offset,
                  c->c_arena);
    }

    s = STR(CHILD(n, 4));
    /* s[2], the third character in the string, will be
       's' for el_s_e, or
       'i' for el_i_f
    */
    if (s[2] == 's') {
        expr_ty expression;
        asdl_seq *seq1, *seq2;

        expression = ast_for_expr(c, CHILD(n, 1));
        if (!expression)
            return NULL;
        seq1 = ast_for_suite(c, CHILD(n, 3));
        if (!seq1)
            return NULL;
        seq2 = ast_for_suite(c, CHILD(n, 6));
        if (!seq2)
            return NULL;

        return If(expression, seq1, seq2, LINENO(n), n->n_col_offset,
                  c->c_arena);
    }
    else if (s[2] == 'i') {
        int i, n_elif, has_else = 0;
        expr_ty expression;
        asdl_seq *suite_seq;
        asdl_seq *orelse = NULL;
        n_elif = NCH(n) - 4;
        /* must reference the child n_elif+1 since 'else' token is third,
           not fourth, child from the end. */
        if (TYPE(CHILD(n, (n_elif + 1))) == NAME
            && STR(CHILD(n, (n_elif + 1)))[2] == 's') {
            has_else = 1;
            n_elif -= 3;
        }
        n_elif /= 4;

        if (has_else) {
            asdl_seq *suite_seq2;

            orelse = asdl_seq_new(1, c->c_arena);
            if (!orelse)
                return NULL;
            expression = ast_for_expr(c, CHILD(n, NCH(n) - 6));
            if (!expression)
                return NULL;
            suite_seq = ast_for_suite(c, CHILD(n, NCH(n) - 4));
            if (!suite_seq)
                return NULL;
            suite_seq2 = ast_for_suite(c, CHILD(n, NCH(n) - 1));
            if (!suite_seq2)
                return NULL;

            asdl_seq_SET(orelse, 0,
                         If(expression, suite_seq, suite_seq2,
                            LINENO(CHILD(n, NCH(n) - 6)),
                            CHILD(n, NCH(n) - 6)->n_col_offset,
                            c->c_arena));
            /* the just-created orelse handled the last elif */
            n_elif--;
        }

        for (i = 0; i < n_elif; i++) {
            int off = 5 + (n_elif - i - 1) * 4;
            asdl_seq *newobj = asdl_seq_new(1, c->c_arena);
            if (!newobj)
                return NULL;
            expression = ast_for_expr(c, CHILD(n, off));
            if (!expression)
                return NULL;
            suite_seq = ast_for_suite(c, CHILD(n, off + 2));
            if (!suite_seq)
                return NULL;

            asdl_seq_SET(newobj, 0,
                         If(expression, suite_seq, orelse,
                            LINENO(CHILD(n, off)),
                            CHILD(n, off)->n_col_offset, c->c_arena));
            orelse = newobj;
        }
        expression = ast_for_expr(c, CHILD(n, 1));
        if (!expression)
            return NULL;
        suite_seq = ast_for_suite(c, CHILD(n, 3));
        if (!suite_seq)
            return NULL;
        return If(expression, suite_seq, orelse,
                  LINENO(n), n->n_col_offset, c->c_arena);
    }

    PyErr_Format(PyExc_SystemError,
                 'unexpected token in 'if' statement: %s', s);
    return NULL;
}
",8912
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static stmt_ty
ast_for_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)
{
    /* funcdef: 'def' NAME parameters ['->' test] ':' suite */
    return ast_for_funcdef_impl(c, n, decorator_seq,
                                false /* is_async */);
}
",8913
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"int
obj2ast_unaryop(PyObject* obj, unaryop_ty* out, PyArena* arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, (PyObject *)Invert_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Invert;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)Not_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Not;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)UAdd_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = UAdd;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)USub_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = USub;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of unaryop, but got %R', obj);
    return 1;
}
",8914
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static void
ExprList_check_invariants(ExprList *l)
{
    /* Check our invariants. Make sure this object is 'live', and
       hasn't been deallocated. */
    assert(l->size >= 0);
    assert(l->p != NULL);
    if (l->size <= EXPRLIST_N_CACHED)
        assert(l->data == l->p);
}
",8915
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Attribute(expr_ty value, identifier attr, expr_context_ty ctx, int lineno, int
          col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        'field value is required for Attribute');
        return NULL;
    }
    if (!attr) {
        PyErr_SetString(PyExc_ValueError,
                        'field attr is required for Attribute');
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        'field ctx is required for Attribute');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Attribute_kind;
    p->v.Attribute.value = value;
    p->v.Attribute.attr = attr;
    p->v.Attribute.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8916
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"int
obj2ast_cmpop(PyObject* obj, cmpop_ty* out, PyArena* arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, (PyObject *)Eq_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Eq;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)NotEq_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = NotEq;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)Lt_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Lt;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)LtE_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = LtE;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)Gt_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Gt;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)GtE_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = GtE;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)Is_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Is;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)IsNot_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = IsNot;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)In_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = In;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)NotIn_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = NotIn;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of cmpop, but got %R', obj);
    return 1;
}
",8917
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static arguments_ty
ast_for_arguments(struct compiling *c, const node *n)
{
    /* parameters: '(' [varargslist] ')'
       varargslist: ((fpdef ['=' test] ',' [TYPE_COMMENT])*
                     ('*' NAME [',' [TYPE_COMMENT]  '**' NAME] [TYPE_COMMENT] | '**' NAME [TYPE_COMMENT]) |
                     fpdef ['=' test] (',' [TYPE_COMMENT] fpdef ['=' test])* [','] [TYPE_COMMENT])
    */
    int i, j, k, l, n_args = 0, n_all_args = 0, n_defaults = 0, found_default = 0;
    asdl_seq *args, *defaults, *type_comments = NULL;
    identifier vararg = NULL, kwarg = NULL;
    node *ch;

    if (TYPE(n) == parameters) {
        if (NCH(n) == 2) /* () as argument list */
            return arguments(NULL, NULL, NULL, NULL, NULL, c->c_arena);
        n = CHILD(n, 1);
    }
    REQ(n, varargslist);

    /* first count the number of normal args & defaults */
    for (i = 0; i < NCH(n); i++) {
        ch = CHILD(n, i);
        if (TYPE(ch) == fpdef)
            n_args++;
        if (TYPE(ch) == EQUAL)
            n_defaults++;
        if (TYPE(ch) == STAR || TYPE(ch) == DOUBLESTAR)
            n_all_args++;
    }
    n_all_args += n_args;
    args = (n_args ? asdl_seq_new(n_args, c->c_arena) : NULL);
    if (!args && n_args)
        return NULL;
    defaults = (n_defaults ? asdl_seq_new(n_defaults, c->c_arena) : NULL);
    if (!defaults && n_defaults)
        return NULL;
    /* type_comments will be lazily initialized if needed.  If there are no
       per-argument type comments, it will remain NULL.  Otherwise, it will be
       an asdl_seq with length equal to the number of args (including varargs
       and kwargs, if present) and with members set to the string of each arg's
       type comment, if present, or NULL otherwise.
     */

    /* fpdef: NAME | '(' fplist ')'
       fplist: fpdef (',' fpdef)* [',']
    */
    i = 0;
    j = 0;  /* index for defaults */
    k = 0;  /* index for args */
    l = 0;  /* index for type comments */
    while (i < NCH(n)) {
        ch = CHILD(n, i);
        switch (TYPE(ch)) {
            case fpdef: {
                int complex_args = 0, parenthesized = 0;
            handle_fpdef:
                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is
                   anything other than EQUAL or a comma? */
                /* XXX Should NCH(n) check be made a separate check? */
                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {
                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));
                    if (!expression)
                        return NULL;
                    assert(defaults != NULL);
                    asdl_seq_SET(defaults, j++, expression);
                    i += 2;
                    found_default = 1;
                }
                else if (found_default) {
                    /* def f((x)=4): pass should raise an error.
                       def f((x, (y))): pass will just incur the tuple unpacking warning. */
                    if (parenthesized && !complex_args) {
                        ast_error(n, 'parenthesized arg with default');
                        return NULL;
                    }
                    ast_error(n,
                             'non-default argument follows default argument');
                    return NULL;
                }
                if (NCH(ch) == 3) {
                    ch = CHILD(ch, 1);
                    /* def foo((x)): is not complex, special case. */
                    if (NCH(ch) != 1) {
                        /* We have complex arguments, setup for unpacking. */
                        if (Py_Py3kWarningFlag && !ast_warn(c, ch,
                            'tuple parameter unpacking has been removed in 3.x'))
                            return NULL;
                        complex_args = 1;
                        asdl_seq_SET(args, k++, compiler_complex_args(c, ch));
                        if (!asdl_seq_GET(args, k-1))
                                return NULL;
                    } else {
                        /* def foo((x)): setup for checking NAME below. */
                        /* Loop because there can be many parens and tuple
                           unpacking mixed in. */
                        parenthesized = 1;
                        ch = CHILD(ch, 0);
                        assert(TYPE(ch) == fpdef);
                        goto handle_fpdef;
                    }
                }
                if (TYPE(CHILD(ch, 0)) == NAME) {
                    PyObject *id;
                    expr_ty name;
                    if (!forbidden_check(c, n, STR(CHILD(ch, 0))))
                        return NULL;
                    id = NEW_IDENTIFIER(CHILD(ch, 0));
                    if (!id)
                        return NULL;
                    name = Name(id, Param, LINENO(ch), ch->n_col_offset,
                                c->c_arena);
                    if (!name)
                        return NULL;
                    asdl_seq_SET(args, k++, name);

                }
                i += 1; /* the name */
                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                if (parenthesized && Py_Py3kWarningFlag &&
                    !ast_warn(c, ch, 'parenthesized argument names '
                              'are invalid in 3.x'))
                    return NULL;

                break;
            }
            case STAR:
                if (!forbidden_check(c, CHILD(n, i+1), STR(CHILD(n, i+1))))
                    return NULL;
                vararg = NEW_IDENTIFIER(CHILD(n, i+1));
                if (!vararg)
                    return NULL;
                i += 2; /* the star and the name */
                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                break;
            case DOUBLESTAR:
                if (!forbidden_check(c, CHILD(n, i+1), STR(CHILD(n, i+1))))
                    return NULL;
                kwarg = NEW_IDENTIFIER(CHILD(n, i+1));
                if (!kwarg)
                    return NULL;
                i += 2; /* the double star and the name */
                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                    i += 1; /* the comma, if present */
                break;
            case TYPE_COMMENT:
                assert(l < k + !!vararg + !!kwarg);

                if (!type_comments) {
                    /* lazily allocate the type_comments seq for perf reasons */
                    type_comments = asdl_seq_new(n_all_args, c->c_arena);
                    if (!type_comments)
                        return NULL;
                }

                while (l < k + !!vararg + !!kwarg - 1) {
                    asdl_seq_SET(type_comments, l++, NULL);
                }

                asdl_seq_SET(type_comments, l++, NEW_TYPE_COMMENT(ch));
                i += 1;
                break;
            default:
                PyErr_Format(PyExc_SystemError,
                             'unexpected node in varargslist: %d @ %d',
                             TYPE(ch), i);
                return NULL;
        }
    }

    if (type_comments) {
        while (l < n_all_args) {
            asdl_seq_SET(type_comments, l++, NULL);
        }
    }

    return arguments(args, vararg, kwarg, defaults, type_comments, c->c_arena);
}
",8918
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_factor(struct compiling *c, const node *n)
{
    expr_ty expression;

    expression = ast_for_expr(c, CHILD(n, 1));
    if (!expression)
        return NULL;

    switch (TYPE(CHILD(n, 0))) {
        case PLUS:
            return UnaryOp(UAdd, expression, LINENO(n), n->n_col_offset,
                           c->c_arena);
        case MINUS:
            return UnaryOp(USub, expression, LINENO(n), n->n_col_offset,
                           c->c_arena);
        case TILDE:
            return UnaryOp(Invert, expression, LINENO(n),
                           n->n_col_offset, c->c_arena);
    }
    PyErr_Format(PyExc_SystemError, 'unhandled factor: %d',
                 TYPE(CHILD(n, 0)));
    return NULL;
}
",8919
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
validate_slice(slice_ty slice)
{
    switch (slice->kind) {
    case Slice_kind:
        return (!slice->v.Slice.lower || validate_expr(slice->v.Slice.lower, Load)) &&
            (!slice->v.Slice.upper || validate_expr(slice->v.Slice.upper, Load)) &&
            (!slice->v.Slice.step || validate_expr(slice->v.Slice.step, Load));
    case ExtSlice_kind: {
        int i;
        if (!validate_nonempty_seq(slice->v.ExtSlice.dims, 'dims', 'ExtSlice'))
            return 0;
        for (i = 0; i < asdl_seq_LEN(slice->v.ExtSlice.dims); i++)
            if (!validate_slice(asdl_seq_GET(slice->v.ExtSlice.dims, i)))
                return 0;
        return 1;
    }
    case Index_kind:
        return validate_expr(slice->v.Index.value, Load);
    default:
        PyErr_SetString(PyExc_SystemError, 'unknown slice node');
        return 0;
    }
}
",8920
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
Assign(asdl_seq * targets, expr_ty value, string type_comment, int lineno, int
       col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        'field value is required for Assign');
        return NULL;
    }
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Assign_kind;
    p->v.Assign.targets = targets;
    p->v.Assign.value = value;
    p->v.Assign.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8921
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"PyObject* ast2obj_unaryop(unaryop_ty o)
{
    switch(o) {
        case Invert:
            Py_INCREF(Invert_singleton);
            return Invert_singleton;
        case Not:
            Py_INCREF(Not_singleton);
            return Not_singleton;
        case UAdd:
            Py_INCREF(UAdd_singleton);
            return UAdd_singleton;
        case USub:
            Py_INCREF(USub_singleton);
            return USub_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, 'unknown unaryop found');
            return NULL;
    }
}
",8922
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"#ifndef PGEN
    if (filename_str != NULL) {
        filename = PyUnicode_DecodeFSDefault(filename_str);
        if (filename == NULL) {
            err_ret->error = E_ERROR;
            return NULL;
        }
",8923
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"mod_ty
Suite(asdl_seq * body, PyArena *arena)
{
    mod_ty p;
    p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Suite_kind;
    p->v.Suite.body = body;
    return p;
}
",8924
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"excepthandler_ty
ExceptHandler(expr_ty type, identifier name, asdl_seq * body, int lineno, int
              col_offset, PyArena *arena)
{
    excepthandler_ty p;
    p = (excepthandler_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ExceptHandler_kind;
    p->v.ExceptHandler.type = type;
    p->v.ExceptHandler.name = name;
    p->v.ExceptHandler.body = body;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8925
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static asdl_seq*
ast_for_class_bases(struct compiling *c, const node* n)
{
    /* testlist: test (',' test)* [','] */
    assert(NCH(n) > 0);
    REQ(n, testlist);
    if (NCH(n) == 1) {
        expr_ty base;
        asdl_seq *bases = asdl_seq_new(1, c->c_arena);
        if (!bases)
            return NULL;
        base = ast_for_expr(c, CHILD(n, 0));
        if (!base)
            return NULL;
        asdl_seq_SET(bases, 0, base);
        return bases;
    }

    return seq_for_testlist(c, n);
}
",8926
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"comprehension_ty
comprehension(expr_ty target, expr_ty iter, asdl_seq * ifs, int is_async,
              PyArena *arena)
{
    comprehension_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        'field target is required for comprehension');
        return NULL;
    }
    if (!iter) {
        PyErr_SetString(PyExc_ValueError,
                        'field iter is required for comprehension');
        return NULL;
    }
    p = (comprehension_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->target = target;
    p->iter = iter;
    p->ifs = ifs;
    p->is_async = is_async;
    return p;
}
",8927
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static void
err_free(perrdetail *err)
{
    Py_CLEAR(err->filename);
}
",8928
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty ast_for_testlist_comp(struct compiling *, const node *);
",8929
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
Global(asdl_seq * names, int lineno, int col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Global_kind;
    p->v.Global.names = names;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8930
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
SetComp(expr_ty elt, asdl_seq * generators, int lineno, int col_offset, PyArena
        *arena)
{
    expr_ty p;
    if (!elt) {
        PyErr_SetString(PyExc_ValueError,
                        'field elt is required for SetComp');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = SetComp_kind;
    p->v.SetComp.elt = elt;
    p->v.SetComp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8931
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
forbidden_name(struct compiling *c, identifier name, const node *n,
               int full_checks)
{
    assert(PyUnicode_Check(name));
    if (_PyUnicode_EqualToASCIIString(name, '__debug__')) {
        ast_error(c, n, 'assignment to keyword');
        return 1;
    }
    if (full_checks) {
        const char * const *p;
        for (p = FORBIDDEN; *p; p++) {
            if (_PyUnicode_EqualToASCIIString(name, *p)) {
                ast_error(c, n, 'assignment to keyword');
                return 1;
            }
        }
    }
    return 0;
}
",8932
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
FstringParser_ConcatAndDel(FstringParser *state, PyObject *str)
{
    FstringParser_check_invariants(state);

    assert(PyUnicode_CheckExact(str));

    if (PyUnicode_GET_LENGTH(str) == 0) {
        Py_DECREF(str);
        return 0;
    }

    if (!state->last_str) {
        /* We didn't have a string before, so just remember this one. */
        state->last_str = str;
    } else {
        /* Concatenate this with the previous string. */
        PyUnicode_AppendAndDel(&state->last_str, str);
        if (!state->last_str)
            return -1;
    }
    FstringParser_check_invariants(state);
    return 0;
}
",8933
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
AugAssign(expr_ty target, operator_ty op, expr_ty value, int lineno, int
          col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        'field target is required for AugAssign');
        return NULL;
    }
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        'field op is required for AugAssign');
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        'field value is required for AugAssign');
        return NULL;
    }
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = AugAssign_kind;
    p->v.AugAssign.target = target;
    p->v.AugAssign.op = op;
    p->v.AugAssign.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8934
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
set_context(struct compiling *c, expr_ty e, expr_context_ty ctx, const node *n)
{
    asdl_seq *s = NULL;
    /* If a particular expression type can't be used for assign / delete,
       set expr_name to its name and an error message will be generated.
    */
    const char* expr_name = NULL;

    /* The ast defines augmented store and load contexts, but the
       implementation here doesn't actually use them.  The code may be
       a little more complex than necessary as a result.  It also means
       that expressions in an augmented assignment have a Store context.
       Consider restructuring so that augmented assignment uses
       set_context(), too.
    */
    assert(ctx != AugStore && ctx != AugLoad);

    switch (e->kind) {
        case Attribute_kind:
            e->v.Attribute.ctx = ctx;
            if (ctx == Store && forbidden_name(c, e->v.Attribute.attr, n, 1))
                return 0;
            break;
        case Subscript_kind:
            e->v.Subscript.ctx = ctx;
            break;
        case Starred_kind:
            e->v.Starred.ctx = ctx;
            if (!set_context(c, e->v.Starred.value, ctx, n))
                return 0;
            break;
        case Name_kind:
            if (ctx == Store) {
                if (forbidden_name(c, e->v.Name.id, n, 0))
                    return 0; /* forbidden_name() calls ast_error() */
            }
            e->v.Name.ctx = ctx;
            break;
        case List_kind:
            e->v.List.ctx = ctx;
            s = e->v.List.elts;
            break;
        case Tuple_kind:
            e->v.Tuple.ctx = ctx;
            s = e->v.Tuple.elts;
            break;
        case Lambda_kind:
            expr_name = 'lambda';
            break;
        case Call_kind:
            expr_name = 'function call';
            break;
        case BoolOp_kind:
        case BinOp_kind:
        case UnaryOp_kind:
            expr_name = 'operator';
            break;
        case GeneratorExp_kind:
            expr_name = 'generator expression';
            break;
        case Yield_kind:
        case YieldFrom_kind:
            expr_name = 'yield expression';
            break;
        case Await_kind:
            expr_name = 'await expression';
            break;
        case ListComp_kind:
            expr_name = 'list comprehension';
            break;
        case SetComp_kind:
            expr_name = 'set comprehension';
            break;
        case DictComp_kind:
            expr_name = 'dict comprehension';
            break;
        case Dict_kind:
        case Set_kind:
        case Num_kind:
        case Str_kind:
        case Bytes_kind:
        case JoinedStr_kind:
        case FormattedValue_kind:
            expr_name = 'literal';
            break;
        case NameConstant_kind:
            expr_name = 'keyword';
            break;
        case Ellipsis_kind:
            expr_name = 'Ellipsis';
            break;
        case Compare_kind:
            expr_name = 'comparison';
            break;
        case IfExp_kind:
            expr_name = 'conditional expression';
            break;
        default:
            PyErr_Format(PyExc_SystemError,
                         'unexpected expression in assignment %d (line %d)',
                         e->kind, e->lineno);
            return 0;
    }
    /* Check for error string set by switch */
    if (expr_name) {
        char buf[300];
        PyOS_snprintf(buf, sizeof(buf),
                      'can't %s %s',
                      ctx == Store ? 'assign to' : 'delete',
                      expr_name);
        return ast_error(c, n, buf);
    }

    /* If the LHS is a list or tuple, we need to set the assignment
       context for all the contained elements.
    */
    if (s) {
        int i;

        for (i = 0; i < asdl_seq_LEN(s); i++) {
            if (!set_context(c, (expr_ty)asdl_seq_GET(s, i), ctx, n))
                return 0;
        }
    }
    return 1;
}
",8935
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_dictcomp(struct compiling *c, const node *n)
{
    expr_ty key, value;
    asdl_seq *comps;

    assert(NCH(n) > 3);
    REQ(CHILD(n, 1), COLON);

    key = ast_for_expr(c, CHILD(n, 0));
    if (!key)
        return NULL;

    value = ast_for_expr(c, CHILD(n, 2));
    if (!value)
        return NULL;

    comps = ast_for_comprehension(c, CHILD(n, 3));
    if (!comps)
        return NULL;

    return DictComp(key, value, comps, LINENO(n), n->n_col_offset, c->c_arena);
}
",8936
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
check_coding_spec(const char* line, Py_ssize_t size, struct tok_state *tok,
                  int set_readline(struct tok_state *, const char *))
{
    char *cs;
    int r = 1;

    if (tok->cont_line) {
        /* It's a continuation line, so it can't be a coding spec. */
        tok->read_coding_spec = 1;
        return 1;
    }
    if (!get_coding_spec(line, &cs, size, tok))
        return 0;
    if (!cs) {
        Py_ssize_t i;
        for (i = 0; i < size; i++) {
            if (line[i] == '#' || line[i] == '\n' || line[i] == '\r')
                break;
            if (line[i] != ' ' && line[i] != '\t' && line[i] != '\014') {
                /* Stop checking coding spec after a line containing
                 * anything except a comment. */
                tok->read_coding_spec = 1;
                break;
            }
        }
        return 1;
    }
    tok->read_coding_spec = 1;
    if (tok->encoding == NULL) {
        assert(tok->decoding_state == STATE_RAW);
        if (strcmp(cs, 'utf-8') == 0) {
            tok->encoding = cs;
        } else {
            r = set_readline(tok, cs);
            if (r) {
                tok->encoding = cs;
                tok->decoding_state = STATE_NORMAL;
            }
            else {
                PyErr_Format(PyExc_SyntaxError,
                             'encoding problem: %s', cs);
                PyMem_FREE(cs);
            }
        }
    } else {                /* then, compare cs with BOM */
        r = (strcmp(tok->encoding, cs) == 0);
        if (!r)
            PyErr_Format(PyExc_SyntaxError,
                         'encoding problem: %s with BOM', cs);
        PyMem_FREE(cs);
    }
    return r;
}
",8937
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
ExprList_Append(ExprList *l, expr_ty exp)
{
    ExprList_check_invariants(l);
    if (l->size >= l->allocated) {
        /* We need to alloc (or realloc) the memory. */
        Py_ssize_t new_size = l->allocated * 2;

        /* See if we've ever allocated anything dynamically. */
        if (l->p == l->data) {
            Py_ssize_t i;
            /* We're still using the cached data. Switch to
               alloc-ing. */
            l->p = PyMem_RawMalloc(sizeof(expr_ty) * new_size);
            if (!l->p)
                return -1;
            /* Copy the cached data into the new buffer. */
            for (i = 0; i < l->size; i++)
                l->p[i] = l->data[i];
        } else {
            /* Just realloc. */
            expr_ty *tmp = PyMem_RawRealloc(l->p, sizeof(expr_ty) * new_size);
            if (!tmp) {
                PyMem_RawFree(l->p);
                l->p = NULL;
                return -1;
            }
            l->p = tmp;
        }

        l->allocated = new_size;
        assert(l->allocated == 2 * l->size);
    }

    l->p[l->size++] = exp;

    ExprList_check_invariants(l);
    return 0;
}
",8938
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static asdl_seq *
ExprList_Finish(ExprList *l, PyArena *arena)
{
    asdl_seq *seq;

    ExprList_check_invariants(l);

    /* Allocate the asdl_seq and copy the expressions in to it. */
    seq = _Ta3_asdl_seq_new(l->size, arena);
    if (seq) {
        Py_ssize_t i;
        for (i = 0; i < l->size; i++)
            asdl_seq_SET(seq, i, l->p[i]);
    }
    ExprList_Dealloc(l);
    return seq;
}
",8939
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"mod_ty
Expression(expr_ty body, PyArena *arena)
{
    mod_ty p;
    if (!body) {
        PyErr_SetString(PyExc_ValueError,
                        'field body is required for Expression');
        return NULL;
    }
    p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Expression_kind;
    p->v.Expression.body = body;
    return p;
}
",8940
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
Delete(asdl_seq * targets, int lineno, int col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Delete_kind;
    p->v.Delete.targets = targets;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8941
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"    'STAR',
",8942
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"    'COMMA',
",8943
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static identifier
new_identifier(const char* n, PyArena *arena) {
    PyObject* id = PyUnicode_InternFromString(n);
    if (id != NULL)
        PyArena_AddPyObject(arena, id);
    return id;
}
",8944
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
fstring_find_literal_and_expr(const char **str, const char *end, int raw,
                              int recurse_lvl, PyObject **literal,
                              expr_ty *expression,
                              struct compiling *c, const node *n)
{
    int result;

    assert(*literal == NULL && *expression == NULL);

    /* Get any literal string. */
    result = fstring_find_literal(str, end, raw, literal, recurse_lvl, c, n);
    if (result < 0)
        goto error;

    assert(result == 0 || result == 1);

    if (result == 1)
        /* We have a literal, but don't look at the expression. */
        return 1;

    if (*str >= end || **str == '}')
        /* We're at the end of the string or the end of a nested
           f-string: no expression. The top-level error case where we
           expect to be at the end of the string but we're at a '}' is
           handled later. */
        return 0;

    /* We must now be the start of an expression, on a '{'. */
    assert(**str == '{');

    if (fstring_find_expr(str, end, raw, recurse_lvl, expression, c, n) < 0)
        goto error;

    return 0;

error:
    Py_CLEAR(*literal);
    return -1;
}
",8945
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static stmt_ty
ast_for_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)
{
    /* funcdef: 'def' NAME parameters ':' [TYPE_COMMENT] suite */
    identifier name;
    arguments_ty args;
    asdl_seq *body;
    int name_i = 1;
    node *tc;
    string type_comment = NULL;

    REQ(n, funcdef);

    name = NEW_IDENTIFIER(CHILD(n, name_i));
    if (!name)
        return NULL;
    else if (!forbidden_check(c, CHILD(n, name_i), STR(CHILD(n, name_i))))
        return NULL;
    args = ast_for_arguments(c, CHILD(n, name_i + 1));
    if (!args)
        return NULL;
    if (TYPE(CHILD(n, name_i + 3)) == TYPE_COMMENT) {
        type_comment = NEW_TYPE_COMMENT(CHILD(n, name_i + 3));
        name_i += 1;
    }
    body = ast_for_suite(c, CHILD(n, name_i + 3));
    if (!body)
        return NULL;

    if (!type_comment && NCH(CHILD(n, name_i + 3)) > 1) {
        /* If the function doesn't have a type comment on the same line, check
         * if the suite has a type comment in it. */
        tc = CHILD(CHILD(n, name_i + 3), 1);

        if (TYPE(tc) == TYPE_COMMENT)
            type_comment = NEW_TYPE_COMMENT(tc);
    }

    return FunctionDef(name, args, body, decorator_seq, type_comment, LINENO(n),
                       n->n_col_offset, c->c_arena);
}
",8946
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"type_ignore_ty
TypeIgnore(int lineno, PyArena *arena)
{
    type_ignore_ty p;
    p = (type_ignore_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = TypeIgnore_kind;
    p->v.TypeIgnore.lineno = lineno;
    return p;
}
",8947
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject *
parsenumber(struct compiling *c, const char *s)
{
    char *dup, *end;
    PyObject *res = NULL;

    assert(s != NULL);

    if (strchr(s, '_') == NULL) {
        return parsenumber_raw(c, s);
    }
    /* Create a duplicate without underscores. */
    dup = PyMem_Malloc(strlen(s) + 1);
    if (dup == NULL) {
        return PyErr_NoMemory();
    }
    end = dup;
    for (; *s; s++) {
        if (*s != '_') {
            *end++ = *s;
        }
    }
    *end = '\0';
    res = parsenumber_raw(c, dup);
    PyMem_Free(dup);
    return res;
}
",8948
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_binop(struct compiling *c, const node *n)
{
    /* Must account for a sequence of expressions.
       How should A op B op C by represented?
       BinOp(BinOp(A, op, B), op, C).
    */

    int i, nops;
    expr_ty expr1, expr2, result;
    operator_ty newoperator;

    expr1 = ast_for_expr(c, CHILD(n, 0));
    if (!expr1)
        return NULL;

    expr2 = ast_for_expr(c, CHILD(n, 2));
    if (!expr2)
        return NULL;

    newoperator = get_operator(c, CHILD(n, 1));
    if (!newoperator)
        return NULL;

    result = BinOp(expr1, newoperator, expr2, LINENO(n), n->n_col_offset,
                   c->c_arena);
    if (!result)
        return NULL;

    nops = (NCH(n) - 1) / 2;
    for (i = 1; i < nops; i++) {
        expr_ty tmp_result, tmp;
        const node* next_oper = CHILD(n, i * 2 + 1);

        newoperator = get_operator(c, next_oper);
        if (!newoperator)
            return NULL;

        tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));
        if (!tmp)
            return NULL;

        tmp_result = BinOp(result, newoperator, tmp,
                           LINENO(next_oper), next_oper->n_col_offset,
                           c->c_arena);
        if (!tmp_result)
            return NULL;
        result = tmp_result;
    }
    return result;
}
",8949
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
FstringParser_Finish(FstringParser *state, struct compiling *c,
                     const node *n)
{
    asdl_seq *seq;

    FstringParser_check_invariants(state);

    /* If we're just a constant string with no expressions, return
       that. */
    if (!state->fmode) {
        assert(!state->expr_list.size);
        if (!state->last_str) {
            /* Create a zero length string. */
            state->last_str = PyUnicode_FromStringAndSize(NULL, 0);
            if (!state->last_str)
                goto error;
        }
        return make_str_node_and_del(&state->last_str, c, n);
    }

    /* Create a Str node out of last_str, if needed. It will be the
       last node in our expression list. */
    if (state->last_str) {
        expr_ty str = make_str_node_and_del(&state->last_str, c, n);
        if (!str || ExprList_Append(&state->expr_list, str) < 0)
            goto error;
    }
    /* This has already been freed. */
    assert(state->last_str == NULL);

    seq = ExprList_Finish(&state->expr_list, c->c_arena);
    if (!seq)
        goto error;

    return JoinedStr(seq, LINENO(n), n->n_col_offset, c->c_arena);

error:
    FstringParser_Dealloc(state);
    return NULL;
}
",8950
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static operator_ty
get_operator(const node *n)
{
    switch (TYPE(n)) {
        case VBAR:
            return BitOr;
        case CIRCUMFLEX:
            return BitXor;
        case AMPER:
            return BitAnd;
        case LEFTSHIFT:
            return LShift;
        case RIGHTSHIFT:
            return RShift;
        case PLUS:
            return Add;
        case MINUS:
            return Sub;
        case STAR:
            return Mult;
        case SLASH:
            return Div;
        case DOUBLESLASH:
            return FloorDiv;
        case PERCENT:
            return Mod;
        default:
            return (operator_ty)0;
    }
}
",8951
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Ellipsis(int lineno, int col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Ellipsis_kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8952
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Constant(constant value, int lineno, int col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        'field value is required for Constant');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Constant_kind;
    p->v.Constant.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8953
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
init_normalization(struct compiling *c)
{
    PyObject *m = PyImport_ImportModuleNoBlock('unicodedata');
    if (!m)
        return 0;
    c->c_normalize = PyObject_GetAttrString(m, 'normalize');
    Py_DECREF(m);
    if (!c->c_normalize)
        return 0;
    return 1;
}
",8954
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static void
FstringParser_Dealloc(FstringParser *state)
{
    FstringParser_check_invariants(state);

    Py_XDECREF(state->last_str);
    ExprList_Dealloc(&state->expr_list);
}
",8955
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"mod_ty
Expression(expr_ty body, PyArena *arena)
{
    mod_ty p;
    if (!body) {
        PyErr_SetString(PyExc_ValueError,
                        'field body is required for Expression');
        return NULL;
    }
    p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Expression_kind;
    p->v.Expression.body = body;
    return p;
}
",8956
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
AsyncWith(asdl_seq * items, asdl_seq * body, string type_comment, int lineno,
          int col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = AsyncWith_kind;
    p->v.AsyncWith.items = items;
    p->v.AsyncWith.body = body;
    p->v.AsyncWith.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8957
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Compare(expr_ty left, asdl_int_seq * ops, asdl_seq * comparators, int lineno,
        int col_offset, PyArena *arena)
{
    expr_ty p;
    if (!left) {
        PyErr_SetString(PyExc_ValueError,
                        'field left is required for Compare');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Compare_kind;
    p->v.Compare.left = left;
    p->v.Compare.ops = ops;
    p->v.Compare.comparators = comparators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8958
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty ast_for_testlist_comp(struct compiling *, const node *);
",8959
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static void
FstringParser_Init(FstringParser *state)
{
    state->last_str = NULL;
    state->fmode = 0;
    ExprList_Init(&state->expr_list);
    FstringParser_check_invariants(state);
}
",8960
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_decorator(struct compiling *c, const node *n)
{
    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
    expr_ty d = NULL;
    expr_ty name_expr;

    REQ(n, decorator);
    REQ(CHILD(n, 0), AT);
    REQ(RCHILD(n, -1), NEWLINE);

    name_expr = ast_for_dotted_name(c, CHILD(n, 1));
    if (!name_expr)
        return NULL;

    if (NCH(n) == 3) { /* No arguments */
        d = name_expr;
        name_expr = NULL;
    }
    else if (NCH(n) == 5) { /* Call with no arguments */
        d = Call(name_expr, NULL, NULL, LINENO(n),
                 n->n_col_offset, c->c_arena);
        if (!d)
            return NULL;
        name_expr = NULL;
    }
    else {
        d = ast_for_call(c, CHILD(n, 3), name_expr, true);
        if (!d)
            return NULL;
        name_expr = NULL;
    }

    return d;
}
",8961
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"excepthandler_ty
ExceptHandler(expr_ty type, identifier name, asdl_seq * body, int lineno, int
              col_offset, PyArena *arena)
{
    excepthandler_ty p;
    p = (excepthandler_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ExceptHandler_kind;
    p->v.ExceptHandler.type = type;
    p->v.ExceptHandler.name = name;
    p->v.ExceptHandler.body = body;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8962
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int exists_not_none(PyObject *obj, _Py_Identifier *id)
{
    int isnone;
    PyObject *attr = _PyObject_GetAttrId(obj, id);
    if (!attr) {
        PyErr_Clear();
        return 0;
    }
    isnone = attr == Py_None;
    Py_DECREF(attr);
    return !isnone;
}
",8963
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static stmt_ty
ast_for_classdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)
{
    /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */
    PyObject *classname;
    asdl_seq *s;
    expr_ty call;

    REQ(n, classdef);

    if (NCH(n) == 4) { /* class NAME ':' suite */
        s = ast_for_suite(c, CHILD(n, 3));
        if (!s)
            return NULL;
        classname = NEW_IDENTIFIER(CHILD(n, 1));
        if (!classname)
            return NULL;
        if (forbidden_name(c, classname, CHILD(n, 3), 0))
            return NULL;
        return ClassDef(classname, NULL, NULL, s, decorator_seq,
                        LINENO(n), n->n_col_offset, c->c_arena);
    }

    if (TYPE(CHILD(n, 3)) == RPAR) { /* class NAME '(' ')' ':' suite */
        s = ast_for_suite(c, CHILD(n, 5));
        if (!s)
            return NULL;
        classname = NEW_IDENTIFIER(CHILD(n, 1));
        if (!classname)
            return NULL;
        if (forbidden_name(c, classname, CHILD(n, 3), 0))
            return NULL;
        return ClassDef(classname, NULL, NULL, s, decorator_seq,
                        LINENO(n), n->n_col_offset, c->c_arena);
    }

    /* class NAME '(' arglist ')' ':' suite */
    /* build up a fake Call node so we can extract its pieces */
    {
        PyObject *dummy_name;
        expr_ty dummy;
        dummy_name = NEW_IDENTIFIER(CHILD(n, 1));
        if (!dummy_name)
            return NULL;
        dummy = Name(dummy_name, Load, LINENO(n), n->n_col_offset, c->c_arena);
        call = ast_for_call(c, CHILD(n, 3), dummy, false);
        if (!call)
            return NULL;
    }
    s = ast_for_suite(c, CHILD(n, 6));
    if (!s)
        return NULL;
    classname = NEW_IDENTIFIER(CHILD(n, 1));
    if (!classname)
        return NULL;
    if (forbidden_name(c, classname, CHILD(n, 1), 0))
        return NULL;

    return ClassDef(classname, call->v.Call.args, call->v.Call.keywords, s,
                    decorator_seq, LINENO(n), n->n_col_offset, c->c_arena);
}
",8964
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Str(string s, string kind, int lineno, int col_offset, PyArena *arena)
{
    expr_ty p;
    if (!s) {
        PyErr_SetString(PyExc_ValueError,
                        'field s is required for Str');
        return NULL;
    }
    if (!kind) {
        PyErr_SetString(PyExc_ValueError,
                        'field kind is required for Str');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Str_kind;
    p->v.Str.s = s;
    p->v.Str.kind = kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8965
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_setcomp(struct compiling *c, const node *n)
{
    assert(TYPE(n) == (dictorsetmaker));
    return ast_for_itercomp(c, n, COMP_SETCOMP);
}
",8966
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static asdl_seq *
ast_for_suite(struct compiling *c, const node *n)
{
    /* suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT */
    asdl_seq *seq;
    stmt_ty s;
    int i, total, num, end, pos = 0;
    node *ch;

    REQ(n, suite);

    total = num_stmts(n);
    seq = asdl_seq_new(total, c->c_arena);
    if (!seq)
        return NULL;
    if (TYPE(CHILD(n, 0)) == simple_stmt) {
        n = CHILD(n, 0);
        /* simple_stmt always ends with a NEWLINE,
           and may have a trailing SEMI
        */
        end = NCH(n) - 1;
        if (TYPE(CHILD(n, end - 1)) == SEMI)
            end--;
        /* loop by 2 to skip semi-colons */
        for (i = 0; i < end; i += 2) {
            ch = CHILD(n, i);
            s = ast_for_stmt(c, ch);
            if (!s)
                return NULL;
            asdl_seq_SET(seq, pos++, s);
        }
    }
    else {
        i = 2;
        if (TYPE(CHILD(n, 1)) == TYPE_COMMENT)
            i += 2;

        for (; i < (NCH(n) - 1); i++) {
            ch = CHILD(n, i);
            REQ(ch, stmt);
            num = num_stmts(ch);
            if (num == 1) {
                /* small_stmt or compound_stmt with only one child */
                s = ast_for_stmt(c, ch);
                if (!s)
                    return NULL;
                asdl_seq_SET(seq, pos++, s);
            }
            else {
                int j;
                ch = CHILD(ch, 0);
                REQ(ch, simple_stmt);
                for (j = 0; j < NCH(ch); j += 2) {
                    /* statement terminates with a semi-colon ';' */
                    if (NCH(CHILD(ch, j)) == 0) {
                        assert((j + 1) == NCH(ch));
                        break;
                    }
                    s = ast_for_stmt(c, CHILD(ch, j));
                    if (!s)
                        return NULL;
                    asdl_seq_SET(seq, pos++, s);
                }
            }
        }
    }
    assert(pos == seq->size);
    return seq;
}
",8967
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"PyObject* ast2obj_expr_context(expr_context_ty o)
{
    switch(o) {
        case Load:
            Py_INCREF(Load_singleton);
            return Load_singleton;
        case Store:
            Py_INCREF(Store_singleton);
            return Store_singleton;
        case Del:
            Py_INCREF(Del_singleton);
            return Del_singleton;
        case AugLoad:
            Py_INCREF(AugLoad_singleton);
            return AugLoad_singleton;
        case AugStore:
            Py_INCREF(AugStore_singleton);
            return AugStore_singleton;
        case Param:
            Py_INCREF(Param_singleton);
            return Param_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, 'unknown expr_context found');
            return NULL;
    }
}
",8968
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"int Ta3AST_Check(PyObject* obj)
{
    if (!init_types())
        return -1;
    return PyObject_IsInstance(obj, (PyObject*)&AST_type);
}
",8969
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static stmt_ty
ast_for_import_stmt(struct compiling *c, const node *n)
{
    /*
      import_stmt: import_name | import_from
      import_name: 'import' dotted_as_names
      import_from: 'from' ('.'* dotted_name | '.') 'import'
                          ('*' | '(' import_as_names ')' | import_as_names)
    */
    int lineno;
    int col_offset;
    int i;
    asdl_seq *aliases;

    REQ(n, import_stmt);
    lineno = LINENO(n);
    col_offset = n->n_col_offset;
    n = CHILD(n, 0);
    if (TYPE(n) == import_name) {
        n = CHILD(n, 1);
        REQ(n, dotted_as_names);
        aliases = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);
        if (!aliases)
            return NULL;
        for (i = 0; i < NCH(n); i += 2) {
            alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);
            if (!import_alias)
                return NULL;
            asdl_seq_SET(aliases, i / 2, import_alias);
        }
        return Import(aliases, lineno, col_offset, c->c_arena);
    }
    else if (TYPE(n) == import_from) {
        int n_children;
        int idx, ndots = 0;
        alias_ty mod = NULL;
        identifier modname = NULL;

       /* Count the number of dots (for relative imports) and check for the
          optional module name */
        for (idx = 1; idx < NCH(n); idx++) {
            if (TYPE(CHILD(n, idx)) == dotted_name) {
                mod = alias_for_import_name(c, CHILD(n, idx), 0);
                if (!mod)
                    return NULL;
                idx++;
                break;
            } else if (TYPE(CHILD(n, idx)) != DOT) {
                break;
            }
            ndots++;
        }
        idx++; /* skip over the 'import' keyword */
        switch (TYPE(CHILD(n, idx))) {
        case STAR:
            /* from ... import * */
            n = CHILD(n, idx);
            n_children = 1;
            break;
        case LPAR:
            /* from ... import (x, y, z) */
            n = CHILD(n, idx + 1);
            n_children = NCH(n);
            break;
        case import_as_names:
            /* from ... import x, y, z */
            n = CHILD(n, idx);
            n_children = NCH(n);
            if (n_children % 2 == 0) {
                ast_error(n, 'trailing comma not allowed without'
                             ' surrounding parentheses');
                return NULL;
            }
            break;
        default:
            ast_error(n, 'Unexpected node-type in from-import');
            return NULL;
        }

        aliases = asdl_seq_new((n_children + 1) / 2, c->c_arena);
        if (!aliases)
            return NULL;

        /* handle 'from ... import *' special b/c there's no children */
        if (TYPE(n) == STAR) {
            alias_ty import_alias = alias_for_import_name(c, n, 1);
            if (!import_alias)
                return NULL;
                asdl_seq_SET(aliases, 0, import_alias);
        }
        else {
            for (i = 0; i < NCH(n); i += 2) {
                alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);
                if (!import_alias)
                    return NULL;
                    asdl_seq_SET(aliases, i / 2, import_alias);
            }
        }
        if (mod != NULL)
            modname = mod->name;
        return ImportFrom(modname, aliases, ndots, lineno, col_offset,
                          c->c_arena);
    }
    PyErr_Format(PyExc_SystemError,
                 'unknown import statement: starts with command '%s'',
                 STR(CHILD(n, 0)));
    return NULL;
}
",8970
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject* ast2obj_list(asdl_seq *seq, PyObject* (*func)(void*))
{
    Py_ssize_t i, n = asdl_seq_LEN(seq);
    PyObject *result = PyList_New(n);
    PyObject *value;
    if (!result)
        return NULL;
    for (i = 0; i < n; i++) {
        value = func(asdl_seq_GET(seq, i));
        if (!value) {
            Py_DECREF(result);
            return NULL;
        }
        PyList_SET_ITEM(result, i, value);
    }
    return result;
}
",8971
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"struct tok_state *
Ta3Tokenizer_FromUTF8(const char *str, int exec_input)
{
    struct tok_state *tok = tok_new();
    if (tok == NULL)
        return NULL;
#ifndef PGEN
    tok->input = str = translate_newlines(str, exec_input, tok);
#endif
    if (str == NULL) {
        Ta3Tokenizer_Free(tok);
        return NULL;
    }
    tok->decoding_state = STATE_RAW;
    tok->read_coding_spec = 1;
    tok->enc = NULL;
    tok->str = str;
    tok->encoding = (char *)PyMem_MALLOC(6);
    if (!tok->encoding) {
        Ta3Tokenizer_Free(tok);
        return NULL;
    }
    strcpy(tok->encoding, 'utf-8');

    /* XXX: constify members. */
    tok->buf = tok->cur = tok->end = tok->inp = (char*)str;
    return tok;
}
",8972
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Bytes(bytes s, int lineno, int col_offset, PyArena *arena)
{
    expr_ty p;
    if (!s) {
        PyErr_SetString(PyExc_ValueError,
                        'field s is required for Bytes');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Bytes_kind;
    p->v.Bytes.s = s;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8973
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Subscript(expr_ty value, slice_ty slice, expr_context_ty ctx, int lineno, int
          col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        'field value is required for Subscript');
        return NULL;
    }
    if (!slice) {
        PyErr_SetString(PyExc_ValueError,
                        'field slice is required for Subscript');
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        'field ctx is required for Subscript');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Subscript_kind;
    p->v.Subscript.value = value;
    p->v.Subscript.slice = slice;
    p->v.Subscript.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8974
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
JoinedStr(asdl_seq * values, int lineno, int col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = JoinedStr_kind;
    p->v.JoinedStr.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8975
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static asdl_seq *
ast_for_comprehension(struct compiling *c, const node *n)
{
    int i, n_fors;
    asdl_seq *comps;

    n_fors = count_comp_fors(c, n);
    if (n_fors == -1)
        return NULL;

    comps = _Ta3_asdl_seq_new(n_fors, c->c_arena);
    if (!comps)
        return NULL;

    for (i = 0; i < n_fors; i++) {
        comprehension_ty comp;
        asdl_seq *t;
        expr_ty expression, first;
        node *for_ch;
        node *sync_n;
        int is_async = 0;

        REQ(n, comp_for);

        if (NCH(n) == 2) {
            is_async = 1;
            REQ(CHILD(n, 0), ASYNC);
            sync_n = CHILD(n, 1);
        }
        else {
            sync_n = CHILD(n, 0);
        }
        REQ(sync_n, sync_comp_for);

        /* Async comprehensions only allowed in Python 3.6 and greater */
        if (is_async && c->c_feature_version < 6) {
            ast_error(c, n,
                    'Async comprehensions are only supported in Python 3.6 and greater');
            return NULL;
        }

        for_ch = CHILD(sync_n, 1);
        t = ast_for_exprlist(c, for_ch, Store);
        if (!t)
            return NULL;
        expression = ast_for_expr(c, CHILD(sync_n, 3));
        if (!expression)
            return NULL;

        /* Check the # of children rather than the length of t, since
           (x for x, in ...) has 1 element in t, but still requires a Tuple. */
        first = (expr_ty)asdl_seq_GET(t, 0);
        if (NCH(for_ch) == 1)
            comp = comprehension(first, expression, NULL,
                                 is_async, c->c_arena);
        else
            comp = comprehension(Tuple(t, Store, first->lineno,
                                       first->col_offset, c->c_arena),
                                 expression, NULL, is_async, c->c_arena);
        if (!comp)
            return NULL;

        if (NCH(sync_n) == 5) {
            int j, n_ifs;
            asdl_seq *ifs;

            n = CHILD(sync_n, 4);
            n_ifs = count_comp_ifs(c, n);
            if (n_ifs == -1)
                return NULL;

            ifs = _Ta3_asdl_seq_new(n_ifs, c->c_arena);
            if (!ifs)
                return NULL;

            for (j = 0; j < n_ifs; j++) {
                REQ(n, comp_iter);
                n = CHILD(n, 0);
                REQ(n, comp_if);

                expression = ast_for_expr(c, CHILD(n, 1));
                if (!expression)
                    return NULL;
                asdl_seq_SET(ifs, j, expression);
                if (NCH(n) == 3)
                    n = CHILD(n, 2);
            }
            /* on exit, must guarantee that n is a comp_for */
            if (TYPE(n) == comp_iter)
                n = CHILD(n, 0);
            comp->ifs = ifs;
        }
        asdl_seq_SET(comps, i, comp);
    }
    return comps;
}
",8976
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
AsyncWith(asdl_seq * items, asdl_seq * body, string type_comment, int lineno,
          int col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = AsyncWith_kind;
    p->v.AsyncWith.items = items;
    p->v.AsyncWith.body = body;
    p->v.AsyncWith.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8977
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
validate_exprs(asdl_seq *exprs, expr_context_ty ctx, int null_ok)
{
    int i;
    for (i = 0; i < asdl_seq_LEN(exprs); i++) {
        expr_ty expr = asdl_seq_GET(exprs, i);
        if (expr) {
            if (!validate_expr(expr, ctx))
                return 0;
        }
        else if (!null_ok) {
            PyErr_SetString(PyExc_ValueError,
                            'None disallowed in expression list');
            return 0;
        }

    }
    return 1;
}
",8978
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static char *
decoding_fgets(char *s, int size, struct tok_state *tok)
{
    char *line = NULL;
    int badchar = 0;
    for (;;) {
        if (tok->decoding_state == STATE_NORMAL) {
            /* We already have a codec associated with
               this input. */
            line = fp_readl(s, size, tok);
            break;
        } else if (tok->decoding_state == STATE_RAW) {
            /* We want a 'raw' read. */
            line = Py_UniversalNewlineFgets(s, size,
                                            tok->fp, NULL);
            break;
        } else {
            /* We have not yet determined the encoding.
               If an encoding is found, use the file-pointer
               reader functions from now on. */
            if (!check_bom(fp_getc, fp_ungetc, fp_setreadl, tok))
                return error_ret(tok);
            assert(tok->decoding_state != STATE_INIT);
        }
    }
    if (line != NULL && tok->lineno < 2 && !tok->read_coding_spec) {
        if (!check_coding_spec(line, strlen(line), tok, fp_setreadl)) {
            return error_ret(tok);
        }
    }
#ifndef PGEN
    /* The default encoding is UTF-8, so make sure we don't have any
       non-UTF-8 sequences in it. */
    if (line && !tok->encoding) {
        unsigned char *c;
        int length;
        for (c = (unsigned char *)line; *c; c += length)
            if (!(length = valid_utf8(c))) {
                badchar = *c;
                break;
            }
    }
    if (badchar) {
        /* Need to add 1 to the line number, since this line
           has not been counted, yet.  */
        PyErr_Format(PyExc_SyntaxError,
                'Non-UTF-8 code starting with '\\x%.2x' '
                'in file %U on line %i, '
                'but no encoding declared; '
                'see http://python.org/dev/peps/pep-0263/ for details',
                badchar, tok->filename, tok->lineno + 1);
        return error_ret(tok);
    }
#endif
    return line;
}
",8979
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_itercomp(struct compiling *c, const node *n, int type)
{
    expr_ty elt;
    asdl_seq *comps;

    assert(NCH(n) > 1);

    elt = ast_for_expr(c, CHILD(n, 0));
    if (!elt)
        return NULL;

    comps = ast_for_comprehension(c, CHILD(n, 1));
    if (!comps)
        return NULL;

    if (type == COMP_GENEXP)
        return GeneratorExp(elt, comps, LINENO(n), n->n_col_offset, c->c_arena);
    else if (type == COMP_SETCOMP)
        return SetComp(elt, comps, LINENO(n), n->n_col_offset, c->c_arena);
    else
        /* Should never happen */
        return NULL;
}
",8980
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int PARSER_FLAGS(PyCompilerFlags *flags)
{
    int parser_flags = 0;
    if (!flags)
        return 0;
    if (flags->cf_flags & PyCF_DONT_IMPLY_DEDENT)
        parser_flags |= PyPARSE_DONT_IMPLY_DEDENT;
    if (flags->cf_flags & PyCF_IGNORE_COOKIE)
        parser_flags |= PyPARSE_IGNORE_COOKIE;
    if (flags->cf_flags & CO_FUTURE_BARRY_AS_BDFL)
        parser_flags |= PyPARSE_BARRY_AS_BDFL;
    return parser_flags;
}
",8981
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int obj2ast_int(PyObject* obj, int* out, PyArena* arena)
{
    int i;
    if (!PyLong_Check(obj)) {
        PyErr_Format(PyExc_ValueError, 'invalid integer value: %R', obj);
        return 1;
    }

    i = _PyLong_AsInt(obj);
    if (i == -1 && PyErr_Occurred())
        return 1;
    *out = i;
    return 0;
}
",8982
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"int Ta3AST_Check(PyObject* obj)
{
    if (!init_types())
        return -1;
    return PyObject_IsInstance(obj, (PyObject*)&AST_type);
}
",8983
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject* ast2obj_list(asdl_seq *seq, PyObject* (*func)(void*))
{
    Py_ssize_t i, n = asdl_seq_LEN(seq);
    PyObject *result = PyList_New(n);
    PyObject *value;
    if (!result)
        return NULL;
    for (i = 0; i < n; i++) {
        value = func(asdl_seq_GET(seq, i));
        if (!value) {
            Py_DECREF(result);
            return NULL;
        }
        PyList_SET_ITEM(result, i, value);
    }
    return result;
}
",8984
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
ImportFrom(identifier module, asdl_seq * names, int level, int lineno, int
           col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ImportFrom_kind;
    p->v.ImportFrom.module = module;
    p->v.ImportFrom.names = names;
    p->v.ImportFrom.level = level;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8985
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
JoinedStr(asdl_seq * values, int lineno, int col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = JoinedStr_kind;
    p->v.JoinedStr.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8986
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject *
parsestr(struct compiling *c, const node *n, const char *s)
{
        size_t len, i;
        int quote = Py_CHARMASK(*s);
        int rawmode = 0;
        int need_encoding;
        int unicode = c->c_future_unicode;
        int bytes = 0;

        if (isalpha(quote) || quote == '_') {
                if (quote == 'u' || quote == 'U') {
                        quote = *++s;
                        unicode = 1;
                }
                if (quote == 'b' || quote == 'B') {
                        quote = *++s;
                        unicode = 0;
                        bytes = 1;
                }
                if (quote == 'r' || quote == 'R') {
                        quote = *++s;
                        rawmode = 1;
                }
        }
        if (quote != '\'' && quote != '\'') {
                PyErr_BadInternalCall();
                return NULL;
        }
        s++;
        len = strlen(s);
        if (len > INT_MAX) {
                PyErr_SetString(PyExc_OverflowError,
                                'string to parse is too long');
                return NULL;
        }
        if (s[--len] != quote) {
                PyErr_BadInternalCall();
                return NULL;
        }
        if (len >= 4 && s[0] == quote && s[1] == quote) {
                s += 2;
                len -= 2;
                if (s[--len] != quote || s[--len] != quote) {
                        PyErr_BadInternalCall();
                        return NULL;
                }
        }
        if (Py_Py3kWarningFlag && bytes) {
            for (i = 0; i < len; i++) {
                if ((unsigned char)s[i] > 127) {
                    if (!ast_warn(c, n,
                        'non-ascii bytes literals not supported in 3.x'))
                        return NULL;
                    break;
                }
            }
        }
#ifdef Py_USING_UNICODE
        if (unicode || Py_UnicodeFlag) {
                return decode_unicode(c, s, len, rawmode, c->c_encoding);
        }
#endif
        need_encoding = (c->c_encoding != NULL &&
                         strcmp(c->c_encoding, 'utf-8') != 0 &&
                         strcmp(c->c_encoding, 'iso-8859-1') != 0);
        if (rawmode || strchr(s, '\\') == NULL) {
                if (need_encoding) {
#ifndef Py_USING_UNICODE
                        /* This should not happen - we never see any other
                           encoding. */
                        Py_FatalError(
                            'cannot deal with encodings in this build.');
#else
                        PyObject *v, *u = PyUnicode_DecodeUTF8(s, len, NULL);
                        if (u == NULL)
                                return NULL;
                        v = PyUnicode_AsEncodedString(u, c->c_encoding, NULL);
                        Py_DECREF(u);
                        return v;
#endif
                } else {
                  return PyBytes_FromStringAndSize(s, len);
                }
        }

        return PyBytes_DecodeEscape(s, len, NULL, 1,
                                    need_encoding ? c->c_encoding : NULL);
}
",8987
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject *
_PyBytes_DecodeEscape(const char *s,
                      Py_ssize_t len,
                      const char *errors,
                      Py_ssize_t unicode,
                      const char *recode_encoding,
                      const char **first_invalid_escape)
{
    *first_invalid_escape = NULL;
    return PyBytes_DecodeEscape(s, len, errors, unicode, recode_encoding);
}
",8988
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject *
decode_bytes_with_escapes(struct compiling *c, const node *n, const char *s,
                          size_t len)
{
    const char *first_invalid_escape;
    PyObject *result = _PyBytes_DecodeEscape(s, len, NULL, 0, NULL,
                                             &first_invalid_escape);
    if (result == NULL)
        return NULL;

    if (first_invalid_escape != NULL) {
        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) < 0) {
            Py_DECREF(result);
            return NULL;
        }
    }
    return result;
}
",8989
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
fstring_find_expr(const char **str, const char *end, int raw, int recurse_lvl,
                  expr_ty *expression, struct compiling *c, const node *n)
{
    /* Return -1 on error, else 0. */

    const char *expr_start;
    const char *expr_end;
    expr_ty simple_expression;
    expr_ty format_spec = NULL; /* Optional format specifier. */
    int conversion = -1; /* The conversion char. -1 if not specified. */

    /* 0 if we're not in a string, else the quote char we're trying to
       match (single or double quote). */
    char quote_char = 0;

    /* If we're inside a string, 1=normal, 3=triple-quoted. */
    int string_type = 0;

    /* Keep track of nesting level for braces/parens/brackets in
       expressions. */
    Py_ssize_t nested_depth = 0;

    /* Can only nest one level deep. */
    if (recurse_lvl >= 2) {
        ast_error(c, n, 'f-string: expressions nested too deeply');
        return -1;
    }

    /* The first char must be a left brace, or we wouldn't have gotten
       here. Skip over it. */
    assert(**str == '{');
    *str += 1;

    expr_start = *str;
    for (; *str < end; (*str)++) {
        char ch;

        /* Loop invariants. */
        assert(nested_depth >= 0);
        assert(*str >= expr_start && *str < end);
        if (quote_char)
            assert(string_type == 1 || string_type == 3);
        else
            assert(string_type == 0);

        ch = **str;
        /* Nowhere inside an expression is a backslash allowed. */
        if (ch == '\\') {
            /* Error: can't include a backslash character, inside
               parens or strings or not. */
            ast_error(c, n, 'f-string expression part '
                            'cannot include a backslash');
            return -1;
        }
        if (quote_char) {
            /* We're inside a string. See if we're at the end. */
            /* This code needs to implement the same non-error logic
               as tok_get from tokenizer.c, at the letter_quote
               label. To actually share that code would be a
               nightmare. But, it's unlikely to change and is small,
               so duplicate it here. Note we don't need to catch all
               of the errors, since they'll be caught when parsing the
               expression. We just need to match the non-error
               cases. Thus we can ignore \n in single-quoted strings,
               for example. Or non-terminated strings. */
            if (ch == quote_char) {
                /* Does this match the string_type (single or triple
                   quoted)? */
                if (string_type == 3) {
                    if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {
                        /* We're at the end of a triple quoted string. */
                        *str += 2;
                        string_type = 0;
                        quote_char = 0;
                        continue;
                    }
                } else {
                    /* We're at the end of a normal string. */
                    quote_char = 0;
                    string_type = 0;
                    continue;
                }
            }
        } else if (ch == '\'' || ch == ''') {
            /* Is this a triple quoted string? */
            if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {
                string_type = 3;
                *str += 2;
            } else {
                /* Start of a normal string. */
                string_type = 1;
            }
            /* Start looking for the end of the string. */
            quote_char = ch;
        } else if (ch == '[' || ch == '{' || ch == '(') {
            nested_depth++;
        } else if (nested_depth != 0 &&
                   (ch == ']' || ch == '}' || ch == ')')) {
            nested_depth--;
        } else if (ch == '#') {
            /* Error: can't include a comment character, inside parens
               or not. */
            ast_error(c, n, 'f-string expression part cannot include '#'');
            return -1;
        } else if (nested_depth == 0 &&
                   (ch == '!' || ch == ':' || ch == '}')) {
            /* First, test for the special case of '!='. Since '=' is
               not an allowed conversion character, nothing is lost in
               this test. */
            if (ch == '!' && *str+1 < end && *(*str+1) == '=') {
                /* This isn't a conversion character, just continue. */
                continue;
            }
            /* Normal way out of this loop. */
            break;
        } else {
            /* Just consume this char and loop around. */
        }
    }
    expr_end = *str;
    /* If we leave this loop in a string or with mismatched parens, we
       don't care. We'll get a syntax error when compiling the
       expression. But, we can produce a better error message, so
       let's just do that.*/
    if (quote_char) {
        ast_error(c, n, 'f-string: unterminated string');
        return -1;
    }
    if (nested_depth) {
        ast_error(c, n, 'f-string: mismatched '(', '{', or '['');
        return -1;
    }

    if (*str >= end)
        goto unexpected_end_of_string;

    /* Compile the expression as soon as possible, so we show errors
       related to the expression before errors related to the
       conversion or format_spec. */
    simple_expression = fstring_compile_expr(expr_start, expr_end, c, n);
    if (!simple_expression)
        return -1;

    /* Check for a conversion char, if present. */
    if (**str == '!') {
        *str += 1;
        if (*str >= end)
            goto unexpected_end_of_string;

        conversion = **str;
        *str += 1;

        /* Validate the conversion. */
        if (!(conversion == 's' || conversion == 'r'
              || conversion == 'a')) {
            ast_error(c, n, 'f-string: invalid conversion character: '
                            'expected 's', 'r', or 'a'');
            return -1;
        }
    }

    /* Check for the format spec, if present. */
    if (*str >= end)
        goto unexpected_end_of_string;
    if (**str == ':') {
        *str += 1;
        if (*str >= end)
            goto unexpected_end_of_string;

        /* Parse the format spec. */
        format_spec = fstring_parse(str, end, raw, recurse_lvl+1, c, n);
        if (!format_spec)
            return -1;
    }

    if (*str >= end || **str != '}')
        goto unexpected_end_of_string;

    /* We're at a right brace. Consume it. */
    assert(*str < end);
    assert(**str == '}');
    *str += 1;

    /* And now create the FormattedValue node that represents this
       entire expression with the conversion and format spec. */
    *expression = FormattedValue(simple_expression, conversion,
                                 format_spec, LINENO(n), n->n_col_offset,
                                 c->c_arena);
    if (!*expression)
        return -1;

    return 0;

unexpected_end_of_string:
    ast_error(c, n, 'f-string: expecting '}'');
    return -1;
}
",8990
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static void
ast_error_finish(const char *filename)
{
    PyObject *type, *value, *tback, *errstr, *loc, *tmp;
    long lineno;

    assert(PyErr_Occurred());
    if (!PyErr_ExceptionMatches(PyExc_SyntaxError))
        return;

    PyErr_Fetch(&type, &value, &tback);
    errstr = PyTuple_GetItem(value, 0);
    if (!errstr)
        return;
    Py_INCREF(errstr);
    lineno = PyLong_AsLong(PyTuple_GetItem(value, 1));
    if (lineno == -1) {
        Py_DECREF(errstr);
        return;
    }
    Py_DECREF(value);

    loc = PyErr_ProgramText(filename, lineno);
    if (!loc) {
        Py_INCREF(Py_None);
        loc = Py_None;
    }
    tmp = Py_BuildValue('(zlOO)', filename, lineno, Py_None, loc);
    Py_DECREF(loc);
    if (!tmp) {
        Py_DECREF(errstr);
        return;
    }
    value = PyTuple_Pack(2, errstr, tmp);
    Py_DECREF(errstr);
    Py_DECREF(tmp);
    if (!value)
        return;
    PyErr_Restore(type, value, tback);
}
",8991
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_power(struct compiling *c, const node *n)
{
    /* power: atom trailer* ('**' factor)*
     */
    int i;
    expr_ty e, tmp;
    REQ(n, power);
    e = ast_for_atom(c, CHILD(n, 0));
    if (!e)
        return NULL;
    if (NCH(n) == 1)
        return e;
    for (i = 1; i < NCH(n); i++) {
        node *ch = CHILD(n, i);
        if (TYPE(ch) != trailer)
            break;
        tmp = ast_for_trailer(c, ch, e);
        if (!tmp)
            return NULL;
        tmp->lineno = e->lineno;
        tmp->col_offset = e->col_offset;
        e = tmp;
    }
    if (TYPE(CHILD(n, NCH(n) - 1)) == factor) {
        expr_ty f = ast_for_expr(c, CHILD(n, NCH(n) - 1));
        if (!f)
            return NULL;
        tmp = BinOp(e, Pow, f, LINENO(n), n->n_col_offset, c->c_arena);
        if (!tmp)
            return NULL;
        e = tmp;
    }
    return e;
}
",8992
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"int
obj2ast_expr_context(PyObject* obj, expr_context_ty* out, PyArena* arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, (PyObject *)Load_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Load;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)Store_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Store;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)Del_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Del;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)AugLoad_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = AugLoad;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)AugStore_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = AugStore;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)Param_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Param;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of expr_context, but got %R', obj);
    return 1;
}
",8993
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static stmt_ty
ast_for_exec_stmt(struct compiling *c, const node *n)
{
    expr_ty expr1, globals = NULL, locals = NULL;
    int n_children = NCH(n);
    if (n_children != 2 && n_children != 4 && n_children != 6) {
        PyErr_Format(PyExc_SystemError,
                     'poorly formed 'exec' statement: %d parts to statement',
                     n_children);
        return NULL;
    }

    /* exec_stmt: 'exec' expr ['in' test [',' test]] */
    REQ(n, exec_stmt);
    expr1 = ast_for_expr(c, CHILD(n, 1));
    if (!expr1)
        return NULL;

    if (expr1->kind == Tuple_kind && n_children < 4 &&
        (asdl_seq_LEN(expr1->v.Tuple.elts) == 2 ||
         asdl_seq_LEN(expr1->v.Tuple.elts) == 3)) {
        /* Backwards compatibility: passing exec args as a tuple */
        globals = asdl_seq_GET(expr1->v.Tuple.elts, 1);
        if (asdl_seq_LEN(expr1->v.Tuple.elts) == 3) {
            locals = asdl_seq_GET(expr1->v.Tuple.elts, 2);
        }
        expr1 = asdl_seq_GET(expr1->v.Tuple.elts, 0);
    }

    if (n_children >= 4) {
        globals = ast_for_expr(c, CHILD(n, 3));
        if (!globals)
            return NULL;
    }
    if (n_children == 6) {
        locals = ast_for_expr(c, CHILD(n, 5));
        if (!locals)
            return NULL;
    }

    return Exec(expr1, globals, locals, LINENO(n), n->n_col_offset,
                c->c_arena);
}
",8994
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static arg_ty
ast_for_arg(struct compiling *c, const node *n)
{
    identifier name;
    expr_ty annotation = NULL;
    node *ch;
    arg_ty ret;

    assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);
    ch = CHILD(n, 0);
    name = NEW_IDENTIFIER(ch);
    if (!name)
        return NULL;
    if (forbidden_name(c, name, ch, 0))
        return NULL;

    if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {
        annotation = ast_for_expr(c, CHILD(n, 2));
        if (!annotation)
            return NULL;
    }

    ret = arg(name, annotation, NULL, LINENO(n), n->n_col_offset, c->c_arena);
    if (!ret)
        return NULL;
    return ret;
}
",8995
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Constant(constant value, int lineno, int col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        'field value is required for Constant');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Constant_kind;
    p->v.Constant.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",8996
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_dictcomp(struct compiling *c, const node *n)
{
    expr_ty key, value;
    asdl_seq *comps;
    int i = 0;

    if (!ast_for_dictelement(c, n, &i, &key, &value))
        return NULL;
    assert(key);
    assert(NCH(n) - i >= 1);

    comps = ast_for_comprehension(c, CHILD(n, i));
    if (!comps)
        return NULL;

    return DictComp(key, value, comps, LINENO(n), n->n_col_offset, c->c_arena);
}
",8997
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static asdl_seq *
seq_for_testlist(struct compiling *c, const node *n)
{
    /* testlist: test (',' test)* [',']
       testlist_star_expr: test|star_expr (',' test|star_expr)* [',']
    */
    asdl_seq *seq;
    expr_ty expression;
    int i;
    assert(TYPE(n) == testlist || TYPE(n) == testlist_star_expr || TYPE(n) == testlist_comp);

    seq = _Ta3_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);
    if (!seq)
        return NULL;

    for (i = 0; i < NCH(n); i += 2) {
        const node *ch = CHILD(n, i);
        assert(TYPE(ch) == test || TYPE(ch) == test_nocond || TYPE(ch) == star_expr);

        expression = ast_for_expr(c, ch);
        if (!expression)
            return NULL;

        assert(i / 2 < seq->size);
        asdl_seq_SET(seq, i / 2, expression);
    }
    return seq;
}
",8998
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static char *
error_ret(struct tok_state *tok) /* XXX */
{
    tok->decoding_erred = 1;
    if (tok->fp != NULL && tok->buf != NULL) /* see Ta3Tokenizer_Free */
        PyMem_FREE(tok->buf);
    tok->buf = tok->cur = tok->end = tok->inp = tok->start = NULL;
    tok->done = E_DECODE;
    return NULL;                /* as if it were EOF */
}
",8999
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"mod_ty Ta3AST_obj2mod(PyObject* ast, PyArena* arena, int mode)
{
    mod_ty res;
    PyObject *req_type[3];
    char *req_name[] = {'Module', 'Expression', 'Interactive'};
    int isinstance;

    req_type[0] = (PyObject*)Module_type;
    req_type[1] = (PyObject*)Expression_type;
    req_type[2] = (PyObject*)Interactive_type;

    assert(0 <= mode && mode <= 2);

    if (!init_types())
        return NULL;

    isinstance = PyObject_IsInstance(ast, req_type[mode]);
    if (isinstance == -1)
        return NULL;
    if (!isinstance) {
        PyErr_Format(PyExc_TypeError, 'expected %s node, got %.400s',
                     req_name[mode], Py_TYPE(ast)->tp_name);
        return NULL;
    }
    if (obj2ast_mod(ast, &res, arena) != 0)
        return NULL;
    else
        return res;
}
",9000
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Dict(asdl_seq * keys, asdl_seq * values, int lineno, int col_offset, PyArena
     *arena)
{
    expr_ty p;
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Dict_kind;
    p->v.Dict.keys = keys;
    p->v.Dict.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",9001
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static asdl_seq *
ast_for_suite(struct compiling *c, const node *n)
{
    /* suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT */
    asdl_seq *seq;
    stmt_ty s;
    int i, total, num, end, pos = 0;
    node *ch;

    REQ(n, suite);

    total = num_stmts(n);
    seq = _Ta3_asdl_seq_new(total, c->c_arena);
    if (!seq)
        return NULL;
    if (TYPE(CHILD(n, 0)) == simple_stmt) {
        n = CHILD(n, 0);
        /* simple_stmt always ends with a NEWLINE,
           and may have a trailing SEMI
        */
        end = NCH(n) - 1;
        if (TYPE(CHILD(n, end - 1)) == SEMI)
            end--;
        /* loop by 2 to skip semi-colons */
        for (i = 0; i < end; i += 2) {
            ch = CHILD(n, i);
            s = ast_for_stmt(c, ch);
            if (!s)
                return NULL;
            asdl_seq_SET(seq, pos++, s);
        }
    }
    else {
        i = 2;
        if (TYPE(CHILD(n, 1)) == TYPE_COMMENT)
            i += 2;

        for (; i < (NCH(n) - 1); i++) {
            ch = CHILD(n, i);
            REQ(ch, stmt);
            num = num_stmts(ch);
            if (num == 1) {
                /* small_stmt or compound_stmt with only one child */
                s = ast_for_stmt(c, ch);
                if (!s)
                    return NULL;
                asdl_seq_SET(seq, pos++, s);
            }
            else {
                int j;
                ch = CHILD(ch, 0);
                REQ(ch, simple_stmt);
                for (j = 0; j < NCH(ch); j += 2) {
                    /* statement terminates with a semi-colon ';' */
                    if (NCH(CHILD(ch, j)) == 0) {
                        assert((j + 1) == NCH(ch));
                        break;
                    }
                    s = ast_for_stmt(c, CHILD(ch, j));
                    if (!s)
                        return NULL;
                    asdl_seq_SET(seq, pos++, s);
                }
            }
        }
    }
    assert(pos == seq->size);
    return seq;
}
",9002
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
compiler_complex_args(struct compiling *c, const node *n)
{
    int i, len = (NCH(n) + 1) / 2;
    expr_ty result;
    asdl_seq *args = asdl_seq_new(len, c->c_arena);
    if (!args)
        return NULL;

    /* fpdef: NAME | '(' fplist ')'
       fplist: fpdef (',' fpdef)* [',']
    */
    REQ(n, fplist);
    for (i = 0; i < len; i++) {
        PyObject *arg_id;
        const node *fpdef_node = CHILD(n, 2*i);
        const node *child;
        expr_ty arg;
set_name:
        /* fpdef_node is either a NAME or an fplist */
        child = CHILD(fpdef_node, 0);
        if (TYPE(child) == NAME) {
            if (!forbidden_check(c, n, STR(child)))
                return NULL;
            arg_id = NEW_IDENTIFIER(child);
            if (!arg_id)
                return NULL;
            arg = Name(arg_id, Store, LINENO(child), child->n_col_offset,
                       c->c_arena);
        }
        else {
            assert(TYPE(fpdef_node) == fpdef);
            /* fpdef_node[0] is not a name, so it must be '(', get CHILD[1] */
            child = CHILD(fpdef_node, 1);
            assert(TYPE(child) == fplist);
            /* NCH == 1 means we have (x), we need to elide the extra parens */
            if (NCH(child) == 1) {
                fpdef_node = CHILD(child, 0);
                assert(TYPE(fpdef_node) == fpdef);
                goto set_name;
            }
            arg = compiler_complex_args(c, child);
        }
        asdl_seq_SET(args, i, arg);
    }

    result = Tuple(args, Store, LINENO(n), n->n_col_offset, c->c_arena);
    if (!set_context(c, result, Store, n))
        return NULL;
    return result;
}
",9003
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static PyObject *
ast3_parse_impl(PyObject *source,
                PyObject *filename,
                const char *mode,
                int feature_version)
{
    PyObject *source_copy;
    const char *str;
    int compile_mode = -1;
    PyCompilerFlags cf;
    int start[] = {Py_file_input, Py_eval_input, Py_single_input, Py_func_type_input};
    PyObject *result;

    cf.cf_flags = PyCF_ONLY_AST | PyCF_SOURCE_IS_UTF8;

    if (strcmp(mode, 'exec') == 0)
        compile_mode = 0;
    else if (strcmp(mode, 'eval') == 0)
        compile_mode = 1;
    else if (strcmp(mode, 'single') == 0)
        compile_mode = 2;
    else if (strcmp(mode, 'func_type') == 0)
        compile_mode = 3;
    else {
        PyErr_SetString(PyExc_ValueError,
                        'parse() mode must be 'exec', 'eval', 'single', for 'func_type'');
        goto error;
    }

    str = source_as_string(source, 'parse', 'string or bytes', &cf, &source_copy);
    if (str == NULL)
        goto error;

    result = string_object_to_py_ast(str, filename, start[compile_mode], &cf, feature_version);
    Py_XDECREF(source_copy);
    goto finally;

error:
    result = NULL;
finally:
    Py_DECREF(filename);
    return result;
}
",9004
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"int
obj2ast_boolop(PyObject* obj, boolop_ty* out, PyArena* arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, (PyObject *)And_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = And;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, (PyObject *)Or_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Or;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, 'expected some sort of boolop, but got %R', obj);
    return 1;
}
",9005
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
Continue(int lineno, int col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Continue_kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",9006
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"PyObject* ast2obj_operator(operator_ty o)
{
    switch(o) {
        case Add:
            Py_INCREF(Add_singleton);
            return Add_singleton;
        case Sub:
            Py_INCREF(Sub_singleton);
            return Sub_singleton;
        case Mult:
            Py_INCREF(Mult_singleton);
            return Mult_singleton;
        case MatMult:
            Py_INCREF(MatMult_singleton);
            return MatMult_singleton;
        case Div:
            Py_INCREF(Div_singleton);
            return Div_singleton;
        case Mod:
            Py_INCREF(Mod_singleton);
            return Mod_singleton;
        case Pow:
            Py_INCREF(Pow_singleton);
            return Pow_singleton;
        case LShift:
            Py_INCREF(LShift_singleton);
            return LShift_singleton;
        case RShift:
            Py_INCREF(RShift_singleton);
            return RShift_singleton;
        case BitOr:
            Py_INCREF(BitOr_singleton);
            return BitOr_singleton;
        case BitXor:
            Py_INCREF(BitXor_singleton);
            return BitXor_singleton;
        case BitAnd:
            Py_INCREF(BitAnd_singleton);
            return BitAnd_singleton;
        case FloorDiv:
            Py_INCREF(FloorDiv_singleton);
            return FloorDiv_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, 'unknown operator found');
            return NULL;
    }
}
",9007
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static expr_ty
ast_for_genexp(struct compiling *c, const node *n)
{
    assert(TYPE(n) == (testlist_comp) || TYPE(n) == (argument));
    return ast_for_itercomp(c, n, COMP_GENEXP);
}
",9008
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
count_list_fors(struct compiling *c, const node *n)
{
    int n_fors = 0;
    node *ch = CHILD(n, 1);

 count_list_for:
    n_fors++;
    REQ(ch, list_for);
    if (NCH(ch) == 5)
        ch = CHILD(ch, 4);
    else
        return n_fors;
 count_list_iter:
    REQ(ch, list_iter);
    ch = CHILD(ch, 0);
    if (TYPE(ch) == list_for)
        goto count_list_for;
    else if (TYPE(ch) == list_if) {
        if (NCH(ch) == 3) {
            ch = CHILD(ch, 2);
            goto count_list_iter;
        }
        else
            return n_fors;
    }

    /* Should never be reached */
    PyErr_SetString(PyExc_SystemError, 'logic error in count_list_fors');
    return -1;
}
",9009
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int obj2ast_object(PyObject* obj, PyObject** out, PyArena* arena)
{
    if (obj == Py_None)
        obj = NULL;
    if (obj) {
        if (PyArena_AddPyObject(arena, obj) < 0) {
            *out = NULL;
            return -1;
        }
        Py_INCREF(obj);
    }
    *out = obj;
    return 0;
}
",9010
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static void
ExprList_check_invariants(ExprList *l)
{
    /* Check our invariants. Make sure this object is 'live', and
       hasn't been deallocated. */
    assert(l->size >= 0);
    assert(l->p != NULL);
    if (l->size <= EXPRLIST_N_CACHED)
        assert(l->data == l->p);
}
",9011
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static void
err_input(perrdetail *err)
{
    PyObject *v, *w, *errtype, *errtext;
    PyObject *msg_obj = NULL;
    char *msg = NULL;
    int offset = err->offset;

    errtype = PyExc_SyntaxError;
    switch (err->error) {
    case E_ERROR:
        return;
    case E_SYNTAX:
        errtype = PyExc_IndentationError;
        if (err->expected == INDENT)
            msg = 'expected an indented block';
        else if (err->token == INDENT)
            msg = 'unexpected indent';
        else if (err->token == DEDENT)
            msg = 'unexpected unindent';
        else {
            errtype = PyExc_SyntaxError;
            if (err->token == TYPE_COMMENT)
              msg = 'misplaced type annotation';
            else
            msg = 'invalid syntax';
        }
        break;
    case E_TOKEN:
        msg = 'invalid token';
        break;
    case E_EOFS:
        msg = 'EOF while scanning triple-quoted string literal';
        break;
    case E_EOLS:
        msg = 'EOL while scanning string literal';
        break;
    case E_INTR:
        if (!PyErr_Occurred())
            PyErr_SetNone(PyExc_KeyboardInterrupt);
        goto cleanup;
    case E_NOMEM:
        PyErr_NoMemory();
        goto cleanup;
    case E_EOF:
        msg = 'unexpected EOF while parsing';
        break;
    case E_TABSPACE:
        errtype = PyExc_TabError;
        msg = 'inconsistent use of tabs and spaces in indentation';
        break;
    case E_OVERFLOW:
        msg = 'expression too long';
        break;
    case E_DEDENT:
        errtype = PyExc_IndentationError;
        msg = 'unindent does not match any outer indentation level';
        break;
    case E_TOODEEP:
        errtype = PyExc_IndentationError;
        msg = 'too many levels of indentation';
        break;
    case E_DECODE: {
        PyObject *type, *value, *tb;
        PyErr_Fetch(&type, &value, &tb);
        msg = 'unknown decode error';
        if (value != NULL)
            msg_obj = PyObject_Str(value);
        Py_XDECREF(type);
        Py_XDECREF(value);
        Py_XDECREF(tb);
        break;
    }
    case E_LINECONT:
        msg = 'unexpected character after line continuation character';
        break;

    case E_IDENTIFIER:
        msg = 'invalid character in identifier';
        break;
    case E_BADSINGLE:
        msg = 'multiple statements found while compiling a single statement';
        break;
    default:
        fprintf(stderr, 'error=%d\n', err->error);
        msg = 'unknown parsing error';
        break;
    }
    /* err->text may not be UTF-8 in case of decoding errors.
       Explicitly convert to an object. */
    if (!err->text) {
        errtext = Py_None;
        Py_INCREF(Py_None);
    } else {
        errtext = PyUnicode_DecodeUTF8(err->text, err->offset,
                                       'replace');
        if (errtext != NULL) {
            Py_ssize_t len = strlen(err->text);
            offset = (int)PyUnicode_GET_LENGTH(errtext);
            if (len != err->offset) {
                Py_DECREF(errtext);
                errtext = PyUnicode_DecodeUTF8(err->text, len,
                                               'replace');
            }
        }
    }
    v = Py_BuildValue('(OiiN)', err->filename,
                      err->lineno, offset, errtext);
    if (v != NULL) {
        if (msg_obj)
            w = Py_BuildValue('(OO)', msg_obj, v);
        else
            w = Py_BuildValue('(sO)', msg, v);
    } else
        w = NULL;
    Py_XDECREF(v);
    PyErr_SetObject(errtype, w);
    Py_XDECREF(w);
cleanup:
    Py_XDECREF(msg_obj);
    if (err->text != NULL) {
        PyObject_FREE(err->text);
        err->text = NULL;
    }
}
",9012
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
While(expr_ty test, asdl_seq * body, asdl_seq * orelse, int lineno, int
      col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        'field test is required for While');
        return NULL;
    }
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = While_kind;
    p->v.While.test = test;
    p->v.While.body = body;
    p->v.While.orelse = orelse;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",9013
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
BinOp(expr_ty left, operator_ty op, expr_ty right, int lineno, int col_offset,
      PyArena *arena)
{
    expr_ty p;
    if (!left) {
        PyErr_SetString(PyExc_ValueError,
                        'field left is required for BinOp');
        return NULL;
    }
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        'field op is required for BinOp');
        return NULL;
    }
    if (!right) {
        PyErr_SetString(PyExc_ValueError,
                        'field right is required for BinOp');
        return NULL;
    }
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = BinOp_kind;
    p->v.BinOp.left = left;
    p->v.BinOp.op = op;
    p->v.BinOp.right = right;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",9014
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
validate_constant(PyObject *value)
{
    if (value == Py_None || value == Py_Ellipsis)
        return 1;

    if (PyLong_CheckExact(value)
            || PyFloat_CheckExact(value)
            || PyComplex_CheckExact(value)
            || PyBool_Check(value)
            || PyUnicode_CheckExact(value)
            || PyBytes_CheckExact(value))
        return 1;

    if (PyTuple_CheckExact(value) || PyFrozenSet_CheckExact(value)) {
        PyObject *it;

        it = PyObject_GetIter(value);
        if (it == NULL)
            return 0;

        while (1) {
            PyObject *item = PyIter_Next(it);
            if (item == NULL) {
                if (PyErr_Occurred()) {
                    Py_DECREF(it);
                    return 0;
                }
                break;
            }

            if (!validate_constant(item)) {
                Py_DECREF(it);
                Py_DECREF(item);
                return 0;
            }
            Py_DECREF(item);
        }

        Py_DECREF(it);
        return 1;
    }

    return 0;
}
",9015
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"mod_ty
Module(asdl_seq * body, asdl_seq * type_ignores, PyArena *arena)
{
    mod_ty p;
    p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Module_kind;
    p->v.Module.body = body;
    p->v.Module.type_ignores = type_ignores;
    return p;
}
",9016
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static int
set_context(struct compiling *c, expr_ty e, expr_context_ty ctx, const node *n)
{
    asdl_seq *s = NULL;
    /* If a particular expression type can't be used for assign / delete,
       set expr_name to its name and an error message will be generated.
    */
    const char* expr_name = NULL;

    /* The ast defines augmented store and load contexts, but the
       implementation here doesn't actually use them.  The code may be
       a little more complex than necessary as a result.  It also means
       that expressions in an augmented assignment have a Store context.
       Consider restructuring so that augmented assignment uses
       set_context(), too.
    */
    assert(ctx != AugStore && ctx != AugLoad);

    switch (e->kind) {
        case Attribute_kind:
            if (ctx == Store && !forbidden_check(c, n,
                                PyUnicode_AsUTF8(e->v.Attribute.attr)))
                    return 0;
            e->v.Attribute.ctx = ctx;
            break;
        case Subscript_kind:
            e->v.Subscript.ctx = ctx;
            break;
        case Name_kind:
            if (ctx == Store && !forbidden_check(c, n,
                                PyUnicode_AsUTF8(e->v.Name.id)))
                    return 0;
            e->v.Name.ctx = ctx;
            break;
        case List_kind:
            e->v.List.ctx = ctx;
            s = e->v.List.elts;
            break;
        case Tuple_kind:
            if (asdl_seq_LEN(e->v.Tuple.elts))  {
                e->v.Tuple.ctx = ctx;
                s = e->v.Tuple.elts;
            }
            else {
                expr_name = '()';
            }
            break;
        case Lambda_kind:
            expr_name = 'lambda';
            break;
        case Call_kind:
            expr_name = 'function call';
            break;
        case BoolOp_kind:
        case BinOp_kind:
        case UnaryOp_kind:
            expr_name = 'operator';
            break;
        case GeneratorExp_kind:
            expr_name = 'generator expression';
            break;
        case Yield_kind:
            expr_name = 'yield expression';
            break;
        case ListComp_kind:
            expr_name = 'list comprehension';
            break;
        case SetComp_kind:
            expr_name = 'set comprehension';
            break;
        case DictComp_kind:
            expr_name = 'dict comprehension';
            break;
        case Dict_kind:
        case Set_kind:
        case Num_kind:
        case Str_kind:
            expr_name = 'literal';
            break;
        case Compare_kind:
            expr_name = 'comparison';
            break;
        case Repr_kind:
            expr_name = 'repr';
            break;
        case IfExp_kind:
            expr_name = 'conditional expression';
            break;
        default:
            PyErr_Format(PyExc_SystemError,
                         'unexpected expression in assignment %d (line %d)',
                         e->kind, e->lineno);
            return 0;
    }
    /* Check for error string set by switch */
    if (expr_name) {
        char buf[300];
        PyOS_snprintf(buf, sizeof(buf),
                      'can't %s %s',
                      ctx == Store ? 'assign to' : 'delete',
                      expr_name);
        return ast_error(n, buf);
    }

    /* If the LHS is a list or tuple, we need to set the assignment
       context for all the contained elements.
    */
    if (s) {
        int i;

        for (i = 0; i < asdl_seq_LEN(s); i++) {
            if (!set_context(c, (expr_ty)asdl_seq_GET(s, i), ctx, n))
                return 0;
        }
    }
    return 1;
}
",9017
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"expr_ty
Set(asdl_seq * elts, int lineno, int col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Set_kind;
    p->v.Set.elts = elts;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",9018
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"    'LESS',
",9019
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"stmt_ty
Raise(expr_ty exc, expr_ty cause, int lineno, int col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Raise_kind;
    p->v.Raise.exc = exc;
    p->v.Raise.cause = cause;
    p->lineno = lineno;
    p->col_offset = col_offset;
    return p;
}
",9020
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static stmt_ty
ast_for_stmt(struct compiling *c, const node *n)
{
    if (TYPE(n) == stmt) {
        assert(NCH(n) == 1);
        n = CHILD(n, 0);
    }
    if (TYPE(n) == simple_stmt) {
        assert(num_stmts(n) == 1);
        n = CHILD(n, 0);
    }
    if (TYPE(n) == small_stmt) {
        n = CHILD(n, 0);
        /* small_stmt: expr_stmt | print_stmt  | del_stmt | pass_stmt
                     | flow_stmt | import_stmt | global_stmt | exec_stmt
                     | assert_stmt
        */
        switch (TYPE(n)) {
            case expr_stmt:
                return ast_for_expr_stmt(c, n);
            case print_stmt:
                return ast_for_print_stmt(c, n);
            case del_stmt:
                return ast_for_del_stmt(c, n);
            case pass_stmt:
                return Pass(LINENO(n), n->n_col_offset, c->c_arena);
            case flow_stmt:
                return ast_for_flow_stmt(c, n);
            case import_stmt:
                return ast_for_import_stmt(c, n);
            case global_stmt:
                return ast_for_global_stmt(c, n);
            case exec_stmt:
                return ast_for_exec_stmt(c, n);
            case assert_stmt:
                return ast_for_assert_stmt(c, n);
            default:
                PyErr_Format(PyExc_SystemError,
                             'unhandled small_stmt: TYPE=%d NCH=%d\n',
                             TYPE(n), NCH(n));
                return NULL;
        }
    }
    else {
        /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt
                        | funcdef | classdef | decorated
        */
        node *ch = CHILD(n, 0);
        REQ(n, compound_stmt);
        switch (TYPE(ch)) {
            case if_stmt:
                return ast_for_if_stmt(c, ch);
            case while_stmt:
                return ast_for_while_stmt(c, ch);
            case for_stmt:
                return ast_for_for_stmt(c, ch);
            case try_stmt:
                return ast_for_try_stmt(c, ch);
            case with_stmt:
                return ast_for_with_stmt(c, ch);
            case funcdef:
                return ast_for_funcdef(c, ch, NULL);
            case classdef:
                return ast_for_classdef(c, ch, NULL);
            case decorated:
                return ast_for_decorated(c, ch);
            default:
                PyErr_Format(PyExc_SystemError,
                             'unhandled small_stmt: TYPE=%d NCH=%d\n',
                             TYPE(n), NCH(n));
                return NULL;
        }
    }
}
",9021
python/typed_ast,156afcb26c198e162504a57caddfe0acd9ed7dce,0,"static void tok_backup(struct tok_state *tok, int c);
",9022
torvalds/linux,73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,0,"static void mpol_rebind_preferred(struct mempolicy *pol,
						const nodemask_t *nodes)
{
	nodemask_t tmp;

	if (pol->flags & MPOL_F_STATIC_NODES) {
		int node = first_node(pol->w.user_nodemask);

		if (node_isset(node, *nodes)) {
			pol->v.preferred_node = node;
			pol->flags &= ~MPOL_F_LOCAL;
		} else
			pol->flags |= MPOL_F_LOCAL;
	} else if (pol->flags & MPOL_F_RELATIVE_NODES) {
		mpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);
		pol->v.preferred_node = first_node(tmp);
	} else if (!(pol->flags & MPOL_F_LOCAL)) {
		pol->v.preferred_node = node_remap(pol->v.preferred_node,
						   pol->w.cpuset_mems_allowed,
						   *nodes);
		pol->w.cpuset_mems_allowed = *nodes;
	}
}
",9025
torvalds/linux,73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,0,"static int mpol_new_interleave(struct mempolicy *pol, const nodemask_t *nodes)
{
	if (nodes_empty(*nodes))
		return -EINVAL;
	pol->v.nodes = *nodes;
	return 0;
}
",9026
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,1,"char* _multi_string_alloc_and_copy( LPCWSTR in )
{
    char *chr;
    int len = 0;

    if ( !in )
    {
        return in;
    }

    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc( len + 2 );

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = 0xFF & in[ len ];
        len ++;
    }
    chr[ len ++ ] = '\0';
    chr[ len ++ ] = '\0';

    return chr;
}
",9027
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,1,"char* _single_string_alloc_and_copy( LPCWSTR in )
{
    char *chr;
    int len = 0;

    if ( !in )
    {
        return in;
    }

    while ( in[ len ] != 0 )
    {
        len ++;
    }

    chr = malloc( len + 1 );

    len = 0;
    while ( in[ len ] != 0 )
    {
        chr[ len ] = 0xFF & in[ len ];
        len ++;
    }
    chr[ len ++ ] = '\0';

    return chr;
}
",9028
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,1,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;

    if ( !in )
    {
        return in;
    }
    
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
",9029
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,1,"SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;

    if ( !in )
    {
        return in;
    }

    while ( in[ len ] != 0 )
    {
        len ++;
    }

    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));

    len = 0;
    while ( in[ len ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;

    return chr;
}
",9030
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,1,"static int ExecuteSQL( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )
{
    SQLHSTMT        hStmt;
    SQLTCHAR        szSepLine[32001];   
    SQLTCHAR        szUcSQL[32001]; 
    SQLSMALLINT     cols;
    SQLINTEGER      ret;
    SQLLEN          nRows                   = 0;

    szSepLine[ 0 ] = 0;

    ansi_to_unicode( szSQL, szUcSQL );

    /****************************
     * EXECUTE SQL
     ***************************/
    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )
    {
        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );
        fprintf( stderr, '[ISQL]ERROR: Could not SQLAllocStmt\n' );
        return 0;
    }

    if ( buseED ) {
        ret = SQLExecDirect( hStmt, szUcSQL, SQL_NTS );

        if ( ret == SQL_NO_DATA )
        {
            fprintf( stderr, '[ISQL]INFO: SQLExecDirect returned SQL_NO_DATA\n' );
        }
        else if ( ret == SQL_SUCCESS_WITH_INFO )
        {
            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );
            fprintf( stderr, '[ISQL]INFO: SQLExecDirect returned SQL_SUCCESS_WITH_INFO\n' );
        }
        else if ( ret != SQL_SUCCESS )
        {
            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );
            fprintf( stderr, '[ISQL]ERROR: Could not SQLExecDirect\n' );
            SQLFreeStmt( hStmt, SQL_DROP );
            free(szSepLine);
            return 0;
        }
    }
    else {
        if ( SQLPrepare( hStmt, szUcSQL, SQL_NTS ) != SQL_SUCCESS )
        {
            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );
            fprintf( stderr, '[ISQL]ERROR: Could not SQLPrepare\n' );
            SQLFreeStmt( hStmt, SQL_DROP );
            return 0;
        }
    
        ret =  SQLExecute( hStmt );
    
        if ( ret == SQL_NO_DATA )
        {
            fprintf( stderr, '[ISQL]INFO: SQLExecute returned SQL_NO_DATA\n' );
        }
        else if ( ret == SQL_SUCCESS_WITH_INFO )
        {
            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );
            fprintf( stderr, '[ISQL]INFO: SQLExecute returned SQL_SUCCESS_WITH_INFO\n' );
        }
        else if ( ret != SQL_SUCCESS )
        {
            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );
            fprintf( stderr, '[ISQL]ERROR: Could not SQLExecute\n' );
            SQLFreeStmt( hStmt, SQL_DROP );
            return 0;
        }
    }

    do 
    {
        /*
         * check to see if it has generated a result set
         */

        if ( SQLNumResultCols( hStmt, &cols ) != SQL_SUCCESS )
        {
            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );
            fprintf( stderr, '[ISQL]ERROR: Could not SQLNumResultCols\n' );
            SQLFreeStmt( hStmt, SQL_DROP );
            return 0;
        }

        if ( cols > 0 )
        {
            /****************************
             * WRITE HEADER
             ***************************/
            if ( bHTMLTable )
                WriteHeaderHTMLTable( hStmt );
            else if ( cDelimiter == 0 )
                UWriteHeaderNormal( hStmt, szSepLine );
            else if ( cDelimiter && bColumnNames )
                WriteHeaderDelimited( hStmt, cDelimiter );

            /****************************
             * WRITE BODY
             ***************************/
            if ( bHTMLTable )
                WriteBodyHTMLTable( hStmt );
            else if ( cDelimiter == 0 )
                nRows = WriteBodyNormal( hStmt );
            else
                WriteBodyDelimited( hStmt, cDelimiter );
        }

        /****************************
         * WRITE FOOTER
         ***************************/
        if ( bHTMLTable )
            WriteFooterHTMLTable( hStmt );
        else if ( cDelimiter == 0 )
            UWriteFooterNormal( hStmt, szSepLine, nRows );
    }
    while ( SQL_SUCCEEDED( SQLMoreResults( hStmt )));

    /****************************
     * CLEANUP
     ***************************/
    SQLFreeStmt( hStmt, SQL_DROP );

    return 1;
}
",9031
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,1,"SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,
           SQLSMALLINT rec_number, 
           SQLSMALLINT field_identifier,
           SQLPOINTER value, 
           SQLINTEGER buffer_length )
{
    /*
     * not quite sure how the descriptor can be
     * allocated to a statement, all the documentation talks
     * about state transitions on statement states, but the
     * descriptor may be allocated with more than one statement
     * at one time. Which one should I check ?
     */
    DMHDESC descriptor = (DMHDESC) descriptor_handle;
    SQLRETURN ret;
    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];
    int isStrField = 0;

    /*
     * check descriptor
     */

    if ( !__validate_desc( descriptor ))
    {
        dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    'Error: SQL_INVALID_HANDLE' );

        return SQL_INVALID_HANDLE;
    }

    function_entry( descriptor );

    if ( log_info.log_flag )
    {
        sprintf( descriptor -> msg, '\n\t\tEntry:\
\n\t\t\tDescriptor = %p\
\n\t\t\tRec Number = %d\
\n\t\t\tField Ident = %s\
\n\t\t\tValue = %p\
\n\t\t\tBuffer Length = %d',
                descriptor,
                rec_number,
                __desc_attr_as_string( s1, field_identifier ),
                value, 
                (int)buffer_length );

        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                descriptor -> msg );
    }

    thread_protect( SQL_HANDLE_DESC, descriptor );

    if ( descriptor -> connection -> state < STATE_C4 )
    {
        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                'Error: HY010' );

        __post_internal_error( &descriptor -> error,
                ERROR_HY010, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    /*
     * check status of statements associated with this descriptor
     */

    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||
        __check_stmt_from_desc( descriptor, STATE_S9 ) ||
        __check_stmt_from_desc( descriptor, STATE_S10 ) ||
        __check_stmt_from_desc( descriptor, STATE_S11 ) ||
        __check_stmt_from_desc( descriptor, STATE_S12 ) ||
        __check_stmt_from_desc( descriptor, STATE_S13 ) ||
        __check_stmt_from_desc( descriptor, STATE_S14 ) ||
        __check_stmt_from_desc( descriptor, STATE_S15 )) {

        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                'Error: HY010' );

        __post_internal_error( &descriptor -> error,
                ERROR_HY010, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }


    if ( rec_number < 0 )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_07009, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    switch ( field_identifier )
    {
    /* Fixed-length fields: buffer_length is ignored */
    case SQL_DESC_ALLOC_TYPE:
    case SQL_DESC_ARRAY_SIZE:
    case SQL_DESC_ARRAY_STATUS_PTR:
    case SQL_DESC_BIND_OFFSET_PTR:
    case SQL_DESC_BIND_TYPE:
    case SQL_DESC_COUNT:
    case SQL_DESC_ROWS_PROCESSED_PTR:
    case SQL_DESC_AUTO_UNIQUE_VALUE:
    case SQL_DESC_CASE_SENSITIVE:
    case SQL_DESC_CONCISE_TYPE:
    case SQL_DESC_DATA_PTR:
    case SQL_DESC_DATETIME_INTERVAL_CODE:
    case SQL_DESC_DATETIME_INTERVAL_PRECISION:
    case SQL_DESC_DISPLAY_SIZE:
    case SQL_DESC_FIXED_PREC_SCALE:
    case SQL_DESC_INDICATOR_PTR:
    case SQL_DESC_LENGTH:
    case SQL_DESC_NULLABLE:
    case SQL_DESC_NUM_PREC_RADIX:
    case SQL_DESC_OCTET_LENGTH:
    case SQL_DESC_OCTET_LENGTH_PTR:
    case SQL_DESC_PARAMETER_TYPE:
    case SQL_DESC_PRECISION:
    case SQL_DESC_ROWVER:
    case SQL_DESC_SCALE:
    case SQL_DESC_SEARCHABLE:
    case SQL_DESC_TYPE:
    case SQL_DESC_UNNAMED:
    case SQL_DESC_UNSIGNED:
    case SQL_DESC_UPDATABLE:
        isStrField = 0;
        break;
    /* Pointer to data: buffer_length must be valid */
    case SQL_DESC_BASE_COLUMN_NAME:
    case SQL_DESC_BASE_TABLE_NAME:
    case SQL_DESC_CATALOG_NAME:
    case SQL_DESC_LABEL:
    case SQL_DESC_LITERAL_PREFIX:
    case SQL_DESC_LITERAL_SUFFIX:
    case SQL_DESC_LOCAL_TYPE_NAME:
    case SQL_DESC_NAME:
    case SQL_DESC_SCHEMA_NAME:
    case SQL_DESC_TABLE_NAME:
    case SQL_DESC_TYPE_NAME:
        isStrField = 1;
        break;
    default:
        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER
            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&
            buffer_length != SQL_IS_USMALLINT;
    }
    
    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)
    {
        __post_internal_error( &descriptor -> error,
            ERROR_HY090, NULL,
            descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_07009, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }
    
    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT
        && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&
        value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_HY105, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))
    {
      ret = SQLSETDESCFIELD( descriptor -> connection,
              descriptor -> driver_desc,
              rec_number, 
              field_identifier,
              value, 
              buffer_length );
    }
    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))
    {
      SQLWCHAR *s1 = NULL;

        if (isStrField)
      {
        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );
            if (SQL_NTS != buffer_length)
            {
                buffer_length *= sizeof(SQLWCHAR);
            }
      }
      else
      {
              s1 = value;
      }
      ret = SQLSETDESCFIELDW( descriptor -> connection,
                descriptor -> driver_desc,
                rec_number, 
                field_identifier,
                s1, 
                buffer_length );
       
        if (isStrField)
       {
        if (s1)
          free(s1); 
       }
    }
    else 
	{
        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                'Error: IM001' );

        __post_internal_error( &descriptor -> error,
                ERROR_IM001, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( log_info.log_flag )
    {
        sprintf( descriptor -> msg, 
                '\n\t\tExit:[%s]',
                    __get_return_status( ret, s1 ));

        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                descriptor -> msg );
    }

    return function_return( SQL_HANDLE_DESC, descriptor, ret );
}
",9032
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,1,"SQLRETURN SQLSetDescFieldW( SQLHDESC descriptor_handle,
           SQLSMALLINT rec_number, 
           SQLSMALLINT field_identifier,
           SQLPOINTER value, 
           SQLINTEGER buffer_length )
{
    /*
     * not quite sure how the descriptor can be
     * allocated to a statement, all the documentation talks
     * about state transitions on statement states, but the
     * descriptor may be allocated with more than one statement
     * at one time. Which one should I check ?
     */
    DMHDESC descriptor = (DMHDESC) descriptor_handle;
    SQLRETURN ret;
    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];
    int isStrField = 0;

    /*
     * check descriptor
     */

    if ( !__validate_desc( descriptor ))
    {
        dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    'Error: SQL_INVALID_HANDLE' );

#ifdef WITH_HANDLE_REDIRECT
		{
			DMHDESC parent_desc;

			parent_desc = find_parent_handle( descriptor, SQL_HANDLE_DESC );

			if ( parent_desc ) {
        		dm_log_write( __FILE__, 
                	__LINE__, 
                    	LOG_INFO, 
                    	LOG_INFO, 
                    	'Info: found parent handle' );

				if ( CHECK_SQLSETDESCFIELDW( parent_desc -> connection ))
				{
        			dm_log_write( __FILE__, 
                		__LINE__, 
                   		 	LOG_INFO, 
                   		 	LOG_INFO, 
                   		 	'Info: calling redirected driver function' );

                	return  SQLSETDESCFIELDW( parent_desc -> connection,
							descriptor,
							rec_number,
							field_identifier,
							value,
							buffer_length );
				}
			}
		}
#endif
        return SQL_INVALID_HANDLE;
    }

    function_entry( descriptor );

    if ( log_info.log_flag )
    {
        sprintf( descriptor -> msg, '\n\t\tEntry:\
\n\t\t\tDescriptor = %p\
\n\t\t\tRec Number = %d\
\n\t\t\tField Ident = %s\
\n\t\t\tValue = %p\
\n\t\t\tBuffer Length = %d',
                descriptor,
                rec_number,
                __desc_attr_as_string( s1, field_identifier ),
                value, 
                (int)buffer_length );

        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                descriptor -> msg );
    }

    thread_protect( SQL_HANDLE_DESC, descriptor );

    if ( descriptor -> connection -> state < STATE_C4 )
    {
        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                'Error: HY010' );

        __post_internal_error( &descriptor -> error,
                ERROR_HY010, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    /*
     * check status of statements associated with this descriptor
     */

    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||
        __check_stmt_from_desc( descriptor, STATE_S9 ) ||
        __check_stmt_from_desc( descriptor, STATE_S10 ) ||
        __check_stmt_from_desc( descriptor, STATE_S11 ) ||
        __check_stmt_from_desc( descriptor, STATE_S12 ) ||
        __check_stmt_from_desc( descriptor, STATE_S13 ) ||
        __check_stmt_from_desc( descriptor, STATE_S14 ) ||
        __check_stmt_from_desc( descriptor, STATE_S15 )) {

        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                'Error: HY010' );

        __post_internal_error( &descriptor -> error,
                ERROR_HY010, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( rec_number < 0 )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_07009, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    switch ( field_identifier )
    {
    /* Fixed-length fields: buffer_length is ignored */
    case SQL_DESC_ALLOC_TYPE:
    case SQL_DESC_ARRAY_SIZE:
    case SQL_DESC_ARRAY_STATUS_PTR:
    case SQL_DESC_BIND_OFFSET_PTR:
    case SQL_DESC_BIND_TYPE:
    case SQL_DESC_COUNT:
    case SQL_DESC_ROWS_PROCESSED_PTR:
    case SQL_DESC_AUTO_UNIQUE_VALUE:
    case SQL_DESC_CASE_SENSITIVE:
    case SQL_DESC_CONCISE_TYPE:
    case SQL_DESC_DATA_PTR:
    case SQL_DESC_DATETIME_INTERVAL_CODE:
    case SQL_DESC_DATETIME_INTERVAL_PRECISION:
    case SQL_DESC_DISPLAY_SIZE:
    case SQL_DESC_FIXED_PREC_SCALE:
    case SQL_DESC_INDICATOR_PTR:
    case SQL_DESC_LENGTH:
    case SQL_DESC_NULLABLE:
    case SQL_DESC_NUM_PREC_RADIX:
    case SQL_DESC_OCTET_LENGTH:
    case SQL_DESC_OCTET_LENGTH_PTR:
    case SQL_DESC_PARAMETER_TYPE:
    case SQL_DESC_PRECISION:
    case SQL_DESC_ROWVER:
    case SQL_DESC_SCALE:
    case SQL_DESC_SEARCHABLE:
    case SQL_DESC_TYPE:
    case SQL_DESC_UNNAMED:
    case SQL_DESC_UNSIGNED:
    case SQL_DESC_UPDATABLE:
        isStrField = 0;
        break;
    /* Pointer to data: buffer_length must be valid */
    case SQL_DESC_BASE_COLUMN_NAME:
    case SQL_DESC_BASE_TABLE_NAME:
    case SQL_DESC_CATALOG_NAME:
    case SQL_DESC_LABEL:
    case SQL_DESC_LITERAL_PREFIX:
    case SQL_DESC_LITERAL_SUFFIX:
    case SQL_DESC_LOCAL_TYPE_NAME:
    case SQL_DESC_NAME:
    case SQL_DESC_SCHEMA_NAME:
    case SQL_DESC_TABLE_NAME:
    case SQL_DESC_TYPE_NAME:
        isStrField = 1;
        break;
    default:
        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER
            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&
            buffer_length != SQL_IS_USMALLINT;
    }
    
    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)
    {
        __post_internal_error( &descriptor -> error,
            ERROR_HY090, NULL,
            descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_07009, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT
        && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&
        value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_HY105, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( descriptor -> connection -> unicode_driver ||
		    CHECK_SQLSETDESCFIELDW( descriptor -> connection ))
	{
    	if ( !CHECK_SQLSETDESCFIELDW( descriptor -> connection ))
    	{
        	dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                'Error: IM001' );

        	__post_internal_error( &descriptor -> error,
                ERROR_IM001, NULL,
                descriptor -> connection -> environment -> requested_version );

        	return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
		}

    	ret = SQLSETDESCFIELDW( descriptor -> connection,
            	descriptor -> driver_desc,
            	rec_number, 
            	field_identifier,
            	value, 
            	buffer_length );
	
    	if ( log_info.log_flag )
    	{
        	sprintf( descriptor -> msg, 
                	'\n\t\tExit:[%s]',
                    	__get_return_status( ret, s1 ));
	
        	dm_log_write( __FILE__, 
                	__LINE__, 
                	LOG_INFO, 
                	LOG_INFO, 
                	descriptor -> msg );
    	}
	}
	else
	{
		SQLCHAR *ascii_str = NULL;

    	if ( !CHECK_SQLSETDESCFIELD( descriptor -> connection ))
    	{
        	dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                'Error: IM001' );

        	__post_internal_error( &descriptor -> error,
                ERROR_IM001, NULL,
                descriptor -> connection -> environment -> requested_version );

        	return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
		}

		/*
		 * is it a char arg...
		 */

		switch ( field_identifier )
		{
			case SQL_DESC_NAME:		/* This is the only R/W SQLCHAR* type */
        		ascii_str = (SQLCHAR*) unicode_to_ansi_alloc( value, buffer_length, descriptor -> connection, NULL );
				value = ascii_str;
				buffer_length = strlen((char*) ascii_str );
				break;

			default:
				break;
		}

    	ret = SQLSETDESCFIELD( descriptor -> connection,
            	descriptor -> driver_desc,
            	rec_number, 
            	field_identifier,
            	value, 
            	buffer_length );
	
    	if ( log_info.log_flag )
    	{
        	sprintf( descriptor -> msg, 
                	'\n\t\tExit:[%s]',
                    	__get_return_status( ret, s1 ));
	
        	dm_log_write( __FILE__, 
                	__LINE__, 
                	LOG_INFO, 
                	LOG_INFO, 
                	descriptor -> msg );
    	}

		if ( ascii_str ) 
		{
			free( ascii_str );
		}
	}

    return function_return( SQL_HANDLE_DESC, descriptor, ret );
}
",9033
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,1,"BOOL SQLWriteFileDSN(			LPCSTR	pszFileName,
								LPCSTR	pszAppName,
								LPCSTR	pszKeyName,
								LPCSTR	pszString )
{
	HINI	hIni;
	char	szFileName[ODBC_FILENAME_MAX+1];

	if ( pszFileName[0] == '/' )
	{
		strncpy( szFileName, sizeof(szFileName) - 5, pszFileName );
	}
	else
	{	
		char szPath[ODBC_FILENAME_MAX+1];
		*szPath = '\0';
		_odbcinst_FileINI( szPath );
		snprintf( szFileName, sizeof(szFileName) - 5, '%s/%s', szPath, pszFileName );
	}

    if ( strlen( szFileName ) < 4 || strcmp( szFileName + strlen( szFileName ) - 4, '.dsn' ))
    {
        strcat( szFileName, '.dsn' );
    }

#ifdef __OS2__
	if ( iniOpen( &hIni, szFileName, '#;', '[', ']', '=', TRUE, 0L ) != INI_SUCCESS )
#else
	if ( iniOpen( &hIni, szFileName, '#;', '[', ']', '=', TRUE ) != INI_SUCCESS )
#endif
	{
       	inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_INVALID_PATH, '' );
		return FALSE;
	}

	/* delete section */
	if ( pszString == NULL && pszKeyName == NULL )
	{
		if ( iniObjectSeek( hIni, (char *)pszAppName ) == INI_SUCCESS )
        {
			iniObjectDelete( hIni );
        }
	}
	/* delete entry */
	else if	( pszString == NULL )
	{
		if ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, '' ) == INI_SUCCESS )
        {
			iniPropertyDelete( hIni );
        }
	}
	else
	{
		/* add section */
		if ( iniObjectSeek( hIni, (char *)pszAppName ) != INI_SUCCESS )
        {
			iniObjectInsert( hIni, (char *)pszAppName );
        }
		/* update entry */
		if ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, '' ) == INI_SUCCESS )
		{
			iniObjectSeek( hIni, (char *)pszAppName );
			iniPropertyUpdate( hIni, (char *)pszKeyName, (char *)pszString );
		}
		/* add entry */
		else
		{
			iniObjectSeek( hIni, (char *)pszAppName );
			iniPropertyInsert( hIni, (char *)pszKeyName, (char *)pszString );
		}
	}

	if ( iniCommit( hIni ) != INI_SUCCESS )
	{
		iniClose( hIni );
        inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_REQUEST_FAILED, '' );
		return FALSE;
	}

	iniClose( hIni );

	return TRUE;
}
",9034
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,0,"static void WriteHeaderDelimited( SQLHSTMT hStmt, char cDelimiter )
{
    SQLINTEGER      nCol                            = 0;
    SQLSMALLINT     nColumns                        = 0;
    SQLTCHAR            szColumnName[MAX_DATA_WIDTH+1]; 

    szColumnName[ 0 ]   = 0;    

    if ( SQLNumResultCols( hStmt, &nColumns ) != SQL_SUCCESS )
        nColumns = -1;

    for ( nCol = 1; nCol <= nColumns; nCol++ )
    {
        SQLColAttribute( hStmt, nCol, SQL_DESC_LABEL, szColumnName, sizeof(szColumnName), NULL, NULL );
        fputs((char*) uc_to_ascii( szColumnName ), stdout );
        if ( nCol < nColumns )
            putchar( cDelimiter );
    }
    putchar( '\n' );
}
",9035
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,0,"SQLRETURN SQLGetDiagRecW( SQLSMALLINT handle_type,
        SQLHANDLE   handle,
        SQLSMALLINT rec_number,
        SQLWCHAR     *sqlstate,
        SQLINTEGER  *native,
        SQLWCHAR     *message_text,
        SQLSMALLINT buffer_length,
        SQLSMALLINT *text_length_ptr )
{
    SQLRETURN ret;
    SQLCHAR s0[ 32 ], s1[ 100 + LOG_MESSAGE_LEN ];
    SQLCHAR s2[ 100 + LOG_MESSAGE_LEN ];
    SQLCHAR s3[ 100 + LOG_MESSAGE_LEN ];

    if ( rec_number < 1 )
    {
        return SQL_ERROR;
    }

    if ( handle_type == SQL_HANDLE_ENV )
    {
        DMHENV environment = ( DMHENV ) handle;

        if ( !__validate_env( environment ))
        {
            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    'Error: SQL_INVALID_HANDLE' );

            return SQL_INVALID_HANDLE;
        }

        thread_protect( SQL_HANDLE_ENV, environment );

        if ( log_info.log_flag )
        {
            sprintf( environment -> msg, 
                '\n\t\tEntry:\
\n\t\t\tEnvironment = %p\
\n\t\t\tRec Number = %d\
\n\t\t\tSQLState = %p\
\n\t\t\tNative = %p\
\n\t\t\tMessage Text = %p\
\n\t\t\tBuffer Length = %d\
\n\t\t\tText Len Ptr = %p',
                    environment,
                    rec_number,
                    sqlstate,
                    native,
                    message_text,
                    buffer_length,
                    text_length_ptr );

            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    environment -> msg );
        }

        ret = extract_sql_error_rec_w( &environment -> error,
                sqlstate,
                rec_number,
                native,
                message_text,
                buffer_length,
                text_length_ptr );

        if ( log_info.log_flag )
        {
            if ( SQL_SUCCEEDED( ret ))
            {
                char *ts1, *ts2;

                sprintf( environment -> msg, 
                    '\n\t\tExit:[%s]\
\n\t\t\tSQLState = %s\
\n\t\t\tNative = %s\
\n\t\t\tMessage Text = %s',
                        __get_return_status( ret, s2 ),
                        __sdata_as_string( s3, SQL_CHAR,
				NULL, ts1 = unicode_to_ansi_alloc( sqlstate, SQL_NTS, NULL, NULL  )),
                        __iptr_as_string( s0, native ),
                        __sdata_as_string( s1, SQL_CHAR, 
                            text_length_ptr, ts2 = unicode_to_ansi_alloc( message_text, SQL_NTS, NULL, NULL  )));

		if ( ts1 ) {
                	free( ts1 );
		}
		if ( ts2 ) {
                	free( ts2 );
		}
            }
            else
            {
                sprintf( environment -> msg, 
                    '\n\t\tExit:[%s]',
                        __get_return_status( ret, s2 ));
            }

            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    environment -> msg );
        }

        thread_release( SQL_HANDLE_ENV, environment );

        return ret;
    }
    else if ( handle_type == SQL_HANDLE_DBC )
    {
        DMHDBC connection = ( DMHDBC ) handle;

        if ( !__validate_dbc( connection ))
        {
            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    'Error: SQL_INVALID_HANDLE' );

#ifdef WITH_HANDLE_REDIRECT
		{
			DMHDBC parent_connection;

			parent_connection = find_parent_handle( connection, SQL_HANDLE_DBC );

			if ( parent_connection ) {
        		dm_log_write( __FILE__, 
                	__LINE__, 
                    	LOG_INFO, 
                    	LOG_INFO, 
                    	'Info: found parent handle' );

				if ( CHECK_SQLGETDIAGRECW( parent_connection ))
				{
        			dm_log_write( __FILE__, 
                		__LINE__, 
                   		 	LOG_INFO, 
                   		 	LOG_INFO, 
                   		 	'Info: calling redirected driver function' );

					return SQLGETDIAGRECW( parent_connection, 
							handle_type,
							connection, 
        					rec_number,
        					sqlstate,
        					native,
        					message_text,
        					buffer_length,
        					text_length_ptr );
				}
			}
		}
#endif
            return SQL_INVALID_HANDLE;
        }

        thread_protect( SQL_HANDLE_DBC, connection );

        if ( log_info.log_flag )
        {
            sprintf( connection -> msg, 
                '\n\t\tEntry:\
\n\t\t\tConnection = %p\
\n\t\t\tRec Number = %d\
\n\t\t\tSQLState = %p\
\n\t\t\tNative = %p\
\n\t\t\tMessage Text = %p\
\n\t\t\tBuffer Length = %d\
\n\t\t\tText Len Ptr = %p',
                    connection,
                    rec_number,
                    sqlstate,
                    native,
                    message_text,
                    buffer_length,
                    text_length_ptr );

            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    connection -> msg );
        }

        ret = extract_sql_error_rec_w( &connection -> error,
                sqlstate,
                rec_number,
                native,
                message_text,
                buffer_length,
                text_length_ptr );

        if ( log_info.log_flag )
        {
            if ( SQL_SUCCEEDED( ret ))
            {
                char *ts1, *ts2;

                sprintf( connection -> msg, 
                    '\n\t\tExit:[%s]\
\n\t\t\tSQLState = %s\
\n\t\t\tNative = %s\
\n\t\t\tMessage Text = %s',
                        __get_return_status( ret, s2 ),
                        __sdata_as_string( s3, SQL_CHAR,
				NULL, ts1 = unicode_to_ansi_alloc( sqlstate, SQL_NTS, connection, NULL  )),
                        __iptr_as_string( s0, native ),
                        __sdata_as_string( s1, SQL_CHAR, 
                            	text_length_ptr, ts2 = unicode_to_ansi_alloc( message_text, SQL_NTS, connection, NULL  )));

		if ( ts1 ) {
                	free( ts1 );
		}
		if ( ts2 ) {
                	free( ts2 );
		}
            }
            else
            {
                sprintf( connection -> msg, 
                    '\n\t\tExit:[%s]',
                        __get_return_status( ret, s2 ));
            }

            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    connection -> msg );
        }

        thread_release( SQL_HANDLE_DBC, connection );

        return ret;
    }
    else if ( handle_type == SQL_HANDLE_STMT )
    {
        DMHSTMT statement = ( DMHSTMT ) handle;

        if ( !__validate_stmt( statement ))
        {
            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    'Error: SQL_INVALID_HANDLE' );

#ifdef WITH_HANDLE_REDIRECT
		{
			DMHSTMT parent_statement;

			parent_statement = find_parent_handle( statement, SQL_HANDLE_STMT );

			if ( parent_statement ) {
        		dm_log_write( __FILE__, 
                	__LINE__, 
                    	LOG_INFO, 
                    	LOG_INFO, 
                    	'Info: found parent handle' );

				if ( CHECK_SQLGETDIAGRECW( parent_statement -> connection ))
				{
        			dm_log_write( __FILE__, 
                		__LINE__, 
                   		 	LOG_INFO, 
                   		 	LOG_INFO, 
                   		 	'Info: calling redirected driver function' );

					return SQLGETDIAGRECW( parent_statement -> connection, 
							handle_type,
							statement,
        					rec_number,
        					sqlstate,
        					native,
        					message_text,
        					buffer_length,
        					text_length_ptr );
				}
			}
		}
#endif
            return SQL_INVALID_HANDLE;
        }

        thread_protect( SQL_HANDLE_STMT, statement );

        if ( log_info.log_flag )
        {
            sprintf( statement -> msg, 
                '\n\t\tEntry:\
\n\t\t\tStatement = %p\
\n\t\t\tRec Number = %d\
\n\t\t\tSQLState = %p\
\n\t\t\tNative = %p\
\n\t\t\tMessage Text = %p\
\n\t\t\tBuffer Length = %d\
\n\t\t\tText Len Ptr = %p',
                    statement,
                    rec_number,
                    sqlstate,
                    native,
                    message_text,
                    buffer_length,
                    text_length_ptr );

            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    statement -> msg );
        }

        ret = extract_sql_error_rec_w( &statement -> error,
                sqlstate,
                rec_number,
                native,
                message_text,
                buffer_length,
                text_length_ptr );

        if ( log_info.log_flag )
        {
            if ( SQL_SUCCEEDED( ret ))
            {
                char *ts1, *ts2;

                sprintf( statement -> msg, 
                    '\n\t\tExit:[%s]\
\n\t\t\tSQLState = %s\
\n\t\t\tNative = %s\
\n\t\t\tMessage Text = %s',
                        __get_return_status( ret, s2 ),
                        __sdata_as_string( s3, SQL_CHAR,
				NULL, ts1 = unicode_to_ansi_alloc( sqlstate, SQL_NTS, statement -> connection, NULL  )),
                        __iptr_as_string( s0, native ),
                        __sdata_as_string( s1, SQL_CHAR, 
                            text_length_ptr, ts2 = unicode_to_ansi_alloc( message_text, SQL_NTS, statement -> connection, NULL  )));

		if ( ts1 ) {
                	free( ts1 );
		}
		if ( ts2 ) {
                	free( ts2 );
		}
            }
            else
            {
                sprintf( statement -> msg, 
                    '\n\t\tExit:[%s]',
                        __get_return_status( ret, s2 ));
            }

            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    statement -> msg );
        }

        thread_release( SQL_HANDLE_STMT, statement );

        return ret;
    }
    else if ( handle_type == SQL_HANDLE_DESC )
    {
        DMHDESC descriptor = ( DMHDESC ) handle;

        if ( !__validate_desc( descriptor ))
        {
            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    'Error: SQL_INVALID_HANDLE' );

#ifdef WITH_HANDLE_REDIRECT
		{
			DMHDESC parent_desc;

			parent_desc = find_parent_handle( descriptor, SQL_HANDLE_DESC );

			if ( parent_desc ) {
        		dm_log_write( __FILE__, 
                	__LINE__, 
                    	LOG_INFO, 
                    	LOG_INFO, 
                    	'Info: found parent handle' );

				if ( CHECK_SQLGETDIAGRECW( parent_desc -> connection ))
				{
        			dm_log_write( __FILE__, 
                		__LINE__, 
                   		 	LOG_INFO, 
                   		 	LOG_INFO, 
                   		 	'Info: calling redirected driver function' );

					return SQLGETDIAGRECW( parent_desc -> connection, 
							handle_type,
							descriptor,
        					rec_number,
        					sqlstate,
        					native,
        					message_text,
        					buffer_length,
        					text_length_ptr );
				}
			}
		}
#endif
            return SQL_INVALID_HANDLE;
        }

        thread_protect( SQL_HANDLE_DESC, descriptor );

        if ( log_info.log_flag )
        {
            sprintf( descriptor -> msg, 
                '\n\t\tEntry:\
\n\t\t\tDescriptor = %p\
\n\t\t\tRec Number = %d\
\n\t\t\tSQLState = %p\
\n\t\t\tNative = %p\
\n\t\t\tMessage Text = %p\
\n\t\t\tBuffer Length = %d\
\n\t\t\tText Len Ptr = %p',
                    descriptor,
                    rec_number,
                    sqlstate,
                    native,
                    message_text,
                    buffer_length,
                    text_length_ptr );

            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    descriptor -> msg );
        }

        ret = extract_sql_error_rec_w( &descriptor -> error,
                sqlstate,
                rec_number,
                native,
                message_text,
                buffer_length,
                text_length_ptr );

        if ( log_info.log_flag )
        {
            if ( SQL_SUCCEEDED( ret ))
            {
                char *ts1, *ts2;

                sprintf( descriptor -> msg, 
                    '\n\t\tExit:[%s]\
\n\t\t\tSQLState = %s\
\n\t\t\tNative = %s\
\n\t\t\tMessage Text = %s',
                        __get_return_status( ret, s2 ),
                        __sdata_as_string( s3, SQL_CHAR,
				NULL, ts1 = unicode_to_ansi_alloc( sqlstate, SQL_NTS, descriptor -> connection, NULL  )),
                        __iptr_as_string( s0, native ),
                        __sdata_as_string( s1, SQL_CHAR, 
                            text_length_ptr, ts2 = unicode_to_ansi_alloc( message_text, SQL_NTS, descriptor -> connection, NULL  )));

		if ( ts1 ) {
                	free( ts1 );
		}
		if ( ts2 ) {
                	free( ts2 );
		}
            }
            else
            {
                sprintf( descriptor -> msg, 
                    '\n\t\tExit:[%s]',
                        __get_return_status( ret, s2 ));
            }

            dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    descriptor -> msg );
        }

        thread_release( SQL_HANDLE_DESC, descriptor );

        return ret;
    }
    return SQL_NO_DATA;
}
",9036
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,0,"static int ExecuteHelp( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )
{
    char            szTable[250]                        = '';
    SQLHSTMT        hStmt;
    SQLTCHAR        szSepLine[32001];   
    SQLLEN          nRows               = 0;

    szSepLine[ 0 ] = 0;

    /****************************
     * EXECUTE SQL
     ***************************/
    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )
    {
        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );
        fprintf( stderr, '[ISQL]ERROR: Could not SQLAllocStmt\n' );
        return 0;
    }

    if ( iniElement( szSQL, ' ', '\0', 1, szTable, sizeof(szTable) ) == INI_SUCCESS )
    {
        SQLWCHAR tname[ 1024 ];

        ansi_to_unicode( szTable, tname );
        /* COLUMNS */
        if ( SQLColumns( hStmt, NULL, 0, NULL, 0, tname, SQL_NTS, NULL, 0 ) != SQL_SUCCESS )
        {
            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );
            fprintf( stderr, '[ISQL]ERROR: Could not SQLColumns\n' );
            SQLFreeStmt( hStmt, SQL_DROP );
            return 0;
        }
    }
    else
    {
        /* TABLES */
        if ( SQLTables( hStmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0 ) != SQL_SUCCESS )
        {
            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );
            fprintf( stderr, '[ISQL]ERROR: Could not SQLTables\n' );
            SQLFreeStmt( hStmt, SQL_DROP );
            return 0;
        }
    }

    /****************************
     * WRITE HEADER
     ***************************/
    if ( bHTMLTable )
        WriteHeaderHTMLTable( hStmt );
    else if ( cDelimiter == 0 )
        UWriteHeaderNormal( hStmt, szSepLine );
    else if ( cDelimiter && bColumnNames )
        WriteHeaderDelimited( hStmt, cDelimiter );

    /****************************
     * WRITE BODY
     ***************************/
    if ( bHTMLTable )
        WriteBodyHTMLTable( hStmt );
    else if ( cDelimiter == 0 )
        nRows = WriteBodyNormal( hStmt );
    else
        WriteBodyDelimited( hStmt, cDelimiter );

    /****************************
     * WRITE FOOTER
     ***************************/
    if ( bHTMLTable )
        WriteFooterHTMLTable( hStmt );
    else if ( cDelimiter == 0 )
        UWriteFooterNormal( hStmt, szSepLine, nRows );

    /****************************
     * CLEANUP
     ***************************/
    SQLFreeStmt( hStmt, SQL_DROP );

    return 1;
}
",9037
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,0,"static SQLRETURN extract_sql_error_rec_w( EHEAD *head,
        SQLWCHAR *sqlstate,
        SQLINTEGER rec_number,
        SQLINTEGER *native_error,
        SQLWCHAR *message_text,
        SQLSMALLINT buffer_length,
        SQLSMALLINT *text_length )
{
    SQLRETURN ret;

    if ( sqlstate )
    {
        SQLWCHAR *tmp;

        tmp = ansi_to_unicode_alloc((SQLCHAR*) '00000', SQL_NTS, __get_connection( head ), NULL );
        wide_strcpy( sqlstate, tmp );
        free( tmp );
    }

    if ( rec_number <= head -> sql_diag_head.internal_count )
    {
        ERROR *ptr;

        ptr = head -> sql_diag_head.internal_list_head;
        while( rec_number > 1 )
        {
            ptr = ptr -> next;
            rec_number --;
        }

		if ( !ptr ) 
		{
	    	return SQL_NO_DATA;
		}

        if ( sqlstate )
        {
            wide_strcpy( sqlstate, ptr -> sqlstate );
        }
        if ( buffer_length < wide_strlen( ptr -> msg ) + 1 )
        {
            ret = SQL_SUCCESS_WITH_INFO;
        }
        else
        {
            ret = SQL_SUCCESS;
        }

        if ( message_text )
        {
            if ( ret == SQL_SUCCESS )
            {
                wide_strcpy( message_text, ptr -> msg );
            }
            else
            {
                memcpy( message_text, ptr -> msg, buffer_length * 2 );
                message_text[ buffer_length - 1 ] = '\0';
            }
        }

        if ( text_length )
        {
            *text_length = wide_strlen( ptr -> msg );
        }

        if ( native_error )
        {
            *native_error = ptr -> native_error;
        }

        /*
         * map 3 to 2 if required
         */

        if ( SQL_SUCCEEDED( ret ) && sqlstate )
            __map_error_state_w(sqlstate, __get_version( head ));

        return ret;
    }
    else if ( !__is_env( head ) && __get_connection( head ) -> state != STATE_C2
        && head->sql_diag_head.error_count )
    {
        ERROR *ptr;
        rec_number -= head -> sql_diag_head.internal_count;

        if ( __get_connection( head ) -> unicode_driver &&
            CHECK_SQLGETDIAGRECW( __get_connection( head )))
        {
            ret = SQLGETDIAGRECW( __get_connection( head ),
                    head -> handle_type,
                    __get_driver_handle( head ),
                    rec_number,
                    sqlstate,
                    native_error,
                    message_text,
                    buffer_length,
                    text_length );

            /*
             * map 3 to 2 if required
             */

            if ( SQL_SUCCEEDED( ret ) && sqlstate )
            {
                __map_error_state_w( sqlstate, __get_version( head ));
            }

            return ret;
        }
        else if ( !__get_connection( head ) -> unicode_driver &&
            CHECK_SQLGETDIAGREC( __get_connection( head )))
        {
            SQLCHAR *as1 = NULL, *as2 = NULL;

            if ( sqlstate )
            {
                as1 = malloc( 7 );
            }

            if ( message_text && buffer_length > 0 )
            {
                as2 = malloc( buffer_length + 1 );
            }
                
            ret = SQLGETDIAGREC( __get_connection( head ),
                    head -> handle_type,
                    __get_driver_handle( head ),
                    rec_number,
                    as1 ? as1 : (SQLCHAR *)sqlstate,
                    native_error,
                    as2 ? as2 : (SQLCHAR *)message_text,
                    buffer_length,
                    text_length );

            /*
             * map 3 to 2 if required
             */

            if ( SQL_SUCCEEDED( ret ) && sqlstate )
            {
                if ( sqlstate )
                {
                    if ( as1 )
                    {
                        ansi_to_unicode_copy( sqlstate,(char*) as1, SQL_NTS, __get_connection( head ), NULL );
                        __map_error_state_w( sqlstate, __get_version( head ));
                    }
                }
                if ( message_text )
                {
                    if ( as2 )
                    {
                        ansi_to_unicode_copy( message_text,(char*) as2, SQL_NTS, __get_connection( head ), NULL );
                    }
                }
            }

            if ( as1 ) free( as1 );
            if ( as2 ) free( as2 );

            return ret;
        }
        else
        {
            ptr = head -> sql_diag_head.error_list_head;
            while( rec_number > 1 )
            {
                ptr = ptr -> next;
                rec_number --;
            }

			if ( !ptr ) 
			{
	    		return SQL_NO_DATA;
			}

            if ( sqlstate )
            {
                wide_strcpy( sqlstate, ptr -> sqlstate );
            }
            if ( buffer_length < wide_strlen( ptr -> msg ) + 1 )
            {
                ret = SQL_SUCCESS_WITH_INFO;
            }
            else
            {
                ret = SQL_SUCCESS;
            }

            if ( message_text )
            {
                if ( ret == SQL_SUCCESS )
                {
                    wide_strcpy( message_text, ptr -> msg );
                }
                else
                {
                    memcpy( message_text, ptr -> msg, buffer_length * 2 );
                    message_text[ buffer_length - 1 ] = '\0';
                }
            }

            if ( text_length )
            {
                *text_length = wide_strlen( ptr -> msg );
            }

            if ( native_error )
            {
                *native_error = ptr -> native_error;
            }

            /*
             * map 3 to 2 if required
             */

            if ( SQL_SUCCEEDED( ret ) && sqlstate )
                __map_error_state_w( sqlstate, __get_version( head ));

            return ret;
        }
    }
    else
    {
        return SQL_NO_DATA;
    }
}
",9038
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,0,"int CloseDatabase( SQLHENV hEnv, SQLHDBC hDbc )
{
    SQLDisconnect( hDbc );
    SQLFreeConnect( hDbc );
    SQLFreeEnv( hEnv );

    return 1;
}
",9039
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,0,"void _multi_string_copy_to_wide( SQLWCHAR *out, LPCSTR in, int len )
{
    while ( len > 0 && ( in[ 0 ] || in[ 1 ] ))
    {
        *out = *in;
        out++;
        in++;
        len --;
    }
    *out++ = 0;
    *out++ = 0;
}
",9040
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,0,"static void WriteFooterHTMLTable( SQLHSTMT hStmt )
{
    printf( '</table>\n' );
}
",9041
lurcher/unixODBC,45ef78e037f578b15fc58938a3a3251655e71d6f,0,"SQLRETURN SQLSetDescFieldA( SQLHDESC descriptor_handle,
           SQLSMALLINT rec_number, 
           SQLSMALLINT field_identifier,
           SQLPOINTER value, 
           SQLINTEGER buffer_length )
{
    return SQLSetDescField( descriptor_handle,
           rec_number, 
           field_identifier,
           value, 
           buffer_length );
}
",9042
kohler/gifsicle,118a46090c50829dc543179019e6140e1235f909,1,"static Gif_Stream *
read_gif(Gif_Reader *grr, int read_flags,
	 const char* landmark, Gif_ReadErrorHandler handler)
{
  Gif_Stream *gfs;
  Gif_Image *gfi;
  Gif_Context gfc;
  int unknown_block_type = 0;

  if (gifgetc(grr) != 'G' ||
      gifgetc(grr) != 'I' ||
      gifgetc(grr) != 'F')
    return 0;
  (void)gifgetc(grr);
  (void)gifgetc(grr);
  (void)gifgetc(grr);

  gfs = Gif_NewStream();
  gfi = Gif_NewImage();

  gfc.stream = gfs;
  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);
  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);
  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);
  gfc.handler = handler;
  gfc.gfi = gfi;
  gfc.errors[0] = gfc.errors[1] = 0;

  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)
    goto done;
  gfs->landmark = landmark;

  GIF_DEBUG(('\nGIF '));
  if (!read_logical_screen_descriptor(gfs, grr))
    goto done;
  GIF_DEBUG(('logscrdesc '));

  while (!gifeof(grr)) {

    uint8_t block = gifgetbyte(grr);

    switch (block) {

     case ',': /* image block */
      GIF_DEBUG(('imageread %d ', gfs->nimages));

      gfi->identifier = last_name;
      last_name = 0;
      if (!Gif_AddImage(gfs, gfi))
          goto done;
      else if (!read_image(grr, &gfc, gfi, read_flags)) {
          Gif_RemoveImage(gfs, gfs->nimages - 1);
          goto done;
      }

      gfc.gfi = gfi = Gif_NewImage();
      if (!gfi)
          goto done;
      break;

     case ';': /* terminator */
      GIF_DEBUG(('term\n'));
      goto done;

     case '!': /* extension */
      block = gifgetbyte(grr);
      GIF_DEBUG(('ext(0x%02X) ', block));
      switch (block) {

       case 0xF9:
	read_graphic_control_extension(&gfc, gfi, grr);
	break;

       case 0xCE:
	last_name = suck_data(last_name, 0, grr);
	break;

       case 0xFE:
	if (!read_comment_extension(gfi, grr)) goto done;
	break;

       case 0xFF:
	read_application_extension(&gfc, grr);
	break;

       default:
        read_unknown_extension(&gfc, grr, block, 0, 0);
	break;

      }
      break;

     default:
       if (!unknown_block_type) {
	 char buf[256];
	 sprintf(buf, 'unknown block type %d at file offset %u', block, grr->pos - 1);
	 gif_read_error(&gfc, 1, buf);
	 unknown_block_type = 1;
       }
       break;

    }

  }

 done:

  /* Move comments and extensions after last image into stream. */
  if (gfs && gfi) {
      Gif_Extension* gfex;
      gfs->end_comment = gfi->comment;
      gfi->comment = 0;
      gfs->end_extension_list = gfi->extension_list;
      gfi->extension_list = 0;
      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)
          gfex->image = NULL;
  }

  Gif_DeleteImage(gfi);
  Gif_DeleteArray(last_name);
  Gif_DeleteArray(gfc.prefix);
  Gif_DeleteArray(gfc.suffix);
  Gif_DeleteArray(gfc.length);
  gfc.gfi = 0;

  if (gfs)
    gfs->errors = gfc.errors[1];
  if (gfs && gfc.errors[1] == 0
      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)
      && !grr->eofer(grr))
      gif_read_error(&gfc, 0, 'trailing garbage after GIF ignored');
  /* finally, export last message */
  gif_read_error(&gfc, -1, 0);

  return gfs;
}
",9043
kohler/gifsicle,118a46090c50829dc543179019e6140e1235f909,1,"static Gif_Stream *
read_gif(Gif_Reader *grr, int read_flags,
	 const char* landmark, Gif_ReadErrorHandler handler)
{
  Gif_Stream *gfs;
  Gif_Image *gfi;
  Gif_Context gfc;
  int unknown_block_type = 0;

  if (gifgetc(grr) != 'G' ||
      gifgetc(grr) != 'I' ||
      gifgetc(grr) != 'F')
    return 0;
  (void)gifgetc(grr);
  (void)gifgetc(grr);
  (void)gifgetc(grr);

  gfs = Gif_NewStream();
  gfi = Gif_NewImage();

  gfc.stream = gfs;
  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);
  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);
  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);
  gfc.handler = handler;
  gfc.gfi = gfi;
  gfc.errors[0] = gfc.errors[1] = 0;

  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)
    goto done;
  gfs->landmark = landmark;

  GIF_DEBUG(('\nGIF '));
  if (!read_logical_screen_descriptor(gfs, grr))
    goto done;
  GIF_DEBUG(('logscrdesc '));

  while (!gifeof(grr)) {

    uint8_t block = gifgetbyte(grr);

    switch (block) {

     case ',': /* image block */
      GIF_DEBUG(('imageread %d ', gfs->nimages));

      gfi->identifier = last_name;
      last_name = 0;
      if (!Gif_AddImage(gfs, gfi))
          goto done;
      else if (!read_image(grr, &gfc, gfi, read_flags)) {
          Gif_RemoveImage(gfs, gfs->nimages - 1);
          gfi = 0;
          goto done;
      }

      gfc.gfi = gfi = Gif_NewImage();
      if (!gfi)
          goto done;
      break;

     case ';': /* terminator */
      GIF_DEBUG(('term\n'));
      goto done;

     case '!': /* extension */
      block = gifgetbyte(grr);
      GIF_DEBUG(('ext(0x%02X) ', block));
      switch (block) {

       case 0xF9:
	read_graphic_control_extension(&gfc, gfi, grr);
	break;

       case 0xCE:
	last_name = suck_data(last_name, 0, grr);
	break;

       case 0xFE:
	if (!read_comment_extension(gfi, grr)) goto done;
	break;

       case 0xFF:
	read_application_extension(&gfc, grr);
	break;

       default:
        read_unknown_extension(&gfc, grr, block, 0, 0);
	break;

      }
      break;

     default:
       if (!unknown_block_type) {
	 char buf[256];
	 sprintf(buf, 'unknown block type %d at file offset %u', block, grr->pos - 1);
	 gif_read_error(&gfc, 1, buf);
	 unknown_block_type = 1;
       }
       break;

    }

  }

 done:

  /* Move comments and extensions after last image into stream. */
  if (gfs && gfi) {
      Gif_Extension* gfex;
      gfs->end_comment = gfi->comment;
      gfi->comment = 0;
      gfs->end_extension_list = gfi->extension_list;
      gfi->extension_list = 0;
      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)
          gfex->image = NULL;
  }

  Gif_DeleteImage(gfi);
  Gif_DeleteArray(last_name);
  Gif_DeleteArray(gfc.prefix);
  Gif_DeleteArray(gfc.suffix);
  Gif_DeleteArray(gfc.length);
  gfc.gfi = 0;

  if (gfs)
    gfs->errors = gfc.errors[1];
  if (gfs && gfc.errors[1] == 0
      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)
      && !grr->eofer(grr))
      gif_read_error(&gfc, 0, 'trailing garbage after GIF ignored');
  /* finally, export last message */
  gif_read_error(&gfc, -1, 0);

  return gfs;
}
",9044
kohler/gifsicle,118a46090c50829dc543179019e6140e1235f909,0,"Gif_Stream *
Gif_ReadRecord(const Gif_Record *gifrec)
{
  return Gif_FullReadRecord(gifrec, GIF_READ_UNCOMPRESSED, 0, 0);
}
",9045
kohler/gifsicle,118a46090c50829dc543179019e6140e1235f909,0,"void
Gif_SetErrorHandler(Gif_ReadErrorHandler handler) {
    default_error_handler = handler;
}
",9046
the-tcpdump-group/tcpdump,2c2cfbd2b771ac888bc5c4a6d922f749d3822538,1,"static void
ip_printroute(netdissect_options *ndo,
              register const u_char *cp, u_int length)
{
	register u_int ptr;
	register u_int len;

	if (length < 3) {
		ND_PRINT((ndo, ' [bad length %u]', length));
		return;
	}
	if ((length + 1) & 3)
		ND_PRINT((ndo, ' [bad length %u]', length));
	ptr = cp[2] - 1;
	if (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)
		ND_PRINT((ndo, ' [bad ptr %u]', cp[2]));

	for (len = 3; len < length; len += 4) {
		ND_PRINT((ndo, ' %s', ipaddr_string(ndo, &cp[len])));
		if (ptr > len)
			ND_PRINT((ndo, ','));
	}
}
",9047
the-tcpdump-group/tcpdump,2c2cfbd2b771ac888bc5c4a6d922f749d3822538,1,"static void
ip_optprint(netdissect_options *ndo,
            register const u_char *cp, u_int length)
{
	register u_int option_len;
	const char *sep = '';

	for (; length > 0; cp += option_len, length -= option_len) {
		u_int option_code;

		ND_PRINT((ndo, '%s', sep));
		sep = ',';

		ND_TCHECK(*cp);
		option_code = *cp;

		ND_PRINT((ndo, '%s',
		          tok2str(ip_option_values,'unknown %u',option_code)));

		if (option_code == IPOPT_NOP ||
                    option_code == IPOPT_EOL)
			option_len = 1;

		else {
			ND_TCHECK(cp[1]);
			option_len = cp[1];
			if (option_len < 2) {
				ND_PRINT((ndo, ' [bad length %u]', option_len));
				return;
			}
		}

		if (option_len > length) {
			ND_PRINT((ndo, ' [bad length %u]', option_len));
			return;
		}

		ND_TCHECK2(*cp, option_len);

		switch (option_code) {
		case IPOPT_EOL:
			return;

		case IPOPT_TS:
			ip_printts(ndo, cp, option_len);
			break;

		case IPOPT_RR:       /* fall through */
		case IPOPT_SSRR:
		case IPOPT_LSRR:
			ip_printroute(ndo, cp, option_len);
			break;

		case IPOPT_RA:
			if (option_len < 4) {
				ND_PRINT((ndo, ' [bad length %u]', option_len));
				break;
			}
			ND_TCHECK(cp[3]);
			if (EXTRACT_16BITS(&cp[2]) != 0)
				ND_PRINT((ndo, ' value %u', EXTRACT_16BITS(&cp[2])));
			break;

		case IPOPT_NOP:       /* nothing to print - fall through */
		case IPOPT_SECURITY:
		default:
			break;
		}
	}
	return;

trunc:
	ND_PRINT((ndo, '%s', tstr));
}
",9048
the-tcpdump-group/tcpdump,2c2cfbd2b771ac888bc5c4a6d922f749d3822538,1,"static void
ip_printts(netdissect_options *ndo,
           register const u_char *cp, u_int length)
{
	register u_int ptr;
	register u_int len;
	int hoplen;
	const char *type;

	if (length < 4) {
		ND_PRINT((ndo, '[bad length %u]', length));
		return;
	}
	ND_PRINT((ndo, ' TS{'));
	hoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;
	if ((length - 4) & (hoplen-1))
		ND_PRINT((ndo, '[bad length %u]', length));
	ptr = cp[2] - 1;
	len = 0;
	if (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)
		ND_PRINT((ndo, '[bad ptr %u]', cp[2]));
	switch (cp[3]&0xF) {
	case IPOPT_TS_TSONLY:
		ND_PRINT((ndo, 'TSONLY'));
		break;
	case IPOPT_TS_TSANDADDR:
		ND_PRINT((ndo, 'TS+ADDR'));
		break;
	/*
	 * prespecified should really be 3, but some ones might send 2
	 * instead, and the IPOPT_TS_PRESPEC constant can apparently
	 * have both values, so we have to hard-code it here.
	 */

	case 2:
		ND_PRINT((ndo, 'PRESPEC2.0'));
		break;
	case 3:			/* IPOPT_TS_PRESPEC */
		ND_PRINT((ndo, 'PRESPEC'));
		break;
	default:
		ND_PRINT((ndo, '[bad ts type %d]', cp[3]&0xF));
		goto done;
	}

	type = ' ';
	for (len = 4; len < length; len += hoplen) {
		if (ptr == len)
			type = ' ^ ';
		ND_PRINT((ndo, '%s%d@%s', type, EXTRACT_32BITS(&cp[len+hoplen-4]),
		       hoplen!=8 ? '' : ipaddr_string(ndo, &cp[len])));
		type = ' ';
	}

done:
	ND_PRINT((ndo, '%s', ptr == len ? ' ^ ' : ''));

	if (cp[3]>>4)
		ND_PRINT((ndo, ' [%d hops not recorded]} ', cp[3]>>4));
	else
		ND_PRINT((ndo, '}'));
}
",9049
the-tcpdump-group/tcpdump,2c2cfbd2b771ac888bc5c4a6d922f749d3822538,1,"static void
ip_optprint(netdissect_options *ndo,
            register const u_char *cp, u_int length)
{
	register u_int option_len;
	const char *sep = '';

	for (; length > 0; cp += option_len, length -= option_len) {
		u_int option_code;

		ND_PRINT((ndo, '%s', sep));
		sep = ',';

		ND_TCHECK(*cp);
		option_code = *cp;

		ND_PRINT((ndo, '%s',
		          tok2str(ip_option_values,'unknown %u',option_code)));

		if (option_code == IPOPT_NOP ||
                    option_code == IPOPT_EOL)
			option_len = 1;

		else {
			ND_TCHECK(cp[1]);
			option_len = cp[1];
			if (option_len < 2) {
				ND_PRINT((ndo, ' [bad length %u]', option_len));
				return;
			}
		}

		if (option_len > length) {
			ND_PRINT((ndo, ' [bad length %u]', option_len));
			return;
		}

		ND_TCHECK2(*cp, option_len);

		switch (option_code) {
		case IPOPT_EOL:
			return;

		case IPOPT_TS:
			ip_printts(ndo, cp, option_len);
			break;

		case IPOPT_RR:       /* fall through */
		case IPOPT_SSRR:
		case IPOPT_LSRR:
			if (ip_printroute(ndo, cp, option_len) == -1)
				goto trunc;
			break;

		case IPOPT_RA:
			if (option_len < 4) {
				ND_PRINT((ndo, ' [bad length %u]', option_len));
				break;
			}
			ND_TCHECK(cp[3]);
			if (EXTRACT_16BITS(&cp[2]) != 0)
				ND_PRINT((ndo, ' value %u', EXTRACT_16BITS(&cp[2])));
			break;

		case IPOPT_NOP:       /* nothing to print - fall through */
		case IPOPT_SECURITY:
		default:
			break;
		}
	}
	return;

trunc:
	ND_PRINT((ndo, '%s', tstr));
}
",9050
the-tcpdump-group/tcpdump,2c2cfbd2b771ac888bc5c4a6d922f749d3822538,0,"static void
ip_printts(netdissect_options *ndo,
           register const u_char *cp, u_int length)
{
	register u_int ptr;
	register u_int len;
	int hoplen;
	const char *type;

	if (length < 4) {
		ND_PRINT((ndo, '[bad length %u]', length));
		return;
	}
	ND_PRINT((ndo, ' TS{'));
	hoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;
	if ((length - 4) & (hoplen-1))
		ND_PRINT((ndo, '[bad length %u]', length));
	ptr = cp[2] - 1;
	len = 0;
	if (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)
		ND_PRINT((ndo, '[bad ptr %u]', cp[2]));
	switch (cp[3]&0xF) {
	case IPOPT_TS_TSONLY:
		ND_PRINT((ndo, 'TSONLY'));
		break;
	case IPOPT_TS_TSANDADDR:
		ND_PRINT((ndo, 'TS+ADDR'));
		break;
	/*
	 * prespecified should really be 3, but some ones might send 2
	 * instead, and the IPOPT_TS_PRESPEC constant can apparently
	 * have both values, so we have to hard-code it here.
	 */

	case 2:
		ND_PRINT((ndo, 'PRESPEC2.0'));
		break;
	case 3:			/* IPOPT_TS_PRESPEC */
		ND_PRINT((ndo, 'PRESPEC'));
		break;
	default:
		ND_PRINT((ndo, '[bad ts type %d]', cp[3]&0xF));
		goto done;
	}

	type = ' ';
	for (len = 4; len < length; len += hoplen) {
		if (ptr == len)
			type = ' ^ ';
		ND_PRINT((ndo, '%s%d@%s', type, EXTRACT_32BITS(&cp[len+hoplen-4]),
		       hoplen!=8 ? '' : ipaddr_string(ndo, &cp[len])));
		type = ' ';
	}

done:
	ND_PRINT((ndo, '%s', ptr == len ? ' ^ ' : ''));

	if (cp[3]>>4)
		ND_PRINT((ndo, ' [%d hops not recorded]} ', cp[3]>>4));
	else
		ND_PRINT((ndo, '}'));
}
",9051
the-tcpdump-group/tcpdump,2c2cfbd2b771ac888bc5c4a6d922f749d3822538,0,"void
ip_print(netdissect_options *ndo,
	 const u_char *bp,
	 u_int length)
{
	struct ip_print_demux_state  ipd;
	struct ip_print_demux_state *ipds=&ipd;
	const u_char *ipend;
	u_int hlen;
	struct cksum_vec vec[1];
	uint16_t sum, ip_sum;
	const char *p_name;

	ipds->ip = (const struct ip *)bp;
	ND_TCHECK(ipds->ip->ip_vhl);
	if (IP_V(ipds->ip) != 4) { /* print version and fail if != 4 */
	    if (IP_V(ipds->ip) == 6)
	      ND_PRINT((ndo, 'IP6, wrong link-layer encapsulation '));
	    else
	      ND_PRINT((ndo, 'IP%u ', IP_V(ipds->ip)));
	    return;
	}
	if (!ndo->ndo_eflag)
		ND_PRINT((ndo, 'IP '));

	ND_TCHECK(*ipds->ip);
	if (length < sizeof (struct ip)) {
		ND_PRINT((ndo, 'truncated-ip %u', length));
		return;
	}
	hlen = IP_HL(ipds->ip) * 4;
	if (hlen < sizeof (struct ip)) {
		ND_PRINT((ndo, 'bad-hlen %u', hlen));
		return;
	}

	ipds->len = EXTRACT_16BITS(&ipds->ip->ip_len);
	if (length < ipds->len)
		ND_PRINT((ndo, 'truncated-ip - %u bytes missing! ',
			ipds->len - length));
	if (ipds->len < hlen) {
#ifdef GUESS_TSO
            if (ipds->len) {
                ND_PRINT((ndo, 'bad-len %u', ipds->len));
                return;
            }
            else {
                /* we guess that it is a TSO send */
                ipds->len = length;
            }
#else
            ND_PRINT((ndo, 'bad-len %u', ipds->len));
            return;
#endif /* GUESS_TSO */
	}

	/*
	 * Cut off the snapshot length to the end of the IP payload.
	 */
	ipend = bp + ipds->len;
	if (ipend < ndo->ndo_snapend)
		ndo->ndo_snapend = ipend;

	ipds->len -= hlen;

	ipds->off = EXTRACT_16BITS(&ipds->ip->ip_off);

        if (ndo->ndo_vflag) {
            ND_PRINT((ndo, '(tos 0x%x', (int)ipds->ip->ip_tos));
            /* ECN bits */
            switch (ipds->ip->ip_tos & 0x03) {

            case 0:
                break;

            case 1:
                ND_PRINT((ndo, ',ECT(1)'));
                break;

            case 2:
                ND_PRINT((ndo, ',ECT(0)'));
                break;

            case 3:
                ND_PRINT((ndo, ',CE'));
                break;
            }

            if (ipds->ip->ip_ttl >= 1)
                ND_PRINT((ndo, ', ttl %u', ipds->ip->ip_ttl));

	    /*
	     * for the firewall guys, print id, offset.
             * On all but the last stick a '+' in the flags portion.
	     * For unfragmented datagrams, note the don't fragment flag.
	     */

	    ND_PRINT((ndo, ', id %u, offset %u, flags [%s], proto %s (%u)',
                         EXTRACT_16BITS(&ipds->ip->ip_id),
                         (ipds->off & 0x1fff) * 8,
                         bittok2str(ip_frag_values, 'none', ipds->off&0xe000),
                         tok2str(ipproto_values,'unknown',ipds->ip->ip_p),
                         ipds->ip->ip_p));

            ND_PRINT((ndo, ', length %u', EXTRACT_16BITS(&ipds->ip->ip_len)));

            if ((hlen - sizeof(struct ip)) > 0) {
                ND_PRINT((ndo, ', options ('));
                ip_optprint(ndo, (const u_char *)(ipds->ip + 1), hlen - sizeof(struct ip));
                ND_PRINT((ndo, ')'));
            }

	    if (!ndo->ndo_Kflag && (const u_char *)ipds->ip + hlen <= ndo->ndo_snapend) {
	        vec[0].ptr = (const uint8_t *)(const void *)ipds->ip;
	        vec[0].len = hlen;
	        sum = in_cksum(vec, 1);
		if (sum != 0) {
		    ip_sum = EXTRACT_16BITS(&ipds->ip->ip_sum);
		    ND_PRINT((ndo, ', bad cksum %x (->%x)!', ip_sum,
			     in_cksum_shouldbe(ip_sum, sum)));
		}
	    }

		ND_PRINT((ndo, ')\n    '));
	}

	/*
	 * If this is fragment zero, hand it to the next higher
	 * level protocol.
	 */
	if ((ipds->off & 0x1fff) == 0) {
		ipds->cp = (const u_char *)ipds->ip + hlen;
		ipds->nh = ipds->ip->ip_p;

		if (ipds->nh != IPPROTO_TCP && ipds->nh != IPPROTO_UDP &&
		    ipds->nh != IPPROTO_SCTP && ipds->nh != IPPROTO_DCCP) {
			ND_PRINT((ndo, '%s > %s: ',
				     ipaddr_string(ndo, &ipds->ip->ip_src),
				     ipaddr_string(ndo, &ipds->ip->ip_dst)));
		}
		ip_print_demux(ndo, ipds);
	} else {
		/*
		 * Ultra quiet now means that all this stuff should be
		 * suppressed.
		 */
		if (ndo->ndo_qflag > 1)
			return;

		/*
		 * This isn't the first frag, so we're missing the
		 * next level protocol header.  print the ip addr
		 * and the protocol.
		 */
		ND_PRINT((ndo, '%s > %s:', ipaddr_string(ndo, &ipds->ip->ip_src),
		          ipaddr_string(ndo, &ipds->ip->ip_dst)));
		if (!ndo->ndo_nflag && (p_name = netdb_protoname(ipds->ip->ip_p)) != NULL)
			ND_PRINT((ndo, ' %s', p_name));
		else
			ND_PRINT((ndo, ' ip-proto-%d', ipds->ip->ip_p));
	}
	return;

trunc:
	ND_PRINT((ndo, '%s', tstr));
	return;
}
",9052
the-tcpdump-group/tcpdump,2c2cfbd2b771ac888bc5c4a6d922f749d3822538,0,"int
nextproto4_cksum(netdissect_options *ndo,
                 const struct ip *ip, const uint8_t *data,
                 u_int len, u_int covlen, u_int next_proto)
{
	struct phdr {
		uint32_t src;
		uint32_t dst;
		u_char mbz;
		u_char proto;
		uint16_t len;
	} ph;
	struct cksum_vec vec[2];

	/* pseudo-header.. */
	ph.len = htons((uint16_t)len);
	ph.mbz = 0;
	ph.proto = next_proto;
	UNALIGNED_MEMCPY(&ph.src, &ip->ip_src, sizeof(uint32_t));
	if (IP_HL(ip) == 5)
		UNALIGNED_MEMCPY(&ph.dst, &ip->ip_dst, sizeof(uint32_t));
	else
		ph.dst = ip_finddst(ndo, ip);

	vec[0].ptr = (const uint8_t *)(void *)&ph;
	vec[0].len = sizeof(ph);
	vec[1].ptr = data;
	vec[1].len = covlen;
	return (in_cksum(vec, 2));
}
",9053
the-tcpdump-group/tcpdump,2c2cfbd2b771ac888bc5c4a6d922f749d3822538,0,"void
ip_print(netdissect_options *ndo,
	 const u_char *bp,
	 u_int length)
{
	struct ip_print_demux_state  ipd;
	struct ip_print_demux_state *ipds=&ipd;
	const u_char *ipend;
	u_int hlen;
	struct cksum_vec vec[1];
	uint16_t sum, ip_sum;
	const char *p_name;

	ipds->ip = (const struct ip *)bp;
	ND_TCHECK(ipds->ip->ip_vhl);
	if (IP_V(ipds->ip) != 4) { /* print version and fail if != 4 */
	    if (IP_V(ipds->ip) == 6)
	      ND_PRINT((ndo, 'IP6, wrong link-layer encapsulation '));
	    else
	      ND_PRINT((ndo, 'IP%u ', IP_V(ipds->ip)));
	    return;
	}
	if (!ndo->ndo_eflag)
		ND_PRINT((ndo, 'IP '));

	ND_TCHECK(*ipds->ip);
	if (length < sizeof (struct ip)) {
		ND_PRINT((ndo, 'truncated-ip %u', length));
		return;
	}
	hlen = IP_HL(ipds->ip) * 4;
	if (hlen < sizeof (struct ip)) {
		ND_PRINT((ndo, 'bad-hlen %u', hlen));
		return;
	}

	ipds->len = EXTRACT_16BITS(&ipds->ip->ip_len);
	if (length < ipds->len)
		ND_PRINT((ndo, 'truncated-ip - %u bytes missing! ',
			ipds->len - length));
	if (ipds->len < hlen) {
#ifdef GUESS_TSO
            if (ipds->len) {
                ND_PRINT((ndo, 'bad-len %u', ipds->len));
                return;
            }
            else {
                /* we guess that it is a TSO send */
                ipds->len = length;
            }
#else
            ND_PRINT((ndo, 'bad-len %u', ipds->len));
            return;
#endif /* GUESS_TSO */
	}

	/*
	 * Cut off the snapshot length to the end of the IP payload.
	 */
	ipend = bp + ipds->len;
	if (ipend < ndo->ndo_snapend)
		ndo->ndo_snapend = ipend;

	ipds->len -= hlen;

	ipds->off = EXTRACT_16BITS(&ipds->ip->ip_off);

        if (ndo->ndo_vflag) {
            ND_PRINT((ndo, '(tos 0x%x', (int)ipds->ip->ip_tos));
            /* ECN bits */
            switch (ipds->ip->ip_tos & 0x03) {

            case 0:
                break;

            case 1:
                ND_PRINT((ndo, ',ECT(1)'));
                break;

            case 2:
                ND_PRINT((ndo, ',ECT(0)'));
                break;

            case 3:
                ND_PRINT((ndo, ',CE'));
                break;
            }

            if (ipds->ip->ip_ttl >= 1)
                ND_PRINT((ndo, ', ttl %u', ipds->ip->ip_ttl));

	    /*
	     * for the firewall guys, print id, offset.
             * On all but the last stick a '+' in the flags portion.
	     * For unfragmented datagrams, note the don't fragment flag.
	     */

	    ND_PRINT((ndo, ', id %u, offset %u, flags [%s], proto %s (%u)',
                         EXTRACT_16BITS(&ipds->ip->ip_id),
                         (ipds->off & 0x1fff) * 8,
                         bittok2str(ip_frag_values, 'none', ipds->off&0xe000),
                         tok2str(ipproto_values,'unknown',ipds->ip->ip_p),
                         ipds->ip->ip_p));

            ND_PRINT((ndo, ', length %u', EXTRACT_16BITS(&ipds->ip->ip_len)));

            if ((hlen - sizeof(struct ip)) > 0) {
                ND_PRINT((ndo, ', options ('));
                ip_optprint(ndo, (const u_char *)(ipds->ip + 1), hlen - sizeof(struct ip));
                ND_PRINT((ndo, ')'));
            }

	    if (!ndo->ndo_Kflag && (const u_char *)ipds->ip + hlen <= ndo->ndo_snapend) {
	        vec[0].ptr = (const uint8_t *)(const void *)ipds->ip;
	        vec[0].len = hlen;
	        sum = in_cksum(vec, 1);
		if (sum != 0) {
		    ip_sum = EXTRACT_16BITS(&ipds->ip->ip_sum);
		    ND_PRINT((ndo, ', bad cksum %x (->%x)!', ip_sum,
			     in_cksum_shouldbe(ip_sum, sum)));
		}
	    }

		ND_PRINT((ndo, ')\n    '));
	}

	/*
	 * If this is fragment zero, hand it to the next higher
	 * level protocol.
	 */
	if ((ipds->off & 0x1fff) == 0) {
		ipds->cp = (const u_char *)ipds->ip + hlen;
		ipds->nh = ipds->ip->ip_p;

		if (ipds->nh != IPPROTO_TCP && ipds->nh != IPPROTO_UDP &&
		    ipds->nh != IPPROTO_SCTP && ipds->nh != IPPROTO_DCCP) {
			ND_PRINT((ndo, '%s > %s: ',
				     ipaddr_string(ndo, &ipds->ip->ip_src),
				     ipaddr_string(ndo, &ipds->ip->ip_dst)));
		}
		ip_print_demux(ndo, ipds);
	} else {
		/*
		 * Ultra quiet now means that all this stuff should be
		 * suppressed.
		 */
		if (ndo->ndo_qflag > 1)
			return;

		/*
		 * This isn't the first frag, so we're missing the
		 * next level protocol header.  print the ip addr
		 * and the protocol.
		 */
		ND_PRINT((ndo, '%s > %s:', ipaddr_string(ndo, &ipds->ip->ip_src),
		          ipaddr_string(ndo, &ipds->ip->ip_dst)));
		if (!ndo->ndo_nflag && (p_name = netdb_protoname(ipds->ip->ip_p)) != NULL)
			ND_PRINT((ndo, ' %s', p_name));
		else
			ND_PRINT((ndo, ' ip-proto-%d', ipds->ip->ip_p));
	}
	return;

trunc:
	ND_PRINT((ndo, '%s', tstr));
	return;
}
",9054
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
{
	jp2_box_t *box;
	int found;
	jas_image_t *image;
	jp2_dec_t *dec;
	bool samedtype;
	int dtype;
	unsigned int i;
	jp2_cmap_t *cmapd;
	jp2_pclr_t *pclrd;
	jp2_cdef_t *cdefd;
	unsigned int channo;
	int newcmptno;
	int_fast32_t *lutents;
#if 0
	jp2_cdefchan_t *cdefent;
	int cmptno;
#endif
	jp2_cmapent_t *cmapent;
	jas_icchdr_t icchdr;
	jas_iccprof_t *iccprof;

	dec = 0;
	box = 0;
	image = 0;

	if (!(dec = jp2_dec_create())) {
		goto error;
	}

	/* Get the first box.  This should be a JP box. */
	if (!(box = jp2_box_get(in))) {
		jas_eprintf('error: cannot get box\n');
		goto error;
	}
	if (box->type != JP2_BOX_JP) {
		jas_eprintf('error: expecting signature box\n');
		goto error;
	}
	if (box->data.jp.magic != JP2_JP_MAGIC) {
		jas_eprintf('incorrect magic number\n');
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get the second box.  This should be a FTYP box. */
	if (!(box = jp2_box_get(in))) {
		goto error;
	}
	if (box->type != JP2_BOX_FTYP) {
		jas_eprintf('expecting file type box\n');
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get more boxes... */
	found = 0;
	while ((box = jp2_box_get(in))) {
		if (jas_getdbglevel() >= 1) {
			jas_eprintf('got box type %s\n', box->info->name);
		}
		switch (box->type) {
		case JP2_BOX_JP2C:
			found = 1;
			break;
		case JP2_BOX_IHDR:
			if (!dec->ihdr) {
				dec->ihdr = box;
				box = 0;
			}
			break;
		case JP2_BOX_BPCC:
			if (!dec->bpcc) {
				dec->bpcc = box;
				box = 0;
			}
			break;
		case JP2_BOX_CDEF:
			if (!dec->cdef) {
				dec->cdef = box;
				box = 0;
			}
			break;
		case JP2_BOX_PCLR:
			if (!dec->pclr) {
				dec->pclr = box;
				box = 0;
			}
			break;
		case JP2_BOX_CMAP:
			if (!dec->cmap) {
				dec->cmap = box;
				box = 0;
			}
			break;
		case JP2_BOX_COLR:
			if (!dec->colr) {
				dec->colr = box;
				box = 0;
			}
			break;
		}
		if (box) {
			jp2_box_destroy(box);
			box = 0;
		}
		if (found) {
			break;
		}
	}

	if (!found) {
		jas_eprintf('error: no code stream found\n');
		goto error;
	}

	if (!(dec->image = jpc_decode(in, optstr))) {
		jas_eprintf('error: cannot decode code stream\n');
		goto error;
	}

	/* An IHDR box must be present. */
	if (!dec->ihdr) {
		jas_eprintf('error: missing IHDR box\n');
		goto error;
	}

	/* Does the number of components indicated in the IHDR box match
	  the value specified in the code stream? */
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
	  jas_image_numcmpts(dec->image))) {
		jas_eprintf('warning: number of components mismatch\n');
	}

	/* At least one component must be present. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf('error: no components\n');
		goto error;
	}

	/* Determine if all components have the same data type. */
	samedtype = true;
	dtype = jas_image_cmptdtype(dec->image, 0);
	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		if (jas_image_cmptdtype(dec->image, i) != dtype) {
			samedtype = false;
			break;
		}
	}

	/* Is the component data type indicated in the IHDR box consistent
	  with the data in the code stream? */
	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
		jas_eprintf('warning: component data type mismatch\n');
	}

	/* Is the compression type supported? */
	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
		jas_eprintf('error: unsupported compression type\n');
		goto error;
	}

	if (dec->bpcc) {
		/* Is the number of components indicated in the BPCC box
		  consistent with the code stream data? */
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
		  dec->image))) {
			jas_eprintf('warning: number of components mismatch\n');
		}
		/* Is the component data type information indicated in the BPCC
		  box consistent with the code stream data? */
		if (!samedtype) {
			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
			  ++i) {
				if (jas_image_cmptdtype(dec->image, i) !=
				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
					jas_eprintf('warning: component data type mismatch\n');
				}
			}
		} else {
			jas_eprintf('warning: superfluous BPCC box\n');
		}
	}

	/* A COLR box must be present. */
	if (!dec->colr) {
		jas_eprintf('error: no COLR box\n');
		goto error;
	}

	switch (dec->colr->data.colr.method) {
	case JP2_COLR_ENUM:
		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
		break;
	case JP2_COLR_ICC:
		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
		  dec->colr->data.colr.iccplen);
		if (!iccprof) {
			jas_eprintf('error: failed to parse ICC profile\n');
			goto error;
		}
		jas_iccprof_gethdr(iccprof, &icchdr);
		jas_eprintf('ICC Profile CS %08x\n', icchdr.colorspc);
		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
		assert(dec->image->cmprof_);
		jas_iccprof_destroy(iccprof);
		break;
	}

	/* If a CMAP box is present, a PCLR box must also be present. */
	if (dec->cmap && !dec->pclr) {
		jas_eprintf('warning: missing PCLR box or superfluous CMAP box\n');
		jp2_box_destroy(dec->cmap);
		dec->cmap = 0;
	}

	/* If a CMAP box is not present, a PCLR box must not be present. */
	if (!dec->cmap && dec->pclr) {
		jas_eprintf('warning: missing CMAP box or superfluous PCLR box\n');
		jp2_box_destroy(dec->pclr);
		dec->pclr = 0;
	}

	/* Determine the number of channels (which is essentially the number
	  of components after any palette mappings have been applied). */
	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
	  JAS_CAST(uint, jas_image_numcmpts(dec->image));

	/* Perform a basic sanity check on the CMAP box if present. */
	if (dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the component number reasonable? */
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
			  jas_image_numcmpts(dec->image))) {
				jas_eprintf('error: invalid component number in CMAP box\n');
				goto error;
			}
			/* Is the LUT index reasonable? */
			if (dec->cmap->data.cmap.ents[i].pcol >=
			  dec->pclr->data.pclr.numchans) {
				jas_eprintf('error: invalid CMAP LUT index\n');
				goto error;
			}
		}
	}

	/* Allocate space for the channel-number to component-number LUT. */
	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
	  sizeof(uint_fast16_t)))) {
		jas_eprintf('error: no memory\n');
		goto error;
	}

	if (!dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			dec->chantocmptlut[i] = i;
		}
	} else {
		cmapd = &dec->cmap->data.cmap;
		pclrd = &dec->pclr->data.pclr;
		cdefd = &dec->cdef->data.cdef;
		for (channo = 0; channo < cmapd->numchans; ++channo) {
			cmapent = &cmapd->ents[channo];
			if (cmapent->map == JP2_CMAP_DIRECT) {
				dec->chantocmptlut[channo] = channo;
			} else if (cmapent->map == JP2_CMAP_PALETTE) {
				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
				for (i = 0; i < pclrd->numlutents; ++i) {
					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
				}
				newcmptno = jas_image_numcmpts(dec->image);
				jas_image_depalettize(dec->image, cmapent->cmptno,
				  pclrd->numlutents, lutents,
				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
				dec->chantocmptlut[channo] = newcmptno;
				jas_free(lutents);
#if 0
				if (dec->cdef) {
					cdefent = jp2_cdef_lookup(cdefd, channo);
					if (!cdefent) {
						abort();
					}
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
				} else {
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
				}
#endif
			}
		}
	}

	/* Mark all components as being of unknown type. */

	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
	}

	/* Determine the type of each component. */
	if (dec->cdef) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the channel number reasonable? */
			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
				jas_eprintf('error: invalid channel number in CDEF box\n');
				goto error;
			}
			jas_image_setcmpttype(dec->image,
			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
			  jp2_getct(jas_image_clrspc(dec->image),
			  dec->cdef->data.cdef.ents[i].type,
			  dec->cdef->data.cdef.ents[i].assoc));
		}
	} else {
		for (i = 0; i < dec->numchans; ++i) {
			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
		}
	}

	/* Delete any components that are not of interest. */
	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
			jas_image_delcmpt(dec->image, i - 1);
		}
	}

	/* Ensure that some components survived. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf('error: no components\n');
		goto error;
	}
#if 0
jas_eprintf('no of components is %d\n', jas_image_numcmpts(dec->image));
#endif

	/* Prevent the image from being destroyed later. */
	image = dec->image;
	dec->image = 0;

	jp2_dec_destroy(dec);

	return image;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (dec) {
		jp2_dec_destroy(dec);
	}
	return 0;
}
",9055
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)
{
	jp2_box_t *box;
	int found;
	jas_image_t *image;
	jp2_dec_t *dec;
	bool samedtype;
	int dtype;
	unsigned int i;
	jp2_cmap_t *cmapd;
	jp2_pclr_t *pclrd;
	jp2_cdef_t *cdefd;
	unsigned int channo;
	int newcmptno;
	int_fast32_t *lutents;
#if 0
	jp2_cdefchan_t *cdefent;
	int cmptno;
#endif
	jp2_cmapent_t *cmapent;
	jas_icchdr_t icchdr;
	jas_iccprof_t *iccprof;

	dec = 0;
	box = 0;
	image = 0;

	JAS_DBGLOG(100, ('jp2_decode(%p, \'%s\')\n', in, optstr));

	if (!(dec = jp2_dec_create())) {
		goto error;
	}

	/* Get the first box.  This should be a JP box. */
	if (!(box = jp2_box_get(in))) {
		jas_eprintf('error: cannot get box\n');
		goto error;
	}
	if (box->type != JP2_BOX_JP) {
		jas_eprintf('error: expecting signature box\n');
		goto error;
	}
	if (box->data.jp.magic != JP2_JP_MAGIC) {
		jas_eprintf('incorrect magic number\n');
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get the second box.  This should be a FTYP box. */
	if (!(box = jp2_box_get(in))) {
		goto error;
	}
	if (box->type != JP2_BOX_FTYP) {
		jas_eprintf('expecting file type box\n');
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get more boxes... */
	found = 0;
	while ((box = jp2_box_get(in))) {
		if (jas_getdbglevel() >= 1) {
			jas_eprintf('got box type %s\n', box->info->name);
		}
		switch (box->type) {
		case JP2_BOX_JP2C:
			found = 1;
			break;
		case JP2_BOX_IHDR:
			if (!dec->ihdr) {
				dec->ihdr = box;
				box = 0;
			}
			break;
		case JP2_BOX_BPCC:
			if (!dec->bpcc) {
				dec->bpcc = box;
				box = 0;
			}
			break;
		case JP2_BOX_CDEF:
			if (!dec->cdef) {
				dec->cdef = box;
				box = 0;
			}
			break;
		case JP2_BOX_PCLR:
			if (!dec->pclr) {
				dec->pclr = box;
				box = 0;
			}
			break;
		case JP2_BOX_CMAP:
			if (!dec->cmap) {
				dec->cmap = box;
				box = 0;
			}
			break;
		case JP2_BOX_COLR:
			if (!dec->colr) {
				dec->colr = box;
				box = 0;
			}
			break;
		}
		if (box) {
			jp2_box_destroy(box);
			box = 0;
		}
		if (found) {
			break;
		}
	}

	if (!found) {
		jas_eprintf('error: no code stream found\n');
		goto error;
	}

	if (!(dec->image = jpc_decode(in, optstr))) {
		jas_eprintf('error: cannot decode code stream\n');
		goto error;
	}

	/* An IHDR box must be present. */
	if (!dec->ihdr) {
		jas_eprintf('error: missing IHDR box\n');
		goto error;
	}

	/* Does the number of components indicated in the IHDR box match
	  the value specified in the code stream? */
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,
	  jas_image_numcmpts(dec->image))) {
		jas_eprintf('warning: number of components mismatch\n');
	}

	/* At least one component must be present. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf('error: no components\n');
		goto error;
	}

	/* Determine if all components have the same data type. */
	samedtype = true;
	dtype = jas_image_cmptdtype(dec->image, 0);
	for (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {
		if (jas_image_cmptdtype(dec->image, i) != dtype) {
			samedtype = false;
			break;
		}
	}

	/* Is the component data type indicated in the IHDR box consistent
	  with the data in the code stream? */
	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
		jas_eprintf('warning: component data type mismatch\n');
	}

	/* Is the compression type supported? */
	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
		jas_eprintf('error: unsupported compression type\n');
		goto error;
	}

	if (dec->bpcc) {
		/* Is the number of components indicated in the BPCC box
		  consistent with the code stream data? */
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(
		  dec->image))) {
			jas_eprintf('warning: number of components mismatch\n');
		}
		/* Is the component data type information indicated in the BPCC
		  box consistent with the code stream data? */
		if (!samedtype) {
			for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));
			  ++i) {
				if (jas_image_cmptdtype(dec->image, i) !=
				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
					jas_eprintf('warning: component data type mismatch\n');
				}
			}
		} else {
			jas_eprintf('warning: superfluous BPCC box\n');
		}
	}

	/* A COLR box must be present. */
	if (!dec->colr) {
		jas_eprintf('error: no COLR box\n');
		goto error;
	}

	switch (dec->colr->data.colr.method) {
	case JP2_COLR_ENUM:
		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
		break;
	case JP2_COLR_ICC:
		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
		  dec->colr->data.colr.iccplen);
		if (!iccprof) {
			jas_eprintf('error: failed to parse ICC profile\n');
			goto error;
		}
		jas_iccprof_gethdr(iccprof, &icchdr);
		jas_eprintf('ICC Profile CS %08x\n', icchdr.colorspc);
		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
		assert(dec->image->cmprof_);
		jas_iccprof_destroy(iccprof);
		break;
	}

	/* If a CMAP box is present, a PCLR box must also be present. */
	if (dec->cmap && !dec->pclr) {
		jas_eprintf('warning: missing PCLR box or superfluous CMAP box\n');
		jp2_box_destroy(dec->cmap);
		dec->cmap = 0;
	}

	/* If a CMAP box is not present, a PCLR box must not be present. */
	if (!dec->cmap && dec->pclr) {
		jas_eprintf('warning: missing CMAP box or superfluous PCLR box\n');
		jp2_box_destroy(dec->pclr);
		dec->pclr = 0;
	}

	/* Determine the number of channels (which is essentially the number
	  of components after any palette mappings have been applied). */
	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
	  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));

	/* Perform a basic sanity check on the CMAP box if present. */
	if (dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the component number reasonable? */
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,
			  jas_image_numcmpts(dec->image))) {
				jas_eprintf('error: invalid component number in CMAP box\n');
				goto error;
			}
			/* Is the LUT index reasonable? */
			if (dec->cmap->data.cmap.ents[i].pcol >=
			  dec->pclr->data.pclr.numchans) {
				jas_eprintf('error: invalid CMAP LUT index\n');
				goto error;
			}
		}
	}

	/* Allocate space for the channel-number to component-number LUT. */
	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
	  sizeof(uint_fast16_t)))) {
		jas_eprintf('error: no memory\n');
		goto error;
	}

	if (!dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			dec->chantocmptlut[i] = i;
		}
	} else {
		cmapd = &dec->cmap->data.cmap;
		pclrd = &dec->pclr->data.pclr;
		cdefd = &dec->cdef->data.cdef;
		for (channo = 0; channo < cmapd->numchans; ++channo) {
			cmapent = &cmapd->ents[channo];
			if (cmapent->map == JP2_CMAP_DIRECT) {
				dec->chantocmptlut[channo] = channo;
			} else if (cmapent->map == JP2_CMAP_PALETTE) {
				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
				for (i = 0; i < pclrd->numlutents; ++i) {
					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
				}
				newcmptno = jas_image_numcmpts(dec->image);
				jas_image_depalettize(dec->image, cmapent->cmptno,
				  pclrd->numlutents, lutents,
				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
				dec->chantocmptlut[channo] = newcmptno;
				jas_free(lutents);
#if 0
				if (dec->cdef) {
					cdefent = jp2_cdef_lookup(cdefd, channo);
					if (!cdefent) {
						abort();
					}
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
				} else {
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
				}
#endif
			}
		}
	}

	/* Mark all components as being of unknown type. */

	for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {
		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
	}

	/* Determine the type of each component. */
	if (dec->cdef) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the channel number reasonable? */
			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
				jas_eprintf('error: invalid channel number in CDEF box\n');
				goto error;
			}
			jas_image_setcmpttype(dec->image,
			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
			  jp2_getct(jas_image_clrspc(dec->image),
			  dec->cdef->data.cdef.ents[i].type,
			  dec->cdef->data.cdef.ents[i].assoc));
		}
	} else {
		for (i = 0; i < dec->numchans; ++i) {
			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
		}
	}

	/* Delete any components that are not of interest. */
	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
			jas_image_delcmpt(dec->image, i - 1);
		}
	}

	/* Ensure that some components survived. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf('error: no components\n');
		goto error;
	}
#if 0
jas_eprintf('no of components is %d\n', jas_image_numcmpts(dec->image));
#endif

	/* Prevent the image from being destroyed later. */
	image = dec->image;
	dec->image = 0;

	jp2_dec_destroy(dec);

	return image;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (dec) {
		jp2_dec_destroy(dec);
	}
	return 0;
}
",9056
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
{
	jp2_box_t *box;
	int found;
	jas_image_t *image;
	jp2_dec_t *dec;
	bool samedtype;
	int dtype;
	unsigned int i;
	jp2_cmap_t *cmapd;
	jp2_pclr_t *pclrd;
	jp2_cdef_t *cdefd;
	unsigned int channo;
	int newcmptno;
	int_fast32_t *lutents;
#if 0
	jp2_cdefchan_t *cdefent;
	int cmptno;
#endif
	jp2_cmapent_t *cmapent;
	jas_icchdr_t icchdr;
	jas_iccprof_t *iccprof;

	dec = 0;
	box = 0;
	image = 0;

	if (!(dec = jp2_dec_create())) {
		goto error;
	}

	/* Get the first box.  This should be a JP box. */
	if (!(box = jp2_box_get(in))) {
		jas_eprintf('error: cannot get box\n');
		goto error;
	}
	if (box->type != JP2_BOX_JP) {
		jas_eprintf('error: expecting signature box\n');
		goto error;
	}
	if (box->data.jp.magic != JP2_JP_MAGIC) {
		jas_eprintf('incorrect magic number\n');
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get the second box.  This should be a FTYP box. */
	if (!(box = jp2_box_get(in))) {
		goto error;
	}
	if (box->type != JP2_BOX_FTYP) {
		jas_eprintf('expecting file type box\n');
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get more boxes... */
	found = 0;
	while ((box = jp2_box_get(in))) {
		if (jas_getdbglevel() >= 1) {
			jas_eprintf('box type %s\n', box->info->name);
		}
		switch (box->type) {
		case JP2_BOX_JP2C:
			found = 1;
			break;
		case JP2_BOX_IHDR:
			if (!dec->ihdr) {
				dec->ihdr = box;
				box = 0;
			}
			break;
		case JP2_BOX_BPCC:
			if (!dec->bpcc) {
				dec->bpcc = box;
				box = 0;
			}
			break;
		case JP2_BOX_CDEF:
			if (!dec->cdef) {
				dec->cdef = box;
				box = 0;
			}
			break;
		case JP2_BOX_PCLR:
			if (!dec->pclr) {
				dec->pclr = box;
				box = 0;
			}
			break;
		case JP2_BOX_CMAP:
			if (!dec->cmap) {
				dec->cmap = box;
				box = 0;
			}
			break;
		case JP2_BOX_COLR:
			if (!dec->colr) {
				dec->colr = box;
				box = 0;
			}
			break;
		}
		if (box) {
			jp2_box_destroy(box);
			box = 0;
		}
		if (found) {
			break;
		}
	}

	if (!found) {
		jas_eprintf('error: no code stream found\n');
		goto error;
	}

	if (!(dec->image = jpc_decode(in, optstr))) {
		jas_eprintf('error: cannot decode code stream\n');
		goto error;
	}

	/* An IHDR box must be present. */
	if (!dec->ihdr) {
		jas_eprintf('error: missing IHDR box\n');
		goto error;
	}

	/* Does the number of components indicated in the IHDR box match
	  the value specified in the code stream? */
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
	  jas_image_numcmpts(dec->image))) {
		jas_eprintf('warning: number of components mismatch\n');
	}

	/* At least one component must be present. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf('error: no components\n');
		goto error;
	}

	/* Determine if all components have the same data type. */
	samedtype = true;
	dtype = jas_image_cmptdtype(dec->image, 0);
	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		if (jas_image_cmptdtype(dec->image, i) != dtype) {
			samedtype = false;
			break;
		}
	}

	/* Is the component data type indicated in the IHDR box consistent
	  with the data in the code stream? */
	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
		jas_eprintf('warning: component data type mismatch\n');
	}

	/* Is the compression type supported? */
	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
		jas_eprintf('error: unsupported compression type\n');
		goto error;
	}

	if (dec->bpcc) {
		/* Is the number of components indicated in the BPCC box
		  consistent with the code stream data? */
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
		  dec->image))) {
			jas_eprintf('warning: number of components mismatch\n');
		}
		/* Is the component data type information indicated in the BPCC
		  box consistent with the code stream data? */
		if (!samedtype) {
			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
			  ++i) {
				if (jas_image_cmptdtype(dec->image, i) !=
				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
					jas_eprintf('warning: component data type mismatch\n');
				}
			}
		} else {
			jas_eprintf('warning: superfluous BPCC box\n');
		}
	}

	/* A COLR box must be present. */
	if (!dec->colr) {
		jas_eprintf('error: no COLR box\n');
		goto error;
	}

	switch (dec->colr->data.colr.method) {
	case JP2_COLR_ENUM:
		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
		break;
	case JP2_COLR_ICC:
		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
		  dec->colr->data.colr.iccplen);
		if (!iccprof) {
			jas_eprintf('error: failed to parse ICC profile\n');
			goto error;
		}
		jas_iccprof_gethdr(iccprof, &icchdr);
		jas_eprintf('ICC Profile CS %08x\n', icchdr.colorspc);
		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
		assert(dec->image->cmprof_);
		jas_iccprof_destroy(iccprof);
		break;
	}

	/* If a CMAP box is present, a PCLR box must also be present. */
	if (dec->cmap && !dec->pclr) {
		jas_eprintf('warning: missing PCLR box or superfluous CMAP box\n');
		jp2_box_destroy(dec->cmap);
		dec->cmap = 0;
	}

	/* If a CMAP box is not present, a PCLR box must not be present. */
	if (!dec->cmap && dec->pclr) {
		jas_eprintf('warning: missing CMAP box or superfluous PCLR box\n');
		jp2_box_destroy(dec->pclr);
		dec->pclr = 0;
	}

	/* Determine the number of channels (which is essentially the number
	  of components after any palette mappings have been applied). */
	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
	  JAS_CAST(uint, jas_image_numcmpts(dec->image));

	/* Perform a basic sanity check on the CMAP box if present. */
	if (dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the component number reasonable? */
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
			  jas_image_numcmpts(dec->image))) {
				jas_eprintf('error: invalid component number in CMAP box\n');
				goto error;
			}
			/* Is the LUT index reasonable? */
			if (dec->cmap->data.cmap.ents[i].pcol >=
			  dec->pclr->data.pclr.numchans) {
				jas_eprintf('error: invalid CMAP LUT index\n');
				goto error;
			}
		}
	}

	/* Allocate space for the channel-number to component-number LUT. */
	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
	  sizeof(uint_fast16_t)))) {
		jas_eprintf('error: no memory\n');
		goto error;
	}

	if (!dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			dec->chantocmptlut[i] = i;
		}
	} else {
		cmapd = &dec->cmap->data.cmap;
		pclrd = &dec->pclr->data.pclr;
		cdefd = &dec->cdef->data.cdef;
		for (channo = 0; channo < cmapd->numchans; ++channo) {
			cmapent = &cmapd->ents[channo];
			if (cmapent->map == JP2_CMAP_DIRECT) {
				dec->chantocmptlut[channo] = channo;
			} else if (cmapent->map == JP2_CMAP_PALETTE) {
				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
				for (i = 0; i < pclrd->numlutents; ++i) {
					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
				}
				newcmptno = jas_image_numcmpts(dec->image);
				jas_image_depalettize(dec->image, cmapent->cmptno,
				  pclrd->numlutents, lutents,
				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
				dec->chantocmptlut[channo] = newcmptno;
				jas_free(lutents);
#if 0
				if (dec->cdef) {
					cdefent = jp2_cdef_lookup(cdefd, channo);
					if (!cdefent) {
						abort();
					}
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
				} else {
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
				}
#endif
			}
		}
	}

	/* Mark all components as being of unknown type. */

	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
	}

	/* Determine the type of each component. */
	if (dec->cdef) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the channel number reasonable? */
			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
				jas_eprintf('error: invalid channel number in CDEF box\n');
				goto error;
			}
			jas_image_setcmpttype(dec->image,
			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
			  jp2_getct(jas_image_clrspc(dec->image),
			  dec->cdef->data.cdef.ents[i].type,
			  dec->cdef->data.cdef.ents[i].assoc));
		}
	} else {
		for (i = 0; i < dec->numchans; ++i) {
			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
		}
	}

	/* Delete any components that are not of interest. */
	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
			jas_image_delcmpt(dec->image, i - 1);
		}
	}

	/* Ensure that some components survived. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf('error: no components\n');
		goto error;
	}
#if 0
jas_eprintf('no of components is %d\n', jas_image_numcmpts(dec->image));
#endif

	/* Prevent the image from being destroyed later. */
	image = dec->image;
	dec->image = 0;

	jp2_dec_destroy(dec);

	return image;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (dec) {
		jp2_dec_destroy(dec);
	}
	return 0;
}
",9057
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"jp2_box_t *jp2_box_create(int type)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		return 0;
	}
	memset(box, 0, sizeof(jp2_box_t));
	box->type = type;
	box->len = 0;
	if (!(boxinfo = jp2_boxinfolookup(type))) {
		return 0;
	}
	box->info = boxinfo;
	box->ops = &boxinfo->ops;
	return box;
}
",9058
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}

	// Mark the box data as never having been constructed
	// so that we will not errantly attempt to destroy it later.
	box->ops = &jp2_boxinfo_unk.ops;

	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
	box->info = boxinfo;
	box->len = len;
	JAS_DBGLOG(10, (
	  'preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n',
	  ''', boxinfo->name, ''', box->type, box->len
	  ));
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf('warning: cannot handle large 64-bit box length\n');
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			jas_eprintf('cannot copy box data\n');
			goto error;
		}
		jas_stream_rewind(tmpstream);

		// From here onwards, the box data will need to be destroyed.
		// So, initialize the box operations.
		box->ops = &boxinfo->ops;

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf('cannot parse box data\n');
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
",9059
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_bpcc_t *bpcc = &box->data.bpcc;
	unsigned int i;
	bpcc->numcmpts = box->datalen;
	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
		return -1;
	}
	for (i = 0; i < bpcc->numcmpts; ++i) {
		if (jp2_getuint8(in, &bpcc->bpcs[i])) {
			return -1;
		}
	}
	return 0;
}
",9060
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_cdef_t *cdef = &box->data.cdef;
	jp2_cdefchan_t *chan;
	unsigned int channo;
	if (jp2_getuint16(in, &cdef->numchans)) {
		return -1;
	}
	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
		return -1;
	}
	for (channo = 0; channo < cdef->numchans; ++channo) {
		chan = &cdef->ents[channo];
		if (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||
		  jp2_getuint16(in, &chan->assoc)) {
			return -1;
		}
	}
	return 0;
}
",9061
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
{
	jas_stream_t *tmpstream;
	bool extlen;
	bool dataflag;

	tmpstream = 0;

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (box->ops->putdata) {
			if ((*box->ops->putdata)(box, tmpstream)) {
				goto error;
			}
		}
		box->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);
		jas_stream_rewind(tmpstream);
	}
	extlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;
	if (jp2_putuint32(out, extlen ? 1 : box->len)) {
		goto error;
	}
	if (jp2_putuint32(out, box->type)) {
		goto error;
	}
	if (extlen) {
		if (jp2_putuint64(out, box->len)) {
			goto error;
		}
	}

	if (dataflag) {
		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
			goto error;
		}
		jas_stream_close(tmpstream);
	}

	return 0;

error:

	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return -1;
}
",9062
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_cmap_t *cmap = &box->data.cmap;
	jp2_cmapent_t *ent;
	unsigned int i;

	cmap->numchans = (box->datalen) / 4;
	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
		return -1;
	}
	for (i = 0; i < cmap->numchans; ++i) {
		ent = &cmap->ents[i];
		if (jp2_getuint16(in, &ent->cmptno) ||
		  jp2_getuint8(in, &ent->map) ||
		  jp2_getuint8(in, &ent->pcol)) {
			return -1;
		}
	}
	
	return 0;
}
",9063
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_pclr_t *pclr = &box->data.pclr;
	int lutsize;
	unsigned int i;
	unsigned int j;
	int_fast32_t x;

	pclr->lutdata = 0;

	if (jp2_getuint16(in, &pclr->numlutents) ||
	  jp2_getuint8(in, &pclr->numchans)) {
		return -1;
	}
	lutsize = pclr->numlutents * pclr->numchans;
	if (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {
		return -1;
	}
	if (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {
		return -1;
	}
	for (i = 0; i < pclr->numchans; ++i) {
		if (jp2_getuint8(in, &pclr->bpc[i])) {
			return -1;
		}
	}
	for (i = 0; i < pclr->numlutents; ++i) {
		for (j = 0; j < pclr->numchans; ++j) {
			if (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,
			  (pclr->bpc[j] & 0x7f) + 1, &x)) {
				return -1;
			}
			pclr->lutdata[i * pclr->numchans + j] = x;
		}
	}
	return 0;
}
",9064
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
{
#if 0
	jp2_pclr_t *pclr = &box->data.pclr;
#endif
/* Eliminate warning about unused variable. */
box = 0;
out = 0;
	return -1;
}
",9065
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}
	box->ops = &jp2_boxinfo_unk.ops;
	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
	box->info = boxinfo;
	box->ops = &boxinfo->ops;
	box->len = len;
	JAS_DBGLOG(10, (
	  'preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n',
	  ''', boxinfo->name, ''', box->type, box->len
	  ));
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf('warning: cannot handle large 64-bit box length\n');
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			// Mark the box data as never having been constructed
			// so that we will not errantly attempt to destroy it later.
			box->ops = &jp2_boxinfo_unk.ops;
			jas_eprintf('cannot copy box data\n');
			goto error;
		}
		jas_stream_rewind(tmpstream);

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf('cannot parse box data\n');
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
",9066
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"void jp2_box_dump(jp2_box_t *box, FILE *out)
{
	jp2_boxinfo_t *boxinfo;
	boxinfo = jp2_boxinfolookup(box->type);
	assert(boxinfo);

	fprintf(out, 'JP2 box: ');
	fprintf(out, 'type=%c%s%c (0x%08'PRIxFAST32'); length=%'PRIuFAST32'\n', ''', boxinfo->name,
	  ''', box->type, box->len);
	if (box->ops->dumpdata) {
		(*box->ops->dumpdata)(box, out);
	}
}
",9067
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,1,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}
	box->ops = &jp2_boxinfo_unk.ops;
	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
	box->info = boxinfo;
	box->ops = &boxinfo->ops;
	box->len = len;
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf('warning: cannot handle large 64-bit box length\n');
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			jas_eprintf('cannot copy box data\n');
			goto error;
		}
		jas_stream_rewind(tmpstream);

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf('cannot parse box data\n');
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
",9068
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0," * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
",9069
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"static int fromiccpcs(int cs)
{
	switch (cs) {
	case ICC_CS_RGB:
		return JAS_CLRSPC_GENRGB;
		break;
	case ICC_CS_YCBCR:
		return JAS_CLRSPC_GENYCBCR;
		break;
	case ICC_CS_GRAY:
		return JAS_CLRSPC_GENGRAY;
		break;
	}
	return JAS_CLRSPC_UNKNOWN;
}
",9070
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"int jp2_validate(jas_stream_t *in)
{
	char buf[JP2_VALIDATELEN];
	int i;
	int n;
#if 0
	jas_stream_t *tmpstream;
	jp2_box_t *box;
#endif

	assert(JAS_STREAM_MAXPUTBACK >= JP2_VALIDATELEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, buf, JP2_VALIDATELEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	/* Did we read enough data? */
	if (n < JP2_VALIDATELEN) {
		return -1;
	}

	/* Is the box type correct? */
	if (((buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7]) !=
	  JP2_BOX_JP)
	{
		return -1;
	}

	return 0;
}
",9071
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"void jp2_box_destroy(jp2_box_t *box)
{
	if (box->ops->destroy) {
		(*box->ops->destroy)(box);
	}
	jas_free(box);
}
",9072
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_cdef_t *cdef = &box->data.cdef;
	jp2_cdefchan_t *chan;
	unsigned int channo;
	if (jp2_getuint16(in, &cdef->numchans)) {
		return -1;
	}
	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
		return -1;
	}
	for (channo = 0; channo < cdef->numchans; ++channo) {
		chan = &cdef->ents[channo];
		if (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||
		  jp2_getuint16(in, &chan->assoc)) {
			return -1;
		}
	}
	return 0;
}
",9073
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"static int jp2_putuint64(jas_stream_t *out, uint_fast64_t val)
{
	if (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||
	  jp2_putuint32(out, val & 0xffffffffUL)) {
		return -1;
	}
	return 0;
}
",9074
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"static void jp2_cmap_destroy(jp2_box_t *box)
{
	jp2_cmap_t *cmap = &box->data.cmap;
	if (cmap->ents) {
		jas_free(cmap->ents);
	}
}
",9075
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"static int jp2_getcs(jp2_colr_t *colr)
{
	if (colr->method == JP2_COLR_ENUM) {
		switch (colr->csid) {
		case JP2_COLR_SRGB:
			return JAS_CLRSPC_SRGB;
			break;
		case JP2_COLR_SYCC:
			return JAS_CLRSPC_SYCBCR;
			break;
		case JP2_COLR_SGRAY:
			return JAS_CLRSPC_SGRAY;
			break;
		}
	}
	return JAS_CLRSPC_UNKNOWN;
}
",9076
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"static void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out)
{
	jp2_pclr_t *pclr = &box->data.pclr;
	unsigned int i;
	int j;
	fprintf(out, 'numents=%d; numchans=%d\n', (int) pclr->numlutents,
	  (int) pclr->numchans);
	for (i = 0; i < pclr->numlutents; ++i) {
		for (j = 0; j < pclr->numchans; ++j) {
			fprintf(out, 'LUT[%d][%d]=%'PRIiFAST32'\n', i, j,
			  pclr->lutdata[i * pclr->numchans + j]);
		}
	}
}
",9077
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0," * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
",9078
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0," * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH
 * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,
",9079
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0," * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE
 * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE
 * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.
 * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS
 * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL
",9080
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"static int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)
{
	int c;
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;
	}
	if (val) {
		*val = c;
	}
	return 0;
}
",9081
mdadams/jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,0,"static int jp2_putuint32(jas_stream_t *out, uint_fast32_t val)
{
	if (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||
	  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||
	  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||
	  jas_stream_putc(out, val & 0xff) == EOF) {
		return -1;
	}
	return 0;
}
",9082
xelerance/Openswan,9eaa6c2a823c1d2b58913506a15f9474bf857a3d,1,"err_t verify_signed_hash(const struct RSA_public_key *k
                         , u_char *s, unsigned int s_max_octets
                         , u_char **psig
                         , size_t hash_len
                         , const u_char *sig_val, size_t sig_len)
{
    unsigned int padlen;

    /* actual exponentiation; see PKCS#1 v2.0 5.1 */
    {
	chunk_t temp_s;
	MP_INT c;

	n_to_mpz(&c, sig_val, sig_len);
	oswcrypto.mod_exp(&c, &c, &k->e, &k->n);

	temp_s = mpz_to_n(&c, sig_len);	/* back to octets */
        if(s_max_octets < sig_len) {
            return '2''exponentiation failed; too many octets';
        }
	memcpy(s, temp_s.ptr, sig_len);
	pfree(temp_s.ptr);
	mpz_clear(&c);
    }

    /* check signature contents */
    /* verify padding (not including any DER digest info! */
    padlen = sig_len - 3 - hash_len;
    /* now check padding */

    DBG(DBG_CRYPT,
	DBG_dump('verify_sh decrypted SIG1:', s, sig_len));
    DBG(DBG_CRYPT, DBG_log('pad_len calculated: %d hash_len: %d', padlen, (int)hash_len));

    /* skip padding */
    if(s[0]    != 0x00
       || s[1] != 0x01
       || s[padlen+2] != 0x00) {
	return '3''SIG padding does not check out';
    }

    s += padlen + 3;
    (*psig) = s;

    /* return SUCCESS */
    return NULL;
}
",9083
xelerance/Openswan,9eaa6c2a823c1d2b58913506a15f9474bf857a3d,0,"sign_hash(const struct private_key_stuff *pks
	  , const u_char *hash_val, size_t hash_len
	  , u_char *sig_val, size_t sig_len)
",9084
GNOME/pango,71aaeaf020340412b8d012fe23a556c0420eda5f,1,"gboolean
_pango_emoji_iter_next (PangoEmojiIter *iter)
{
  PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID;

  if (iter->end == iter->text_end)
    return FALSE;

  iter->start = iter->end;

  for (; iter->end < iter->text_end; iter->end = g_utf8_next_char (iter->end))
    {
      gunichar ch = g_utf8_get_char (iter->end);

    /* Except at the beginning, ZWJ just carries over the emoji or neutral
     * text type, VS15 & VS16 we just carry over as well, since we already
     * resolved those through lookahead. Also, don't downgrade to text
     * presentation for emoji that are part of a ZWJ sequence, example
     * U+1F441 U+200D U+1F5E8, eye (text presentation) + ZWJ + left speech
     * bubble, see below. */
    if ((!(ch == kZeroWidthJoinerCharacter && !iter->is_emoji) &&
	 ch != kVariationSelector15Character &&
	 ch != kVariationSelector16Character &&
	 ch != kCombiningEnclosingCircleBackslashCharacter &&
	 !_pango_Is_Regional_Indicator(ch) &&
	 !((ch == kLeftSpeechBubbleCharacter ||
	    ch == kRainbowCharacter ||
	    ch == kMaleSignCharacter ||
	    ch == kFemaleSignCharacter ||
	    ch == kStaffOfAesculapiusCharacter) &&
	   !iter->is_emoji)) ||
	current_emoji_type == PANGO_EMOJI_TYPE_INVALID) {
      current_emoji_type = _pango_get_emoji_type (ch);
    }

    if (g_utf8_next_char (iter->end) < iter->text_end) /* Optimize. */
    {
      gunichar peek_char = g_utf8_get_char (g_utf8_next_char (iter->end));

      /* Variation Selectors */
      if (current_emoji_type ==
	      PANGO_EMOJI_TYPE_EMOJI_EMOJI &&
	  peek_char == kVariationSelector15Character) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT;
      }

      if ((current_emoji_type ==
	       PANGO_EMOJI_TYPE_EMOJI_TEXT ||
	   _pango_Is_Emoji_Keycap_Base(ch)) &&
	  peek_char == kVariationSelector16Character) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
      }

      /* Combining characters Keycap... */
      if (_pango_Is_Emoji_Keycap_Base(ch) &&
	  peek_char == kCombiningEnclosingKeycapCharacter) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
      };

      /* Regional indicators */
      if (_pango_Is_Regional_Indicator(ch) &&
	  _pango_Is_Regional_Indicator(peek_char)) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
      }

      /* Upgrade text presentation emoji to emoji presentation when followed by
       * ZWJ, Example U+1F441 U+200D U+1F5E8, eye + ZWJ + left speech bubble. */
      if ((ch == kEyeCharacter ||
	   ch == kWavingWhiteFlagCharacter) &&
	  peek_char == kZeroWidthJoinerCharacter) {
	current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI;
      }
    }

    if (iter->is_emoji == (gboolean) 2)
      iter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);
    if (iter->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type))
    {
      iter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);
      return TRUE;
    }
  }

  iter->is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);

  return TRUE;
}
",9085
GNOME/pango,71aaeaf020340412b8d012fe23a556c0420eda5f,0,"static PangoEmojiType
_pango_get_emoji_type (gunichar codepoint)
{
  /* Those should only be Emoji presentation as combinations of two. */
  if (_pango_Is_Emoji_Keycap_Base (codepoint) ||
      _pango_Is_Regional_Indicator (codepoint))
    return PANGO_EMOJI_TYPE_TEXT;

  if (codepoint == kCombiningEnclosingKeycapCharacter)
    return PANGO_EMOJI_TYPE_EMOJI_EMOJI;

  if (_pango_Is_Emoji_Emoji_Default (codepoint) ||
      _pango_Is_Emoji_Modifier_Base (codepoint) ||
      _pango_Is_Emoji_Modifier (codepoint))
    return PANGO_EMOJI_TYPE_EMOJI_EMOJI;

  if (_pango_Is_Emoji_Text_Default (codepoint))
    return PANGO_EMOJI_TYPE_EMOJI_TEXT;

  return PANGO_EMOJI_TYPE_TEXT;
}
",9086
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,1,"static char *fstrndup(const char *ptr, unsigned long len) {
  char *result;
  if (len <= 0) return NULL;
  result = ALLOC_N(char, len);
  memccpy(result, ptr, 0, len);
  return result;
}
",9087
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,1,"static VALUE cState_indent_set(VALUE self, VALUE indent)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(indent, T_STRING);
    len = RSTRING_LEN(indent);
    if (len == 0) {
        if (state->indent) {
            ruby_xfree(state->indent);
            state->indent = NULL;
            state->indent_len = 0;
        }
    } else {
        if (state->indent) ruby_xfree(state->indent);
        state->indent = strdup(RSTRING_PTR(indent));
        state->indent_len = len;
    }
    return Qnil;
}
",9088
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,1,"static VALUE cState_space_set(VALUE self, VALUE space)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space, T_STRING);
    len = RSTRING_LEN(space);
    if (len == 0) {
        if (state->space) {
            ruby_xfree(state->space);
            state->space = NULL;
            state->space_len = 0;
        }
    } else {
        if (state->space) ruby_xfree(state->space);
        state->space = strdup(RSTRING_PTR(space));
        state->space_len = len;
    }
    return Qnil;
}
",9089
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,1,"static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}
",9090
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,1,"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}
",9091
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,1,"static VALUE cState_array_nl_set(VALUE self, VALUE array_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(array_nl, T_STRING);
    len = RSTRING_LEN(array_nl);
    if (len == 0) {
        if (state->array_nl) {
            ruby_xfree(state->array_nl);
            state->array_nl = NULL;
        }
    } else {
        if (state->array_nl) ruby_xfree(state->array_nl);
        state->array_nl = strdup(RSTRING_PTR(array_nl));
        state->array_nl_len = len;
    }
    return Qnil;
}
",9092
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,0,"static VALUE mString_to_json_raw_object(VALUE self)
{
    VALUE ary;
    VALUE result = rb_hash_new();
    rb_hash_aset(result, rb_funcall(mJSON, i_create_id, 0), rb_class_name(rb_obj_class(self)));
    ary = rb_funcall(self, i_unpack, 1, rb_str_new2('C*'));
    rb_hash_aset(result, rb_str_new2('raw'), ary);
    return result;
}
",9093
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,0,"static void generate_json(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)
{
    VALUE tmp;
    VALUE klass = CLASS_OF(obj);
    if (klass == rb_cHash) {
        generate_json_object(buffer, Vstate, state, obj);
    } else if (klass == rb_cArray) {
        generate_json_array(buffer, Vstate, state, obj);
    } else if (klass == rb_cString) {
        generate_json_string(buffer, Vstate, state, obj);
    } else if (obj == Qnil) {
        generate_json_null(buffer, Vstate, state, obj);
    } else if (obj == Qfalse) {
        generate_json_false(buffer, Vstate, state, obj);
    } else if (obj == Qtrue) {
        generate_json_true(buffer, Vstate, state, obj);
    } else if (FIXNUM_P(obj)) {
        generate_json_fixnum(buffer, Vstate, state, obj);
    } else if (RB_TYPE_P(obj, T_BIGNUM)) {
        generate_json_bignum(buffer, Vstate, state, obj);
    } else if (klass == rb_cFloat) {
        generate_json_float(buffer, Vstate, state, obj);
    } else if (rb_respond_to(obj, i_to_json)) {
        tmp = rb_funcall(obj, i_to_json, 1, Vstate);
        Check_Type(tmp, T_STRING);
        fbuffer_append_str(buffer, tmp);
    } else {
        tmp = rb_funcall(obj, i_to_s, 0);
        Check_Type(tmp, T_STRING);
        generate_json_string(buffer, Vstate, state, tmp);
    }
}
",9094
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,0,"            case 2: ch += *source++; ch <<= 6;
            case 1: ch += *source++; ch <<= 6;
            case 0: ch += *source++;
        }
        ch -= offsetsFromUTF8[extraBytesToRead];

",9095
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,0,"/*
",9096
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,0," */
",9097
flori/json,8f782fd8e181d9cfe9387ded43a5ca9692266b85,0," * call-seq: max_nesting
 *
 * This integer returns the maximum level of data structure nesting in
",9098
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,1,"static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)
{
  SV* sv;
  HV* hv;
  char* dbname;
  char* host;
  char* port;
  char* user;
  char* password;
  char* mysql_socket;
  int   result;
  int fresh = 0;
  D_imp_xxh(dbh);

  /* TODO- resolve this so that it is set only if DBI is 1.607 */
#define TAKE_IMP_DATA_VERSION 1
#if TAKE_IMP_DATA_VERSION
  if (DBIc_has(imp_dbh, DBIcf_IMPSET))
  { /* eg from take_imp_data() */
    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))
    {
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh), 'my_login skip connect\n');
      /* tell our parent we've adopted an active child */
      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));
      return TRUE;
    }
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    'my_login IMPSET but not ACTIVE so connect not skipped\n');
  }
#endif

  sv = DBIc_IMP_DATA(imp_dbh);

  if (!sv  ||  !SvROK(sv))
    return FALSE;

  hv = (HV*) SvRV(sv);
  if (SvTYPE(hv) != SVt_PVHV)
    return FALSE;

  host=		safe_hv_fetch(aTHX_ hv, 'host', 4);
  port=		safe_hv_fetch(aTHX_ hv, 'port', 4);
  user=		safe_hv_fetch(aTHX_ hv, 'user', 4);
  password=	safe_hv_fetch(aTHX_ hv, 'password', 8);
  dbname=	safe_hv_fetch(aTHX_ hv, 'database', 8);
  mysql_socket=	safe_hv_fetch(aTHX_ hv, 'mysql_socket', 12);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
		  'imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,' \
		  'host = %s, port = %s\n',
		  dbname ? dbname : 'NULL',
		  user ? user : 'NULL',
		  password ? password : 'NULL',
		  host ? host : 'NULL',
		  port ? port : 'NULL');

  if (!imp_dbh->pmysql) {
     fresh = 1;
     Newz(908, imp_dbh->pmysql, 1, MYSQL);
  }
  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,
			  password, dbname, imp_dbh) ? TRUE : FALSE;
  if (fresh && !result) {
      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */
      Safefree(imp_dbh->pmysql);
  }
  return result;
}
",9099
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,1,"int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,
		 char* password) {
#ifdef dTHR
  dTHR;
#endif
  dTHX; 
  D_imp_xxh(dbh);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
		  'imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\n',
		  dbname ? dbname : 'NULL',
		  user ? user : 'NULL',
		  password ? password : 'NULL');

  imp_dbh->stats.auto_reconnects_ok= 0;
  imp_dbh->stats.auto_reconnects_failed= 0;
  imp_dbh->bind_type_guessing= FALSE;
  imp_dbh->bind_comment_placeholders= FALSE;
  imp_dbh->has_transactions= TRUE;
 /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */
  imp_dbh->auto_reconnect = FALSE;

  /* HELMUT */
#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */
  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */
#endif

  if (!my_login(aTHX_ dbh, imp_dbh))
  {
    if(imp_dbh->pmysql)
        do_error(dbh, mysql_errno(imp_dbh->pmysql),
                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));
    return FALSE;
  }

    /*
     *  Tell DBI, that dbh->disconnect should be called for this handle
     */
    DBIc_ACTIVE_on(imp_dbh);

    /* Tell DBI, that dbh->destroy should be called for this handle */
    DBIc_on(imp_dbh, DBIcf_IMPSET);

    return TRUE;
}
",9100
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,1,"int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,
		 IV sql_type, SV *attribs, int is_inout, IV maxlen) {
  dTHX;
  int rc;
  int param_num= SvIV(param);
  int idx= param_num - 1;
  char err_msg[64];
  D_imp_xxh(sth);

#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
  STRLEN slen;
  char *buffer= NULL;
  int buffer_is_null= 0;
  int buffer_length= slen;
  unsigned int buffer_type= 0;
  IV tmp;
#endif

  D_imp_dbh_from_sth;
  ASYNC_CHECK_RETURN(sth, FALSE);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  '   Called: dbd_bind_ph\n');

  attribs= attribs;
  maxlen= maxlen;

  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))
  {
    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, 'Illegal parameter number', NULL);
    return FALSE;
  }

  /*
     This fixes the bug whereby no warning was issued upon binding a
     defined non-numeric as numeric
   */
  if (SvOK(value) &&
      (sql_type == SQL_NUMERIC  ||
       sql_type == SQL_DECIMAL  ||
       sql_type == SQL_INTEGER  ||
       sql_type == SQL_SMALLINT ||
       sql_type == SQL_FLOAT    ||
       sql_type == SQL_REAL     ||
       sql_type == SQL_DOUBLE) )
  {
    if (! looks_like_number(value))
    {
      sprintf(err_msg,
              'Binding non-numeric field %d, value %s as a numeric!',
              param_num, neatsvpv(value,0));
      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);
    }
  }

  if (is_inout)
  {
    do_error(sth, JW_ERR_NOT_IMPLEMENTED, 'Output parameters not implemented', NULL);
    return FALSE;
  }

  rc = bind_param(&imp_sth->params[idx], value, sql_type);

#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
  if (imp_sth->use_server_side_prepare)
  {
      switch(sql_type) {
      case SQL_NUMERIC:
      case SQL_INTEGER:
      case SQL_SMALLINT:
      case SQL_BIGINT:
      case SQL_TINYINT:
          buffer_type= MYSQL_TYPE_LONG;
          break;
      case SQL_DOUBLE:
      case SQL_DECIMAL: 
      case SQL_FLOAT: 
      case SQL_REAL:
          buffer_type= MYSQL_TYPE_DOUBLE;
          break;
      case SQL_CHAR: 
      case SQL_VARCHAR: 
      case SQL_DATE: 
      case SQL_TIME: 
      case SQL_TIMESTAMP: 
      case SQL_LONGVARCHAR: 
      case SQL_BINARY: 
      case SQL_VARBINARY: 
      case SQL_LONGVARBINARY:
          buffer_type= MYSQL_TYPE_BLOB;
          break;
      default:
          buffer_type= MYSQL_TYPE_STRING;
    }
    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);
    if (! buffer_is_null) {
      switch(buffer_type) {
        case MYSQL_TYPE_LONG:
          /* INT */
          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tTRY TO BIND AN INT NUMBER\n');
          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;

          tmp = SvIV(imp_sth->params[idx].value);
          if (tmp > INT32_MAX)
	        croak('Could not bind %ld: Integer too large for MYSQL_TYPE_LONG', tmp);
          imp_sth->fbind[idx].numeric_val.lval= tmp;
          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                          '   SCALAR type %d ->%'PRId32'<- IS A INT NUMBER\n',
                          (int) sql_type, *(int32_t *)buffer);
          break;

        case MYSQL_TYPE_DOUBLE:
          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tTRY TO BIND A FLOAT NUMBER\n');
          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;
          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);
          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                          '   SCALAR type %d ->%f<- IS A FLOAT NUMBER\n',
                          (int) sql_type, (double)(*buffer));
          break;

        case MYSQL_TYPE_BLOB:
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                          '   SCALAR type BLOB\n');
          break;

        case MYSQL_TYPE_STRING:
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                          '   SCALAR type STRING %d, buffertype=%d\n', (int) sql_type, buffer_type);
          break;

        default:
          croak('Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.');
      }

      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)
      {
        buffer= SvPV(imp_sth->params[idx].value, slen);
        buffer_length= slen;
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                        ' SCALAR type %d ->length %d<- IS A STRING or BLOB\n',
                        (int) sql_type, buffer_length);
      }
    }
    else
    {
      /*case: buffer_is_null != 0*/
      buffer= NULL;
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                      '   SCALAR NULL VALUE: buffer type is: %d\n', buffer_type);
    }

    /* Type of column was changed. Force to rebind */
    if (imp_sth->bind[idx].buffer_type != buffer_type) {
      /* Note: this looks like being another bug:
       * if type of parameter N changes, then a bind is triggered
       * with an only partially filled bind structure ??
       */
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                        '   FORCE REBIND: buffer type changed from %d to %d, sql-type=%d\n',
                        (int) imp_sth->bind[idx].buffer_type, buffer_type, (int) sql_type);
      imp_sth->has_been_bound = 0;
    }

    /* prepare has not been called */
    if (imp_sth->has_been_bound == 0)
    {
      imp_sth->bind[idx].buffer_type= buffer_type;
      imp_sth->bind[idx].buffer= buffer;
      imp_sth->bind[idx].buffer_length= buffer_length;
    }
    else /* prepare has been called */
    {
      imp_sth->stmt->params[idx].buffer= buffer;
      imp_sth->stmt->params[idx].buffer_length= buffer_length;
    }
    imp_sth->fbind[idx].length= buffer_length;
    imp_sth->fbind[idx].is_null= buffer_is_null;
  }
#endif
  return rc;
}
",9101
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,1,"static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)
{
  SV* sv;
  HV* hv;
  char* dbname;
  char* host;
  char* port;
  char* user;
  char* password;
  char* mysql_socket;
  int   result;
  D_imp_xxh(dbh);

  /* TODO- resolve this so that it is set only if DBI is 1.607 */
#define TAKE_IMP_DATA_VERSION 1
#if TAKE_IMP_DATA_VERSION
  if (DBIc_has(imp_dbh, DBIcf_IMPSET))
  { /* eg from take_imp_data() */
    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))
    {
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh), 'my_login skip connect\n');
      /* tell our parent we've adopted an active child */
      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));
      return TRUE;
    }
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    'my_login IMPSET but not ACTIVE so connect not skipped\n');
  }
#endif

  sv = DBIc_IMP_DATA(imp_dbh);

  if (!sv  ||  !SvROK(sv))
    return FALSE;

  hv = (HV*) SvRV(sv);
  if (SvTYPE(hv) != SVt_PVHV)
    return FALSE;

  host=		safe_hv_fetch(aTHX_ hv, 'host', 4);
  port=		safe_hv_fetch(aTHX_ hv, 'port', 4);
  user=		safe_hv_fetch(aTHX_ hv, 'user', 4);
  password=	safe_hv_fetch(aTHX_ hv, 'password', 8);
  dbname=	safe_hv_fetch(aTHX_ hv, 'database', 8);
  mysql_socket=	safe_hv_fetch(aTHX_ hv, 'mysql_socket', 12);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
		  'imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,' \
		  'host = %s, port = %s\n',
		  dbname ? dbname : 'NULL',
		  user ? user : 'NULL',
		  password ? password : 'NULL',
		  host ? host : 'NULL',
		  port ? port : 'NULL');

  if (!imp_dbh->pmysql) {
     Newz(908, imp_dbh->pmysql, 1, MYSQL);
  }
  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,
			  password, dbname, imp_dbh) ? TRUE : FALSE;
  if (!result)
      Safefree(imp_dbh->pmysql);
  return result;
}
",9102
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,1,"int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,
		 char* password) {
#ifdef dTHR
  dTHR;
#endif
  dTHX; 
  D_imp_xxh(dbh);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
		  'imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\n',
		  dbname ? dbname : 'NULL',
		  user ? user : 'NULL',
		  password ? password : 'NULL');

  imp_dbh->stats.auto_reconnects_ok= 0;
  imp_dbh->stats.auto_reconnects_failed= 0;
  imp_dbh->bind_type_guessing= FALSE;
  imp_dbh->bind_comment_placeholders= FALSE;
  imp_dbh->has_transactions= TRUE;
 /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */
  imp_dbh->auto_reconnect = FALSE;

  /* HELMUT */
#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */
#endif

  if (!my_login(aTHX_ dbh, imp_dbh))
  {
    do_error(dbh, mysql_errno(imp_dbh->pmysql),
            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));
    return FALSE;
  }

    /*
     *  Tell DBI, that dbh->disconnect should be called for this handle
     */
    DBIc_ACTIVE_on(imp_dbh);

    /* Tell DBI, that dbh->destroy should be called for this handle */
    DBIc_on(imp_dbh, DBIcf_IMPSET);

    return TRUE;
}
",9103
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,1,"AV*
dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)
{
  dTHX;
  int num_fields, ChopBlanks, i, rc;
  unsigned long *lengths;
  AV *av;
  int av_length, av_readonly;
  MYSQL_ROW cols;
  D_imp_dbh_from_sth;
  MYSQL* svsock= imp_dbh->pmysql;
  imp_sth_fbh_t *fbh;
  D_imp_xxh(sth);
#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  MYSQL_BIND *buffer;
#endif
  MYSQL_FIELD *fields;
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t-> dbd_st_fetch\n');

#if MYSQL_ASYNC
  if(imp_dbh->async_query_in_flight) {
      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {
        return Nullav;
      }
  }
#endif

#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  if (imp_sth->use_server_side_prepare)
  {
    if (!DBIc_ACTIVE(imp_sth) )
    {
      do_error(sth, JW_ERR_SEQUENCE, 'no statement executing\n',NULL);
      return Nullav;
    }

    if (imp_sth->fetch_done)
    {
      do_error(sth, JW_ERR_SEQUENCE, 'fetch() but fetch already done',NULL);
      return Nullav;
    }

    if (!imp_sth->done_desc)
    {
      if (!dbd_describe(sth, imp_sth))
      {
        do_error(sth, JW_ERR_SEQUENCE, 'Error while describe result set.',
                 NULL);
        return Nullav;
      }
    }
  }
#endif

  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  '\t\tdbd_st_fetch for %p, chopblanks %d\n',
                  sth, ChopBlanks);

  if (!imp_sth->result)
  {
    do_error(sth, JW_ERR_SEQUENCE, 'fetch() without execute()' ,NULL);
    return Nullav;
  }

  /* fix from 2.9008 */
  imp_dbh->pmysql->net.last_errno = 0;

#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  if (imp_sth->use_server_side_prepare)
  {
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tdbd_st_fetch calling mysql_fetch\n');

    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))
    {
      if (rc == 1)
        do_error(sth, mysql_stmt_errno(imp_sth->stmt),
                 mysql_stmt_error(imp_sth->stmt),
                mysql_stmt_sqlstate(imp_sth->stmt));

#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 
      if (rc == MYSQL_DATA_TRUNCATED) {
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tdbd_st_fetch data truncated\n');
        goto process;
      }
#endif

      if (rc == MYSQL_NO_DATA)
      {
        /* Update row_num to affected_rows value */
        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);
        imp_sth->fetch_done=1;
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tdbd_st_fetch no data\n');
      }

      dbd_st_finish(sth, imp_sth);

      return Nullav;
    }

process:
    imp_sth->currow++;

    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);
    num_fields=mysql_stmt_field_count(imp_sth->stmt);
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    '\t\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\n',
                    rc, num_fields);

    for (
         buffer= imp_sth->buffer,
         fbh= imp_sth->fbh,
         i= 0;
         i < num_fields;
         i++,
         fbh++,
         buffer++
        )
    {
      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV	*/
      STRLEN len;

      /* This is wrong, null is not being set correctly
       * This is not the way to determine length (this would break blobs!)
       */
      if (fbh->is_null)
        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */
      else
      {
        /* In case of BLOB/TEXT fields we allocate only 8192 bytes
           in dbd_describe() for data. Here we know real size of field
           so we should increase buffer size and refetch column value
        */
        if (fbh->length > buffer->buffer_length || fbh->error)
        {
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),
              '\t\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\n',
              i, fbh->length, fbh->error);

          Renew(fbh->data, fbh->length, char);
          buffer->buffer_length= fbh->length;
          buffer->buffer= (char *) fbh->data;

          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
            int j;
            int m = MIN(*buffer->length, buffer->buffer_length);
            char *ptr = (char*)buffer->buffer;
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),'\t\tbefore buffer->buffer: ');
            for (j = 0; j < m; j++) {
              PerlIO_printf(DBIc_LOGPIO(imp_xxh), '%c', *ptr++);
            }
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),'\n');
          }

          /*TODO: Use offset instead of 0 to fetch only remain part of data*/
          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))
            do_error(sth, mysql_stmt_errno(imp_sth->stmt),
                     mysql_stmt_error(imp_sth->stmt),
                     mysql_stmt_sqlstate(imp_sth->stmt));

          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
            int j;
            int m = MIN(*buffer->length, buffer->buffer_length);
            char *ptr = (char*)buffer->buffer;
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),'\t\tafter buffer->buffer: ');
            for (j = 0; j < m; j++) {
              PerlIO_printf(DBIc_LOGPIO(imp_xxh), '%c', *ptr++);
            }
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),'\n');
          }
        }

        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */
        /* Credit due to Georg - mysqli_api.c  ;) --PMG */
        switch (buffer->buffer_type) {
        case MYSQL_TYPE_DOUBLE:
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tst_fetch double data %f\n', fbh->ddata);
          sv_setnv(sv, fbh->ddata);
          break;

        case MYSQL_TYPE_LONG:
        case MYSQL_TYPE_LONGLONG:
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tst_fetch int data %'IVdf', unsigned? %d\n',
                          fbh->ldata, buffer->is_unsigned);
          if (buffer->is_unsigned)
            sv_setuv(sv, fbh->ldata);
          else
            sv_setiv(sv, fbh->ldata);

          break;

        case MYSQL_TYPE_BIT:
          sv_setpvn(sv, fbh->data, fbh->length);

          break;

        default:
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tERROR IN st_fetch_string');
          len= fbh->length;
	  /* ChopBlanks server-side prepared statement */
          if (ChopBlanks)
          {
            /* 
              see bottom of:
              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html
            */
            if (fbh->charsetnr != 63)
              while (len && fbh->data[len-1] == ' ') { --len; }
          }
	  /* END OF ChopBlanks */

          sv_setpvn(sv, fbh->data, len);

	/* UTF8 */
        /*HELMUT*/
#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION

#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION 
  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */
        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)
#else
	if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))
#endif
	  sv_utf8_decode(sv);
#endif
	/* END OF UTF8 */
          break;

        }

      }
    }

    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t<- dbd_st_fetch, %d cols\n', num_fields);

    return av;
  }
  else
  {
#endif

    imp_sth->currow++;

    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    {
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\tdbd_st_fetch result set details\n');
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\timp_sth->result=%p\n', imp_sth->result);
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\tmysql_num_fields=%u\n',
                    mysql_num_fields(imp_sth->result));
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\tmysql_num_rows=%llu\n',
                    mysql_num_rows(imp_sth->result));
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\tmysql_affected_rows=%llu\n',
                    mysql_affected_rows(imp_dbh->pmysql));
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\tdbd_st_fetch for %p, currow= %d\n',
                    sth,imp_sth->currow);
    }

    if (!(cols= mysql_fetch_row(imp_sth->result)))
    {
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      {
        PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\tdbd_st_fetch, no more rows to fetch');
      }
      if (mysql_errno(imp_dbh->pmysql))
        do_error(sth, mysql_errno(imp_dbh->pmysql),
                 mysql_error(imp_dbh->pmysql),
                 mysql_sqlstate(imp_dbh->pmysql));


#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
      if (!mysql_more_results(svsock))
#endif
        dbd_st_finish(sth, imp_sth);
      return Nullav;
    }

    num_fields= mysql_num_fields(imp_sth->result);
    fields= mysql_fetch_fields(imp_sth->result);
    lengths= mysql_fetch_lengths(imp_sth->result);

    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)
    {
      av_length= av_len(av)+1;

      if (av_length != num_fields)              /* Resize array if necessary */
      {
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\n',
                                   av_length, num_fields);

        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t<- dbd_st_fetch, result fields(%d)\n',
                                   DBIc_NUM_FIELDS(imp_sth));

        av_readonly = SvREADONLY(av);

        if (av_readonly)
          SvREADONLY_off( av );              /* DBI sets this readonly */

        while (av_length < num_fields)
        {
          av_store(av, av_length++, newSV(0));
        }

        while (av_length > num_fields)
        {
          SvREFCNT_dec(av_pop(av));
          av_length--;
        }
        if (av_readonly)
          SvREADONLY_on(av);
      }
    }

    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);

    for (i= 0;  i < num_fields; ++i)
    {
      char *col= cols[i];
      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV	*/

      if (col)
      {
        STRLEN len= lengths[i];
        if (ChopBlanks)
        {
          while (len && col[len-1] == ' ')
          {	--len; }
        }

        /* Set string value returned from mysql server */
        sv_setpvn(sv, col, len);

        switch (mysql_to_perl_type(fields[i].type)) {
        case MYSQL_TYPE_DOUBLE:
          /* Coerce to dobule and set scalar as NV */
          (void) SvNV(sv);
          SvNOK_only(sv);
          break;

        case MYSQL_TYPE_LONG:
        case MYSQL_TYPE_LONGLONG:
          /* Coerce to integer and set scalar as UV resp. IV */
          if (fields[i].flags & UNSIGNED_FLAG)
          {
            (void) SvUV(sv);
            SvIOK_only_UV(sv);
          }
          else
          {
            (void) SvIV(sv);
            SvIOK_only(sv);
          }
          break;

#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION
        case MYSQL_TYPE_BIT:
          /* Let it as binary string */
          break;
#endif

        default:
	/* UTF8 */
        /*HELMUT*/
#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION

  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */
        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)
	  sv_utf8_decode(sv);
#endif
	/* END OF UTF8 */
          break;
        }
      }
      else
        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */
    }

    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t<- dbd_st_fetch, %d cols\n', num_fields);
    return av;

#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION
  }
#endif

}
",9104
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,1,"int
dbd_st_prepare(
  SV *sth,
  imp_sth_t *imp_sth,
  char *statement,
  SV *attribs)
{
  int i;
  SV **svp;
  dTHX;
#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
#if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION
  char *str_ptr, *str_last_ptr;
#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION
  int limit_flag=0;
#endif
#endif
  int col_type, prepare_retval;
  MYSQL_BIND *bind, *bind_end;
  imp_sth_phb_t *fbind;
#endif
  D_imp_xxh(sth);
  D_imp_dbh_from_sth;

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                 '\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\n',
                  MYSQL_VERSION_ID, statement);

#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
 /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */
  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;
  if (attribs)
  {
    svp= DBD_ATTRIB_GET_SVP(attribs, 'mysql_server_prepare', 20);
    imp_sth->use_server_side_prepare = (svp) ?
      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;

    svp = DBD_ATTRIB_GET_SVP(attribs, 'async', 5);

    if(svp && SvTRUE(*svp)) {
#if MYSQL_ASYNC
        imp_sth->is_async = TRUE;
        imp_sth->use_server_side_prepare = FALSE;
#else
        do_error(sth, 2000,
                 'Async support was not built into this version of DBD::mysql', 'HY000');
        return 0;
#endif
    }
  }

  imp_sth->fetch_done= 0;
#endif

  imp_sth->done_desc= 0;
  imp_sth->result= NULL;
  imp_sth->currow= 0;

  /* Set default value of 'mysql_use_result' attribute for sth from dbh */
  svp= DBD_ATTRIB_GET_SVP(attribs, 'mysql_use_result', 16);
  imp_sth->use_mysql_use_result= svp ?
    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;

  for (i= 0; i < AV_ATTRIB_LAST; i++)
    imp_sth->av_attr[i]= Nullav;

  /*
     Clean-up previous result set(s) for sth to prevent
     'Commands out of sync' error 
  */
  mysql_st_free_result_sets(sth, imp_sth);

#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION
  if (imp_sth->use_server_side_prepare)
  {
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    '\t\tuse_server_side_prepare set, check restrictions\n');
    /*
      This code is here because placeholder support is not implemented for
      statements with :-
      1. LIMIT < 5.0.7
      2. CALL < 5.5.3 (Added support for out & inout parameters)
      In these cases we have to disable server side prepared statements
      NOTE: These checks could cause a false positive on statements which
      include columns / table names that match 'call ' or ' limit '
    */ 
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh),
#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION
                    '\t\tneed to test for LIMIT & CALL\n');
#else
                    '\t\tneed to test for restrictions\n');
#endif
    str_last_ptr = statement + strlen(statement);
    for (str_ptr= statement; str_ptr < str_last_ptr; str_ptr++)
    {
#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION
      /*
        Place holders not supported in LIMIT's
      */
      if (limit_flag)
      {
        if (*str_ptr == '?')
        {
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    '\t\tLIMIT and ? found, set to use_server_side_prepare=0\n');
          /* ... then we do not want to try server side prepare (use emulation) */
          imp_sth->use_server_side_prepare= 0;
          break;
        }
      }
      else if (str_ptr < str_last_ptr - 6 &&
          isspace(*(str_ptr + 0)) &&
          tolower(*(str_ptr + 1)) == 'l' &&
          tolower(*(str_ptr + 2)) == 'i' &&
          tolower(*(str_ptr + 3)) == 'm' &&
          tolower(*(str_ptr + 4)) == 'i' &&
          tolower(*(str_ptr + 5)) == 't' &&
          isspace(*(str_ptr + 6)))
      {
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), 'LIMIT set limit flag to 1\n');
        limit_flag= 1;
      }
#endif
      /*
        Place holders not supported in CALL's
      */
      if (str_ptr < str_last_ptr - 4 &&
           tolower(*(str_ptr + 0)) == 'c' &&
           tolower(*(str_ptr + 1)) == 'a' &&
           tolower(*(str_ptr + 2)) == 'l' &&
           tolower(*(str_ptr + 3)) == 'l' &&
           isspace(*(str_ptr + 4)))
      {
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), 'Disable PS mode for CALL()\n');
        imp_sth->use_server_side_prepare= 0;
        break;
      }
    }
  }
#endif

#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
  if (imp_sth->use_server_side_prepare)
  {
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    '\t\tuse_server_side_prepare set\n');
    /* do we really need this? If we do, we should return, not just continue */
    if (imp_sth->stmt)
      fprintf(stderr,
              'ERROR: Trying to prepare new stmt while we have \
              already not closed one \n');

    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);

    if (! imp_sth->stmt)
    {
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                      '\t\tERROR: Unable to return MYSQL_STMT structure \
                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\n',
                      mysql_errno(imp_dbh->pmysql),
                      mysql_error(imp_dbh->pmysql));
    }

    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,
                                       statement,
                                       strlen(statement));
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                      '\t\tmysql_stmt_prepare returned %d\n',
                      prepare_retval);

    if (prepare_retval)
    {
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                      '\t\tmysql_stmt_prepare %d %s\n',
                      mysql_stmt_errno(imp_sth->stmt),
                      mysql_stmt_error(imp_sth->stmt));

      /* For commands that are not supported by server side prepared statement
         mechanism lets try to pass them through regular API */
      if (mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)
      {
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    '\t\tSETTING imp_sth->use_server_side_prepare to 0\n');
        imp_sth->use_server_side_prepare= 0;
      }
      else
      {
        do_error(sth, mysql_stmt_errno(imp_sth->stmt),
                 mysql_stmt_error(imp_sth->stmt),
                mysql_sqlstate(imp_dbh->pmysql));
        mysql_stmt_close(imp_sth->stmt);
        imp_sth->stmt= NULL;
        return FALSE;
      }
    }
    else
    {
      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);
      /* mysql_stmt_param_count */

      if (DBIc_NUM_PARAMS(imp_sth) > 0)
      {
        int has_statement_fields= imp_sth->stmt->fields != 0;
        /* Allocate memory for bind variables */
        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));
        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));
        imp_sth->has_been_bound=  0;

        /* Initialize ph variables with  NULL values */
        for (i= 0,
             bind=      imp_sth->bind,
             fbind=     imp_sth->fbind,
             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);
             bind < bind_end ;
             bind++, fbind++, i++ )
        {
          /*
            if this statement has a result set, field types will be
            correctly identified. If there is no result set, such as
            with an INSERT, fields will not be defined, and all buffer_type
            will default to MYSQL_TYPE_VAR_STRING
          */
          col_type= (has_statement_fields ?
                     imp_sth->stmt->fields[i].type : MYSQL_TYPE_STRING);

          bind->buffer_type=  mysql_to_perl_type(col_type);

          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tmysql_to_perl_type returned %d\n', col_type);

          bind->buffer=       NULL;
          bind->length=       &(fbind->length);
          bind->is_null=      (char*) &(fbind->is_null);
          fbind->is_null=     1;
          fbind->length=      0;
        }
      }
    }
  }
#endif

#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
  /* Count the number of parameters (driver, vs server-side) */
  if (imp_sth->use_server_side_prepare == 0)
    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,
                                            imp_dbh->bind_comment_placeholders);
#else
  DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,
                                          imp_dbh->bind_comment_placeholders);
#endif

  /* Allocate memory for parameters */
  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));
  DBIc_IMPSET_on(imp_sth);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t<- dbd_st_prepare\n');
  return 1;
}
",9105
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,0,"int dbd_describe(SV* sth, imp_sth_t* imp_sth)
{
  dTHX;
  D_imp_xxh(sth);
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t--> dbd_describe\n');


#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION

  if (imp_sth->use_server_side_prepare)
  {
    int i;
    int col_type;
    int num_fields= DBIc_NUM_FIELDS(imp_sth);
    imp_sth_fbh_t *fbh;
    MYSQL_BIND *buffer;
    MYSQL_FIELD *fields;

    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tdbd_describe() num_fields %d\n',
                    num_fields);

    if (imp_sth->done_desc)
      return TRUE;

    if (!num_fields || !imp_sth->result)
    {
      /* no metadata */
      do_error(sth, JW_ERR_SEQUENCE,
               'no metadata information while trying describe result set',
               NULL);
      return 0;
    }

    /* allocate fields buffers  */
    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))
          || !(imp_sth->buffer= alloc_bind(num_fields)) )
    {
      /* Out of memory */
      do_error(sth, JW_ERR_SEQUENCE,
               'Out of memory in dbd_sescribe()',NULL);
      return 0;
    }

    fields= mysql_fetch_fields(imp_sth->result);

    for (
         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;
         i < num_fields;
         i++, fbh++, buffer++
        )
    {
      /* get the column type */
      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;

      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      {
        PerlIO_printf(DBIc_LOGPIO(imp_xxh),'\t\ti %d col_type %d fbh->length %lu\n',
                      i, col_type, fbh->length);
        PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                      '\t\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\n',
                      (long unsigned int) fields[i].length, (long unsigned int) fields[i].max_length, fields[i].type,
                      fields[i].charsetnr);
      }
      fbh->charsetnr = fields[i].charsetnr;
#if MYSQL_VERSION_ID < FIELD_CHARSETNR_VERSION 
      fbh->flags     = fields[i].flags;
#endif

      buffer->buffer_type= mysql_to_perl_type(col_type);
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tmysql_to_perl_type returned %d\n',
                      col_type);
      buffer->length= &(fbh->length);
      buffer->is_null= (my_bool*) &(fbh->is_null);
      buffer->error= (my_bool*) &(fbh->error);

      switch (buffer->buffer_type) {
      case MYSQL_TYPE_DOUBLE:
        buffer->buffer_length= sizeof(fbh->ddata);
        buffer->buffer= (char*) &fbh->ddata;
        break;

      case MYSQL_TYPE_LONG:
        buffer->buffer_length= sizeof(fbh->ldata);
        buffer->buffer= (char*) &fbh->ldata;
        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;
        break;

      default:
        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;
        Newz(908, fbh->data, buffer->buffer_length, char);
        buffer->buffer= (char *) fbh->data;
      }
    }

    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))
    {
      do_error(sth, mysql_stmt_errno(imp_sth->stmt),
               mysql_stmt_error(imp_sth->stmt),
               mysql_stmt_sqlstate(imp_sth->stmt));
      return 0;
    }
  }
#endif

  imp_sth->done_desc= 1;
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t<- dbd_describe\n');
  return TRUE;
}
",9106
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,0,"SV*
dbd_st_FETCH_internal(
  SV *sth,
  int what,
  MYSQL_RES *res,
  int cacheit
)
{
  dTHX;
  D_imp_sth(sth);
  AV *av= Nullav;
  MYSQL_FIELD *curField;

  /* Are we asking for a legal value? */
  if (what < 0 ||  what >= AV_ATTRIB_LAST)
    do_error(sth, JW_ERR_NOT_IMPLEMENTED, 'Not implemented', NULL);

  /* Return cached value, if possible */
  else if (cacheit  &&  imp_sth->av_attr[what])
    av= imp_sth->av_attr[what];

  /* Does this sth really have a result? */
  else if (!res)
    do_error(sth, JW_ERR_NOT_ACTIVE,
	     'statement contains no result' ,NULL);
  /* Do the real work. */
  else
  {
    av= newAV();
    mysql_field_seek(res, 0);
    while ((curField= mysql_fetch_field(res)))
    {
      SV *sv;

      switch(what) {
      case AV_ATTRIB_NAME:
        sv= newSVpv(curField->name, strlen(curField->name));
        break;

      case AV_ATTRIB_TABLE:
        sv= newSVpv(curField->table, strlen(curField->table));
        break;

      case AV_ATTRIB_TYPE:
        sv= newSViv((int) curField->type);
        break;

      case AV_ATTRIB_SQL_TYPE:
        sv= newSViv((int) native2sql(curField->type)->data_type);
        break;
      case AV_ATTRIB_IS_PRI_KEY:
        sv= boolSV(IS_PRI_KEY(curField->flags));
        break;

      case AV_ATTRIB_IS_NOT_NULL:
        sv= boolSV(IS_NOT_NULL(curField->flags));
        break;

      case AV_ATTRIB_NULLABLE:
        sv= boolSV(!IS_NOT_NULL(curField->flags));
        break;

      case AV_ATTRIB_LENGTH:
        sv= newSViv((int) curField->length);
        break;

      case AV_ATTRIB_IS_NUM:
        sv= newSViv((int) native2sql(curField->type)->is_num);
        break;

      case AV_ATTRIB_TYPE_NAME:
        sv= newSVpv((char*) native2sql(curField->type)->type_name, 0);
        break;

      case AV_ATTRIB_MAX_LENGTH:
        sv= newSViv((int) curField->max_length);
        break;

      case AV_ATTRIB_IS_AUTO_INCREMENT:
#if defined(AUTO_INCREMENT_FLAG)
        sv= boolSV(IS_AUTO_INCREMENT(curField->flags));
        break;
#else
        croak('AUTO_INCREMENT_FLAG is not supported on this machine');
#endif

      case AV_ATTRIB_IS_KEY:
        sv= boolSV(IS_KEY(curField->flags));
        break;

      case AV_ATTRIB_IS_BLOB:
        sv= boolSV(IS_BLOB(curField->flags));
        break;

      case AV_ATTRIB_SCALE:
        sv= newSViv((int) curField->decimals);
        break;

      case AV_ATTRIB_PRECISION:
        sv= newSViv((int) (curField->length > curField->max_length) ?
                     curField->length : curField->max_length);
        break;

      default:
        sv= &PL_sv_undef;
        break;
      }
      av_push(av, sv);
    }

    /* Ensure that this value is kept, decremented in
     *  dbd_st_destroy and dbd_st_execute.  */
    if (!cacheit)
      return sv_2mortal(newRV_noinc((SV*)av));
    imp_sth->av_attr[what]= av;
  }

  if (av == Nullav)
    return &PL_sv_undef;

  return sv_2mortal(newRV_inc((SV*)av));
}
",9107
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,0,"int
dbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {
  /* croak, if not in AutoCommit mode */
  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))
    return FALSE;

  ASYNC_CHECK_RETURN(dbh, FALSE);

  if (imp_dbh->has_transactions)
  {
#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION
    if (mysql_real_query(imp_dbh->pmysql, 'ROLLBACK', 8))
#else
      if (mysql_rollback(imp_dbh->pmysql))
#endif
      {
        do_error(dbh, mysql_errno(imp_dbh->pmysql),
                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));
        return FALSE;
      }
  }
  else
    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,
             'Rollback ineffective because transactions are not available' ,NULL);
  return TRUE;
}
",9108
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,0,"static int
count_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)
{
  bool comment_end= false;
  char* ptr= statement;
  int num_params= 0;
  int comment_length= 0;
  char c;

  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh), '>count_params statement %s\n', statement);

  while ( (c = *ptr++) )
  {
    switch (c) {
      /* so, this is a -- comment, so let's burn up characters */
    case '-':
      {
          if (bind_comment_placeholders)
          {
              c = *ptr++;
              break;
          }
          else
          {
              comment_length= 1;
              /* let's see if the next one is a dash */
              c = *ptr++;

              if  (c == '-') {
                  /* if two dashes, ignore everything until newline */
                  while ((c = *ptr))
                  {
                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)
                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), '%c\n', c);
                      ptr++;
                      comment_length++;
                      if (c == '\n')
                      {
                          comment_end= true;
                          break;
                      }
                  }
                  /*
                    if not comment_end, the comment never ended and we need to iterate
                    back to the beginning of where we started and let the database 
                    handle whatever is in the statement
                */
                  if (! comment_end)
                      ptr-= comment_length;
              }
              /* otherwise, only one dash/hyphen, backtrack by one */
              else
                  ptr--;
              break;
          }
      }
    /* c-type comments */
    case '/':
      {
          if (bind_comment_placeholders)
          {
              c = *ptr++;
              break;
          }
          else
          {
              c = *ptr++;
              /* let's check if the next one is an asterisk */
              if  (c == '*')
              {
                  comment_length= 0;
                  comment_end= false;
                  /* ignore everything until closing comment */
                  while ((c= *ptr))
                  {
                      ptr++;
                      comment_length++;

                      if (c == '*')
                      {
                          c = *ptr++;
                          /* alas, end of comment */
                          if (c == '/')
                          {
                              comment_end= true;
                              break;
                          }
                          /*
                            nope, just an asterisk, not so fast, not
                            end of comment, go back one
                        */
                          else
                              ptr--;
                      }
                  }
                  /*
                    if the end of the comment was never found, we have
                    to backtrack to whereever we first started skipping
                    over the possible comment.
                    This means we will pass the statement to the database
                    to see its own fate and issue the error
                */
                  if (!comment_end)
                      ptr -= comment_length;
              }
              else
                  ptr--;
              break;
          }
      }
    case '`':
    case ''':
    case '\'':
      /* Skip string */
      {
        char end_token = c;
        while ((c = *ptr)  &&  c != end_token)
        {
          if (c == '\\')
            if (! *(++ptr))
              continue;

          ++ptr;
        }
        if (c)
          ++ptr;
        break;
      }

    case '?':
      ++num_params;
      break;

    default:
      break;
    }
  }
  return num_params;
}
",9109
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,0,"static const sql_type_info_t *native2sql(int t)
{
  switch (t) {
    case FIELD_TYPE_VAR_STRING:  return &SQL_GET_TYPE_INFO_values[0];
    case FIELD_TYPE_DECIMAL:     return &SQL_GET_TYPE_INFO_values[1];
#ifdef FIELD_TYPE_NEWDECIMAL
    case FIELD_TYPE_NEWDECIMAL:  return &SQL_GET_TYPE_INFO_values[1];
#endif
    case FIELD_TYPE_TINY:        return &SQL_GET_TYPE_INFO_values[2];
    case FIELD_TYPE_SHORT:       return &SQL_GET_TYPE_INFO_values[3];
    case FIELD_TYPE_LONG:        return &SQL_GET_TYPE_INFO_values[4];
    case FIELD_TYPE_FLOAT:       return &SQL_GET_TYPE_INFO_values[5];

    /* 6  */
    case FIELD_TYPE_DOUBLE:      return &SQL_GET_TYPE_INFO_values[7];
    case FIELD_TYPE_TIMESTAMP:   return &SQL_GET_TYPE_INFO_values[8];
    case FIELD_TYPE_LONGLONG:    return &SQL_GET_TYPE_INFO_values[9];
    case FIELD_TYPE_INT24:       return &SQL_GET_TYPE_INFO_values[10];
    case FIELD_TYPE_DATE:        return &SQL_GET_TYPE_INFO_values[11];
    case FIELD_TYPE_TIME:        return &SQL_GET_TYPE_INFO_values[12];
    case FIELD_TYPE_DATETIME:    return &SQL_GET_TYPE_INFO_values[13];
    case FIELD_TYPE_YEAR:        return &SQL_GET_TYPE_INFO_values[14];
    case FIELD_TYPE_NEWDATE:     return &SQL_GET_TYPE_INFO_values[15];
    case FIELD_TYPE_ENUM:        return &SQL_GET_TYPE_INFO_values[16];
    case FIELD_TYPE_SET:         return &SQL_GET_TYPE_INFO_values[17];
    case FIELD_TYPE_BLOB:        return &SQL_GET_TYPE_INFO_values[18];
    case FIELD_TYPE_TINY_BLOB:   return &SQL_GET_TYPE_INFO_values[19];
    case FIELD_TYPE_MEDIUM_BLOB: return &SQL_GET_TYPE_INFO_values[20];
    case FIELD_TYPE_LONG_BLOB:   return &SQL_GET_TYPE_INFO_values[21];
    case FIELD_TYPE_STRING:      return &SQL_GET_TYPE_INFO_values[22];
    default:                     return &SQL_GET_TYPE_INFO_values[0];
  }
}
",9110
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,0,"my_ulonglong mysql_st_internal_execute41(
                                         SV *sth,
                                         int num_params,
                                         MYSQL_RES **result,
                                         MYSQL_STMT *stmt,
                                         MYSQL_BIND *bind,
                                         int *has_been_bound
                                        )
{
  int i;
  enum enum_field_types enum_type;
  dTHX;
  int execute_retval;
  my_ulonglong rows=0;
  D_imp_xxh(sth);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  '\t-> mysql_st_internal_execute41\n');

  /* free result if exists */
  if (*result)
  {
    mysql_free_result(*result);
    *result= 0;
  }

  /*
    If were performed any changes with ph variables
    we have to rebind them
  */

  if (num_params > 0 && !(*has_been_bound))
  {
    if (mysql_stmt_bind_param(stmt,bind))
      goto error;

    *has_been_bound= 1;
  }

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  '\t\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\n',
                  num_params);

  execute_retval= mysql_stmt_execute(stmt);
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  '\t\tmysql_stmt_execute returned %d\n',
                  execute_retval);
  if (execute_retval)
    goto error;

  /*
   This statement does not return a result set (INSERT, UPDATE...)
  */
  if (!(*result= mysql_stmt_result_metadata(stmt)))
  {
    if (mysql_stmt_errno(stmt))
      goto error;

    rows= mysql_stmt_affected_rows(stmt);

    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */
    if (rows == (my_ulonglong)-1)
      goto error;
  }
  /*
    This statement returns a result set (SELECT...)
  */
  else
  {
    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {
        enum_type = mysql_to_perl_type(stmt->fields[i].type);
        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG)
        {
            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */
            my_bool on = 1;
            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);
            break;
        }
    }
    /* Get the total rows affected and return */
    if (mysql_stmt_store_result(stmt))
      goto error;
    else
      rows= mysql_stmt_num_rows(stmt);
  }
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  '\t<- mysql_internal_execute_41 returning %d rows\n',
                  (int) rows);
  return(rows);

error:
  if (*result)
  {
    mysql_free_result(*result);
    *result= 0;
  }
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  '     errno %d err message %s\n',
                  mysql_stmt_errno(stmt),
                  mysql_stmt_error(stmt));
  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),
           mysql_stmt_sqlstate(stmt));
  mysql_stmt_reset(stmt);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  '\t<- mysql_st_internal_execute41\n');
  return -2;

}
",9111
perl5-dbi/DBD-mysql,2e1cbd0034cf0041f832ba81d07c24db886782d8,0,"int dbd_describe(SV* sth, imp_sth_t* imp_sth)
{
  dTHX;
  D_imp_xxh(sth);
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t--> dbd_describe\n');


#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION

  if (imp_sth->use_server_side_prepare)
  {
    int i;
    int col_type;
    int num_fields= DBIc_NUM_FIELDS(imp_sth);
    imp_sth_fbh_t *fbh;
    MYSQL_BIND *buffer;
    MYSQL_FIELD *fields;

    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tdbd_describe() num_fields %d\n',
                    num_fields);

    if (imp_sth->done_desc)
      return TRUE;

    if (!num_fields || !imp_sth->result)
    {
      /* no metadata */
      do_error(sth, JW_ERR_SEQUENCE,
               'no metadata information while trying describe result set',
               NULL);
      return 0;
    }

    /* allocate fields buffers  */
    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))
          || !(imp_sth->buffer= alloc_bind(num_fields)) )
    {
      /* Out of memory */
      do_error(sth, JW_ERR_SEQUENCE,
               'Out of memory in dbd_sescribe()',NULL);
      return 0;
    }

    fields= mysql_fetch_fields(imp_sth->result);

    for (
         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;
         i < num_fields;
         i++, fbh++, buffer++
        )
    {
      /* get the column type */
      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;

      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      {
        PerlIO_printf(DBIc_LOGPIO(imp_xxh),'\t\ti %d col_type %d fbh->length %d\n',
                      i, col_type, (int) fbh->length);
        PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                      '\t\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\n',
                      (long unsigned int) fields[i].length, (long unsigned int) fields[i].max_length, fields[i].type,
                      fields[i].charsetnr);
      }
      fbh->charsetnr = fields[i].charsetnr;
#if MYSQL_VERSION_ID < FIELD_CHARSETNR_VERSION 
      fbh->flags     = fields[i].flags;
#endif

      buffer->buffer_type= mysql_to_perl_type(col_type);
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t\tmysql_to_perl_type returned %d\n',
                      col_type);
      buffer->length= &(fbh->length);
      buffer->is_null= (char*) &(fbh->is_null);

      switch (buffer->buffer_type) {
      case MYSQL_TYPE_DOUBLE:
        buffer->buffer_length= sizeof(fbh->ddata);
        buffer->buffer= (char*) &fbh->ddata;
        break;

      case MYSQL_TYPE_LONG:
        buffer->buffer_length= sizeof(fbh->ldata);
        buffer->buffer= (char*) &fbh->ldata;
        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;
        break;

      default:
        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;
        Newz(908, fbh->data, buffer->buffer_length, char);
        buffer->buffer= (char *) fbh->data;
      }
    }

    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))
    {
      do_error(sth, mysql_stmt_errno(imp_sth->stmt),
               mysql_stmt_error(imp_sth->stmt),
               mysql_stmt_sqlstate(imp_sth->stmt));
      return 0;
    }
  }
#endif

  imp_sth->done_desc= 1;
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh), '\t<- dbd_describe\n');
  return TRUE;
}
",9112
libguestfs/hivex,4bbdf555f88baeae0fa804a369a81a83908bd705,1,"hive_h *
hivex_open (const char *filename, int flags)
{
  hive_h *h = NULL;

  assert (sizeof (struct ntreg_header) == 0x1000);
  assert (offsetof (struct ntreg_header, csum) == 0x1fc);

  h = calloc (1, sizeof *h);
  if (h == NULL)
    goto error;

  h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;

  const char *debug = getenv ('HIVEX_DEBUG');
  if (debug && STREQ (debug, '1'))
    h->msglvl = 2;

  DEBUG (2, 'created handle %p', h);

  h->writable = !!(flags & HIVEX_OPEN_WRITE);
  h->filename = strdup (filename);
  if (h->filename == NULL)
    goto error;

#ifdef O_CLOEXEC
  h->fd = open (filename, O_RDONLY | O_CLOEXEC | O_BINARY);
#else
  h->fd = open (filename, O_RDONLY | O_BINARY);
#endif
  if (h->fd == -1)
    goto error;
#ifndef O_CLOEXEC
  fcntl (h->fd, F_SETFD, FD_CLOEXEC);
#endif

  struct stat statbuf;
  if (fstat (h->fd, &statbuf) == -1)
    goto error;

  h->size = statbuf.st_size;

  if (h->size < 0x2000) {
    SET_ERRNO (EINVAL,
               '%s: file is too small to be a Windows NT Registry hive file',
               filename);
    goto error;
  }

  if (!h->writable) {
    h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);
    if (h->addr == MAP_FAILED)
      goto error;

    DEBUG (2, 'mapped file at %p', h->addr);
  } else {
    h->addr = malloc (h->size);
    if (h->addr == NULL)
      goto error;

    if (full_read (h->fd, h->addr, h->size) < h->size)
      goto error;

    /* We don't need the file descriptor along this path, since we
     * have read all the data.
     */
    if (close (h->fd) == -1)
      goto error;
    h->fd = -1;
  }

  /* Check header. */
  if (h->hdr->magic[0] != 'r' ||
      h->hdr->magic[1] != 'e' ||
      h->hdr->magic[2] != 'g' ||
      h->hdr->magic[3] != 'f') {
    SET_ERRNO (ENOTSUP,
               '%s: not a Windows NT Registry hive file', filename);
    goto error;
  }

  /* Check major version. */
  uint32_t major_ver = le32toh (h->hdr->major_ver);
  if (major_ver != 1) {
    SET_ERRNO (ENOTSUP,
               '%s: hive file major version %' PRIu32 ' (expected 1)',
               filename, major_ver);
    goto error;
  }

  h->bitmap = calloc (1 + h->size / 32, 1);
  if (h->bitmap == NULL)
    goto error;

  /* Header checksum. */
  uint32_t sum = header_checksum (h);
  if (sum != le32toh (h->hdr->csum)) {
    SET_ERRNO (EINVAL, '%s: bad checksum in hive header', filename);
    goto error;
  }

  /* Last modified time. */
  h->last_modified = le64toh ((int64_t) h->hdr->last_modified);

  if (h->msglvl >= 2) {
    char *name = _hivex_windows_utf16_to_utf8 (h->hdr->name, 64);

    fprintf (stderr,
             'hivex_open: header fields:\n'
             '  file version             %' PRIu32 '.%' PRIu32 '\n'
             '  sequence nos             %' PRIu32 ' %' PRIu32 '\n'
             '    (sequences nos should match if hive was synched at shutdown)\n'
             '  last modified            %' PRIu64 '\n'
             '    (Windows filetime, x 100 ns since 1601-01-01)\n'
             '  original file name       %s\n'
             '    (only 32 chars are stored, name is probably truncated)\n'
             '  root offset              0x%x + 0x1000\n'
             '  end of last page         0x%x + 0x1000 (total file size 0x%zx)\n'
             '  checksum                 0x%x (calculated 0x%x)\n',
             major_ver, le32toh (h->hdr->minor_ver),
             le32toh (h->hdr->sequence1), le32toh (h->hdr->sequence2),
             h->last_modified,
             name ? name : '(conversion failed)',
             le32toh (h->hdr->offset),
             le32toh (h->hdr->blocks), h->size,
             le32toh (h->hdr->csum), sum);
    free (name);
  }

  h->rootoffs = le32toh (h->hdr->offset) + 0x1000;
  h->endpages = le32toh (h->hdr->blocks) + 0x1000;

  DEBUG (2, 'root offset = 0x%zx', h->rootoffs);

  /* We'll set this flag when we see a block with the root offset (ie.
   * the root block).
   */
  int seen_root_block = 0, bad_root_block = 0;

  /* Collect some stats. */
  size_t pages = 0;           /* Number of hbin pages read. */
  size_t smallest_page = SIZE_MAX, largest_page = 0;
  size_t blocks = 0;          /* Total number of blocks found. */
  size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;
  size_t used_blocks = 0;     /* Total number of used blocks found. */
  size_t used_size = 0;       /* Total size (bytes) of used blocks. */

  /* Read the pages and blocks.  The aim here is to be robust against
   * corrupt or malicious registries.  So we make sure the loops
   * always make forward progress.  We add the address of each block
   * we read to a hash table so pointers will only reference the start
   * of valid blocks.
   */
  size_t off;
  struct ntreg_hbin_page *page;
  for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {
    if (off >= h->endpages)
      break;

    page = (struct ntreg_hbin_page *) ((char *) h->addr + off);
    if (page->magic[0] != 'h' ||
        page->magic[1] != 'b' ||
        page->magic[2] != 'i' ||
        page->magic[3] != 'n') {
      SET_ERRNO (ENOTSUP,
                 '%s: trailing garbage at end of file '
                 '(at 0x%zx, after %zu pages)',
                 filename, off, pages);
      goto error;
    }

    size_t page_size = le32toh (page->page_size);
    DEBUG (2, 'page at 0x%zx, size %zu', off, page_size);
    pages++;
    if (page_size < smallest_page) smallest_page = page_size;
    if (page_size > largest_page) largest_page = page_size;

    if (page_size <= sizeof (struct ntreg_hbin_page) ||
        (page_size & 0x0fff) != 0) {
      SET_ERRNO (ENOTSUP,
                 '%s: page size %zu at 0x%zx, bad registry',
                 filename, page_size, off);
      goto error;
    }

    /* Read the blocks in this page. */
    size_t blkoff;
    struct ntreg_hbin_block *block;
    size_t seg_len;
    for (blkoff = off + 0x20;
         blkoff < off + page_size;
         blkoff += seg_len) {
      blocks++;

      int is_root = blkoff == h->rootoffs;
      if (is_root)
        seen_root_block = 1;

      block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);
      int used;
      seg_len = block_len (h, blkoff, &used);
      if (seg_len <= 4 || (seg_len & 3) != 0) {
        SET_ERRNO (ENOTSUP,
                   '%s: block size %' PRIu32 ' at 0x%zx, bad registry',
                   filename, le32toh (block->seg_len), blkoff);
        goto error;
      }

      if (h->msglvl >= 2) {
        unsigned char *id = (unsigned char *) block->id;
        int id0 = id[0], id1 = id[1];

        fprintf (stderr, '%s: %s: '
                 '%s block id %d,%d (%c%c) at 0x%zx size %zu%s\n',
                 'hivex', __func__,
                 used ? 'used' : 'free',
                 id0, id1,
                 c_isprint (id0) ? id0 : '.',
                 c_isprint (id1) ? id1 : '.',
                 blkoff,
                 seg_len, is_root ? ' (root)' : '');
      }

      blocks_bytes += seg_len;
      if (seg_len < smallest_block) smallest_block = seg_len;
      if (seg_len > largest_block) largest_block = seg_len;

      if (is_root && !used)
        bad_root_block = 1;

      if (used) {
        used_blocks++;
        used_size += seg_len;

        /* Root block must be an nk-block. */
        if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))
          bad_root_block = 1;

        /* Note this blkoff is a valid address. */
        BITMAP_SET (h->bitmap, blkoff);
      }
    }
  }

  if (!seen_root_block) {
    SET_ERRNO (ENOTSUP, '%s: no root block found', filename);
    goto error;
  }

  if (bad_root_block) {
    SET_ERRNO (ENOTSUP, '%s: bad root block (free or not nk)', filename);
    goto error;
  }

  DEBUG (1, 'successfully read Windows Registry hive file:\n'
         '  pages:          %zu [sml: %zu, lge: %zu]\n'
         '  blocks:         %zu [sml: %zu, avg: %zu, lge: %zu]\n'
         '  blocks used:    %zu\n'
         '  bytes used:     %zu',
         pages, smallest_page, largest_page,
         blocks, smallest_block, blocks_bytes / blocks, largest_block,
         used_blocks, used_size);

  return h;

 error:;
  int err = errno;
  if (h) {
    free (h->bitmap);
    if (h->addr && h->size && h->addr != MAP_FAILED) {
      if (!h->writable)
        munmap (h->addr, h->size);
      else
        free (h->addr);
    }
    if (h->fd >= 0)
      close (h->fd);
    free (h->filename);
    free (h);
  }
  errno = err;
  return NULL;
}
",9113
libguestfs/hivex,4bbdf555f88baeae0fa804a369a81a83908bd705,1,"hive_h *
hivex_open (const char *filename, int flags)
{
  hive_h *h = NULL;

  assert (sizeof (struct ntreg_header) == 0x1000);
  assert (offsetof (struct ntreg_header, csum) == 0x1fc);

  h = calloc (1, sizeof *h);
  if (h == NULL)
    goto error;

  h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;

  const char *debug = getenv ('HIVEX_DEBUG');
  if (debug && STREQ (debug, '1'))
    h->msglvl = 2;

  DEBUG (2, 'created handle %p', h);

  h->writable = !!(flags & HIVEX_OPEN_WRITE);
  h->filename = strdup (filename);
  if (h->filename == NULL)
    goto error;

#ifdef O_CLOEXEC
  h->fd = open (filename, O_RDONLY | O_CLOEXEC | O_BINARY);
#else
  h->fd = open (filename, O_RDONLY | O_BINARY);
#endif
  if (h->fd == -1)
    goto error;
#ifndef O_CLOEXEC
  fcntl (h->fd, F_SETFD, FD_CLOEXEC);
#endif

  struct stat statbuf;
  if (fstat (h->fd, &statbuf) == -1)
    goto error;

  h->size = statbuf.st_size;

  if (!h->writable) {
    h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);
    if (h->addr == MAP_FAILED)
      goto error;

    DEBUG (2, 'mapped file at %p', h->addr);
  } else {
    h->addr = malloc (h->size);
    if (h->addr == NULL)
      goto error;

    if (full_read (h->fd, h->addr, h->size) < h->size)
      goto error;

    /* We don't need the file descriptor along this path, since we
     * have read all the data.
     */
    if (close (h->fd) == -1)
      goto error;
    h->fd = -1;
  }

  /* Check header. */
  if (h->hdr->magic[0] != 'r' ||
      h->hdr->magic[1] != 'e' ||
      h->hdr->magic[2] != 'g' ||
      h->hdr->magic[3] != 'f') {
    SET_ERRNO (ENOTSUP,
               '%s: not a Windows NT Registry hive file', filename);
    goto error;
  }

  /* Check major version. */
  uint32_t major_ver = le32toh (h->hdr->major_ver);
  if (major_ver != 1) {
    SET_ERRNO (ENOTSUP,
               '%s: hive file major version %' PRIu32 ' (expected 1)',
               filename, major_ver);
    goto error;
  }

  h->bitmap = calloc (1 + h->size / 32, 1);
  if (h->bitmap == NULL)
    goto error;

  /* Header checksum. */
  uint32_t sum = header_checksum (h);
  if (sum != le32toh (h->hdr->csum)) {
    SET_ERRNO (EINVAL, '%s: bad checksum in hive header', filename);
    goto error;
  }

  /* Last modified time. */
  h->last_modified = le64toh ((int64_t) h->hdr->last_modified);

  if (h->msglvl >= 2) {
    char *name = _hivex_windows_utf16_to_utf8 (h->hdr->name, 64);

    fprintf (stderr,
             'hivex_open: header fields:\n'
             '  file version             %' PRIu32 '.%' PRIu32 '\n'
             '  sequence nos             %' PRIu32 ' %' PRIu32 '\n'
             '    (sequences nos should match if hive was synched at shutdown)\n'
             '  last modified            %' PRIu64 '\n'
             '    (Windows filetime, x 100 ns since 1601-01-01)\n'
             '  original file name       %s\n'
             '    (only 32 chars are stored, name is probably truncated)\n'
             '  root offset              0x%x + 0x1000\n'
             '  end of last page         0x%x + 0x1000 (total file size 0x%zx)\n'
             '  checksum                 0x%x (calculated 0x%x)\n',
             major_ver, le32toh (h->hdr->minor_ver),
             le32toh (h->hdr->sequence1), le32toh (h->hdr->sequence2),
             h->last_modified,
             name ? name : '(conversion failed)',
             le32toh (h->hdr->offset),
             le32toh (h->hdr->blocks), h->size,
             le32toh (h->hdr->csum), sum);
    free (name);
  }

  h->rootoffs = le32toh (h->hdr->offset) + 0x1000;
  h->endpages = le32toh (h->hdr->blocks) + 0x1000;

  DEBUG (2, 'root offset = 0x%zx', h->rootoffs);

  /* We'll set this flag when we see a block with the root offset (ie.
   * the root block).
   */
  int seen_root_block = 0, bad_root_block = 0;

  /* Collect some stats. */
  size_t pages = 0;           /* Number of hbin pages read. */
  size_t smallest_page = SIZE_MAX, largest_page = 0;
  size_t blocks = 0;          /* Total number of blocks found. */
  size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;
  size_t used_blocks = 0;     /* Total number of used blocks found. */
  size_t used_size = 0;       /* Total size (bytes) of used blocks. */

  /* Read the pages and blocks.  The aim here is to be robust against
   * corrupt or malicious registries.  So we make sure the loops
   * always make forward progress.  We add the address of each block
   * we read to a hash table so pointers will only reference the start
   * of valid blocks.
   */
  size_t off;
  struct ntreg_hbin_page *page;
  for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {
    if (off >= h->endpages)
      break;

    page = (struct ntreg_hbin_page *) ((char *) h->addr + off);
    if (page->magic[0] != 'h' ||
        page->magic[1] != 'b' ||
        page->magic[2] != 'i' ||
        page->magic[3] != 'n') {
      SET_ERRNO (ENOTSUP,
                 '%s: trailing garbage at end of file '
                 '(at 0x%zx, after %zu pages)',
                 filename, off, pages);
      goto error;
    }

    size_t page_size = le32toh (page->page_size);
    DEBUG (2, 'page at 0x%zx, size %zu', off, page_size);
    pages++;
    if (page_size < smallest_page) smallest_page = page_size;
    if (page_size > largest_page) largest_page = page_size;

    if (page_size <= sizeof (struct ntreg_hbin_page) ||
        (page_size & 0x0fff) != 0) {
      SET_ERRNO (ENOTSUP,
                 '%s: page size %zu at 0x%zx, bad registry',
                 filename, page_size, off);
      goto error;
    }

    /* Read the blocks in this page. */
    size_t blkoff;
    struct ntreg_hbin_block *block;
    size_t seg_len;
    for (blkoff = off + 0x20;
         blkoff < off + page_size;
         blkoff += seg_len) {
      blocks++;

      int is_root = blkoff == h->rootoffs;
      if (is_root)
        seen_root_block = 1;

      block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);
      int used;
      seg_len = block_len (h, blkoff, &used);
      if (seg_len <= 4 || (seg_len & 3) != 0) {
        SET_ERRNO (ENOTSUP,
                   '%s: block size %' PRIu32 ' at 0x%zx, bad registry',
                   filename, le32toh (block->seg_len), blkoff);
        goto error;
      }

      if (h->msglvl >= 2) {
        unsigned char *id = (unsigned char *) block->id;
        int id0 = id[0], id1 = id[1];

        fprintf (stderr, '%s: %s: '
                 '%s block id %d,%d (%c%c) at 0x%zx size %zu%s\n',
                 'hivex', __func__,
                 used ? 'used' : 'free',
                 id0, id1,
                 c_isprint (id0) ? id0 : '.',
                 c_isprint (id1) ? id1 : '.',
                 blkoff,
                 seg_len, is_root ? ' (root)' : '');
      }

      blocks_bytes += seg_len;
      if (seg_len < smallest_block) smallest_block = seg_len;
      if (seg_len > largest_block) largest_block = seg_len;

      if (is_root && !used)
        bad_root_block = 1;

      if (used) {
        used_blocks++;
        used_size += seg_len;

        /* Root block must be an nk-block. */
        if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))
          bad_root_block = 1;

        /* Note this blkoff is a valid address. */
        BITMAP_SET (h->bitmap, blkoff);
      }
    }
  }

  if (!seen_root_block) {
    SET_ERRNO (ENOTSUP, '%s: no root block found', filename);
    goto error;
  }

  if (bad_root_block) {
    SET_ERRNO (ENOTSUP, '%s: bad root block (free or not nk)', filename);
    goto error;
  }

  DEBUG (1, 'successfully read Windows Registry hive file:\n'
         '  pages:          %zu [sml: %zu, lge: %zu]\n'
         '  blocks:         %zu [sml: %zu, avg: %zu, lge: %zu]\n'
         '  blocks used:    %zu\n'
         '  bytes used:     %zu',
         pages, smallest_page, largest_page,
         blocks, smallest_block, blocks_bytes / blocks, largest_block,
         used_blocks, used_size);

  return h;

 error:;
  int err = errno;
  if (h) {
    free (h->bitmap);
    if (h->addr && h->size && h->addr != MAP_FAILED) {
      if (!h->writable)
        munmap (h->addr, h->size);
      else
        free (h->addr);
    }
    if (h->fd >= 0)
      close (h->fd);
    free (h->filename);
    free (h);
  }
  errno = err;
  return NULL;
}
",9114
libguestfs/hivex,4bbdf555f88baeae0fa804a369a81a83908bd705,0,"
  const char *debug = getenv ('HIVEX_DEBUG');
  if (debug && STREQ (debug, '1'))
",9115
libguestfs/hivex,4bbdf555f88baeae0fa804a369a81a83908bd705,0,"  assert (sizeof (struct ntreg_header) == 0x1000);
  assert (offsetof (struct ntreg_header, csum) == 0x1fc);

",9116
